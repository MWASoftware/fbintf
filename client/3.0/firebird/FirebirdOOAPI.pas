{ This file was autogenerated by cloop - Cross Language Object Oriented Programming }

{ $DEFINE USEFBEXCEPTION}
{ $DEFINE STATIC_LINK_TO_FIREBIRD_LIBRARY}

{$WARNINGS OFF}
{$IFDEF FPC}
{$MODE DELPHI}
{$ENDIF}

unit FirebirdOOAPI;

interface

uses Classes, Sysutils, IBErrorCodes;

type
{$IFNDEF FPC}
	QWord = UInt64;
{$ENDIF}

	IVersioned = ^TVersioned;
	IReferenceCounted = ^TReferenceCounted;
	IDisposable = ^TDisposable;
	IStatus = ^TStatus;
	IMaster = ^TMaster;
	IPluginBase = ^TPluginBase;
	IPluginSet = ^TPluginSet;
	IConfigEntry = ^TConfigEntry;
	IConfig = ^TConfig;
	IFirebirdConf = ^TFirebirdConf;
	IPluginConfig = ^TPluginConfig;
	IPluginFactory = ^TPluginFactory;
	IPluginModule = ^TPluginModule;
	IPluginManager = ^TPluginManager;
	ICryptKey = ^TCryptKey;
	IConfigManager = ^TConfigManager;
	IEventCallback = ^TEventCallback;
	IBlob = ^TBlob;
	ITransaction = ^TTransaction;
	IMessageMetadata = ^TMessageMetadata;
	IMetadataBuilder = ^TMetadataBuilder;
	IResultSet = ^TResultSet;
	IStatement = ^TStatement;
	IBatch = ^TBatch;
	IBatchCompletionState = ^TBatchCompletionState;
	IReplicator = ^TReplicator;
	IRequest = ^TRequest;
	IEvents = ^TEvents;
	IAttachment = ^TAttachment;
	IService = ^TService;
	IProvider = ^TProvider;
	IDtcStart = ^TDtcStart;
	IDtc = ^TDtc;
	IAuth = ^TAuth;
	IWriter = ^TWriter;
	IServerBlock = ^TServerBlock;
	IClientBlock = ^TClientBlock;
	IServer = ^TServer;
	IClient = ^TClient;
	IUserField = ^TUserField;
	ICharUserField = ^TCharUserField;
	IIntUserField = ^TIntUserField;
	IUser = ^TUser;
	IListUsers = ^TListUsers;
	ILogonInfo = ^TLogonInfo;
	IManagement = ^TManagement;
	IAuthBlock = ^TAuthBlock;
	IWireCryptPlugin = ^TWireCryptPlugin;
	ICryptKeyCallback = ^TCryptKeyCallback;
	IKeyHolderPlugin = ^TKeyHolderPlugin;
	IDbCryptInfo = ^TDbCryptInfo;
	IDbCryptPlugin = ^TDbCryptPlugin;
	IExternalContext = ^TExternalContext;
	IExternalResultSet = ^TExternalResultSet;
	IExternalFunction = ^TExternalFunction;
	IExternalProcedure = ^TExternalProcedure;
	IExternalTrigger = ^TExternalTrigger;
	IRoutineMetadata = ^TRoutineMetadata;
	IExternalEngine = ^TExternalEngine;
	ITimer = ^TTimer;
	ITimerControl = ^TTimerControl;
	IVersionCallback = ^TVersionCallback;
	IUtil = ^TUtil;
	IOffsetsCallback = ^TOffsetsCallback;
	IXpbBuilder = ^TXpbBuilder;
	ITraceConnection = ^TTraceConnection;
	ITraceDatabaseConnection = ^TTraceDatabaseConnection;
	ITraceTransaction = ^TTraceTransaction;
	ITraceParams = ^TTraceParams;
	ITraceStatement = ^TTraceStatement;
	ITraceSQLStatement = ^TTraceSQLStatement;
	ITraceBLRStatement = ^TTraceBLRStatement;
	ITraceDYNRequest = ^TTraceDYNRequest;
	ITraceContextVariable = ^TTraceContextVariable;
	ITraceProcedure = ^TTraceProcedure;
	ITraceFunction = ^TTraceFunction;
	ITraceTrigger = ^TTraceTrigger;
	ITraceServiceConnection = ^TTraceServiceConnection;
	ITraceStatusVector = ^TTraceStatusVector;
	ITraceSweepInfo = ^TTraceSweepInfo;
	ITraceLogWriter = ^TTraceLogWriter;
	ITraceInitInfo = ^TTraceInitInfo;
	ITracePlugin = ^TTracePlugin;
	ITraceFactory = ^TTraceFactory;
	IUdrFunctionFactory = ^TUdrFunctionFactory;
	IUdrProcedureFactory = ^TUdrProcedureFactory;
	IUdrTriggerFactory = ^TUdrTriggerFactory;
	IUdrPlugin = ^TUdrPlugin;
	IDecFloat16 = ^TDecFloat16;
	IDecFloat34 = ^TDecFloat34;
	IInt128 = ^TInt128;
	IReplicatedField = ^TReplicatedField;
	IReplicatedRecord = ^TReplicatedRecord;
	IReplicatedTransaction = ^TReplicatedTransaction;
	IReplicatedSession = ^TReplicatedSession;

	ISC_DATE = Integer;
	ISC_TIME = Integer;
	ISC_QUAD = array [1..2] of Integer;
	FB_DEC16 = array [1..1] of Int64;
	FB_DEC34 = array [1..2] of Int64;
	FB_I128 = array [1..2] of Int64;

	isc_tr_handle = ^Integer;
	isc_stmt_handle = ^Integer;

	ISC_USHORT = word;		{ 16 bit unsigned }
	ISC_SHORT = smallint;	{ 16 bit signed }

	ISC_TIME_TZ = record
		utc_time: ISC_TIME;
		time_zone: ISC_USHORT;
	end;

	ISC_TIME_TZ_EX = record
		utc_time: ISC_TIME;
		time_zone: ISC_USHORT;
		ext_offset: ISC_SHORT;
	end;

	ISC_TIMESTAMP = record
		timestamp_date: ISC_DATE;
		timestamp_time: ISC_TIME;
	end;

	ISC_TIMESTAMP_TZ = record
		utc_timestamp: ISC_TIMESTAMP;
		time_zone: ISC_USHORT;
	end;

	ISC_TIMESTAMP_TZ_EX = record
		utc_timestamp: ISC_TIMESTAMP;
		time_zone: ISC_USHORT;
		ext_offset: ISC_SHORT;
	end;

	ntrace_relation_t = Integer;
	TraceCounts = Record
		trc_relation_id		: ntrace_relation_t;
		trc_relation_name	: PAnsiChar;
		trc_counters		: ^Int64;
	end;
	TraceCountsPtr = ^TraceCounts;
	PerformanceInfo = Record
		pin_time			: Int64;
		pin_counters		: ^Int64;
		pin_count			: NativeUInt;
		pin_tables			: TraceCountsPtr;
		pin_records_fetched	: Int64;
	end;

	Dsc = Record
		dsc_dtype, dsc_scale: Byte;
		dsc_length, dsc_sub_type, dsc_flags: Int16;
		dsc_address: ^Byte;
	end;

	FbException = class(Exception)
	public
		constructor create(status: IStatus); virtual;
		destructor Destroy(); override;

		function getStatus: IStatus;

		class procedure checkException(status: IStatus);
		class procedure catchException(status: IStatus; e: Exception);

	private
		status: IStatus;
	end;

	BooleanPtr = ^Boolean;
	BytePtr = PByte;
	CardinalPtr = ^Cardinal;
	FB_DEC16Ptr = ^FB_DEC16;
	FB_DEC34Ptr = ^FB_DEC34;
	FB_I128Ptr = ^FB_I128;
	ISC_QUADPtr = ^ISC_QUAD;
	ISC_TIMESTAMP_TZPtr = ^ISC_TIMESTAMP_TZ;
	ISC_TIMESTAMP_TZ_EXPtr = ^ISC_TIMESTAMP_TZ_EX;
	ISC_TIME_TZPtr = ^ISC_TIME_TZ;
	ISC_TIME_TZ_EXPtr = ^ISC_TIME_TZ_EX;
	Int64Ptr = ^Int64;
	IntegerPtr = ^Integer;
	NativeIntPtr = ^NativeInt;
	PerformanceInfoPtr = ^PerformanceInfo;
	dscPtr = ^dsc;

	IReferenceCounted_addRefPtr = procedure(this: IReferenceCounted); cdecl;
	IReferenceCounted_releasePtr = function(this: IReferenceCounted): Integer; cdecl;
	IDisposable_disposePtr = procedure(this: IDisposable); cdecl;
	IStatus_initPtr = procedure(this: IStatus); cdecl;
	IStatus_getStatePtr = function(this: IStatus): Cardinal; cdecl;
	IStatus_setErrors2Ptr = procedure(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
	IStatus_setWarnings2Ptr = procedure(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
	IStatus_setErrorsPtr = procedure(this: IStatus; value: NativeIntPtr); cdecl;
	IStatus_setWarningsPtr = procedure(this: IStatus; value: NativeIntPtr); cdecl;
	IStatus_getErrorsPtr = function(this: IStatus): NativeIntPtr; cdecl;
	IStatus_getWarningsPtr = function(this: IStatus): NativeIntPtr; cdecl;
	IStatus_clonePtr = function(this: IStatus): IStatus; cdecl;
	IMaster_getStatusPtr = function(this: IMaster): IStatus; cdecl;
	IMaster_getDispatcherPtr = function(this: IMaster): IProvider; cdecl;
	IMaster_getPluginManagerPtr = function(this: IMaster): IPluginManager; cdecl;
	IMaster_getTimerControlPtr = function(this: IMaster): ITimerControl; cdecl;
	IMaster_getDtcPtr = function(this: IMaster): IDtc; cdecl;
	IMaster_registerAttachmentPtr = function(this: IMaster; provider: IProvider; attachment: IAttachment): IAttachment; cdecl;
	IMaster_registerTransactionPtr = function(this: IMaster; attachment: IAttachment; transaction: ITransaction): ITransaction; cdecl;
	IMaster_getMetadataBuilderPtr = function(this: IMaster; status: IStatus; fieldCount: Cardinal): IMetadataBuilder; cdecl;
	IMaster_serverModePtr = function(this: IMaster; mode: Integer): Integer; cdecl;
	IMaster_getUtilInterfacePtr = function(this: IMaster): IUtil; cdecl;
	IMaster_getConfigManagerPtr = function(this: IMaster): IConfigManager; cdecl;
	IMaster_getProcessExitingPtr = function(this: IMaster): Boolean; cdecl;
	IPluginBase_setOwnerPtr = procedure(this: IPluginBase; r: IReferenceCounted); cdecl;
	IPluginBase_getOwnerPtr = function(this: IPluginBase): IReferenceCounted; cdecl;
	IPluginSet_getNamePtr = function(this: IPluginSet): PAnsiChar; cdecl;
	IPluginSet_getModuleNamePtr = function(this: IPluginSet): PAnsiChar; cdecl;
	IPluginSet_getPluginPtr = function(this: IPluginSet; status: IStatus): IPluginBase; cdecl;
	IPluginSet_nextPtr = procedure(this: IPluginSet; status: IStatus); cdecl;
	IPluginSet_set_Ptr = procedure(this: IPluginSet; status: IStatus; s: PAnsiChar); cdecl;
	IConfigEntry_getNamePtr = function(this: IConfigEntry): PAnsiChar; cdecl;
	IConfigEntry_getValuePtr = function(this: IConfigEntry): PAnsiChar; cdecl;
	IConfigEntry_getIntValuePtr = function(this: IConfigEntry): Int64; cdecl;
	IConfigEntry_getBoolValuePtr = function(this: IConfigEntry): Boolean; cdecl;
	IConfigEntry_getSubConfigPtr = function(this: IConfigEntry; status: IStatus): IConfig; cdecl;
	IConfig_findPtr = function(this: IConfig; status: IStatus; name: PAnsiChar): IConfigEntry; cdecl;
	IConfig_findValuePtr = function(this: IConfig; status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry; cdecl;
	IConfig_findPosPtr = function(this: IConfig; status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry; cdecl;
	IFirebirdConf_getKeyPtr = function(this: IFirebirdConf; name: PAnsiChar): Cardinal; cdecl;
	IFirebirdConf_asIntegerPtr = function(this: IFirebirdConf; key: Cardinal): Int64; cdecl;
	IFirebirdConf_asStringPtr = function(this: IFirebirdConf; key: Cardinal): PAnsiChar; cdecl;
	IFirebirdConf_asBooleanPtr = function(this: IFirebirdConf; key: Cardinal): Boolean; cdecl;
	IFirebirdConf_getVersionPtr = function(this: IFirebirdConf; status: IStatus): Cardinal; cdecl;
	IPluginConfig_getConfigFileNamePtr = function(this: IPluginConfig): PAnsiChar; cdecl;
	IPluginConfig_getDefaultConfigPtr = function(this: IPluginConfig; status: IStatus): IConfig; cdecl;
	IPluginConfig_getFirebirdConfPtr = function(this: IPluginConfig; status: IStatus): IFirebirdConf; cdecl;
	IPluginConfig_setReleaseDelayPtr = procedure(this: IPluginConfig; status: IStatus; microSeconds: QWord); cdecl;
	IPluginFactory_createPluginPtr = function(this: IPluginFactory; status: IStatus; factoryParameter: IPluginConfig): IPluginBase; cdecl;
	IPluginModule_doCleanPtr = procedure(this: IPluginModule); cdecl;
	IPluginModule_threadDetachPtr = procedure(this: IPluginModule); cdecl;
	IPluginManager_registerPluginFactoryPtr = procedure(this: IPluginManager; pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory); cdecl;
	IPluginManager_registerModulePtr = procedure(this: IPluginManager; cleanup: IPluginModule); cdecl;
	IPluginManager_unregisterModulePtr = procedure(this: IPluginManager; cleanup: IPluginModule); cdecl;
	IPluginManager_getPluginsPtr = function(this: IPluginManager; status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet; cdecl;
	IPluginManager_getConfigPtr = function(this: IPluginManager; status: IStatus; filename: PAnsiChar): IConfig; cdecl;
	IPluginManager_releasePluginPtr = procedure(this: IPluginManager; plugin: IPluginBase); cdecl;
	ICryptKey_setSymmetricPtr = procedure(this: ICryptKey; status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); cdecl;
	ICryptKey_setAsymmetricPtr = procedure(this: ICryptKey; status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); cdecl;
	ICryptKey_getEncryptKeyPtr = function(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
	ICryptKey_getDecryptKeyPtr = function(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
	IConfigManager_getDirectoryPtr = function(this: IConfigManager; code: Cardinal): PAnsiChar; cdecl;
	IConfigManager_getFirebirdConfPtr = function(this: IConfigManager): IFirebirdConf; cdecl;
	IConfigManager_getDatabaseConfPtr = function(this: IConfigManager; dbName: PAnsiChar): IFirebirdConf; cdecl;
	IConfigManager_getPluginConfigPtr = function(this: IConfigManager; configuredPlugin: PAnsiChar): IConfig; cdecl;
	IConfigManager_getInstallDirectoryPtr = function(this: IConfigManager): PAnsiChar; cdecl;
	IConfigManager_getRootDirectoryPtr = function(this: IConfigManager): PAnsiChar; cdecl;
	IConfigManager_getDefaultSecurityDbPtr = function(this: IConfigManager): PAnsiChar; cdecl;
	IEventCallback_eventCallbackFunctionPtr = procedure(this: IEventCallback; length: Cardinal; events: BytePtr); cdecl;
	IBlob_getInfoPtr = procedure(this: IBlob; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IBlob_getSegmentPtr = function(this: IBlob; status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; cdecl;
	IBlob_putSegmentPtr = procedure(this: IBlob; status: IStatus; length: Cardinal; buffer: Pointer); cdecl;
	IBlob_cancelPtr = procedure(this: IBlob; status: IStatus); cdecl;
	IBlob_closePtr = procedure(this: IBlob; status: IStatus); cdecl;
	IBlob_seekPtr = function(this: IBlob; status: IStatus; mode: Integer; offset: Integer): Integer; cdecl;
	ITransaction_getInfoPtr = procedure(this: ITransaction; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	ITransaction_preparePtr = procedure(this: ITransaction; status: IStatus; msgLength: Cardinal; message: BytePtr); cdecl;
	ITransaction_commitPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_commitRetainingPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_rollbackPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_rollbackRetainingPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_disconnectPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_joinPtr = function(this: ITransaction; status: IStatus; transaction: ITransaction): ITransaction; cdecl;
	ITransaction_validatePtr = function(this: ITransaction; status: IStatus; attachment: IAttachment): ITransaction; cdecl;
	ITransaction_enterDtcPtr = function(this: ITransaction; status: IStatus): ITransaction; cdecl;
	IMessageMetadata_getCountPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMessageMetadata_getFieldPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getRelationPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getOwnerPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getAliasPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getTypePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_isNullablePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Boolean; cdecl;
	IMessageMetadata_getSubTypePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
	IMessageMetadata_getLengthPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getScalePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
	IMessageMetadata_getCharSetPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getOffsetPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getNullOffsetPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getBuilderPtr = function(this: IMessageMetadata; status: IStatus): IMetadataBuilder; cdecl;
	IMessageMetadata_getMessageLengthPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMessageMetadata_getAlignmentPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMessageMetadata_getAlignedLengthPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMetadataBuilder_setTypePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; type_: Cardinal); cdecl;
	IMetadataBuilder_setSubTypePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; subType: Integer); cdecl;
	IMetadataBuilder_setLengthPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; length: Cardinal); cdecl;
	IMetadataBuilder_setCharSetPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; charSet: Cardinal); cdecl;
	IMetadataBuilder_setScalePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; scale: Integer); cdecl;
	IMetadataBuilder_truncatePtr = procedure(this: IMetadataBuilder; status: IStatus; count: Cardinal); cdecl;
	IMetadataBuilder_moveNameToIndexPtr = procedure(this: IMetadataBuilder; status: IStatus; name: PAnsiChar; index: Cardinal); cdecl;
	IMetadataBuilder_removePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal); cdecl;
	IMetadataBuilder_addFieldPtr = function(this: IMetadataBuilder; status: IStatus): Cardinal; cdecl;
	IMetadataBuilder_getMetadataPtr = function(this: IMetadataBuilder; status: IStatus): IMessageMetadata; cdecl;
	IMetadataBuilder_setFieldPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; field: PAnsiChar); cdecl;
	IMetadataBuilder_setRelationPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; relation: PAnsiChar); cdecl;
	IMetadataBuilder_setOwnerPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; owner: PAnsiChar); cdecl;
	IMetadataBuilder_setAliasPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; alias: PAnsiChar); cdecl;
	IResultSet_fetchNextPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchPriorPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchFirstPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchLastPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchAbsolutePtr = function(this: IResultSet; status: IStatus; position: Integer; message: Pointer): Integer; cdecl;
	IResultSet_fetchRelativePtr = function(this: IResultSet; status: IStatus; offset: Integer; message: Pointer): Integer; cdecl;
	IResultSet_isEofPtr = function(this: IResultSet; status: IStatus): Boolean; cdecl;
	IResultSet_isBofPtr = function(this: IResultSet; status: IStatus): Boolean; cdecl;
	IResultSet_getMetadataPtr = function(this: IResultSet; status: IStatus): IMessageMetadata; cdecl;
	IResultSet_closePtr = procedure(this: IResultSet; status: IStatus); cdecl;
	IResultSet_setDelayedOutputFormatPtr = procedure(this: IResultSet; status: IStatus; format: IMessageMetadata); cdecl;
	IStatement_getInfoPtr = procedure(this: IStatement; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IStatement_getTypePtr = function(this: IStatement; status: IStatus): Cardinal; cdecl;
	IStatement_getPlanPtr = function(this: IStatement; status: IStatus; detailed: Boolean): PAnsiChar; cdecl;
	IStatement_getAffectedRecordsPtr = function(this: IStatement; status: IStatus): QWord; cdecl;
	IStatement_getInputMetadataPtr = function(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
	IStatement_getOutputMetadataPtr = function(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
	IStatement_executePtr = function(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
	IStatement_openCursorPtr = function(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet; cdecl;
	IStatement_setCursorNamePtr = procedure(this: IStatement; status: IStatus; name: PAnsiChar); cdecl;
	IStatement_freePtr = procedure(this: IStatement; status: IStatus); cdecl;
	IStatement_getFlagsPtr = function(this: IStatement; status: IStatus): Cardinal; cdecl;
	IStatement_getTimeoutPtr = function(this: IStatement; status: IStatus): Cardinal; cdecl;
	IStatement_setTimeoutPtr = procedure(this: IStatement; status: IStatus; timeOut: Cardinal); cdecl;
	IStatement_createBatchPtr = function(this: IStatement; status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
	IBatch_addPtr = procedure(this: IBatch; status: IStatus; count: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_addBlobPtr = procedure(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); cdecl;
	IBatch_appendBlobDataPtr = procedure(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_addBlobStreamPtr = procedure(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_registerBlobPtr = procedure(this: IBatch; status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); cdecl;
	IBatch_executePtr = function(this: IBatch; status: IStatus; transaction: ITransaction): IBatchCompletionState; cdecl;
	IBatch_cancelPtr = procedure(this: IBatch; status: IStatus); cdecl;
	IBatch_getBlobAlignmentPtr = function(this: IBatch; status: IStatus): Cardinal; cdecl;
	IBatch_getMetadataPtr = function(this: IBatch; status: IStatus): IMessageMetadata; cdecl;
	IBatch_setDefaultBpbPtr = procedure(this: IBatch; status: IStatus; parLength: Cardinal; par: BytePtr); cdecl;
	IBatch_closePtr = procedure(this: IBatch; status: IStatus); cdecl;
	IBatchCompletionState_getSizePtr = function(this: IBatchCompletionState; status: IStatus): Cardinal; cdecl;
	IBatchCompletionState_getStatePtr = function(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Integer; cdecl;
	IBatchCompletionState_findErrorPtr = function(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Cardinal; cdecl;
	IBatchCompletionState_getStatusPtr = procedure(this: IBatchCompletionState; status: IStatus; to_: IStatus; pos: Cardinal); cdecl;
	IReplicator_processPtr = procedure(this: IReplicator; status: IStatus; length: Cardinal; data: BytePtr); cdecl;
	IReplicator_closePtr = procedure(this: IReplicator; status: IStatus); cdecl;
	IRequest_receivePtr = procedure(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_sendPtr = procedure(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_getInfoPtr = procedure(this: IRequest; status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IRequest_startPtr = procedure(this: IRequest; status: IStatus; tra: ITransaction; level: Integer); cdecl;
	IRequest_startAndSendPtr = procedure(this: IRequest; status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_unwindPtr = procedure(this: IRequest; status: IStatus; level: Integer); cdecl;
	IRequest_freePtr = procedure(this: IRequest; status: IStatus); cdecl;
	IEvents_cancelPtr = procedure(this: IEvents; status: IStatus); cdecl;
	IAttachment_getInfoPtr = procedure(this: IAttachment; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IAttachment_startTransactionPtr = function(this: IAttachment; status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction; cdecl;
	IAttachment_reconnectTransactionPtr = function(this: IAttachment; status: IStatus; length: Cardinal; id: BytePtr): ITransaction; cdecl;
	IAttachment_compileRequestPtr = function(this: IAttachment; status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest; cdecl;
	IAttachment_transactRequestPtr = procedure(this: IAttachment; status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); cdecl;
	IAttachment_createBlobPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
	IAttachment_openBlobPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
	IAttachment_getSlicePtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; cdecl;
	IAttachment_putSlicePtr = procedure(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); cdecl;
	IAttachment_executeDynPtr = procedure(this: IAttachment; status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr); cdecl;
	IAttachment_preparePtr = function(this: IAttachment; status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement; cdecl;
	IAttachment_executePtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
	IAttachment_openCursorPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet; cdecl;
	IAttachment_queEventsPtr = function(this: IAttachment; status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents; cdecl;
	IAttachment_cancelOperationPtr = procedure(this: IAttachment; status: IStatus; option: Integer); cdecl;
	IAttachment_pingPtr = procedure(this: IAttachment; status: IStatus); cdecl;
	IAttachment_detachPtr = procedure(this: IAttachment; status: IStatus); cdecl;
	IAttachment_dropDatabasePtr = procedure(this: IAttachment; status: IStatus); cdecl;
	IAttachment_getIdleTimeoutPtr = function(this: IAttachment; status: IStatus): Cardinal; cdecl;
	IAttachment_setIdleTimeoutPtr = procedure(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
	IAttachment_getStatementTimeoutPtr = function(this: IAttachment; status: IStatus): Cardinal; cdecl;
	IAttachment_setStatementTimeoutPtr = procedure(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
	IAttachment_createBatchPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
	IAttachment_createReplicatorPtr = function(this: IAttachment; status: IStatus): IReplicator; cdecl;
	IService_detachPtr = procedure(this: IService; status: IStatus); cdecl;
	IService_queryPtr = procedure(this: IService; status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IService_startPtr = procedure(this: IService; status: IStatus; spbLength: Cardinal; spb: BytePtr); cdecl;
	IProvider_attachDatabasePtr = function(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
	IProvider_createDatabasePtr = function(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
	IProvider_attachServiceManagerPtr = function(this: IProvider; status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService; cdecl;
	IProvider_shutdownPtr = procedure(this: IProvider; status: IStatus; timeout: Cardinal; reason: Integer); cdecl;
	IProvider_setDbCryptCallbackPtr = procedure(this: IProvider; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
	IDtcStart_addAttachmentPtr = procedure(this: IDtcStart; status: IStatus; att: IAttachment); cdecl;
	IDtcStart_addWithTpbPtr = procedure(this: IDtcStart; status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr); cdecl;
	IDtcStart_startPtr = function(this: IDtcStart; status: IStatus): ITransaction; cdecl;
	IDtc_joinPtr = function(this: IDtc; status: IStatus; one: ITransaction; two: ITransaction): ITransaction; cdecl;
	IDtc_startBuilderPtr = function(this: IDtc; status: IStatus): IDtcStart; cdecl;
	IWriter_resetPtr = procedure(this: IWriter); cdecl;
	IWriter_addPtr = procedure(this: IWriter; status: IStatus; name: PAnsiChar); cdecl;
	IWriter_setTypePtr = procedure(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
	IWriter_setDbPtr = procedure(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
	IServerBlock_getLoginPtr = function(this: IServerBlock): PAnsiChar; cdecl;
	IServerBlock_getDataPtr = function(this: IServerBlock; length: CardinalPtr): BytePtr; cdecl;
	IServerBlock_putDataPtr = procedure(this: IServerBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
	IServerBlock_newKeyPtr = function(this: IServerBlock; status: IStatus): ICryptKey; cdecl;
	IClientBlock_getLoginPtr = function(this: IClientBlock): PAnsiChar; cdecl;
	IClientBlock_getPasswordPtr = function(this: IClientBlock): PAnsiChar; cdecl;
	IClientBlock_getDataPtr = function(this: IClientBlock; length: CardinalPtr): BytePtr; cdecl;
	IClientBlock_putDataPtr = procedure(this: IClientBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
	IClientBlock_newKeyPtr = function(this: IClientBlock; status: IStatus): ICryptKey; cdecl;
	IClientBlock_getAuthBlockPtr = function(this: IClientBlock; status: IStatus): IAuthBlock; cdecl;
	IServer_authenticatePtr = function(this: IServer; status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer; cdecl;
	IServer_setDbCryptCallbackPtr = procedure(this: IServer; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
	IClient_authenticatePtr = function(this: IClient; status: IStatus; cBlock: IClientBlock): Integer; cdecl;
	IUserField_enteredPtr = function(this: IUserField): Integer; cdecl;
	IUserField_specifiedPtr = function(this: IUserField): Integer; cdecl;
	IUserField_setEnteredPtr = procedure(this: IUserField; status: IStatus; newValue: Integer); cdecl;
	ICharUserField_getPtr = function(this: ICharUserField): PAnsiChar; cdecl;
	ICharUserField_set_Ptr = procedure(this: ICharUserField; status: IStatus; newValue: PAnsiChar); cdecl;
	IIntUserField_getPtr = function(this: IIntUserField): Integer; cdecl;
	IIntUserField_set_Ptr = procedure(this: IIntUserField; status: IStatus; newValue: Integer); cdecl;
	IUser_operationPtr = function(this: IUser): Cardinal; cdecl;
	IUser_userNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_passwordPtr = function(this: IUser): ICharUserField; cdecl;
	IUser_firstNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_lastNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_middleNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_commentPtr = function(this: IUser): ICharUserField; cdecl;
	IUser_attributesPtr = function(this: IUser): ICharUserField; cdecl;
	IUser_activePtr = function(this: IUser): IIntUserField; cdecl;
	IUser_adminPtr = function(this: IUser): IIntUserField; cdecl;
	IUser_clearPtr = procedure(this: IUser; status: IStatus); cdecl;
	IListUsers_listPtr = procedure(this: IListUsers; status: IStatus; user: IUser); cdecl;
	ILogonInfo_namePtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_rolePtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_networkProtocolPtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_remoteAddressPtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_authBlockPtr = function(this: ILogonInfo; length: CardinalPtr): BytePtr; cdecl;
	ILogonInfo_attachmentPtr = function(this: ILogonInfo; status: IStatus): IAttachment; cdecl;
	ILogonInfo_transactionPtr = function(this: ILogonInfo; status: IStatus): ITransaction; cdecl;
	IManagement_startPtr = procedure(this: IManagement; status: IStatus; logonInfo: ILogonInfo); cdecl;
	IManagement_executePtr = function(this: IManagement; status: IStatus; user: IUser; callback: IListUsers): Integer; cdecl;
	IManagement_commitPtr = procedure(this: IManagement; status: IStatus); cdecl;
	IManagement_rollbackPtr = procedure(this: IManagement; status: IStatus); cdecl;
	IAuthBlock_getTypePtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getNamePtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getPluginPtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getSecurityDbPtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getOriginalPluginPtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_nextPtr = function(this: IAuthBlock; status: IStatus): Boolean; cdecl;
	IAuthBlock_firstPtr = function(this: IAuthBlock; status: IStatus): Boolean; cdecl;
	IWireCryptPlugin_getKnownTypesPtr = function(this: IWireCryptPlugin; status: IStatus): PAnsiChar; cdecl;
	IWireCryptPlugin_setKeyPtr = procedure(this: IWireCryptPlugin; status: IStatus; key: ICryptKey); cdecl;
	IWireCryptPlugin_encryptPtr = procedure(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IWireCryptPlugin_decryptPtr = procedure(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IWireCryptPlugin_getSpecificDataPtr = function(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr; cdecl;
	IWireCryptPlugin_setSpecificDataPtr = procedure(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr); cdecl;
	ICryptKeyCallback_callbackPtr = function(this: ICryptKeyCallback; dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; cdecl;
	IKeyHolderPlugin_keyCallbackPtr = function(this: IKeyHolderPlugin; status: IStatus; callback: ICryptKeyCallback): Integer; cdecl;
	IKeyHolderPlugin_keyHandlePtr = function(this: IKeyHolderPlugin; status: IStatus; keyName: PAnsiChar): ICryptKeyCallback; cdecl;
	IKeyHolderPlugin_useOnlyOwnKeysPtr = function(this: IKeyHolderPlugin; status: IStatus): Boolean; cdecl;
	IKeyHolderPlugin_chainHandlePtr = function(this: IKeyHolderPlugin; status: IStatus): ICryptKeyCallback; cdecl;
	IDbCryptInfo_getDatabaseFullPathPtr = function(this: IDbCryptInfo; status: IStatus): PAnsiChar; cdecl;
	IDbCryptPlugin_setKeyPtr = procedure(this: IDbCryptPlugin; status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar); cdecl;
	IDbCryptPlugin_encryptPtr = procedure(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IDbCryptPlugin_decryptPtr = procedure(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IDbCryptPlugin_setInfoPtr = procedure(this: IDbCryptPlugin; status: IStatus; info: IDbCryptInfo); cdecl;
	IExternalContext_getMasterPtr = function(this: IExternalContext): IMaster; cdecl;
	IExternalContext_getEnginePtr = function(this: IExternalContext; status: IStatus): IExternalEngine; cdecl;
	IExternalContext_getAttachmentPtr = function(this: IExternalContext; status: IStatus): IAttachment; cdecl;
	IExternalContext_getTransactionPtr = function(this: IExternalContext; status: IStatus): ITransaction; cdecl;
	IExternalContext_getUserNamePtr = function(this: IExternalContext): PAnsiChar; cdecl;
	IExternalContext_getDatabaseNamePtr = function(this: IExternalContext): PAnsiChar; cdecl;
	IExternalContext_getClientCharSetPtr = function(this: IExternalContext): PAnsiChar; cdecl;
	IExternalContext_obtainInfoCodePtr = function(this: IExternalContext): Integer; cdecl;
	IExternalContext_getInfoPtr = function(this: IExternalContext; code: Integer): Pointer; cdecl;
	IExternalContext_setInfoPtr = function(this: IExternalContext; code: Integer; value: Pointer): Pointer; cdecl;
	IExternalResultSet_fetchPtr = function(this: IExternalResultSet; status: IStatus): Boolean; cdecl;
	IExternalFunction_getCharSetPtr = procedure(this: IExternalFunction; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalFunction_executePtr = procedure(this: IExternalFunction; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer); cdecl;
	IExternalProcedure_getCharSetPtr = procedure(this: IExternalProcedure; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalProcedure_openPtr = function(this: IExternalProcedure; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet; cdecl;
	IExternalTrigger_getCharSetPtr = procedure(this: IExternalTrigger; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalTrigger_executePtr = procedure(this: IExternalTrigger; status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); cdecl;
	IRoutineMetadata_getPackagePtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getNamePtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getEntryPointPtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getBodyPtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getInputMetadataPtr = function(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
	IRoutineMetadata_getOutputMetadataPtr = function(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
	IRoutineMetadata_getTriggerMetadataPtr = function(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
	IRoutineMetadata_getTriggerTablePtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getTriggerTypePtr = function(this: IRoutineMetadata; status: IStatus): Cardinal; cdecl;
	IExternalEngine_openPtr = procedure(this: IExternalEngine; status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal); cdecl;
	IExternalEngine_openAttachmentPtr = procedure(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
	IExternalEngine_closeAttachmentPtr = procedure(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
	IExternalEngine_makeFunctionPtr = function(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction; cdecl;
	IExternalEngine_makeProcedurePtr = function(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure; cdecl;
	IExternalEngine_makeTriggerPtr = function(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger; cdecl;
	ITimer_handlerPtr = procedure(this: ITimer); cdecl;
	ITimerControl_startPtr = procedure(this: ITimerControl; status: IStatus; timer: ITimer; microSeconds: QWord); cdecl;
	ITimerControl_stopPtr = procedure(this: ITimerControl; status: IStatus; timer: ITimer); cdecl;
	IVersionCallback_callbackPtr = procedure(this: IVersionCallback; status: IStatus; text: PAnsiChar); cdecl;
	IUtil_getFbVersionPtr = procedure(this: IUtil; status: IStatus; att: IAttachment; callback: IVersionCallback); cdecl;
	IUtil_loadBlobPtr = procedure(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
	IUtil_dumpBlobPtr = procedure(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
	IUtil_getPerfCountersPtr = procedure(this: IUtil; status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr); cdecl;
	IUtil_executeCreateDatabasePtr = function(this: IUtil; status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment; cdecl;
	IUtil_decodeDatePtr = procedure(this: IUtil; date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); cdecl;
	IUtil_decodeTimePtr = procedure(this: IUtil; time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); cdecl;
	IUtil_encodeDatePtr = function(this: IUtil; year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; cdecl;
	IUtil_encodeTimePtr = function(this: IUtil; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; cdecl;
	IUtil_formatStatusPtr = function(this: IUtil; buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal; cdecl;
	IUtil_getClientVersionPtr = function(this: IUtil): Cardinal; cdecl;
	IUtil_getXpbBuilderPtr = function(this: IUtil; status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder; cdecl;
	IUtil_setOffsetsPtr = function(this: IUtil; status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal; cdecl;
	IUtil_getDecFloat16Ptr = function(this: IUtil; status: IStatus): IDecFloat16; cdecl;
	IUtil_getDecFloat34Ptr = function(this: IUtil; status: IStatus): IDecFloat34; cdecl;
	IUtil_decodeTimeTzPtr = procedure(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_decodeTimeStampTzPtr = procedure(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_encodeTimeTzPtr = procedure(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
	IUtil_encodeTimeStampTzPtr = procedure(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
	IUtil_getInt128Ptr = function(this: IUtil; status: IStatus): IInt128; cdecl;
	IUtil_decodeTimeTzExPtr = procedure(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_decodeTimeStampTzExPtr = procedure(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IOffsetsCallback_setOffsetPtr = procedure(this: IOffsetsCallback; status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); cdecl;
	IXpbBuilder_clearPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_removeCurrentPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_insertIntPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; value: Integer); cdecl;
	IXpbBuilder_insertBigIntPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; value: Int64); cdecl;
	IXpbBuilder_insertBytesPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal); cdecl;
	IXpbBuilder_insertStringPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; str: PAnsiChar); cdecl;
	IXpbBuilder_insertTagPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte); cdecl;
	IXpbBuilder_isEofPtr = function(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
	IXpbBuilder_moveNextPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_rewindPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_findFirstPtr = function(this: IXpbBuilder; status: IStatus; tag: Byte): Boolean; cdecl;
	IXpbBuilder_findNextPtr = function(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
	IXpbBuilder_getTagPtr = function(this: IXpbBuilder; status: IStatus): Byte; cdecl;
	IXpbBuilder_getLengthPtr = function(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
	IXpbBuilder_getIntPtr = function(this: IXpbBuilder; status: IStatus): Integer; cdecl;
	IXpbBuilder_getBigIntPtr = function(this: IXpbBuilder; status: IStatus): Int64; cdecl;
	IXpbBuilder_getStringPtr = function(this: IXpbBuilder; status: IStatus): PAnsiChar; cdecl;
	IXpbBuilder_getBytesPtr = function(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
	IXpbBuilder_getBufferLengthPtr = function(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
	IXpbBuilder_getBufferPtr = function(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
	ITraceConnection_getKindPtr = function(this: ITraceConnection): Cardinal; cdecl;
	ITraceConnection_getProcessIDPtr = function(this: ITraceConnection): Integer; cdecl;
	ITraceConnection_getUserNamePtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRoleNamePtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getCharSetPtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRemoteProtocolPtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRemoteAddressPtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRemoteProcessIDPtr = function(this: ITraceConnection): Integer; cdecl;
	ITraceConnection_getRemoteProcessNamePtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceDatabaseConnection_getConnectionIDPtr = function(this: ITraceDatabaseConnection): Int64; cdecl;
	ITraceDatabaseConnection_getDatabaseNamePtr = function(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
	ITraceTransaction_getTransactionIDPtr = function(this: ITraceTransaction): Int64; cdecl;
	ITraceTransaction_getReadOnlyPtr = function(this: ITraceTransaction): Boolean; cdecl;
	ITraceTransaction_getWaitPtr = function(this: ITraceTransaction): Integer; cdecl;
	ITraceTransaction_getIsolationPtr = function(this: ITraceTransaction): Cardinal; cdecl;
	ITraceTransaction_getPerfPtr = function(this: ITraceTransaction): PerformanceInfoPtr; cdecl;
	ITraceTransaction_getInitialIDPtr = function(this: ITraceTransaction): Int64; cdecl;
	ITraceTransaction_getPreviousIDPtr = function(this: ITraceTransaction): Int64; cdecl;
	ITraceParams_getCountPtr = function(this: ITraceParams): Cardinal; cdecl;
	ITraceParams_getParamPtr = function(this: ITraceParams; idx: Cardinal): dscPtr; cdecl;
	ITraceParams_getTextUTF8Ptr = function(this: ITraceParams; status: IStatus; idx: Cardinal): PAnsiChar; cdecl;
	ITraceStatement_getStmtIDPtr = function(this: ITraceStatement): Int64; cdecl;
	ITraceStatement_getPerfPtr = function(this: ITraceStatement): PerformanceInfoPtr; cdecl;
	ITraceSQLStatement_getTextPtr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceSQLStatement_getPlanPtr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceSQLStatement_getInputsPtr = function(this: ITraceSQLStatement): ITraceParams; cdecl;
	ITraceSQLStatement_getTextUTF8Ptr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceSQLStatement_getExplainedPlanPtr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceBLRStatement_getDataPtr = function(this: ITraceBLRStatement): BytePtr; cdecl;
	ITraceBLRStatement_getDataLengthPtr = function(this: ITraceBLRStatement): Cardinal; cdecl;
	ITraceBLRStatement_getTextPtr = function(this: ITraceBLRStatement): PAnsiChar; cdecl;
	ITraceDYNRequest_getDataPtr = function(this: ITraceDYNRequest): BytePtr; cdecl;
	ITraceDYNRequest_getDataLengthPtr = function(this: ITraceDYNRequest): Cardinal; cdecl;
	ITraceDYNRequest_getTextPtr = function(this: ITraceDYNRequest): PAnsiChar; cdecl;
	ITraceContextVariable_getNameSpacePtr = function(this: ITraceContextVariable): PAnsiChar; cdecl;
	ITraceContextVariable_getVarNamePtr = function(this: ITraceContextVariable): PAnsiChar; cdecl;
	ITraceContextVariable_getVarValuePtr = function(this: ITraceContextVariable): PAnsiChar; cdecl;
	ITraceProcedure_getProcNamePtr = function(this: ITraceProcedure): PAnsiChar; cdecl;
	ITraceProcedure_getInputsPtr = function(this: ITraceProcedure): ITraceParams; cdecl;
	ITraceProcedure_getPerfPtr = function(this: ITraceProcedure): PerformanceInfoPtr; cdecl;
	ITraceFunction_getFuncNamePtr = function(this: ITraceFunction): PAnsiChar; cdecl;
	ITraceFunction_getInputsPtr = function(this: ITraceFunction): ITraceParams; cdecl;
	ITraceFunction_getResultPtr = function(this: ITraceFunction): ITraceParams; cdecl;
	ITraceFunction_getPerfPtr = function(this: ITraceFunction): PerformanceInfoPtr; cdecl;
	ITraceTrigger_getTriggerNamePtr = function(this: ITraceTrigger): PAnsiChar; cdecl;
	ITraceTrigger_getRelationNamePtr = function(this: ITraceTrigger): PAnsiChar; cdecl;
	ITraceTrigger_getActionPtr = function(this: ITraceTrigger): Integer; cdecl;
	ITraceTrigger_getWhichPtr = function(this: ITraceTrigger): Integer; cdecl;
	ITraceTrigger_getPerfPtr = function(this: ITraceTrigger): PerformanceInfoPtr; cdecl;
	ITraceServiceConnection_getServiceIDPtr = function(this: ITraceServiceConnection): Pointer; cdecl;
	ITraceServiceConnection_getServiceMgrPtr = function(this: ITraceServiceConnection): PAnsiChar; cdecl;
	ITraceServiceConnection_getServiceNamePtr = function(this: ITraceServiceConnection): PAnsiChar; cdecl;
	ITraceStatusVector_hasErrorPtr = function(this: ITraceStatusVector): Boolean; cdecl;
	ITraceStatusVector_hasWarningPtr = function(this: ITraceStatusVector): Boolean; cdecl;
	ITraceStatusVector_getStatusPtr = function(this: ITraceStatusVector): IStatus; cdecl;
	ITraceStatusVector_getTextPtr = function(this: ITraceStatusVector): PAnsiChar; cdecl;
	ITraceSweepInfo_getOITPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getOSTPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getOATPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getNextPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getPerfPtr = function(this: ITraceSweepInfo): PerformanceInfoPtr; cdecl;
	ITraceLogWriter_writePtr = function(this: ITraceLogWriter; buf: Pointer; size: Cardinal): Cardinal; cdecl;
	ITraceLogWriter_write_sPtr = function(this: ITraceLogWriter; status: IStatus; buf: Pointer; size: Cardinal): Cardinal; cdecl;
	ITraceInitInfo_getConfigTextPtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getTraceSessionIDPtr = function(this: ITraceInitInfo): Integer; cdecl;
	ITraceInitInfo_getTraceSessionNamePtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getFirebirdRootDirectoryPtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getDatabaseNamePtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getConnectionPtr = function(this: ITraceInitInfo): ITraceDatabaseConnection; cdecl;
	ITraceInitInfo_getLogWriterPtr = function(this: ITraceInitInfo): ITraceLogWriter; cdecl;
	ITracePlugin_trace_get_errorPtr = function(this: ITracePlugin): PAnsiChar; cdecl;
	ITracePlugin_trace_attachPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_detachPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean; cdecl;
	ITracePlugin_trace_transaction_startPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_transaction_endPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_proc_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_trigger_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_set_contextPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean; cdecl;
	ITracePlugin_trace_dsql_preparePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dsql_freePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dsql_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_blr_compilePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_blr_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dyn_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_attachPtr = function(this: ITracePlugin; service: ITraceServiceConnection; att_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_startPtr = function(this: ITracePlugin; service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_queryPtr = function(this: ITracePlugin; service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_detachPtr = function(this: ITracePlugin; service: ITraceServiceConnection; detach_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_event_errorPtr = function(this: ITracePlugin; connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean; cdecl;
	ITracePlugin_trace_event_sweepPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_func_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean; cdecl;
	ITraceFactory_trace_needsPtr = function(this: ITraceFactory): QWord; cdecl;
	ITraceFactory_trace_createPtr = function(this: ITraceFactory; status: IStatus; init_info: ITraceInitInfo): ITracePlugin; cdecl;
	IUdrFunctionFactory_setupPtr = procedure(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
	IUdrFunctionFactory_newItemPtr = function(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction; cdecl;
	IUdrProcedureFactory_setupPtr = procedure(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
	IUdrProcedureFactory_newItemPtr = function(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure; cdecl;
	IUdrTriggerFactory_setupPtr = procedure(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder); cdecl;
	IUdrTriggerFactory_newItemPtr = function(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger; cdecl;
	IUdrPlugin_getMasterPtr = function(this: IUdrPlugin): IMaster; cdecl;
	IUdrPlugin_registerFunctionPtr = procedure(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory); cdecl;
	IUdrPlugin_registerProcedurePtr = procedure(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory); cdecl;
	IUdrPlugin_registerTriggerPtr = procedure(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory); cdecl;
	IDecFloat16_toBcdPtr = procedure(this: IDecFloat16; from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
	IDecFloat16_toStringPtr = procedure(this: IDecFloat16; status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IDecFloat16_fromBcdPtr = procedure(this: IDecFloat16; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); cdecl;
	IDecFloat16_fromStringPtr = procedure(this: IDecFloat16; status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr); cdecl;
	IDecFloat34_toBcdPtr = procedure(this: IDecFloat34; from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
	IDecFloat34_toStringPtr = procedure(this: IDecFloat34; status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IDecFloat34_fromBcdPtr = procedure(this: IDecFloat34; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); cdecl;
	IDecFloat34_fromStringPtr = procedure(this: IDecFloat34; status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr); cdecl;
	IInt128_toStringPtr = procedure(this: IInt128; status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IInt128_fromStringPtr = procedure(this: IInt128; status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); cdecl;
	IReplicatedField_getNamePtr = function(this: IReplicatedField): PAnsiChar; cdecl;
	IReplicatedField_getTypePtr = function(this: IReplicatedField): Cardinal; cdecl;
	IReplicatedField_getSubTypePtr = function(this: IReplicatedField): Integer; cdecl;
	IReplicatedField_getScalePtr = function(this: IReplicatedField): Integer; cdecl;
	IReplicatedField_getLengthPtr = function(this: IReplicatedField): Cardinal; cdecl;
	IReplicatedField_getCharSetPtr = function(this: IReplicatedField): Cardinal; cdecl;
	IReplicatedField_getDataPtr = function(this: IReplicatedField): Pointer; cdecl;
	IReplicatedRecord_getCountPtr = function(this: IReplicatedRecord): Cardinal; cdecl;
	IReplicatedRecord_getFieldPtr = function(this: IReplicatedRecord; index: Cardinal): IReplicatedField; cdecl;
	IReplicatedRecord_getRawLengthPtr = function(this: IReplicatedRecord): Cardinal; cdecl;
	IReplicatedRecord_getRawDataPtr = function(this: IReplicatedRecord): BytePtr; cdecl;
	IReplicatedTransaction_preparePtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_commitPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_rollbackPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_startSavepointPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_releaseSavepointPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_rollbackSavepointPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_insertRecordPtr = procedure(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
	IReplicatedTransaction_updateRecordPtr = procedure(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord); cdecl;
	IReplicatedTransaction_deleteRecordPtr = procedure(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
	IReplicatedTransaction_executeSqlPtr = procedure(this: IReplicatedTransaction; status: IStatus; sql: PAnsiChar); cdecl;
	IReplicatedTransaction_executeSqlIntlPtr = procedure(this: IReplicatedTransaction; status: IStatus; charset: Cardinal; sql: PAnsiChar); cdecl;
	IReplicatedSession_initPtr = function(this: IReplicatedSession; status: IStatus; attachment: IAttachment): Boolean; cdecl;
	IReplicatedSession_startTransactionPtr = function(this: IReplicatedSession; status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction; cdecl;
	IReplicatedSession_cleanupTransactionPtr = procedure(this: IReplicatedSession; status: IStatus; number: Int64); cdecl;
	IReplicatedSession_setSequencePtr = procedure(this: IReplicatedSession; status: IStatus; name: PAnsiChar; value: Int64); cdecl;

	PVersionedVTable = ^VersionedVTable;
	VersionedVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	end;

	IVersionedImpl = class;

	TFirebirdOOAPIImplementationClass = class of IVersionedImpl;

	TVersioned = record
	private
	  FNullPtr: pointer;
	  FvTable: PVersionedVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IVersioned; inline;
	public
	  function isIVersionedImpl: boolean;
	  function asIVersionedImpl: IVersionedImpl;
	  property vTable: PVersionedVTable read FvTable;
	end;

	IVersionedImpl = class
	private
	  FNullPtr: pointer;
	  FvTable: pointer;
	  FObject: TObject;
	  function getVTable: PVersionedVTable;
	public
	  const VERSION = 0;
	public
	  constructor create;
	  function asIVersioned: IVersioned;
	  class function isIVersionedImpl(intf: IVersioned): boolean;
	  property vTable: PVersionedVTable read getVTable;
	end;

	PReferenceCountedVTable = ^ReferenceCountedVTable;
	ReferenceCountedVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	end;

	IReferenceCountedImpl = class;

	TReferenceCounted = record
	private
	  FNullPtr: pointer;
	  FvTable: PReferenceCountedVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IReferenceCounted; inline;
	public
	  function isIReferenceCountedImpl: boolean;
	  function asIReferenceCountedImpl: IReferenceCountedImpl;
	  property vTable: PReferenceCountedVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	end;

	IReferenceCountedImpl = class(IVersionedImpl)
	private
	  function getVTable: PReferenceCountedVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asIReferenceCounted: IReferenceCounted;
	  class function isIReferenceCountedImpl(intf: IReferenceCounted): boolean;
	  property vTable: PReferenceCountedVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure addRef(); virtual; abstract;
	  function release(): Integer; virtual; abstract;
	end;

	PDisposableVTable = ^DisposableVTable;
	DisposableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	end;

	IDisposableImpl = class;

	TDisposable = record
	private
	  FNullPtr: pointer;
	  FvTable: PDisposableVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDisposable; inline;
	public
	  function isIDisposableImpl: boolean;
	  function asIDisposableImpl: IDisposableImpl;
	  property vTable: PDisposableVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	end;

	IDisposableImpl = class(IVersionedImpl)
	private
	  function getVTable: PDisposableVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asIDisposable: IDisposable;
	  class function isIDisposableImpl(intf: IDisposable): boolean;
	  property vTable: PDisposableVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure dispose(); virtual; abstract;
	end;

	PStatusVTable = ^StatusVTable;
	StatusVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  init: IStatus_initPtr;
	  getState: IStatus_getStatePtr;
	  setErrors2: IStatus_setErrors2Ptr;
	  setWarnings2: IStatus_setWarnings2Ptr;
	  setErrors: IStatus_setErrorsPtr;
	  setWarnings: IStatus_setWarningsPtr;
	  getErrors: IStatus_getErrorsPtr;
	  getWarnings: IStatus_getWarningsPtr;
	  clone: IStatus_clonePtr;
	end;

	IStatusImpl = class;

	TStatus = record
	private
	  FNullPtr: pointer;
	  FvTable: PStatusVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IStatus; inline;
	public
	  function isIStatusImpl: boolean;
	  function asIStatusImpl: IStatusImpl;
	  property vTable: PStatusVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure init();
	  function getState(): Cardinal;
	  procedure setErrors2(length: Cardinal; value: NativeIntPtr);
	  procedure setWarnings2(length: Cardinal; value: NativeIntPtr);
	  procedure setErrors(value: NativeIntPtr);
	  procedure setWarnings(value: NativeIntPtr);
	  function getErrors(): NativeIntPtr;
	  function getWarnings(): NativeIntPtr;
	  function clone(): IStatus;
	end;

	IStatusImpl = class(IDisposableImpl)
	private
	  function getVTable: PStatusVTable;
	public
	  const VERSION = 10;
	  const STATE_WARNINGS = Cardinal($1);
	  const STATE_ERRORS = Cardinal($2);
	  const RESULT_ERROR = Integer(-1);
	  const RESULT_OK = Integer(0);
	  const RESULT_NO_DATA = Integer(1);
	  const RESULT_SEGMENT = Integer(2);
	public
	  constructor create;
	  function asIStatus: IStatus;
	  class function isIStatusImpl(intf: IStatus): boolean;
	  property vTable: PStatusVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure init(); virtual; abstract;
	  function getState(): Cardinal; virtual; abstract;
	  procedure setErrors2(length: Cardinal; value: NativeIntPtr); virtual; abstract;
	  procedure setWarnings2(length: Cardinal; value: NativeIntPtr); virtual; abstract;
	  procedure setErrors(value: NativeIntPtr); virtual; abstract;
	  procedure setWarnings(value: NativeIntPtr); virtual; abstract;
	  function getErrors(): NativeIntPtr; virtual; abstract;
	  function getWarnings(): NativeIntPtr; virtual; abstract;
	  function clone(): IStatus; virtual; abstract;
	end;

	PMasterVTable = ^MasterVTable;
	MasterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStatus: IMaster_getStatusPtr;
	  getDispatcher: IMaster_getDispatcherPtr;
	  getPluginManager: IMaster_getPluginManagerPtr;
	  getTimerControl: IMaster_getTimerControlPtr;
	  getDtc: IMaster_getDtcPtr;
	  registerAttachment: IMaster_registerAttachmentPtr;
	  registerTransaction: IMaster_registerTransactionPtr;
	  getMetadataBuilder: IMaster_getMetadataBuilderPtr;
	  serverMode: IMaster_serverModePtr;
	  getUtilInterface: IMaster_getUtilInterfacePtr;
	  getConfigManager: IMaster_getConfigManagerPtr;
	  getProcessExiting: IMaster_getProcessExitingPtr;
	end;

	IMasterImpl = class;

	TMaster = record
	private
	  FNullPtr: pointer;
	  FvTable: PMasterVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IMaster; inline;
	public
	  function isIMasterImpl: boolean;
	  function asIMasterImpl: IMasterImpl;
	  property vTable: PMasterVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getStatus(): IStatus;
	  function getDispatcher(): IProvider;
	  function getPluginManager(): IPluginManager;
	  function getTimerControl(): ITimerControl;
	  function getDtc(): IDtc;
	  function registerAttachment(provider: IProvider; attachment: IAttachment): IAttachment;
	  function registerTransaction(attachment: IAttachment; transaction: ITransaction): ITransaction;
	  function getMetadataBuilder(status: IStatus; fieldCount: Cardinal): IMetadataBuilder;
	  function serverMode(mode: Integer): Integer;
	  function getUtilInterface(): IUtil;
	  function getConfigManager(): IConfigManager;
	  function getProcessExiting(): Boolean;
	end;

	IMasterImpl = class(IVersionedImpl)
	private
	  function getVTable: PMasterVTable;
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function asIMaster: IMaster;
	  class function isIMasterImpl(intf: IMaster): boolean;
	  property vTable: PMasterVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getStatus(): IStatus; virtual; abstract;
	  function getDispatcher(): IProvider; virtual; abstract;
	  function getPluginManager(): IPluginManager; virtual; abstract;
	  function getTimerControl(): ITimerControl; virtual; abstract;
	  function getDtc(): IDtc; virtual; abstract;
	  function registerAttachment(provider: IProvider; attachment: IAttachment): IAttachment; virtual; abstract;
	  function registerTransaction(attachment: IAttachment; transaction: ITransaction): ITransaction; virtual; abstract;
	  function getMetadataBuilder(status: IStatus; fieldCount: Cardinal): IMetadataBuilder; virtual; abstract;
	  function serverMode(mode: Integer): Integer; virtual; abstract;
	  function getUtilInterface(): IUtil; virtual; abstract;
	  function getConfigManager(): IConfigManager; virtual; abstract;
	  function getProcessExiting(): Boolean; virtual; abstract;
	end;

	PPluginBaseVTable = ^PluginBaseVTable;
	PluginBaseVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	end;

	IPluginBaseImpl = class;

	TPluginBase = record
	private
	  FNullPtr: pointer;
	  FvTable: PPluginBaseVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IPluginBase; inline;
	public
	  function isIPluginBaseImpl: boolean;
	  function asIPluginBaseImpl: IPluginBaseImpl;
	  property vTable: PPluginBaseVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	end;

	IPluginBaseImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PPluginBaseVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIPluginBase: IPluginBase;
	  class function isIPluginBaseImpl(intf: IPluginBase): boolean;
	  property vTable: PPluginBaseVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setOwner(r: IReferenceCounted); virtual; abstract;
	  function getOwner(): IReferenceCounted; virtual; abstract;
	end;

	PPluginSetVTable = ^PluginSetVTable;
	PluginSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getName: IPluginSet_getNamePtr;
	  getModuleName: IPluginSet_getModuleNamePtr;
	  getPlugin: IPluginSet_getPluginPtr;
	  next: IPluginSet_nextPtr;
	  set_: IPluginSet_set_Ptr;
	end;

	IPluginSetImpl = class;

	TPluginSet = record
	private
	  FNullPtr: pointer;
	  FvTable: PPluginSetVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IPluginSet; inline;
	public
	  function isIPluginSetImpl: boolean;
	  function asIPluginSetImpl: IPluginSetImpl;
	  property vTable: PPluginSetVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getName(): PAnsiChar;
	  function getModuleName(): PAnsiChar;
	  function getPlugin(status: IStatus): IPluginBase;
	  procedure next(status: IStatus);
	  procedure set_(status: IStatus; s: PAnsiChar);
	end;

	IPluginSetImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PPluginSetVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asIPluginSet: IPluginSet;
	  class function isIPluginSetImpl(intf: IPluginSet): boolean;
	  property vTable: PPluginSetVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getName(): PAnsiChar; virtual; abstract;
	  function getModuleName(): PAnsiChar; virtual; abstract;
	  function getPlugin(status: IStatus): IPluginBase; virtual; abstract;
	  procedure next(status: IStatus); virtual; abstract;
	  procedure set_(status: IStatus; s: PAnsiChar); virtual; abstract;
	end;

	PConfigEntryVTable = ^ConfigEntryVTable;
	ConfigEntryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getName: IConfigEntry_getNamePtr;
	  getValue: IConfigEntry_getValuePtr;
	  getIntValue: IConfigEntry_getIntValuePtr;
	  getBoolValue: IConfigEntry_getBoolValuePtr;
	  getSubConfig: IConfigEntry_getSubConfigPtr;
	end;

	IConfigEntryImpl = class;

	TConfigEntry = record
	private
	  FNullPtr: pointer;
	  FvTable: PConfigEntryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IConfigEntry; inline;
	public
	  function isIConfigEntryImpl: boolean;
	  function asIConfigEntryImpl: IConfigEntryImpl;
	  property vTable: PConfigEntryVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getName(): PAnsiChar;
	  function getValue(): PAnsiChar;
	  function getIntValue(): Int64;
	  function getBoolValue(): Boolean;
	  function getSubConfig(status: IStatus): IConfig;
	end;

	IConfigEntryImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PConfigEntryVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asIConfigEntry: IConfigEntry;
	  class function isIConfigEntryImpl(intf: IConfigEntry): boolean;
	  property vTable: PConfigEntryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getName(): PAnsiChar; virtual; abstract;
	  function getValue(): PAnsiChar; virtual; abstract;
	  function getIntValue(): Int64; virtual; abstract;
	  function getBoolValue(): Boolean; virtual; abstract;
	  function getSubConfig(status: IStatus): IConfig; virtual; abstract;
	end;

	PConfigVTable = ^ConfigVTable;
	ConfigVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  find: IConfig_findPtr;
	  findValue: IConfig_findValuePtr;
	  findPos: IConfig_findPosPtr;
	end;

	IConfigImpl = class;

	TConfig = record
	private
	  FNullPtr: pointer;
	  FvTable: PConfigVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IConfig; inline;
	public
	  function isIConfigImpl: boolean;
	  function asIConfigImpl: IConfigImpl;
	  property vTable: PConfigVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function find(status: IStatus; name: PAnsiChar): IConfigEntry;
	  function findValue(status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry;
	  function findPos(status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry;
	end;

	IConfigImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PConfigVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asIConfig: IConfig;
	  class function isIConfigImpl(intf: IConfig): boolean;
	  property vTable: PConfigVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function find(status: IStatus; name: PAnsiChar): IConfigEntry; virtual; abstract;
	  function findValue(status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry; virtual; abstract;
	  function findPos(status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry; virtual; abstract;
	end;

	PFirebirdConfVTable = ^FirebirdConfVTable;
	FirebirdConfVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getKey: IFirebirdConf_getKeyPtr;
	  asInteger: IFirebirdConf_asIntegerPtr;
	  asString: IFirebirdConf_asStringPtr;
	  asBoolean: IFirebirdConf_asBooleanPtr;
	  getVersion: IFirebirdConf_getVersionPtr;
	end;

	IFirebirdConfImpl = class;

	TFirebirdConf = record
	private
	  FNullPtr: pointer;
	  FvTable: PFirebirdConfVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IFirebirdConf; inline;
	public
	  function isIFirebirdConfImpl: boolean;
	  function asIFirebirdConfImpl: IFirebirdConfImpl;
	  property vTable: PFirebirdConfVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getKey(name: PAnsiChar): Cardinal;
	  function asInteger(key: Cardinal): Int64;
	  function asString(key: Cardinal): PAnsiChar;
	  function asBoolean(key: Cardinal): Boolean;
	  function getVersion(status: IStatus): Cardinal;
	end;

	IFirebirdConfImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PFirebirdConfVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asIFirebirdConf: IFirebirdConf;
	  class function isIFirebirdConfImpl(intf: IFirebirdConf): boolean;
	  property vTable: PFirebirdConfVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getKey(name: PAnsiChar): Cardinal; virtual; abstract;
	  function asInteger(key: Cardinal): Int64; virtual; abstract;
	  function asString(key: Cardinal): PAnsiChar; virtual; abstract;
	  function asBoolean(key: Cardinal): Boolean; virtual; abstract;
	  function getVersion(status: IStatus): Cardinal; virtual; abstract;
	end;

	PPluginConfigVTable = ^PluginConfigVTable;
	PluginConfigVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getConfigFileName: IPluginConfig_getConfigFileNamePtr;
	  getDefaultConfig: IPluginConfig_getDefaultConfigPtr;
	  getFirebirdConf: IPluginConfig_getFirebirdConfPtr;
	  setReleaseDelay: IPluginConfig_setReleaseDelayPtr;
	end;

	IPluginConfigImpl = class;

	TPluginConfig = record
	private
	  FNullPtr: pointer;
	  FvTable: PPluginConfigVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IPluginConfig; inline;
	public
	  function isIPluginConfigImpl: boolean;
	  function asIPluginConfigImpl: IPluginConfigImpl;
	  property vTable: PPluginConfigVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getConfigFileName(): PAnsiChar;
	  function getDefaultConfig(status: IStatus): IConfig;
	  function getFirebirdConf(status: IStatus): IFirebirdConf;
	  procedure setReleaseDelay(status: IStatus; microSeconds: QWord);
	end;

	IPluginConfigImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PPluginConfigVTable;
	public
	  const VERSION = 6;
	public
	  constructor create;
	  function asIPluginConfig: IPluginConfig;
	  class function isIPluginConfigImpl(intf: IPluginConfig): boolean;
	  property vTable: PPluginConfigVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getConfigFileName(): PAnsiChar; virtual; abstract;
	  function getDefaultConfig(status: IStatus): IConfig; virtual; abstract;
	  function getFirebirdConf(status: IStatus): IFirebirdConf; virtual; abstract;
	  procedure setReleaseDelay(status: IStatus; microSeconds: QWord); virtual; abstract;
	end;

	PPluginFactoryVTable = ^PluginFactoryVTable;
	PluginFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  createPlugin: IPluginFactory_createPluginPtr;
	end;

	IPluginFactoryImpl = class;

	TPluginFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PPluginFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IPluginFactory; inline;
	public
	  function isIPluginFactoryImpl: boolean;
	  function asIPluginFactoryImpl: IPluginFactoryImpl;
	  property vTable: PPluginFactoryVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function createPlugin(status: IStatus; factoryParameter: IPluginConfig): IPluginBase;
	end;

	IPluginFactoryImpl = class(IVersionedImpl)
	private
	  function getVTable: PPluginFactoryVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asIPluginFactory: IPluginFactory;
	  class function isIPluginFactoryImpl(intf: IPluginFactory): boolean;
	  property vTable: PPluginFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function createPlugin(status: IStatus; factoryParameter: IPluginConfig): IPluginBase; virtual; abstract;
	end;

	PPluginModuleVTable = ^PluginModuleVTable;
	PluginModuleVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  doClean: IPluginModule_doCleanPtr;
	  threadDetach: IPluginModule_threadDetachPtr;
	end;

	IPluginModuleImpl = class;

	TPluginModule = record
	private
	  FNullPtr: pointer;
	  FvTable: PPluginModuleVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IPluginModule; inline;
	public
	  function isIPluginModuleImpl: boolean;
	  function asIPluginModuleImpl: IPluginModuleImpl;
	  property vTable: PPluginModuleVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure doClean();
	  procedure threadDetach();
	end;

	IPluginModuleImpl = class(IVersionedImpl)
	private
	  function getVTable: PPluginModuleVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asIPluginModule: IPluginModule;
	  class function isIPluginModuleImpl(intf: IPluginModule): boolean;
	  property vTable: PPluginModuleVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure doClean(); virtual; abstract;
	  procedure threadDetach(); virtual; abstract;
	end;

	PPluginManagerVTable = ^PluginManagerVTable;
	PluginManagerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  registerPluginFactory: IPluginManager_registerPluginFactoryPtr;
	  registerModule: IPluginManager_registerModulePtr;
	  unregisterModule: IPluginManager_unregisterModulePtr;
	  getPlugins: IPluginManager_getPluginsPtr;
	  getConfig: IPluginManager_getConfigPtr;
	  releasePlugin: IPluginManager_releasePluginPtr;
	end;

	IPluginManagerImpl = class;

	TPluginManager = record
	private
	  FNullPtr: pointer;
	  FvTable: PPluginManagerVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IPluginManager; inline;
	public
	  function isIPluginManagerImpl: boolean;
	  function asIPluginManagerImpl: IPluginManagerImpl;
	  property vTable: PPluginManagerVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory);
	  procedure registerModule(cleanup: IPluginModule);
	  procedure unregisterModule(cleanup: IPluginModule);
	  function getPlugins(status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet;
	  function getConfig(status: IStatus; filename: PAnsiChar): IConfig;
	  procedure releasePlugin(plugin: IPluginBase);
	end;

	IPluginManagerImpl = class(IVersionedImpl)
	private
	  function getVTable: PPluginManagerVTable;
	public
	  const VERSION = 6;
	  const TYPE_PROVIDER = Cardinal(1);
	  const TYPE_FIRST_NON_LIB = Cardinal(2);
	  const TYPE_AUTH_SERVER = Cardinal(3);
	  const TYPE_AUTH_CLIENT = Cardinal(4);
	  const TYPE_AUTH_USER_MANAGEMENT = Cardinal(5);
	  const TYPE_EXTERNAL_ENGINE = Cardinal(6);
	  const TYPE_TRACE = Cardinal(7);
	  const TYPE_WIRE_CRYPT = Cardinal(8);
	  const TYPE_DB_CRYPT = Cardinal(9);
	  const TYPE_KEY_HOLDER = Cardinal(10);
	  const TYPE_REPLICATOR = Cardinal(11);
	  const TYPE_COUNT = Cardinal(12);
	public
	  constructor create;
	  function asIPluginManager: IPluginManager;
	  class function isIPluginManagerImpl(intf: IPluginManager): boolean;
	  property vTable: PPluginManagerVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory); virtual; abstract;
	  procedure registerModule(cleanup: IPluginModule); virtual; abstract;
	  procedure unregisterModule(cleanup: IPluginModule); virtual; abstract;
	  function getPlugins(status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet; virtual; abstract;
	  function getConfig(status: IStatus; filename: PAnsiChar): IConfig; virtual; abstract;
	  procedure releasePlugin(plugin: IPluginBase); virtual; abstract;
	end;

	PCryptKeyVTable = ^CryptKeyVTable;
	CryptKeyVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  setSymmetric: ICryptKey_setSymmetricPtr;
	  setAsymmetric: ICryptKey_setAsymmetricPtr;
	  getEncryptKey: ICryptKey_getEncryptKeyPtr;
	  getDecryptKey: ICryptKey_getDecryptKeyPtr;
	end;

	ICryptKeyImpl = class;

	TCryptKey = record
	private
	  FNullPtr: pointer;
	  FvTable: PCryptKeyVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ICryptKey; inline;
	public
	  function isICryptKeyImpl: boolean;
	  function asICryptKeyImpl: ICryptKeyImpl;
	  property vTable: PCryptKeyVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure setSymmetric(status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer);
	  procedure setAsymmetric(status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer);
	  function getEncryptKey(length: CardinalPtr): Pointer;
	  function getDecryptKey(length: CardinalPtr): Pointer;
	end;

	ICryptKeyImpl = class(IVersionedImpl)
	private
	  function getVTable: PCryptKeyVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asICryptKey: ICryptKey;
	  class function isICryptKeyImpl(intf: ICryptKey): boolean;
	  property vTable: PCryptKeyVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setSymmetric(status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); virtual; abstract;
	  procedure setAsymmetric(status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); virtual; abstract;
	  function getEncryptKey(length: CardinalPtr): Pointer; virtual; abstract;
	  function getDecryptKey(length: CardinalPtr): Pointer; virtual; abstract;
	end;

	PConfigManagerVTable = ^ConfigManagerVTable;
	ConfigManagerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getDirectory: IConfigManager_getDirectoryPtr;
	  getFirebirdConf: IConfigManager_getFirebirdConfPtr;
	  getDatabaseConf: IConfigManager_getDatabaseConfPtr;
	  getPluginConfig: IConfigManager_getPluginConfigPtr;
	  getInstallDirectory: IConfigManager_getInstallDirectoryPtr;
	  getRootDirectory: IConfigManager_getRootDirectoryPtr;
	  getDefaultSecurityDb: IConfigManager_getDefaultSecurityDbPtr;
	end;

	IConfigManagerImpl = class;

	TConfigManager = record
	private
	  FNullPtr: pointer;
	  FvTable: PConfigManagerVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IConfigManager; inline;
	public
	  function isIConfigManagerImpl: boolean;
	  function asIConfigManagerImpl: IConfigManagerImpl;
	  property vTable: PConfigManagerVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getDirectory(code: Cardinal): PAnsiChar;
	  function getFirebirdConf(): IFirebirdConf;
	  function getDatabaseConf(dbName: PAnsiChar): IFirebirdConf;
	  function getPluginConfig(configuredPlugin: PAnsiChar): IConfig;
	  function getInstallDirectory(): PAnsiChar;
	  function getRootDirectory(): PAnsiChar;
	  function getDefaultSecurityDb(): PAnsiChar;
	end;

	IConfigManagerImpl = class(IVersionedImpl)
	private
	  function getVTable: PConfigManagerVTable;
	public
	  const VERSION = 7;
	  const DIR_BIN = Cardinal(0);
	  const DIR_SBIN = Cardinal(1);
	  const DIR_CONF = Cardinal(2);
	  const DIR_LIB = Cardinal(3);
	  const DIR_INC = Cardinal(4);
	  const DIR_DOC = Cardinal(5);
	  const DIR_UDF = Cardinal(6);
	  const DIR_SAMPLE = Cardinal(7);
	  const DIR_SAMPLEDB = Cardinal(8);
	  const DIR_HELP = Cardinal(9);
	  const DIR_INTL = Cardinal(10);
	  const DIR_MISC = Cardinal(11);
	  const DIR_SECDB = Cardinal(12);
	  const DIR_MSG = Cardinal(13);
	  const DIR_LOG = Cardinal(14);
	  const DIR_GUARD = Cardinal(15);
	  const DIR_PLUGINS = Cardinal(16);
	  const DIR_TZDATA = Cardinal(17);
	  const DIR_COUNT = Cardinal(18);
	public
	  constructor create;
	  function asIConfigManager: IConfigManager;
	  class function isIConfigManagerImpl(intf: IConfigManager): boolean;
	  property vTable: PConfigManagerVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getDirectory(code: Cardinal): PAnsiChar; virtual; abstract;
	  function getFirebirdConf(): IFirebirdConf; virtual; abstract;
	  function getDatabaseConf(dbName: PAnsiChar): IFirebirdConf; virtual; abstract;
	  function getPluginConfig(configuredPlugin: PAnsiChar): IConfig; virtual; abstract;
	  function getInstallDirectory(): PAnsiChar; virtual; abstract;
	  function getRootDirectory(): PAnsiChar; virtual; abstract;
	  function getDefaultSecurityDb(): PAnsiChar; virtual; abstract;
	end;

	PEventCallbackVTable = ^EventCallbackVTable;
	EventCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  eventCallbackFunction: IEventCallback_eventCallbackFunctionPtr;
	end;

	IEventCallbackImpl = class;

	TEventCallback = record
	private
	  FNullPtr: pointer;
	  FvTable: PEventCallbackVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IEventCallback; inline;
	public
	  function isIEventCallbackImpl: boolean;
	  function asIEventCallbackImpl: IEventCallbackImpl;
	  property vTable: PEventCallbackVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure eventCallbackFunction(length: Cardinal; events: BytePtr);
	end;

	IEventCallbackImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PEventCallbackVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIEventCallback: IEventCallback;
	  class function isIEventCallbackImpl(intf: IEventCallback): boolean;
	  property vTable: PEventCallbackVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure eventCallbackFunction(length: Cardinal; events: BytePtr); virtual; abstract;
	end;

	PBlobVTable = ^BlobVTable;
	BlobVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IBlob_getInfoPtr;
	  getSegment: IBlob_getSegmentPtr;
	  putSegment: IBlob_putSegmentPtr;
	  cancel: IBlob_cancelPtr;
	  close: IBlob_closePtr;
	  seek: IBlob_seekPtr;
	end;

	IBlobImpl = class;

	TBlob = record
	private
	  FNullPtr: pointer;
	  FvTable: PBlobVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IBlob; inline;
	public
	  function isIBlobImpl: boolean;
	  function asIBlobImpl: IBlobImpl;
	  property vTable: PBlobVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function getSegment(status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer;
	  procedure putSegment(status: IStatus; length: Cardinal; buffer: Pointer);
	  procedure cancel(status: IStatus);
	  procedure close(status: IStatus);
	  function seek(status: IStatus; mode: Integer; offset: Integer): Integer;
	end;

	IBlobImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PBlobVTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asIBlob: IBlob;
	  class function isIBlobImpl(intf: IBlob): boolean;
	  property vTable: PBlobVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  function getSegment(status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; virtual; abstract;
	  procedure putSegment(status: IStatus; length: Cardinal; buffer: Pointer); virtual; abstract;
	  procedure cancel(status: IStatus); virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	  function seek(status: IStatus; mode: Integer; offset: Integer): Integer; virtual; abstract;
	end;

	PTransactionVTable = ^TransactionVTable;
	TransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: ITransaction_getInfoPtr;
	  prepare: ITransaction_preparePtr;
	  commit: ITransaction_commitPtr;
	  commitRetaining: ITransaction_commitRetainingPtr;
	  rollback: ITransaction_rollbackPtr;
	  rollbackRetaining: ITransaction_rollbackRetainingPtr;
	  disconnect: ITransaction_disconnectPtr;
	  join: ITransaction_joinPtr;
	  validate: ITransaction_validatePtr;
	  enterDtc: ITransaction_enterDtcPtr;
	end;

	ITransactionImpl = class;

	TTransaction = record
	private
	  FNullPtr: pointer;
	  FvTable: PTransactionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITransaction; inline;
	public
	  function isITransactionImpl: boolean;
	  function asITransactionImpl: ITransactionImpl;
	  property vTable: PTransactionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure prepare(status: IStatus; msgLength: Cardinal; message: BytePtr);
	  procedure commit(status: IStatus);
	  procedure commitRetaining(status: IStatus);
	  procedure rollback(status: IStatus);
	  procedure rollbackRetaining(status: IStatus);
	  procedure disconnect(status: IStatus);
	  function join(status: IStatus; transaction: ITransaction): ITransaction;
	  function validate(status: IStatus; attachment: IAttachment): ITransaction;
	  function enterDtc(status: IStatus): ITransaction;
	end;

	ITransactionImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PTransactionVTable;
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function asITransaction: ITransaction;
	  class function isITransactionImpl(intf: ITransaction): boolean;
	  property vTable: PTransactionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  procedure prepare(status: IStatus; msgLength: Cardinal; message: BytePtr); virtual; abstract;
	  procedure commit(status: IStatus); virtual; abstract;
	  procedure commitRetaining(status: IStatus); virtual; abstract;
	  procedure rollback(status: IStatus); virtual; abstract;
	  procedure rollbackRetaining(status: IStatus); virtual; abstract;
	  procedure disconnect(status: IStatus); virtual; abstract;
	  function join(status: IStatus; transaction: ITransaction): ITransaction; virtual; abstract;
	  function validate(status: IStatus; attachment: IAttachment): ITransaction; virtual; abstract;
	  function enterDtc(status: IStatus): ITransaction; virtual; abstract;
	end;

	PMessageMetadataVTable = ^MessageMetadataVTable;
	MessageMetadataVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getCount: IMessageMetadata_getCountPtr;
	  getField: IMessageMetadata_getFieldPtr;
	  getRelation: IMessageMetadata_getRelationPtr;
	  getOwner: IMessageMetadata_getOwnerPtr;
	  getAlias: IMessageMetadata_getAliasPtr;
	  getType: IMessageMetadata_getTypePtr;
	  isNullable: IMessageMetadata_isNullablePtr;
	  getSubType: IMessageMetadata_getSubTypePtr;
	  getLength: IMessageMetadata_getLengthPtr;
	  getScale: IMessageMetadata_getScalePtr;
	  getCharSet: IMessageMetadata_getCharSetPtr;
	  getOffset: IMessageMetadata_getOffsetPtr;
	  getNullOffset: IMessageMetadata_getNullOffsetPtr;
	  getBuilder: IMessageMetadata_getBuilderPtr;
	  getMessageLength: IMessageMetadata_getMessageLengthPtr;
	  getAlignment: IMessageMetadata_getAlignmentPtr;
	  getAlignedLength: IMessageMetadata_getAlignedLengthPtr;
	end;

	IMessageMetadataImpl = class;

	TMessageMetadata = record
	private
	  FNullPtr: pointer;
	  FvTable: PMessageMetadataVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IMessageMetadata; inline;
	public
	  function isIMessageMetadataImpl: boolean;
	  function asIMessageMetadataImpl: IMessageMetadataImpl;
	  property vTable: PMessageMetadataVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getCount(status: IStatus): Cardinal;
	  function getField(status: IStatus; index: Cardinal): PAnsiChar;
	  function getRelation(status: IStatus; index: Cardinal): PAnsiChar;
	  function getOwner(status: IStatus; index: Cardinal): PAnsiChar;
	  function getAlias(status: IStatus; index: Cardinal): PAnsiChar;
	  function getType(status: IStatus; index: Cardinal): Cardinal;
	  function isNullable(status: IStatus; index: Cardinal): Boolean;
	  function getSubType(status: IStatus; index: Cardinal): Integer;
	  function getLength(status: IStatus; index: Cardinal): Cardinal;
	  function getScale(status: IStatus; index: Cardinal): Integer;
	  function getCharSet(status: IStatus; index: Cardinal): Cardinal;
	  function getOffset(status: IStatus; index: Cardinal): Cardinal;
	  function getNullOffset(status: IStatus; index: Cardinal): Cardinal;
	  function getBuilder(status: IStatus): IMetadataBuilder;
	  function getMessageLength(status: IStatus): Cardinal;
	  function getAlignment(status: IStatus): Cardinal;
	  function getAlignedLength(status: IStatus): Cardinal;
	end;

	IMessageMetadataImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PMessageMetadataVTable;
	public
	  const VERSION = 19;
	public
	  constructor create;
	  function asIMessageMetadata: IMessageMetadata;
	  class function isIMessageMetadataImpl(intf: IMessageMetadata): boolean;
	  property vTable: PMessageMetadataVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getCount(status: IStatus): Cardinal; virtual; abstract;
	  function getField(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getRelation(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getOwner(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getAlias(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getType(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function isNullable(status: IStatus; index: Cardinal): Boolean; virtual; abstract;
	  function getSubType(status: IStatus; index: Cardinal): Integer; virtual; abstract;
	  function getLength(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getScale(status: IStatus; index: Cardinal): Integer; virtual; abstract;
	  function getCharSet(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getOffset(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getNullOffset(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getBuilder(status: IStatus): IMetadataBuilder; virtual; abstract;
	  function getMessageLength(status: IStatus): Cardinal; virtual; abstract;
	  function getAlignment(status: IStatus): Cardinal; virtual; abstract;
	  function getAlignedLength(status: IStatus): Cardinal; virtual; abstract;
	end;

	PMetadataBuilderVTable = ^MetadataBuilderVTable;
	MetadataBuilderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setType: IMetadataBuilder_setTypePtr;
	  setSubType: IMetadataBuilder_setSubTypePtr;
	  setLength: IMetadataBuilder_setLengthPtr;
	  setCharSet: IMetadataBuilder_setCharSetPtr;
	  setScale: IMetadataBuilder_setScalePtr;
	  truncate: IMetadataBuilder_truncatePtr;
	  moveNameToIndex: IMetadataBuilder_moveNameToIndexPtr;
	  remove: IMetadataBuilder_removePtr;
	  addField: IMetadataBuilder_addFieldPtr;
	  getMetadata: IMetadataBuilder_getMetadataPtr;
	  setField: IMetadataBuilder_setFieldPtr;
	  setRelation: IMetadataBuilder_setRelationPtr;
	  setOwner: IMetadataBuilder_setOwnerPtr;
	  setAlias: IMetadataBuilder_setAliasPtr;
	end;

	IMetadataBuilderImpl = class;

	TMetadataBuilder = record
	private
	  FNullPtr: pointer;
	  FvTable: PMetadataBuilderVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IMetadataBuilder; inline;
	public
	  function isIMetadataBuilderImpl: boolean;
	  function asIMetadataBuilderImpl: IMetadataBuilderImpl;
	  property vTable: PMetadataBuilderVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setType(status: IStatus; index: Cardinal; type_: Cardinal);
	  procedure setSubType(status: IStatus; index: Cardinal; subType: Integer);
	  procedure setLength(status: IStatus; index: Cardinal; length: Cardinal);
	  procedure setCharSet(status: IStatus; index: Cardinal; charSet: Cardinal);
	  procedure setScale(status: IStatus; index: Cardinal; scale: Integer);
	  procedure truncate(status: IStatus; count: Cardinal);
	  procedure moveNameToIndex(status: IStatus; name: PAnsiChar; index: Cardinal);
	  procedure remove(status: IStatus; index: Cardinal);
	  function addField(status: IStatus): Cardinal;
	  function getMetadata(status: IStatus): IMessageMetadata;
	  procedure setField(status: IStatus; index: Cardinal; field: PAnsiChar);
	  procedure setRelation(status: IStatus; index: Cardinal; relation: PAnsiChar);
	  procedure setOwner(status: IStatus; index: Cardinal; owner: PAnsiChar);
	  procedure setAlias(status: IStatus; index: Cardinal; alias: PAnsiChar);
	end;

	IMetadataBuilderImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PMetadataBuilderVTable;
	public
	  const VERSION = 16;
	public
	  constructor create;
	  function asIMetadataBuilder: IMetadataBuilder;
	  class function isIMetadataBuilderImpl(intf: IMetadataBuilder): boolean;
	  property vTable: PMetadataBuilderVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setType(status: IStatus; index: Cardinal; type_: Cardinal); virtual; abstract;
	  procedure setSubType(status: IStatus; index: Cardinal; subType: Integer); virtual; abstract;
	  procedure setLength(status: IStatus; index: Cardinal; length: Cardinal); virtual; abstract;
	  procedure setCharSet(status: IStatus; index: Cardinal; charSet: Cardinal); virtual; abstract;
	  procedure setScale(status: IStatus; index: Cardinal; scale: Integer); virtual; abstract;
	  procedure truncate(status: IStatus; count: Cardinal); virtual; abstract;
	  procedure moveNameToIndex(status: IStatus; name: PAnsiChar; index: Cardinal); virtual; abstract;
	  procedure remove(status: IStatus; index: Cardinal); virtual; abstract;
	  function addField(status: IStatus): Cardinal; virtual; abstract;
	  function getMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  procedure setField(status: IStatus; index: Cardinal; field: PAnsiChar); virtual; abstract;
	  procedure setRelation(status: IStatus; index: Cardinal; relation: PAnsiChar); virtual; abstract;
	  procedure setOwner(status: IStatus; index: Cardinal; owner: PAnsiChar); virtual; abstract;
	  procedure setAlias(status: IStatus; index: Cardinal; alias: PAnsiChar); virtual; abstract;
	end;

	PResultSetVTable = ^ResultSetVTable;
	ResultSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  fetchNext: IResultSet_fetchNextPtr;
	  fetchPrior: IResultSet_fetchPriorPtr;
	  fetchFirst: IResultSet_fetchFirstPtr;
	  fetchLast: IResultSet_fetchLastPtr;
	  fetchAbsolute: IResultSet_fetchAbsolutePtr;
	  fetchRelative: IResultSet_fetchRelativePtr;
	  isEof: IResultSet_isEofPtr;
	  isBof: IResultSet_isBofPtr;
	  getMetadata: IResultSet_getMetadataPtr;
	  close: IResultSet_closePtr;
	  setDelayedOutputFormat: IResultSet_setDelayedOutputFormatPtr;
	end;

	IResultSetImpl = class;

	TResultSet = record
	private
	  FNullPtr: pointer;
	  FvTable: PResultSetVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IResultSet; inline;
	public
	  function isIResultSetImpl: boolean;
	  function asIResultSetImpl: IResultSetImpl;
	  property vTable: PResultSetVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function fetchNext(status: IStatus; message: Pointer): Integer;
	  function fetchPrior(status: IStatus; message: Pointer): Integer;
	  function fetchFirst(status: IStatus; message: Pointer): Integer;
	  function fetchLast(status: IStatus; message: Pointer): Integer;
	  function fetchAbsolute(status: IStatus; position: Integer; message: Pointer): Integer;
	  function fetchRelative(status: IStatus; offset: Integer; message: Pointer): Integer;
	  function isEof(status: IStatus): Boolean;
	  function isBof(status: IStatus): Boolean;
	  function getMetadata(status: IStatus): IMessageMetadata;
	  procedure close(status: IStatus);
	  procedure setDelayedOutputFormat(status: IStatus; format: IMessageMetadata);
	end;

	IResultSetImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PResultSetVTable;
	public
	  const VERSION = 13;
	public
	  constructor create;
	  function asIResultSet: IResultSet;
	  class function isIResultSetImpl(intf: IResultSet): boolean;
	  property vTable: PResultSetVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function fetchNext(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchPrior(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchFirst(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchLast(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchAbsolute(status: IStatus; position: Integer; message: Pointer): Integer; virtual; abstract;
	  function fetchRelative(status: IStatus; offset: Integer; message: Pointer): Integer; virtual; abstract;
	  function isEof(status: IStatus): Boolean; virtual; abstract;
	  function isBof(status: IStatus): Boolean; virtual; abstract;
	  function getMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	  procedure setDelayedOutputFormat(status: IStatus; format: IMessageMetadata); virtual; abstract;
	end;

	PStatementVTable = ^StatementVTable;
	StatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IStatement_getInfoPtr;
	  getType: IStatement_getTypePtr;
	  getPlan: IStatement_getPlanPtr;
	  getAffectedRecords: IStatement_getAffectedRecordsPtr;
	  getInputMetadata: IStatement_getInputMetadataPtr;
	  getOutputMetadata: IStatement_getOutputMetadataPtr;
	  execute: IStatement_executePtr;
	  openCursor: IStatement_openCursorPtr;
	  setCursorName: IStatement_setCursorNamePtr;
	  free: IStatement_freePtr;
	  getFlags: IStatement_getFlagsPtr;
	  getTimeout: IStatement_getTimeoutPtr;
	  setTimeout: IStatement_setTimeoutPtr;
	  createBatch: IStatement_createBatchPtr;
	end;

	IStatementImpl = class;

	TStatement = record
	private
	  FNullPtr: pointer;
	  FvTable: PStatementVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IStatement; inline;
	public
	  function isIStatementImpl: boolean;
	  function asIStatementImpl: IStatementImpl;
	  property vTable: PStatementVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function getType(status: IStatus): Cardinal;
	  function getPlan(status: IStatus; detailed: Boolean): PAnsiChar;
	  function getAffectedRecords(status: IStatus): QWord;
	  function getInputMetadata(status: IStatus): IMessageMetadata;
	  function getOutputMetadata(status: IStatus): IMessageMetadata;
	  function execute(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
	  function openCursor(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet;
	  procedure setCursorName(status: IStatus; name: PAnsiChar);
	  procedure free(status: IStatus);
	  function getFlags(status: IStatus): Cardinal;
	  function getTimeout(status: IStatus): Cardinal;
	  procedure setTimeout(status: IStatus; timeOut: Cardinal);
	  function createBatch(status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
	end;

	IStatementImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PStatementVTable;
	public
	  const VERSION = 16;
	  const PREPARE_PREFETCH_NONE = Cardinal($0);
	  const PREPARE_PREFETCH_TYPE = Cardinal($1);
	  const PREPARE_PREFETCH_INPUT_PARAMETERS = Cardinal($2);
	  const PREPARE_PREFETCH_OUTPUT_PARAMETERS = Cardinal($4);
	  const PREPARE_PREFETCH_LEGACY_PLAN = Cardinal($8);
	  const PREPARE_PREFETCH_DETAILED_PLAN = Cardinal($10);
	  const PREPARE_PREFETCH_AFFECTED_RECORDS = Cardinal($20);
	  const PREPARE_PREFETCH_FLAGS = Cardinal($40);
	  const PREPARE_PREFETCH_METADATA = Cardinal(IStatementImpl.PREPARE_PREFETCH_TYPE or IStatementImpl.PREPARE_PREFETCH_FLAGS or IStatementImpl.PREPARE_PREFETCH_INPUT_PARAMETERS or IStatementImpl.PREPARE_PREFETCH_OUTPUT_PARAMETERS);
	  const PREPARE_PREFETCH_ALL = Cardinal(IStatementImpl.PREPARE_PREFETCH_METADATA or IStatementImpl.PREPARE_PREFETCH_LEGACY_PLAN or IStatementImpl.PREPARE_PREFETCH_DETAILED_PLAN or IStatementImpl.PREPARE_PREFETCH_AFFECTED_RECORDS);
	  const FLAG_HAS_CURSOR = Cardinal($1);
	  const FLAG_REPEAT_EXECUTE = Cardinal($2);
	  const CURSOR_TYPE_SCROLLABLE = Cardinal($1);
	public
	  constructor create;
	  function asIStatement: IStatement;
	  class function isIStatementImpl(intf: IStatement): boolean;
	  property vTable: PStatementVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  function getType(status: IStatus): Cardinal; virtual; abstract;
	  function getPlan(status: IStatus; detailed: Boolean): PAnsiChar; virtual; abstract;
	  function getAffectedRecords(status: IStatus): QWord; virtual; abstract;
	  function getInputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getOutputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function execute(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; virtual; abstract;
	  function openCursor(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet; virtual; abstract;
	  procedure setCursorName(status: IStatus; name: PAnsiChar); virtual; abstract;
	  procedure free(status: IStatus); virtual; abstract;
	  function getFlags(status: IStatus): Cardinal; virtual; abstract;
	  function getTimeout(status: IStatus): Cardinal; virtual; abstract;
	  procedure setTimeout(status: IStatus; timeOut: Cardinal); virtual; abstract;
	  function createBatch(status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; virtual; abstract;
	end;

	PBatchVTable = ^BatchVTable;
	BatchVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  add: IBatch_addPtr;
	  addBlob: IBatch_addBlobPtr;
	  appendBlobData: IBatch_appendBlobDataPtr;
	  addBlobStream: IBatch_addBlobStreamPtr;
	  registerBlob: IBatch_registerBlobPtr;
	  execute: IBatch_executePtr;
	  cancel: IBatch_cancelPtr;
	  getBlobAlignment: IBatch_getBlobAlignmentPtr;
	  getMetadata: IBatch_getMetadataPtr;
	  setDefaultBpb: IBatch_setDefaultBpbPtr;
	  close: IBatch_closePtr;
	end;

	IBatchImpl = class;

	TBatch = record
	private
	  FNullPtr: pointer;
	  FvTable: PBatchVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IBatch; inline;
	public
	  function isIBatchImpl: boolean;
	  function asIBatchImpl: IBatchImpl;
	  property vTable: PBatchVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure add(status: IStatus; count: Cardinal; inBuffer: Pointer);
	  procedure addBlob(status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr);
	  procedure appendBlobData(status: IStatus; length: Cardinal; inBuffer: Pointer);
	  procedure addBlobStream(status: IStatus; length: Cardinal; inBuffer: Pointer);
	  procedure registerBlob(status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr);
	  function execute(status: IStatus; transaction: ITransaction): IBatchCompletionState;
	  procedure cancel(status: IStatus);
	  function getBlobAlignment(status: IStatus): Cardinal;
	  function getMetadata(status: IStatus): IMessageMetadata;
	  procedure setDefaultBpb(status: IStatus; parLength: Cardinal; par: BytePtr);
	  procedure close(status: IStatus);
	end;

	IBatchImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PBatchVTable;
	public
	  const VERSION = 13;
	  const VERSION1 = Byte(1);
	  const TAG_MULTIERROR = Byte(1);
	  const TAG_RECORD_COUNTS = Byte(2);
	  const TAG_BUFFER_BYTES_SIZE = Byte(3);
	  const TAG_BLOB_POLICY = Byte(4);
	  const TAG_DETAILED_ERRORS = Byte(5);
	  const BLOB_NONE = Byte(0);
	  const BLOB_ID_ENGINE = Byte(1);
	  const BLOB_ID_USER = Byte(2);
	  const BLOB_STREAM = Byte(3);
	  const BLOB_SEGHDR_ALIGN = Cardinal(2);
	public
	  constructor create;
	  function asIBatch: IBatch;
	  class function isIBatchImpl(intf: IBatch): boolean;
	  property vTable: PBatchVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure add(status: IStatus; count: Cardinal; inBuffer: Pointer); virtual; abstract;
	  procedure addBlob(status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); virtual; abstract;
	  procedure appendBlobData(status: IStatus; length: Cardinal; inBuffer: Pointer); virtual; abstract;
	  procedure addBlobStream(status: IStatus; length: Cardinal; inBuffer: Pointer); virtual; abstract;
	  procedure registerBlob(status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); virtual; abstract;
	  function execute(status: IStatus; transaction: ITransaction): IBatchCompletionState; virtual; abstract;
	  procedure cancel(status: IStatus); virtual; abstract;
	  function getBlobAlignment(status: IStatus): Cardinal; virtual; abstract;
	  function getMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  procedure setDefaultBpb(status: IStatus; parLength: Cardinal; par: BytePtr); virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	end;

	PBatchCompletionStateVTable = ^BatchCompletionStateVTable;
	BatchCompletionStateVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getSize: IBatchCompletionState_getSizePtr;
	  getState: IBatchCompletionState_getStatePtr;
	  findError: IBatchCompletionState_findErrorPtr;
	  getStatus: IBatchCompletionState_getStatusPtr;
	end;

	IBatchCompletionStateImpl = class;

	TBatchCompletionState = record
	private
	  FNullPtr: pointer;
	  FvTable: PBatchCompletionStateVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IBatchCompletionState; inline;
	public
	  function isIBatchCompletionStateImpl: boolean;
	  function asIBatchCompletionStateImpl: IBatchCompletionStateImpl;
	  property vTable: PBatchCompletionStateVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function getSize(status: IStatus): Cardinal;
	  function getState(status: IStatus; pos: Cardinal): Integer;
	  function findError(status: IStatus; pos: Cardinal): Cardinal;
	  procedure getStatus(status: IStatus; to_: IStatus; pos: Cardinal);
	end;

	IBatchCompletionStateImpl = class(IDisposableImpl)
	private
	  function getVTable: PBatchCompletionStateVTable;
	public
	  const VERSION = 5;
	  const EXECUTE_FAILED = Integer(-1);
	  const SUCCESS_NO_INFO = Integer(-2);
	  const NO_MORE_ERRORS = Cardinal($ffffffff);
	public
	  constructor create;
	  function asIBatchCompletionState: IBatchCompletionState;
	  class function isIBatchCompletionStateImpl(intf: IBatchCompletionState): boolean;
	  property vTable: PBatchCompletionStateVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getSize(status: IStatus): Cardinal; virtual; abstract;
	  function getState(status: IStatus; pos: Cardinal): Integer; virtual; abstract;
	  function findError(status: IStatus; pos: Cardinal): Cardinal; virtual; abstract;
	  procedure getStatus(status: IStatus; to_: IStatus; pos: Cardinal); virtual; abstract;
	end;

	PReplicatorVTable = ^ReplicatorVTable;
	ReplicatorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  process: IReplicator_processPtr;
	  close: IReplicator_closePtr;
	end;

	IReplicatorImpl = class;

	TReplicator = record
	private
	  FNullPtr: pointer;
	  FvTable: PReplicatorVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IReplicator; inline;
	public
	  function isIReplicatorImpl: boolean;
	  function asIReplicatorImpl: IReplicatorImpl;
	  property vTable: PReplicatorVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure process(status: IStatus; length: Cardinal; data: BytePtr);
	  procedure close(status: IStatus);
	end;

	IReplicatorImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PReplicatorVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIReplicator: IReplicator;
	  class function isIReplicatorImpl(intf: IReplicator): boolean;
	  property vTable: PReplicatorVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure process(status: IStatus; length: Cardinal; data: BytePtr); virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	end;

	PRequestVTable = ^RequestVTable;
	RequestVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  receive: IRequest_receivePtr;
	  send: IRequest_sendPtr;
	  getInfo: IRequest_getInfoPtr;
	  start: IRequest_startPtr;
	  startAndSend: IRequest_startAndSendPtr;
	  unwind: IRequest_unwindPtr;
	  free: IRequest_freePtr;
	end;

	IRequestImpl = class;

	TRequest = record
	private
	  FNullPtr: pointer;
	  FvTable: PRequestVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IRequest; inline;
	public
	  function isIRequestImpl: boolean;
	  function asIRequestImpl: IRequestImpl;
	  property vTable: PRequestVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure receive(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure send(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure getInfo(status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure start(status: IStatus; tra: ITransaction; level: Integer);
	  procedure startAndSend(status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure unwind(status: IStatus; level: Integer);
	  procedure free(status: IStatus);
	end;

	IRequestImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PRequestVTable;
	public
	  const VERSION = 9;
	public
	  constructor create;
	  function asIRequest: IRequest;
	  class function isIRequestImpl(intf: IRequest): boolean;
	  property vTable: PRequestVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure receive(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
	  procedure send(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
	  procedure getInfo(status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  procedure start(status: IStatus; tra: ITransaction; level: Integer); virtual; abstract;
	  procedure startAndSend(status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
	  procedure unwind(status: IStatus; level: Integer); virtual; abstract;
	  procedure free(status: IStatus); virtual; abstract;
	end;

	PEventsVTable = ^EventsVTable;
	EventsVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  cancel: IEvents_cancelPtr;
	end;

	IEventsImpl = class;

	TEvents = record
	private
	  FNullPtr: pointer;
	  FvTable: PEventsVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IEvents; inline;
	public
	  function isIEventsImpl: boolean;
	  function asIEventsImpl: IEventsImpl;
	  property vTable: PEventsVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure cancel(status: IStatus);
	end;

	IEventsImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PEventsVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIEvents: IEvents;
	  class function isIEventsImpl(intf: IEvents): boolean;
	  property vTable: PEventsVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure cancel(status: IStatus); virtual; abstract;
	end;

	PAttachmentVTable = ^AttachmentVTable;
	AttachmentVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IAttachment_getInfoPtr;
	  startTransaction: IAttachment_startTransactionPtr;
	  reconnectTransaction: IAttachment_reconnectTransactionPtr;
	  compileRequest: IAttachment_compileRequestPtr;
	  transactRequest: IAttachment_transactRequestPtr;
	  createBlob: IAttachment_createBlobPtr;
	  openBlob: IAttachment_openBlobPtr;
	  getSlice: IAttachment_getSlicePtr;
	  putSlice: IAttachment_putSlicePtr;
	  executeDyn: IAttachment_executeDynPtr;
	  prepare: IAttachment_preparePtr;
	  execute: IAttachment_executePtr;
	  openCursor: IAttachment_openCursorPtr;
	  queEvents: IAttachment_queEventsPtr;
	  cancelOperation: IAttachment_cancelOperationPtr;
	  ping: IAttachment_pingPtr;
	  detach: IAttachment_detachPtr;
	  dropDatabase: IAttachment_dropDatabasePtr;
	  getIdleTimeout: IAttachment_getIdleTimeoutPtr;
	  setIdleTimeout: IAttachment_setIdleTimeoutPtr;
	  getStatementTimeout: IAttachment_getStatementTimeoutPtr;
	  setStatementTimeout: IAttachment_setStatementTimeoutPtr;
	  createBatch: IAttachment_createBatchPtr;
	  createReplicator: IAttachment_createReplicatorPtr;
	end;

	IAttachmentImpl = class;

	TAttachment = record
	private
	  FNullPtr: pointer;
	  FvTable: PAttachmentVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IAttachment; inline;
	public
	  function isIAttachmentImpl: boolean;
	  function asIAttachmentImpl: IAttachmentImpl;
	  property vTable: PAttachmentVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function startTransaction(status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction;
	  function reconnectTransaction(status: IStatus; length: Cardinal; id: BytePtr): ITransaction;
	  function compileRequest(status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest;
	  procedure transactRequest(status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr);
	  function createBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
	  function openBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
	  function getSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer;
	  procedure putSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr);
	  procedure executeDyn(status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr);
	  function prepare(status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement;
	  function execute(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
	  function openCursor(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet;
	  function queEvents(status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents;
	  procedure cancelOperation(status: IStatus; option: Integer);
	  procedure ping(status: IStatus);
	  procedure detach(status: IStatus);
	  procedure dropDatabase(status: IStatus);
	  function getIdleTimeout(status: IStatus): Cardinal;
	  procedure setIdleTimeout(status: IStatus; timeOut: Cardinal);
	  function getStatementTimeout(status: IStatus): Cardinal;
	  procedure setStatementTimeout(status: IStatus; timeOut: Cardinal);
	  function createBatch(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
	  function createReplicator(status: IStatus): IReplicator;
	end;

	IAttachmentImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PAttachmentVTable;
	public
	  const VERSION = 26;
	public
	  constructor create;
	  function asIAttachment: IAttachment;
	  class function isIAttachmentImpl(intf: IAttachment): boolean;
	  property vTable: PAttachmentVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  function startTransaction(status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction; virtual; abstract;
	  function reconnectTransaction(status: IStatus; length: Cardinal; id: BytePtr): ITransaction; virtual; abstract;
	  function compileRequest(status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest; virtual; abstract;
	  procedure transactRequest(status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); virtual; abstract;
	  function createBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; virtual; abstract;
	  function openBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; virtual; abstract;
	  function getSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; virtual; abstract;
	  procedure putSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); virtual; abstract;
	  procedure executeDyn(status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr); virtual; abstract;
	  function prepare(status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement; virtual; abstract;
	  function execute(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; virtual; abstract;
	  function openCursor(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet; virtual; abstract;
	  function queEvents(status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents; virtual; abstract;
	  procedure cancelOperation(status: IStatus; option: Integer); virtual; abstract;
	  procedure ping(status: IStatus); virtual; abstract;
	  procedure detach(status: IStatus); virtual; abstract;
	  procedure dropDatabase(status: IStatus); virtual; abstract;
	  function getIdleTimeout(status: IStatus): Cardinal; virtual; abstract;
	  procedure setIdleTimeout(status: IStatus; timeOut: Cardinal); virtual; abstract;
	  function getStatementTimeout(status: IStatus): Cardinal; virtual; abstract;
	  procedure setStatementTimeout(status: IStatus; timeOut: Cardinal); virtual; abstract;
	  function createBatch(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; virtual; abstract;
	  function createReplicator(status: IStatus): IReplicator; virtual; abstract;
	end;

	PServiceVTable = ^ServiceVTable;
	ServiceVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  detach: IService_detachPtr;
	  query: IService_queryPtr;
	  start: IService_startPtr;
	end;

	IServiceImpl = class;

	TService = record
	private
	  FNullPtr: pointer;
	  FvTable: PServiceVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IService; inline;
	public
	  function isIServiceImpl: boolean;
	  function asIServiceImpl: IServiceImpl;
	  property vTable: PServiceVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure detach(status: IStatus);
	  procedure query(status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure start(status: IStatus; spbLength: Cardinal; spb: BytePtr);
	end;

	IServiceImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PServiceVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asIService: IService;
	  class function isIServiceImpl(intf: IService): boolean;
	  property vTable: PServiceVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure detach(status: IStatus); virtual; abstract;
	  procedure query(status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  procedure start(status: IStatus; spbLength: Cardinal; spb: BytePtr); virtual; abstract;
	end;

	PProviderVTable = ^ProviderVTable;
	ProviderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  attachDatabase: IProvider_attachDatabasePtr;
	  createDatabase: IProvider_createDatabasePtr;
	  attachServiceManager: IProvider_attachServiceManagerPtr;
	  shutdown: IProvider_shutdownPtr;
	  setDbCryptCallback: IProvider_setDbCryptCallbackPtr;
	end;

	IProviderImpl = class;

	TProvider = record
	private
	  FNullPtr: pointer;
	  FvTable: PProviderVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IProvider; inline;
	public
	  function isIProviderImpl: boolean;
	  function asIProviderImpl: IProviderImpl;
	  property vTable: PProviderVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function attachDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
	  function createDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
	  function attachServiceManager(status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService;
	  procedure shutdown(status: IStatus; timeout: Cardinal; reason: Integer);
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
	end;

	IProviderImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PProviderVTable;
	public
	  const VERSION = 9;
	public
	  constructor create;
	  function asIProvider: IProvider;
	  class function isIProviderImpl(intf: IProvider): boolean;
	  property vTable: PProviderVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function attachDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; virtual; abstract;
	  function createDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; virtual; abstract;
	  function attachServiceManager(status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService; virtual; abstract;
	  procedure shutdown(status: IStatus; timeout: Cardinal; reason: Integer); virtual; abstract;
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback); virtual; abstract;
	end;

	PDtcStartVTable = ^DtcStartVTable;
	DtcStartVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  addAttachment: IDtcStart_addAttachmentPtr;
	  addWithTpb: IDtcStart_addWithTpbPtr;
	  start: IDtcStart_startPtr;
	end;

	IDtcStartImpl = class;

	TDtcStart = record
	private
	  FNullPtr: pointer;
	  FvTable: PDtcStartVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDtcStart; inline;
	public
	  function isIDtcStartImpl: boolean;
	  function asIDtcStartImpl: IDtcStartImpl;
	  property vTable: PDtcStartVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure addAttachment(status: IStatus; att: IAttachment);
	  procedure addWithTpb(status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr);
	  function start(status: IStatus): ITransaction;
	end;

	IDtcStartImpl = class(IDisposableImpl)
	private
	  function getVTable: PDtcStartVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIDtcStart: IDtcStart;
	  class function isIDtcStartImpl(intf: IDtcStart): boolean;
	  property vTable: PDtcStartVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure addAttachment(status: IStatus; att: IAttachment); virtual; abstract;
	  procedure addWithTpb(status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr); virtual; abstract;
	  function start(status: IStatus): ITransaction; virtual; abstract;
	end;

	PDtcVTable = ^DtcVTable;
	DtcVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  join: IDtc_joinPtr;
	  startBuilder: IDtc_startBuilderPtr;
	end;

	IDtcImpl = class;

	TDtc = record
	private
	  FNullPtr: pointer;
	  FvTable: PDtcVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDtc; inline;
	public
	  function isIDtcImpl: boolean;
	  function asIDtcImpl: IDtcImpl;
	  property vTable: PDtcVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function join(status: IStatus; one: ITransaction; two: ITransaction): ITransaction;
	  function startBuilder(status: IStatus): IDtcStart;
	end;

	IDtcImpl = class(IVersionedImpl)
	private
	  function getVTable: PDtcVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asIDtc: IDtc;
	  class function isIDtcImpl(intf: IDtc): boolean;
	  property vTable: PDtcVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function join(status: IStatus; one: ITransaction; two: ITransaction): ITransaction; virtual; abstract;
	  function startBuilder(status: IStatus): IDtcStart; virtual; abstract;
	end;

	PAuthVTable = ^AuthVTable;
	AuthVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	end;

	IAuthImpl = class;

	TAuth = record
	private
	  FNullPtr: pointer;
	  FvTable: PAuthVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IAuth; inline;
	public
	  function isIAuthImpl: boolean;
	  function asIAuthImpl: IAuthImpl;
	  property vTable: PAuthVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	end;

	IAuthImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PAuthVTable;
	public
	  const VERSION = 4;
	  const AUTH_FAILED = Integer(-1);
	  const AUTH_SUCCESS = Integer(0);
	  const AUTH_MORE_DATA = Integer(1);
	  const AUTH_CONTINUE = Integer(2);
	public
	  constructor create;
	  function asIAuth: IAuth;
	  class function isIAuthImpl(intf: IAuth): boolean;
	  property vTable: PAuthVTable read getVTable;
	end;

	PWriterVTable = ^WriterVTable;
	WriterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  reset: IWriter_resetPtr;
	  add: IWriter_addPtr;
	  setType: IWriter_setTypePtr;
	  setDb: IWriter_setDbPtr;
	end;

	IWriterImpl = class;

	TWriter = record
	private
	  FNullPtr: pointer;
	  FvTable: PWriterVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IWriter; inline;
	public
	  function isIWriterImpl: boolean;
	  function asIWriterImpl: IWriterImpl;
	  property vTable: PWriterVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure reset();
	  procedure add(status: IStatus; name: PAnsiChar);
	  procedure setType(status: IStatus; value: PAnsiChar);
	  procedure setDb(status: IStatus; value: PAnsiChar);
	end;

	IWriterImpl = class(IVersionedImpl)
	private
	  function getVTable: PWriterVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIWriter: IWriter;
	  class function isIWriterImpl(intf: IWriter): boolean;
	  property vTable: PWriterVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure reset(); virtual; abstract;
	  procedure add(status: IStatus; name: PAnsiChar); virtual; abstract;
	  procedure setType(status: IStatus; value: PAnsiChar); virtual; abstract;
	  procedure setDb(status: IStatus; value: PAnsiChar); virtual; abstract;
	end;

	PServerBlockVTable = ^ServerBlockVTable;
	ServerBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getLogin: IServerBlock_getLoginPtr;
	  getData: IServerBlock_getDataPtr;
	  putData: IServerBlock_putDataPtr;
	  newKey: IServerBlock_newKeyPtr;
	end;

	IServerBlockImpl = class;

	TServerBlock = record
	private
	  FNullPtr: pointer;
	  FvTable: PServerBlockVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IServerBlock; inline;
	public
	  function isIServerBlockImpl: boolean;
	  function asIServerBlockImpl: IServerBlockImpl;
	  property vTable: PServerBlockVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getLogin(): PAnsiChar;
	  function getData(length: CardinalPtr): BytePtr;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer);
	  function newKey(status: IStatus): ICryptKey;
	end;

	IServerBlockImpl = class(IVersionedImpl)
	private
	  function getVTable: PServerBlockVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIServerBlock: IServerBlock;
	  class function isIServerBlockImpl(intf: IServerBlock): boolean;
	  property vTable: PServerBlockVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getLogin(): PAnsiChar; virtual; abstract;
	  function getData(length: CardinalPtr): BytePtr; virtual; abstract;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer); virtual; abstract;
	  function newKey(status: IStatus): ICryptKey; virtual; abstract;
	end;

	PClientBlockVTable = ^ClientBlockVTable;
	ClientBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getLogin: IClientBlock_getLoginPtr;
	  getPassword: IClientBlock_getPasswordPtr;
	  getData: IClientBlock_getDataPtr;
	  putData: IClientBlock_putDataPtr;
	  newKey: IClientBlock_newKeyPtr;
	  getAuthBlock: IClientBlock_getAuthBlockPtr;
	end;

	IClientBlockImpl = class;

	TClientBlock = record
	private
	  FNullPtr: pointer;
	  FvTable: PClientBlockVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IClientBlock; inline;
	public
	  function isIClientBlockImpl: boolean;
	  function asIClientBlockImpl: IClientBlockImpl;
	  property vTable: PClientBlockVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getLogin(): PAnsiChar;
	  function getPassword(): PAnsiChar;
	  function getData(length: CardinalPtr): BytePtr;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer);
	  function newKey(status: IStatus): ICryptKey;
	  function getAuthBlock(status: IStatus): IAuthBlock;
	end;

	IClientBlockImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PClientBlockVTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asIClientBlock: IClientBlock;
	  class function isIClientBlockImpl(intf: IClientBlock): boolean;
	  property vTable: PClientBlockVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getLogin(): PAnsiChar; virtual; abstract;
	  function getPassword(): PAnsiChar; virtual; abstract;
	  function getData(length: CardinalPtr): BytePtr; virtual; abstract;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer); virtual; abstract;
	  function newKey(status: IStatus): ICryptKey; virtual; abstract;
	  function getAuthBlock(status: IStatus): IAuthBlock; virtual; abstract;
	end;

	PServerVTable = ^ServerVTable;
	ServerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  authenticate: IServer_authenticatePtr;
	  setDbCryptCallback: IServer_setDbCryptCallbackPtr;
	end;

	IServerImpl = class;

	TServer = record
	private
	  FNullPtr: pointer;
	  FvTable: PServerVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IServer; inline;
	public
	  function isIServerImpl: boolean;
	  function asIServerImpl: IServerImpl;
	  property vTable: PServerVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function authenticate(status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer;
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
	end;

	IServerImpl = class(IAuthImpl)
	private
	  function getVTable: PServerVTable;
	public
	  const VERSION = 6;
	public
	  constructor create;
	  function asIServer: IServer;
	  class function isIServerImpl(intf: IServer): boolean;
	  property vTable: PServerVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function authenticate(status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer; virtual; abstract;
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback); virtual; abstract;
	end;

	PClientVTable = ^ClientVTable;
	ClientVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  authenticate: IClient_authenticatePtr;
	end;

	IClientImpl = class;

	TClient = record
	private
	  FNullPtr: pointer;
	  FvTable: PClientVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IClient; inline;
	public
	  function isIClientImpl: boolean;
	  function asIClientImpl: IClientImpl;
	  property vTable: PClientVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function authenticate(status: IStatus; cBlock: IClientBlock): Integer;
	end;

	IClientImpl = class(IAuthImpl)
	private
	  function getVTable: PClientVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asIClient: IClient;
	  class function isIClientImpl(intf: IClient): boolean;
	  property vTable: PClientVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function authenticate(status: IStatus; cBlock: IClientBlock): Integer; virtual; abstract;
	end;

	PUserFieldVTable = ^UserFieldVTable;
	UserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	end;

	IUserFieldImpl = class;

	TUserField = record
	private
	  FNullPtr: pointer;
	  FvTable: PUserFieldVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUserField; inline;
	public
	  function isIUserFieldImpl: boolean;
	  function asIUserFieldImpl: IUserFieldImpl;
	  property vTable: PUserFieldVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: IStatus; newValue: Integer);
	end;

	IUserFieldImpl = class(IVersionedImpl)
	private
	  function getVTable: PUserFieldVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIUserField: IUserField;
	  class function isIUserFieldImpl(intf: IUserField): boolean;
	  property vTable: PUserFieldVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function entered(): Integer; virtual; abstract;
	  function specified(): Integer; virtual; abstract;
	  procedure setEntered(status: IStatus; newValue: Integer); virtual; abstract;
	end;

	PCharUserFieldVTable = ^CharUserFieldVTable;
	CharUserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	  get: ICharUserField_getPtr;
	  set_: ICharUserField_set_Ptr;
	end;

	ICharUserFieldImpl = class;

	TCharUserField = record
	private
	  FNullPtr: pointer;
	  FvTable: PCharUserFieldVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ICharUserField; inline;
	public
	  function isICharUserFieldImpl: boolean;
	  function asICharUserFieldImpl: ICharUserFieldImpl;
	  property vTable: PCharUserFieldVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: IStatus; newValue: Integer);
	  function get(): PAnsiChar;
	  procedure set_(status: IStatus; newValue: PAnsiChar);
	end;

	ICharUserFieldImpl = class(IUserFieldImpl)
	private
	  function getVTable: PCharUserFieldVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asICharUserField: ICharUserField;
	  class function isICharUserFieldImpl(intf: ICharUserField): boolean;
	  property vTable: PCharUserFieldVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function get(): PAnsiChar; virtual; abstract;
	  procedure set_(status: IStatus; newValue: PAnsiChar); virtual; abstract;
	end;

	PIntUserFieldVTable = ^IntUserFieldVTable;
	IntUserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	  get: IIntUserField_getPtr;
	  set_: IIntUserField_set_Ptr;
	end;

	IIntUserFieldImpl = class;

	TIntUserField = record
	private
	  FNullPtr: pointer;
	  FvTable: PIntUserFieldVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IIntUserField; inline;
	public
	  function isIIntUserFieldImpl: boolean;
	  function asIIntUserFieldImpl: IIntUserFieldImpl;
	  property vTable: PIntUserFieldVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: IStatus; newValue: Integer);
	  function get(): Integer;
	  procedure set_(status: IStatus; newValue: Integer);
	end;

	IIntUserFieldImpl = class(IUserFieldImpl)
	private
	  function getVTable: PIntUserFieldVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asIIntUserField: IIntUserField;
	  class function isIIntUserFieldImpl(intf: IIntUserField): boolean;
	  property vTable: PIntUserFieldVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function get(): Integer; virtual; abstract;
	  procedure set_(status: IStatus; newValue: Integer); virtual; abstract;
	end;

	PUserVTable = ^UserVTable;
	UserVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  operation: IUser_operationPtr;
	  userName: IUser_userNamePtr;
	  password: IUser_passwordPtr;
	  firstName: IUser_firstNamePtr;
	  lastName: IUser_lastNamePtr;
	  middleName: IUser_middleNamePtr;
	  comment: IUser_commentPtr;
	  attributes: IUser_attributesPtr;
	  active: IUser_activePtr;
	  admin: IUser_adminPtr;
	  clear: IUser_clearPtr;
	end;

	IUserImpl = class;

	TUser = record
	private
	  FNullPtr: pointer;
	  FvTable: PUserVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUser; inline;
	public
	  function isIUserImpl: boolean;
	  function asIUserImpl: IUserImpl;
	  property vTable: PUserVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function operation(): Cardinal;
	  function userName(): ICharUserField;
	  function password(): ICharUserField;
	  function firstName(): ICharUserField;
	  function lastName(): ICharUserField;
	  function middleName(): ICharUserField;
	  function comment(): ICharUserField;
	  function attributes(): ICharUserField;
	  function active(): IIntUserField;
	  function admin(): IIntUserField;
	  procedure clear(status: IStatus);
	end;

	IUserImpl = class(IVersionedImpl)
	private
	  function getVTable: PUserVTable;
	public
	  const VERSION = 11;
	  const OP_USER_ADD = Cardinal(1);
	  const OP_USER_MODIFY = Cardinal(2);
	  const OP_USER_DELETE = Cardinal(3);
	  const OP_USER_DISPLAY = Cardinal(4);
	  const OP_USER_SET_MAP = Cardinal(5);
	  const OP_USER_DROP_MAP = Cardinal(6);
	public
	  constructor create;
	  function asIUser: IUser;
	  class function isIUserImpl(intf: IUser): boolean;
	  property vTable: PUserVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function operation(): Cardinal; virtual; abstract;
	  function userName(): ICharUserField; virtual; abstract;
	  function password(): ICharUserField; virtual; abstract;
	  function firstName(): ICharUserField; virtual; abstract;
	  function lastName(): ICharUserField; virtual; abstract;
	  function middleName(): ICharUserField; virtual; abstract;
	  function comment(): ICharUserField; virtual; abstract;
	  function attributes(): ICharUserField; virtual; abstract;
	  function active(): IIntUserField; virtual; abstract;
	  function admin(): IIntUserField; virtual; abstract;
	  procedure clear(status: IStatus); virtual; abstract;
	end;

	PListUsersVTable = ^ListUsersVTable;
	ListUsersVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  list: IListUsers_listPtr;
	end;

	IListUsersImpl = class;

	TListUsers = record
	private
	  FNullPtr: pointer;
	  FvTable: PListUsersVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IListUsers; inline;
	public
	  function isIListUsersImpl: boolean;
	  function asIListUsersImpl: IListUsersImpl;
	  property vTable: PListUsersVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure list(status: IStatus; user: IUser);
	end;

	IListUsersImpl = class(IVersionedImpl)
	private
	  function getVTable: PListUsersVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asIListUsers: IListUsers;
	  class function isIListUsersImpl(intf: IListUsers): boolean;
	  property vTable: PListUsersVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure list(status: IStatus; user: IUser); virtual; abstract;
	end;

	PLogonInfoVTable = ^LogonInfoVTable;
	LogonInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  name: ILogonInfo_namePtr;
	  role: ILogonInfo_rolePtr;
	  networkProtocol: ILogonInfo_networkProtocolPtr;
	  remoteAddress: ILogonInfo_remoteAddressPtr;
	  authBlock: ILogonInfo_authBlockPtr;
	  attachment: ILogonInfo_attachmentPtr;
	  transaction: ILogonInfo_transactionPtr;
	end;

	ILogonInfoImpl = class;

	TLogonInfo = record
	private
	  FNullPtr: pointer;
	  FvTable: PLogonInfoVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ILogonInfo; inline;
	public
	  function isILogonInfoImpl: boolean;
	  function asILogonInfoImpl: ILogonInfoImpl;
	  property vTable: PLogonInfoVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function name(): PAnsiChar;
	  function role(): PAnsiChar;
	  function networkProtocol(): PAnsiChar;
	  function remoteAddress(): PAnsiChar;
	  function authBlock(length: CardinalPtr): BytePtr;
	  function attachment(status: IStatus): IAttachment;
	  function transaction(status: IStatus): ITransaction;
	end;

	ILogonInfoImpl = class(IVersionedImpl)
	private
	  function getVTable: PLogonInfoVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asILogonInfo: ILogonInfo;
	  class function isILogonInfoImpl(intf: ILogonInfo): boolean;
	  property vTable: PLogonInfoVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function name(): PAnsiChar; virtual; abstract;
	  function role(): PAnsiChar; virtual; abstract;
	  function networkProtocol(): PAnsiChar; virtual; abstract;
	  function remoteAddress(): PAnsiChar; virtual; abstract;
	  function authBlock(length: CardinalPtr): BytePtr; virtual; abstract;
	  function attachment(status: IStatus): IAttachment; virtual; abstract;
	  function transaction(status: IStatus): ITransaction; virtual; abstract;
	end;

	PManagementVTable = ^ManagementVTable;
	ManagementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  start: IManagement_startPtr;
	  execute: IManagement_executePtr;
	  commit: IManagement_commitPtr;
	  rollback: IManagement_rollbackPtr;
	end;

	IManagementImpl = class;

	TManagement = record
	private
	  FNullPtr: pointer;
	  FvTable: PManagementVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IManagement; inline;
	public
	  function isIManagementImpl: boolean;
	  function asIManagementImpl: IManagementImpl;
	  property vTable: PManagementVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  procedure start(status: IStatus; logonInfo: ILogonInfo);
	  function execute(status: IStatus; user: IUser; callback: IListUsers): Integer;
	  procedure commit(status: IStatus);
	  procedure rollback(status: IStatus);
	end;

	IManagementImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PManagementVTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asIManagement: IManagement;
	  class function isIManagementImpl(intf: IManagement): boolean;
	  property vTable: PManagementVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure start(status: IStatus; logonInfo: ILogonInfo); virtual; abstract;
	  function execute(status: IStatus; user: IUser; callback: IListUsers): Integer; virtual; abstract;
	  procedure commit(status: IStatus); virtual; abstract;
	  procedure rollback(status: IStatus); virtual; abstract;
	end;

	PAuthBlockVTable = ^AuthBlockVTable;
	AuthBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getType: IAuthBlock_getTypePtr;
	  getName: IAuthBlock_getNamePtr;
	  getPlugin: IAuthBlock_getPluginPtr;
	  getSecurityDb: IAuthBlock_getSecurityDbPtr;
	  getOriginalPlugin: IAuthBlock_getOriginalPluginPtr;
	  next: IAuthBlock_nextPtr;
	  first: IAuthBlock_firstPtr;
	end;

	IAuthBlockImpl = class;

	TAuthBlock = record
	private
	  FNullPtr: pointer;
	  FvTable: PAuthBlockVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IAuthBlock; inline;
	public
	  function isIAuthBlockImpl: boolean;
	  function asIAuthBlockImpl: IAuthBlockImpl;
	  property vTable: PAuthBlockVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getType(): PAnsiChar;
	  function getName(): PAnsiChar;
	  function getPlugin(): PAnsiChar;
	  function getSecurityDb(): PAnsiChar;
	  function getOriginalPlugin(): PAnsiChar;
	  function next(status: IStatus): Boolean;
	  function first(status: IStatus): Boolean;
	end;

	IAuthBlockImpl = class(IVersionedImpl)
	private
	  function getVTable: PAuthBlockVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asIAuthBlock: IAuthBlock;
	  class function isIAuthBlockImpl(intf: IAuthBlock): boolean;
	  property vTable: PAuthBlockVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getType(): PAnsiChar; virtual; abstract;
	  function getName(): PAnsiChar; virtual; abstract;
	  function getPlugin(): PAnsiChar; virtual; abstract;
	  function getSecurityDb(): PAnsiChar; virtual; abstract;
	  function getOriginalPlugin(): PAnsiChar; virtual; abstract;
	  function next(status: IStatus): Boolean; virtual; abstract;
	  function first(status: IStatus): Boolean; virtual; abstract;
	end;

	PWireCryptPluginVTable = ^WireCryptPluginVTable;
	WireCryptPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  getKnownTypes: IWireCryptPlugin_getKnownTypesPtr;
	  setKey: IWireCryptPlugin_setKeyPtr;
	  encrypt: IWireCryptPlugin_encryptPtr;
	  decrypt: IWireCryptPlugin_decryptPtr;
	  getSpecificData: IWireCryptPlugin_getSpecificDataPtr;
	  setSpecificData: IWireCryptPlugin_setSpecificDataPtr;
	end;

	IWireCryptPluginImpl = class;

	TWireCryptPlugin = record
	private
	  FNullPtr: pointer;
	  FvTable: PWireCryptPluginVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IWireCryptPlugin; inline;
	public
	  function isIWireCryptPluginImpl: boolean;
	  function asIWireCryptPluginImpl: IWireCryptPluginImpl;
	  property vTable: PWireCryptPluginVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function getKnownTypes(status: IStatus): PAnsiChar;
	  procedure setKey(status: IStatus; key: ICryptKey);
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  function getSpecificData(status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr;
	  procedure setSpecificData(status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr);
	end;

	IWireCryptPluginImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PWireCryptPluginVTable;
	public
	  const VERSION = 10;
	public
	  constructor create;
	  function asIWireCryptPlugin: IWireCryptPlugin;
	  class function isIWireCryptPluginImpl(intf: IWireCryptPlugin): boolean;
	  property vTable: PWireCryptPluginVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getKnownTypes(status: IStatus): PAnsiChar; virtual; abstract;
	  procedure setKey(status: IStatus; key: ICryptKey); virtual; abstract;
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  function getSpecificData(status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr; virtual; abstract;
	  procedure setSpecificData(status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr); virtual; abstract;
	end;

	PCryptKeyCallbackVTable = ^CryptKeyCallbackVTable;
	CryptKeyCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  callback: ICryptKeyCallback_callbackPtr;
	end;

	ICryptKeyCallbackImpl = class;

	TCryptKeyCallback = record
	private
	  FNullPtr: pointer;
	  FvTable: PCryptKeyCallbackVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ICryptKeyCallback; inline;
	public
	  function isICryptKeyCallbackImpl: boolean;
	  function asICryptKeyCallbackImpl: ICryptKeyCallbackImpl;
	  property vTable: PCryptKeyCallbackVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal;
	end;

	ICryptKeyCallbackImpl = class(IVersionedImpl)
	private
	  function getVTable: PCryptKeyCallbackVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asICryptKeyCallback: ICryptKeyCallback;
	  class function isICryptKeyCallbackImpl(intf: ICryptKeyCallback): boolean;
	  property vTable: PCryptKeyCallbackVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; virtual; abstract;
	end;

	PKeyHolderPluginVTable = ^KeyHolderPluginVTable;
	KeyHolderPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  keyCallback: IKeyHolderPlugin_keyCallbackPtr;
	  keyHandle: IKeyHolderPlugin_keyHandlePtr;
	  useOnlyOwnKeys: IKeyHolderPlugin_useOnlyOwnKeysPtr;
	  chainHandle: IKeyHolderPlugin_chainHandlePtr;
	end;

	IKeyHolderPluginImpl = class;

	TKeyHolderPlugin = record
	private
	  FNullPtr: pointer;
	  FvTable: PKeyHolderPluginVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IKeyHolderPlugin; inline;
	public
	  function isIKeyHolderPluginImpl: boolean;
	  function asIKeyHolderPluginImpl: IKeyHolderPluginImpl;
	  property vTable: PKeyHolderPluginVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function keyCallback(status: IStatus; callback: ICryptKeyCallback): Integer;
	  function keyHandle(status: IStatus; keyName: PAnsiChar): ICryptKeyCallback;
	  function useOnlyOwnKeys(status: IStatus): Boolean;
	  function chainHandle(status: IStatus): ICryptKeyCallback;
	end;

	IKeyHolderPluginImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PKeyHolderPluginVTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asIKeyHolderPlugin: IKeyHolderPlugin;
	  class function isIKeyHolderPluginImpl(intf: IKeyHolderPlugin): boolean;
	  property vTable: PKeyHolderPluginVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function keyCallback(status: IStatus; callback: ICryptKeyCallback): Integer; virtual; abstract;
	  function keyHandle(status: IStatus; keyName: PAnsiChar): ICryptKeyCallback; virtual; abstract;
	  function useOnlyOwnKeys(status: IStatus): Boolean; virtual; abstract;
	  function chainHandle(status: IStatus): ICryptKeyCallback; virtual; abstract;
	end;

	PDbCryptInfoVTable = ^DbCryptInfoVTable;
	DbCryptInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getDatabaseFullPath: IDbCryptInfo_getDatabaseFullPathPtr;
	end;

	IDbCryptInfoImpl = class;

	TDbCryptInfo = record
	private
	  FNullPtr: pointer;
	  FvTable: PDbCryptInfoVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDbCryptInfo; inline;
	public
	  function isIDbCryptInfoImpl: boolean;
	  function asIDbCryptInfoImpl: IDbCryptInfoImpl;
	  property vTable: PDbCryptInfoVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getDatabaseFullPath(status: IStatus): PAnsiChar;
	end;

	IDbCryptInfoImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PDbCryptInfoVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIDbCryptInfo: IDbCryptInfo;
	  class function isIDbCryptInfoImpl(intf: IDbCryptInfo): boolean;
	  property vTable: PDbCryptInfoVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getDatabaseFullPath(status: IStatus): PAnsiChar; virtual; abstract;
	end;

	PDbCryptPluginVTable = ^DbCryptPluginVTable;
	DbCryptPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  setKey: IDbCryptPlugin_setKeyPtr;
	  encrypt: IDbCryptPlugin_encryptPtr;
	  decrypt: IDbCryptPlugin_decryptPtr;
	  setInfo: IDbCryptPlugin_setInfoPtr;
	end;

	IDbCryptPluginImpl = class;

	TDbCryptPlugin = record
	private
	  FNullPtr: pointer;
	  FvTable: PDbCryptPluginVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDbCryptPlugin; inline;
	public
	  function isIDbCryptPluginImpl: boolean;
	  function asIDbCryptPluginImpl: IDbCryptPluginImpl;
	  property vTable: PDbCryptPluginVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  procedure setKey(status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar);
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure setInfo(status: IStatus; info: IDbCryptInfo);
	end;

	IDbCryptPluginImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PDbCryptPluginVTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asIDbCryptPlugin: IDbCryptPlugin;
	  class function isIDbCryptPluginImpl(intf: IDbCryptPlugin): boolean;
	  property vTable: PDbCryptPluginVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setKey(status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar); virtual; abstract;
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  procedure setInfo(status: IStatus; info: IDbCryptInfo); virtual; abstract;
	end;

	PExternalContextVTable = ^ExternalContextVTable;
	ExternalContextVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getMaster: IExternalContext_getMasterPtr;
	  getEngine: IExternalContext_getEnginePtr;
	  getAttachment: IExternalContext_getAttachmentPtr;
	  getTransaction: IExternalContext_getTransactionPtr;
	  getUserName: IExternalContext_getUserNamePtr;
	  getDatabaseName: IExternalContext_getDatabaseNamePtr;
	  getClientCharSet: IExternalContext_getClientCharSetPtr;
	  obtainInfoCode: IExternalContext_obtainInfoCodePtr;
	  getInfo: IExternalContext_getInfoPtr;
	  setInfo: IExternalContext_setInfoPtr;
	end;

	IExternalContextImpl = class;

	TExternalContext = record
	private
	  FNullPtr: pointer;
	  FvTable: PExternalContextVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IExternalContext; inline;
	public
	  function isIExternalContextImpl: boolean;
	  function asIExternalContextImpl: IExternalContextImpl;
	  property vTable: PExternalContextVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getMaster(): IMaster;
	  function getEngine(status: IStatus): IExternalEngine;
	  function getAttachment(status: IStatus): IAttachment;
	  function getTransaction(status: IStatus): ITransaction;
	  function getUserName(): PAnsiChar;
	  function getDatabaseName(): PAnsiChar;
	  function getClientCharSet(): PAnsiChar;
	  function obtainInfoCode(): Integer;
	  function getInfo(code: Integer): Pointer;
	  function setInfo(code: Integer; value: Pointer): Pointer;
	end;

	IExternalContextImpl = class(IVersionedImpl)
	private
	  function getVTable: PExternalContextVTable;
	public
	  const VERSION = 10;
	public
	  constructor create;
	  function asIExternalContext: IExternalContext;
	  class function isIExternalContextImpl(intf: IExternalContext): boolean;
	  property vTable: PExternalContextVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getMaster(): IMaster; virtual; abstract;
	  function getEngine(status: IStatus): IExternalEngine; virtual; abstract;
	  function getAttachment(status: IStatus): IAttachment; virtual; abstract;
	  function getTransaction(status: IStatus): ITransaction; virtual; abstract;
	  function getUserName(): PAnsiChar; virtual; abstract;
	  function getDatabaseName(): PAnsiChar; virtual; abstract;
	  function getClientCharSet(): PAnsiChar; virtual; abstract;
	  function obtainInfoCode(): Integer; virtual; abstract;
	  function getInfo(code: Integer): Pointer; virtual; abstract;
	  function setInfo(code: Integer; value: Pointer): Pointer; virtual; abstract;
	end;

	PExternalResultSetVTable = ^ExternalResultSetVTable;
	ExternalResultSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  fetch: IExternalResultSet_fetchPtr;
	end;

	IExternalResultSetImpl = class;

	TExternalResultSet = record
	private
	  FNullPtr: pointer;
	  FvTable: PExternalResultSetVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IExternalResultSet; inline;
	public
	  function isIExternalResultSetImpl: boolean;
	  function asIExternalResultSetImpl: IExternalResultSetImpl;
	  property vTable: PExternalResultSetVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function fetch(status: IStatus): Boolean;
	end;

	IExternalResultSetImpl = class(IDisposableImpl)
	private
	  function getVTable: PExternalResultSetVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asIExternalResultSet: IExternalResultSet;
	  class function isIExternalResultSetImpl(intf: IExternalResultSet): boolean;
	  property vTable: PExternalResultSetVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function fetch(status: IStatus): Boolean; virtual; abstract;
	end;

	PExternalFunctionVTable = ^ExternalFunctionVTable;
	ExternalFunctionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalFunction_getCharSetPtr;
	  execute: IExternalFunction_executePtr;
	end;

	IExternalFunctionImpl = class;

	TExternalFunction = record
	private
	  FNullPtr: pointer;
	  FvTable: PExternalFunctionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IExternalFunction; inline;
	public
	  function isIExternalFunctionImpl: boolean;
	  function asIExternalFunctionImpl: IExternalFunctionImpl;
	  property vTable: PExternalFunctionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
	  procedure execute(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer);
	end;

	IExternalFunctionImpl = class(IDisposableImpl)
	private
	  function getVTable: PExternalFunctionVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIExternalFunction: IExternalFunction;
	  class function isIExternalFunctionImpl(intf: IExternalFunction): boolean;
	  property vTable: PExternalFunctionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
	  procedure execute(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer); virtual; abstract;
	end;

	PExternalProcedureVTable = ^ExternalProcedureVTable;
	ExternalProcedureVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalProcedure_getCharSetPtr;
	  open: IExternalProcedure_openPtr;
	end;

	IExternalProcedureImpl = class;

	TExternalProcedure = record
	private
	  FNullPtr: pointer;
	  FvTable: PExternalProcedureVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IExternalProcedure; inline;
	public
	  function isIExternalProcedureImpl: boolean;
	  function asIExternalProcedureImpl: IExternalProcedureImpl;
	  property vTable: PExternalProcedureVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
	  function open(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet;
	end;

	IExternalProcedureImpl = class(IDisposableImpl)
	private
	  function getVTable: PExternalProcedureVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIExternalProcedure: IExternalProcedure;
	  class function isIExternalProcedureImpl(intf: IExternalProcedure): boolean;
	  property vTable: PExternalProcedureVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
	  function open(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet; virtual; abstract;
	end;

	PExternalTriggerVTable = ^ExternalTriggerVTable;
	ExternalTriggerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalTrigger_getCharSetPtr;
	  execute: IExternalTrigger_executePtr;
	end;

	IExternalTriggerImpl = class;

	TExternalTrigger = record
	private
	  FNullPtr: pointer;
	  FvTable: PExternalTriggerVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IExternalTrigger; inline;
	public
	  function isIExternalTriggerImpl: boolean;
	  function asIExternalTriggerImpl: IExternalTriggerImpl;
	  property vTable: PExternalTriggerVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
	  procedure execute(status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer);
	end;

	IExternalTriggerImpl = class(IDisposableImpl)
	private
	  function getVTable: PExternalTriggerVTable;
	public
	  const VERSION = 3;
	  const TYPE_BEFORE = Cardinal(1);
	  const TYPE_AFTER = Cardinal(2);
	  const TYPE_DATABASE = Cardinal(3);
	  const ACTION_INSERT = Cardinal(1);
	  const ACTION_UPDATE = Cardinal(2);
	  const ACTION_DELETE = Cardinal(3);
	  const ACTION_CONNECT = Cardinal(4);
	  const ACTION_DISCONNECT = Cardinal(5);
	  const ACTION_TRANS_START = Cardinal(6);
	  const ACTION_TRANS_COMMIT = Cardinal(7);
	  const ACTION_TRANS_ROLLBACK = Cardinal(8);
	  const ACTION_DDL = Cardinal(9);
	public
	  constructor create;
	  function asIExternalTrigger: IExternalTrigger;
	  class function isIExternalTriggerImpl(intf: IExternalTrigger): boolean;
	  property vTable: PExternalTriggerVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
	  procedure execute(status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); virtual; abstract;
	end;

	PRoutineMetadataVTable = ^RoutineMetadataVTable;
	RoutineMetadataVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getPackage: IRoutineMetadata_getPackagePtr;
	  getName: IRoutineMetadata_getNamePtr;
	  getEntryPoint: IRoutineMetadata_getEntryPointPtr;
	  getBody: IRoutineMetadata_getBodyPtr;
	  getInputMetadata: IRoutineMetadata_getInputMetadataPtr;
	  getOutputMetadata: IRoutineMetadata_getOutputMetadataPtr;
	  getTriggerMetadata: IRoutineMetadata_getTriggerMetadataPtr;
	  getTriggerTable: IRoutineMetadata_getTriggerTablePtr;
	  getTriggerType: IRoutineMetadata_getTriggerTypePtr;
	end;

	IRoutineMetadataImpl = class;

	TRoutineMetadata = record
	private
	  FNullPtr: pointer;
	  FvTable: PRoutineMetadataVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IRoutineMetadata; inline;
	public
	  function isIRoutineMetadataImpl: boolean;
	  function asIRoutineMetadataImpl: IRoutineMetadataImpl;
	  property vTable: PRoutineMetadataVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getPackage(status: IStatus): PAnsiChar;
	  function getName(status: IStatus): PAnsiChar;
	  function getEntryPoint(status: IStatus): PAnsiChar;
	  function getBody(status: IStatus): PAnsiChar;
	  function getInputMetadata(status: IStatus): IMessageMetadata;
	  function getOutputMetadata(status: IStatus): IMessageMetadata;
	  function getTriggerMetadata(status: IStatus): IMessageMetadata;
	  function getTriggerTable(status: IStatus): PAnsiChar;
	  function getTriggerType(status: IStatus): Cardinal;
	end;

	IRoutineMetadataImpl = class(IVersionedImpl)
	private
	  function getVTable: PRoutineMetadataVTable;
	public
	  const VERSION = 9;
	public
	  constructor create;
	  function asIRoutineMetadata: IRoutineMetadata;
	  class function isIRoutineMetadataImpl(intf: IRoutineMetadata): boolean;
	  property vTable: PRoutineMetadataVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getPackage(status: IStatus): PAnsiChar; virtual; abstract;
	  function getName(status: IStatus): PAnsiChar; virtual; abstract;
	  function getEntryPoint(status: IStatus): PAnsiChar; virtual; abstract;
	  function getBody(status: IStatus): PAnsiChar; virtual; abstract;
	  function getInputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getOutputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getTriggerMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getTriggerTable(status: IStatus): PAnsiChar; virtual; abstract;
	  function getTriggerType(status: IStatus): Cardinal; virtual; abstract;
	end;

	PExternalEngineVTable = ^ExternalEngineVTable;
	ExternalEngineVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  open: IExternalEngine_openPtr;
	  openAttachment: IExternalEngine_openAttachmentPtr;
	  closeAttachment: IExternalEngine_closeAttachmentPtr;
	  makeFunction: IExternalEngine_makeFunctionPtr;
	  makeProcedure: IExternalEngine_makeProcedurePtr;
	  makeTrigger: IExternalEngine_makeTriggerPtr;
	end;

	IExternalEngineImpl = class;

	TExternalEngine = record
	private
	  FNullPtr: pointer;
	  FvTable: PExternalEngineVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IExternalEngine; inline;
	public
	  function isIExternalEngineImpl: boolean;
	  function asIExternalEngineImpl: IExternalEngineImpl;
	  property vTable: PExternalEngineVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  procedure open(status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal);
	  procedure openAttachment(status: IStatus; context: IExternalContext);
	  procedure closeAttachment(status: IStatus; context: IExternalContext);
	  function makeFunction(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction;
	  function makeProcedure(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure;
	  function makeTrigger(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger;
	end;

	IExternalEngineImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PExternalEngineVTable;
	public
	  const VERSION = 10;
	public
	  constructor create;
	  function asIExternalEngine: IExternalEngine;
	  class function isIExternalEngineImpl(intf: IExternalEngine): boolean;
	  property vTable: PExternalEngineVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure open(status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal); virtual; abstract;
	  procedure openAttachment(status: IStatus; context: IExternalContext); virtual; abstract;
	  procedure closeAttachment(status: IStatus; context: IExternalContext); virtual; abstract;
	  function makeFunction(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction; virtual; abstract;
	  function makeProcedure(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure; virtual; abstract;
	  function makeTrigger(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger; virtual; abstract;
	end;

	PTimerVTable = ^TimerVTable;
	TimerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  handler: ITimer_handlerPtr;
	end;

	ITimerImpl = class;

	TTimer = record
	private
	  FNullPtr: pointer;
	  FvTable: PTimerVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITimer; inline;
	public
	  function isITimerImpl: boolean;
	  function asITimerImpl: ITimerImpl;
	  property vTable: PTimerVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure handler();
	end;

	ITimerImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PTimerVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asITimer: ITimer;
	  class function isITimerImpl(intf: ITimer): boolean;
	  property vTable: PTimerVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure handler(); virtual; abstract;
	end;

	PTimerControlVTable = ^TimerControlVTable;
	TimerControlVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  start: ITimerControl_startPtr;
	  stop: ITimerControl_stopPtr;
	end;

	ITimerControlImpl = class;

	TTimerControl = record
	private
	  FNullPtr: pointer;
	  FvTable: PTimerControlVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITimerControl; inline;
	public
	  function isITimerControlImpl: boolean;
	  function asITimerControlImpl: ITimerControlImpl;
	  property vTable: PTimerControlVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure start(status: IStatus; timer: ITimer; microSeconds: QWord);
	  procedure stop(status: IStatus; timer: ITimer);
	end;

	ITimerControlImpl = class(IVersionedImpl)
	private
	  function getVTable: PTimerControlVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asITimerControl: ITimerControl;
	  class function isITimerControlImpl(intf: ITimerControl): boolean;
	  property vTable: PTimerControlVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure start(status: IStatus; timer: ITimer; microSeconds: QWord); virtual; abstract;
	  procedure stop(status: IStatus; timer: ITimer); virtual; abstract;
	end;

	PVersionCallbackVTable = ^VersionCallbackVTable;
	VersionCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  callback: IVersionCallback_callbackPtr;
	end;

	IVersionCallbackImpl = class;

	TVersionCallback = record
	private
	  FNullPtr: pointer;
	  FvTable: PVersionCallbackVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IVersionCallback; inline;
	public
	  function isIVersionCallbackImpl: boolean;
	  function asIVersionCallbackImpl: IVersionCallbackImpl;
	  property vTable: PVersionCallbackVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure callback(status: IStatus; text: PAnsiChar);
	end;

	IVersionCallbackImpl = class(IVersionedImpl)
	private
	  function getVTable: PVersionCallbackVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asIVersionCallback: IVersionCallback;
	  class function isIVersionCallbackImpl(intf: IVersionCallback): boolean;
	  property vTable: PVersionCallbackVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure callback(status: IStatus; text: PAnsiChar); virtual; abstract;
	end;

	PUtilVTable = ^UtilVTable;
	UtilVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getFbVersion: IUtil_getFbVersionPtr;
	  loadBlob: IUtil_loadBlobPtr;
	  dumpBlob: IUtil_dumpBlobPtr;
	  getPerfCounters: IUtil_getPerfCountersPtr;
	  executeCreateDatabase: IUtil_executeCreateDatabasePtr;
	  decodeDate: IUtil_decodeDatePtr;
	  decodeTime: IUtil_decodeTimePtr;
	  encodeDate: IUtil_encodeDatePtr;
	  encodeTime: IUtil_encodeTimePtr;
	  formatStatus: IUtil_formatStatusPtr;
	  getClientVersion: IUtil_getClientVersionPtr;
	  getXpbBuilder: IUtil_getXpbBuilderPtr;
	  setOffsets: IUtil_setOffsetsPtr;
	  getDecFloat16: IUtil_getDecFloat16Ptr;
	  getDecFloat34: IUtil_getDecFloat34Ptr;
	  decodeTimeTz: IUtil_decodeTimeTzPtr;
	  decodeTimeStampTz: IUtil_decodeTimeStampTzPtr;
	  encodeTimeTz: IUtil_encodeTimeTzPtr;
	  encodeTimeStampTz: IUtil_encodeTimeStampTzPtr;
	  getInt128: IUtil_getInt128Ptr;
	  decodeTimeTzEx: IUtil_decodeTimeTzExPtr;
	  decodeTimeStampTzEx: IUtil_decodeTimeStampTzExPtr;
	end;

	IUtilImpl = class;

	TUtil = record
	private
	  FNullPtr: pointer;
	  FvTable: PUtilVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUtil; inline;
	public
	  function isIUtilImpl: boolean;
	  function asIUtilImpl: IUtilImpl;
	  property vTable: PUtilVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure getFbVersion(status: IStatus; att: IAttachment; callback: IVersionCallback);
	  procedure loadBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
	  procedure dumpBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
	  procedure getPerfCounters(status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr);
	  function executeCreateDatabase(status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment;
	  procedure decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr);
	  procedure decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr);
	  function encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE;
	  function encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME;
	  function formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal;
	  function getClientVersion(): Cardinal;
	  function getXpbBuilder(status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder;
	  function setOffsets(status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal;
	  function getDecFloat16(status: IStatus): IDecFloat16;
	  function getDecFloat34(status: IStatus): IDecFloat34;
	  procedure decodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure decodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure encodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
	  procedure encodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
	  function getInt128(status: IStatus): IInt128;
	  procedure decodeTimeTzEx(status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure decodeTimeStampTzEx(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	end;

	IUtilImpl = class(IVersionedImpl)
	private
	  function getVTable: PUtilVTable;
	public
	  const VERSION = 22;
	public
	  constructor create;
	  function asIUtil: IUtil;
	  class function isIUtilImpl(intf: IUtil): boolean;
	  property vTable: PUtilVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure getFbVersion(status: IStatus; att: IAttachment; callback: IVersionCallback); virtual; abstract;
	  procedure loadBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); virtual; abstract;
	  procedure dumpBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); virtual; abstract;
	  procedure getPerfCounters(status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr); virtual; abstract;
	  function executeCreateDatabase(status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment; virtual; abstract;
	  procedure decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); virtual; abstract;
	  procedure decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); virtual; abstract;
	  function encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; virtual; abstract;
	  function encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; virtual; abstract;
	  function formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal; virtual; abstract;
	  function getClientVersion(): Cardinal; virtual; abstract;
	  function getXpbBuilder(status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder; virtual; abstract;
	  function setOffsets(status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal; virtual; abstract;
	  function getDecFloat16(status: IStatus): IDecFloat16; virtual; abstract;
	  function getDecFloat34(status: IStatus): IDecFloat34; virtual; abstract;
	  procedure decodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	  procedure decodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	  procedure encodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); virtual; abstract;
	  procedure encodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); virtual; abstract;
	  function getInt128(status: IStatus): IInt128; virtual; abstract;
	  procedure decodeTimeTzEx(status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	  procedure decodeTimeStampTzEx(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	end;

	POffsetsCallbackVTable = ^OffsetsCallbackVTable;
	OffsetsCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  setOffset: IOffsetsCallback_setOffsetPtr;
	end;

	IOffsetsCallbackImpl = class;

	TOffsetsCallback = record
	private
	  FNullPtr: pointer;
	  FvTable: POffsetsCallbackVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IOffsetsCallback; inline;
	public
	  function isIOffsetsCallbackImpl: boolean;
	  function asIOffsetsCallbackImpl: IOffsetsCallbackImpl;
	  property vTable: POffsetsCallbackVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure setOffset(status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal);
	end;

	IOffsetsCallbackImpl = class(IVersionedImpl)
	private
	  function getVTable: POffsetsCallbackVTable;
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function asIOffsetsCallback: IOffsetsCallback;
	  class function isIOffsetsCallbackImpl(intf: IOffsetsCallback): boolean;
	  property vTable: POffsetsCallbackVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setOffset(status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); virtual; abstract;
	end;

	PXpbBuilderVTable = ^XpbBuilderVTable;
	XpbBuilderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  clear: IXpbBuilder_clearPtr;
	  removeCurrent: IXpbBuilder_removeCurrentPtr;
	  insertInt: IXpbBuilder_insertIntPtr;
	  insertBigInt: IXpbBuilder_insertBigIntPtr;
	  insertBytes: IXpbBuilder_insertBytesPtr;
	  insertString: IXpbBuilder_insertStringPtr;
	  insertTag: IXpbBuilder_insertTagPtr;
	  isEof: IXpbBuilder_isEofPtr;
	  moveNext: IXpbBuilder_moveNextPtr;
	  rewind: IXpbBuilder_rewindPtr;
	  findFirst: IXpbBuilder_findFirstPtr;
	  findNext: IXpbBuilder_findNextPtr;
	  getTag: IXpbBuilder_getTagPtr;
	  getLength: IXpbBuilder_getLengthPtr;
	  getInt: IXpbBuilder_getIntPtr;
	  getBigInt: IXpbBuilder_getBigIntPtr;
	  getString: IXpbBuilder_getStringPtr;
	  getBytes: IXpbBuilder_getBytesPtr;
	  getBufferLength: IXpbBuilder_getBufferLengthPtr;
	  getBuffer: IXpbBuilder_getBufferPtr;
	end;

	IXpbBuilderImpl = class;

	TXpbBuilder = record
	private
	  FNullPtr: pointer;
	  FvTable: PXpbBuilderVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IXpbBuilder; inline;
	public
	  function isIXpbBuilderImpl: boolean;
	  function asIXpbBuilderImpl: IXpbBuilderImpl;
	  property vTable: PXpbBuilderVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure clear(status: IStatus);
	  procedure removeCurrent(status: IStatus);
	  procedure insertInt(status: IStatus; tag: Byte; value: Integer);
	  procedure insertBigInt(status: IStatus; tag: Byte; value: Int64);
	  procedure insertBytes(status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal);
	  procedure insertString(status: IStatus; tag: Byte; str: PAnsiChar);
	  procedure insertTag(status: IStatus; tag: Byte);
	  function isEof(status: IStatus): Boolean;
	  procedure moveNext(status: IStatus);
	  procedure rewind(status: IStatus);
	  function findFirst(status: IStatus; tag: Byte): Boolean;
	  function findNext(status: IStatus): Boolean;
	  function getTag(status: IStatus): Byte;
	  function getLength(status: IStatus): Cardinal;
	  function getInt(status: IStatus): Integer;
	  function getBigInt(status: IStatus): Int64;
	  function getString(status: IStatus): PAnsiChar;
	  function getBytes(status: IStatus): BytePtr;
	  function getBufferLength(status: IStatus): Cardinal;
	  function getBuffer(status: IStatus): BytePtr;
	end;

	IXpbBuilderImpl = class(IDisposableImpl)
	private
	  function getVTable: PXpbBuilderVTable;
	public
	  const VERSION = 21;
	  const DPB = Cardinal(1);
	  const SPB_ATTACH = Cardinal(2);
	  const SPB_START = Cardinal(3);
	  const TPB = Cardinal(4);
	  const BATCH = Cardinal(5);
	  const BPB = Cardinal(6);
	  const SPB_SEND = Cardinal(7);
	  const SPB_RECEIVE = Cardinal(8);
	  const SPB_RESPONSE = Cardinal(9);
	public
	  constructor create;
	  function asIXpbBuilder: IXpbBuilder;
	  class function isIXpbBuilderImpl(intf: IXpbBuilder): boolean;
	  property vTable: PXpbBuilderVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure clear(status: IStatus); virtual; abstract;
	  procedure removeCurrent(status: IStatus); virtual; abstract;
	  procedure insertInt(status: IStatus; tag: Byte; value: Integer); virtual; abstract;
	  procedure insertBigInt(status: IStatus; tag: Byte; value: Int64); virtual; abstract;
	  procedure insertBytes(status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal); virtual; abstract;
	  procedure insertString(status: IStatus; tag: Byte; str: PAnsiChar); virtual; abstract;
	  procedure insertTag(status: IStatus; tag: Byte); virtual; abstract;
	  function isEof(status: IStatus): Boolean; virtual; abstract;
	  procedure moveNext(status: IStatus); virtual; abstract;
	  procedure rewind(status: IStatus); virtual; abstract;
	  function findFirst(status: IStatus; tag: Byte): Boolean; virtual; abstract;
	  function findNext(status: IStatus): Boolean; virtual; abstract;
	  function getTag(status: IStatus): Byte; virtual; abstract;
	  function getLength(status: IStatus): Cardinal; virtual; abstract;
	  function getInt(status: IStatus): Integer; virtual; abstract;
	  function getBigInt(status: IStatus): Int64; virtual; abstract;
	  function getString(status: IStatus): PAnsiChar; virtual; abstract;
	  function getBytes(status: IStatus): BytePtr; virtual; abstract;
	  function getBufferLength(status: IStatus): Cardinal; virtual; abstract;
	  function getBuffer(status: IStatus): BytePtr; virtual; abstract;
	end;

	PTraceConnectionVTable = ^TraceConnectionVTable;
	TraceConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	end;

	ITraceConnectionImpl = class;

	TTraceConnection = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceConnectionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceConnection; inline;
	public
	  function isITraceConnectionImpl: boolean;
	  function asITraceConnectionImpl: ITraceConnectionImpl;
	  property vTable: PTraceConnectionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	end;

	ITraceConnectionImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceConnectionVTable;
	public
	  const VERSION = 9;
	  const KIND_DATABASE = Cardinal(1);
	  const KIND_SERVICE = Cardinal(2);
	public
	  constructor create;
	  function asITraceConnection: ITraceConnection;
	  class function isITraceConnectionImpl(intf: ITraceConnection): boolean;
	  property vTable: PTraceConnectionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getKind(): Cardinal; virtual; abstract;
	  function getProcessID(): Integer; virtual; abstract;
	  function getUserName(): PAnsiChar; virtual; abstract;
	  function getRoleName(): PAnsiChar; virtual; abstract;
	  function getCharSet(): PAnsiChar; virtual; abstract;
	  function getRemoteProtocol(): PAnsiChar; virtual; abstract;
	  function getRemoteAddress(): PAnsiChar; virtual; abstract;
	  function getRemoteProcessID(): Integer; virtual; abstract;
	  function getRemoteProcessName(): PAnsiChar; virtual; abstract;
	end;

	PTraceDatabaseConnectionVTable = ^TraceDatabaseConnectionVTable;
	TraceDatabaseConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	  getConnectionID: ITraceDatabaseConnection_getConnectionIDPtr;
	  getDatabaseName: ITraceDatabaseConnection_getDatabaseNamePtr;
	end;

	ITraceDatabaseConnectionImpl = class;

	TTraceDatabaseConnection = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceDatabaseConnectionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceDatabaseConnection; inline;
	public
	  function isITraceDatabaseConnectionImpl: boolean;
	  function asITraceDatabaseConnectionImpl: ITraceDatabaseConnectionImpl;
	  property vTable: PTraceDatabaseConnectionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  function getConnectionID(): Int64;
	  function getDatabaseName(): PAnsiChar;
	end;

	ITraceDatabaseConnectionImpl = class(ITraceConnectionImpl)
	private
	  function getVTable: PTraceDatabaseConnectionVTable;
	public
	  const VERSION = 11;
	public
	  constructor create;
	  function asITraceDatabaseConnection: ITraceDatabaseConnection;
	  class function isITraceDatabaseConnectionImpl(intf: ITraceDatabaseConnection): boolean;
	  property vTable: PTraceDatabaseConnectionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getConnectionID(): Int64; virtual; abstract;
	  function getDatabaseName(): PAnsiChar; virtual; abstract;
	end;

	PTraceTransactionVTable = ^TraceTransactionVTable;
	TraceTransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getTransactionID: ITraceTransaction_getTransactionIDPtr;
	  getReadOnly: ITraceTransaction_getReadOnlyPtr;
	  getWait: ITraceTransaction_getWaitPtr;
	  getIsolation: ITraceTransaction_getIsolationPtr;
	  getPerf: ITraceTransaction_getPerfPtr;
	  getInitialID: ITraceTransaction_getInitialIDPtr;
	  getPreviousID: ITraceTransaction_getPreviousIDPtr;
	end;

	ITraceTransactionImpl = class;

	TTraceTransaction = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceTransactionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceTransaction; inline;
	public
	  function isITraceTransactionImpl: boolean;
	  function asITraceTransactionImpl: ITraceTransactionImpl;
	  property vTable: PTraceTransactionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getTransactionID(): Int64;
	  function getReadOnly(): Boolean;
	  function getWait(): Integer;
	  function getIsolation(): Cardinal;
	  function getPerf(): PerformanceInfoPtr;
	  function getInitialID(): Int64;
	  function getPreviousID(): Int64;
	end;

	ITraceTransactionImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceTransactionVTable;
	public
	  const VERSION = 7;
	  const ISOLATION_CONSISTENCY = Cardinal(1);
	  const ISOLATION_CONCURRENCY = Cardinal(2);
	  const ISOLATION_READ_COMMITTED_RECVER = Cardinal(3);
	  const ISOLATION_READ_COMMITTED_NORECVER = Cardinal(4);
	  const ISOLATION_READ_COMMITTED_READ_CONSISTENCY = Cardinal(5);
	public
	  constructor create;
	  function asITraceTransaction: ITraceTransaction;
	  class function isITraceTransactionImpl(intf: ITraceTransaction): boolean;
	  property vTable: PTraceTransactionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getTransactionID(): Int64; virtual; abstract;
	  function getReadOnly(): Boolean; virtual; abstract;
	  function getWait(): Integer; virtual; abstract;
	  function getIsolation(): Cardinal; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	  function getInitialID(): Int64; virtual; abstract;
	  function getPreviousID(): Int64; virtual; abstract;
	end;

	PTraceParamsVTable = ^TraceParamsVTable;
	TraceParamsVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getCount: ITraceParams_getCountPtr;
	  getParam: ITraceParams_getParamPtr;
	  getTextUTF8: ITraceParams_getTextUTF8Ptr;
	end;

	ITraceParamsImpl = class;

	TTraceParams = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceParamsVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceParams; inline;
	public
	  function isITraceParamsImpl: boolean;
	  function asITraceParamsImpl: ITraceParamsImpl;
	  property vTable: PTraceParamsVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getCount(): Cardinal;
	  function getParam(idx: Cardinal): dscPtr;
	  function getTextUTF8(status: IStatus; idx: Cardinal): PAnsiChar;
	end;

	ITraceParamsImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceParamsVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asITraceParams: ITraceParams;
	  class function isITraceParamsImpl(intf: ITraceParams): boolean;
	  property vTable: PTraceParamsVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getCount(): Cardinal; virtual; abstract;
	  function getParam(idx: Cardinal): dscPtr; virtual; abstract;
	  function getTextUTF8(status: IStatus; idx: Cardinal): PAnsiChar; virtual; abstract;
	end;

	PTraceStatementVTable = ^TraceStatementVTable;
	TraceStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	end;

	ITraceStatementImpl = class;

	TTraceStatement = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceStatementVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceStatement; inline;
	public
	  function isITraceStatementImpl: boolean;
	  function asITraceStatementImpl: ITraceStatementImpl;
	  property vTable: PTraceStatementVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceStatementImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceStatementVTable;
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function asITraceStatement: ITraceStatement;
	  class function isITraceStatementImpl(intf: ITraceStatement): boolean;
	  property vTable: PTraceStatementVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getStmtID(): Int64; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceSQLStatementVTable = ^TraceSQLStatementVTable;
	TraceSQLStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	  getText: ITraceSQLStatement_getTextPtr;
	  getPlan: ITraceSQLStatement_getPlanPtr;
	  getInputs: ITraceSQLStatement_getInputsPtr;
	  getTextUTF8: ITraceSQLStatement_getTextUTF8Ptr;
	  getExplainedPlan: ITraceSQLStatement_getExplainedPlanPtr;
	end;

	ITraceSQLStatementImpl = class;

	TTraceSQLStatement = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceSQLStatementVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceSQLStatement; inline;
	public
	  function isITraceSQLStatementImpl: boolean;
	  function asITraceSQLStatementImpl: ITraceSQLStatementImpl;
	  property vTable: PTraceSQLStatementVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  function getText(): PAnsiChar;
	  function getPlan(): PAnsiChar;
	  function getInputs(): ITraceParams;
	  function getTextUTF8(): PAnsiChar;
	  function getExplainedPlan(): PAnsiChar;
	end;

	ITraceSQLStatementImpl = class(ITraceStatementImpl)
	private
	  function getVTable: PTraceSQLStatementVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asITraceSQLStatement: ITraceSQLStatement;
	  class function isITraceSQLStatementImpl(intf: ITraceSQLStatement): boolean;
	  property vTable: PTraceSQLStatementVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getText(): PAnsiChar; virtual; abstract;
	  function getPlan(): PAnsiChar; virtual; abstract;
	  function getInputs(): ITraceParams; virtual; abstract;
	  function getTextUTF8(): PAnsiChar; virtual; abstract;
	  function getExplainedPlan(): PAnsiChar; virtual; abstract;
	end;

	PTraceBLRStatementVTable = ^TraceBLRStatementVTable;
	TraceBLRStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	  getData: ITraceBLRStatement_getDataPtr;
	  getDataLength: ITraceBLRStatement_getDataLengthPtr;
	  getText: ITraceBLRStatement_getTextPtr;
	end;

	ITraceBLRStatementImpl = class;

	TTraceBLRStatement = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceBLRStatementVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceBLRStatement; inline;
	public
	  function isITraceBLRStatementImpl: boolean;
	  function asITraceBLRStatementImpl: ITraceBLRStatementImpl;
	  property vTable: PTraceBLRStatementVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  function getData(): BytePtr;
	  function getDataLength(): Cardinal;
	  function getText(): PAnsiChar;
	end;

	ITraceBLRStatementImpl = class(ITraceStatementImpl)
	private
	  function getVTable: PTraceBLRStatementVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asITraceBLRStatement: ITraceBLRStatement;
	  class function isITraceBLRStatementImpl(intf: ITraceBLRStatement): boolean;
	  property vTable: PTraceBLRStatementVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getData(): BytePtr; virtual; abstract;
	  function getDataLength(): Cardinal; virtual; abstract;
	  function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceDYNRequestVTable = ^TraceDYNRequestVTable;
	TraceDYNRequestVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getData: ITraceDYNRequest_getDataPtr;
	  getDataLength: ITraceDYNRequest_getDataLengthPtr;
	  getText: ITraceDYNRequest_getTextPtr;
	end;

	ITraceDYNRequestImpl = class;

	TTraceDYNRequest = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceDYNRequestVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceDYNRequest; inline;
	public
	  function isITraceDYNRequestImpl: boolean;
	  function asITraceDYNRequestImpl: ITraceDYNRequestImpl;
	  property vTable: PTraceDYNRequestVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getData(): BytePtr;
	  function getDataLength(): Cardinal;
	  function getText(): PAnsiChar;
	end;

	ITraceDYNRequestImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceDYNRequestVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asITraceDYNRequest: ITraceDYNRequest;
	  class function isITraceDYNRequestImpl(intf: ITraceDYNRequest): boolean;
	  property vTable: PTraceDYNRequestVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getData(): BytePtr; virtual; abstract;
	  function getDataLength(): Cardinal; virtual; abstract;
	  function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceContextVariableVTable = ^TraceContextVariableVTable;
	TraceContextVariableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getNameSpace: ITraceContextVariable_getNameSpacePtr;
	  getVarName: ITraceContextVariable_getVarNamePtr;
	  getVarValue: ITraceContextVariable_getVarValuePtr;
	end;

	ITraceContextVariableImpl = class;

	TTraceContextVariable = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceContextVariableVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceContextVariable; inline;
	public
	  function isITraceContextVariableImpl: boolean;
	  function asITraceContextVariableImpl: ITraceContextVariableImpl;
	  property vTable: PTraceContextVariableVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getNameSpace(): PAnsiChar;
	  function getVarName(): PAnsiChar;
	  function getVarValue(): PAnsiChar;
	end;

	ITraceContextVariableImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceContextVariableVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asITraceContextVariable: ITraceContextVariable;
	  class function isITraceContextVariableImpl(intf: ITraceContextVariable): boolean;
	  property vTable: PTraceContextVariableVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getNameSpace(): PAnsiChar; virtual; abstract;
	  function getVarName(): PAnsiChar; virtual; abstract;
	  function getVarValue(): PAnsiChar; virtual; abstract;
	end;

	PTraceProcedureVTable = ^TraceProcedureVTable;
	TraceProcedureVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getProcName: ITraceProcedure_getProcNamePtr;
	  getInputs: ITraceProcedure_getInputsPtr;
	  getPerf: ITraceProcedure_getPerfPtr;
	end;

	ITraceProcedureImpl = class;

	TTraceProcedure = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceProcedureVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceProcedure; inline;
	public
	  function isITraceProcedureImpl: boolean;
	  function asITraceProcedureImpl: ITraceProcedureImpl;
	  property vTable: PTraceProcedureVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getProcName(): PAnsiChar;
	  function getInputs(): ITraceParams;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceProcedureImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceProcedureVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asITraceProcedure: ITraceProcedure;
	  class function isITraceProcedureImpl(intf: ITraceProcedure): boolean;
	  property vTable: PTraceProcedureVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getProcName(): PAnsiChar; virtual; abstract;
	  function getInputs(): ITraceParams; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceFunctionVTable = ^TraceFunctionVTable;
	TraceFunctionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getFuncName: ITraceFunction_getFuncNamePtr;
	  getInputs: ITraceFunction_getInputsPtr;
	  getResult: ITraceFunction_getResultPtr;
	  getPerf: ITraceFunction_getPerfPtr;
	end;

	ITraceFunctionImpl = class;

	TTraceFunction = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceFunctionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceFunction; inline;
	public
	  function isITraceFunctionImpl: boolean;
	  function asITraceFunctionImpl: ITraceFunctionImpl;
	  property vTable: PTraceFunctionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getFuncName(): PAnsiChar;
	  function getInputs(): ITraceParams;
	  function getResult(): ITraceParams;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceFunctionImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceFunctionVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asITraceFunction: ITraceFunction;
	  class function isITraceFunctionImpl(intf: ITraceFunction): boolean;
	  property vTable: PTraceFunctionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getFuncName(): PAnsiChar; virtual; abstract;
	  function getInputs(): ITraceParams; virtual; abstract;
	  function getResult(): ITraceParams; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceTriggerVTable = ^TraceTriggerVTable;
	TraceTriggerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getTriggerName: ITraceTrigger_getTriggerNamePtr;
	  getRelationName: ITraceTrigger_getRelationNamePtr;
	  getAction: ITraceTrigger_getActionPtr;
	  getWhich: ITraceTrigger_getWhichPtr;
	  getPerf: ITraceTrigger_getPerfPtr;
	end;

	ITraceTriggerImpl = class;

	TTraceTrigger = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceTriggerVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceTrigger; inline;
	public
	  function isITraceTriggerImpl: boolean;
	  function asITraceTriggerImpl: ITraceTriggerImpl;
	  property vTable: PTraceTriggerVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getTriggerName(): PAnsiChar;
	  function getRelationName(): PAnsiChar;
	  function getAction(): Integer;
	  function getWhich(): Integer;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceTriggerImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceTriggerVTable;
	public
	  const VERSION = 5;
	  const TYPE_ALL = Cardinal(0);
	  const TYPE_BEFORE = Cardinal(1);
	  const TYPE_AFTER = Cardinal(2);
	public
	  constructor create;
	  function asITraceTrigger: ITraceTrigger;
	  class function isITraceTriggerImpl(intf: ITraceTrigger): boolean;
	  property vTable: PTraceTriggerVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getTriggerName(): PAnsiChar; virtual; abstract;
	  function getRelationName(): PAnsiChar; virtual; abstract;
	  function getAction(): Integer; virtual; abstract;
	  function getWhich(): Integer; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceServiceConnectionVTable = ^TraceServiceConnectionVTable;
	TraceServiceConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	  getServiceID: ITraceServiceConnection_getServiceIDPtr;
	  getServiceMgr: ITraceServiceConnection_getServiceMgrPtr;
	  getServiceName: ITraceServiceConnection_getServiceNamePtr;
	end;

	ITraceServiceConnectionImpl = class;

	TTraceServiceConnection = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceServiceConnectionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceServiceConnection; inline;
	public
	  function isITraceServiceConnectionImpl: boolean;
	  function asITraceServiceConnectionImpl: ITraceServiceConnectionImpl;
	  property vTable: PTraceServiceConnectionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  function getServiceID(): Pointer;
	  function getServiceMgr(): PAnsiChar;
	  function getServiceName(): PAnsiChar;
	end;

	ITraceServiceConnectionImpl = class(ITraceConnectionImpl)
	private
	  function getVTable: PTraceServiceConnectionVTable;
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function asITraceServiceConnection: ITraceServiceConnection;
	  class function isITraceServiceConnectionImpl(intf: ITraceServiceConnection): boolean;
	  property vTable: PTraceServiceConnectionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getServiceID(): Pointer; virtual; abstract;
	  function getServiceMgr(): PAnsiChar; virtual; abstract;
	  function getServiceName(): PAnsiChar; virtual; abstract;
	end;

	PTraceStatusVectorVTable = ^TraceStatusVectorVTable;
	TraceStatusVectorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  hasError: ITraceStatusVector_hasErrorPtr;
	  hasWarning: ITraceStatusVector_hasWarningPtr;
	  getStatus: ITraceStatusVector_getStatusPtr;
	  getText: ITraceStatusVector_getTextPtr;
	end;

	ITraceStatusVectorImpl = class;

	TTraceStatusVector = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceStatusVectorVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceStatusVector; inline;
	public
	  function isITraceStatusVectorImpl: boolean;
	  function asITraceStatusVectorImpl: ITraceStatusVectorImpl;
	  property vTable: PTraceStatusVectorVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function hasError(): Boolean;
	  function hasWarning(): Boolean;
	  function getStatus(): IStatus;
	  function getText(): PAnsiChar;
	end;

	ITraceStatusVectorImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceStatusVectorVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asITraceStatusVector: ITraceStatusVector;
	  class function isITraceStatusVectorImpl(intf: ITraceStatusVector): boolean;
	  property vTable: PTraceStatusVectorVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function hasError(): Boolean; virtual; abstract;
	  function hasWarning(): Boolean; virtual; abstract;
	  function getStatus(): IStatus; virtual; abstract;
	  function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceSweepInfoVTable = ^TraceSweepInfoVTable;
	TraceSweepInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getOIT: ITraceSweepInfo_getOITPtr;
	  getOST: ITraceSweepInfo_getOSTPtr;
	  getOAT: ITraceSweepInfo_getOATPtr;
	  getNext: ITraceSweepInfo_getNextPtr;
	  getPerf: ITraceSweepInfo_getPerfPtr;
	end;

	ITraceSweepInfoImpl = class;

	TTraceSweepInfo = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceSweepInfoVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceSweepInfo; inline;
	public
	  function isITraceSweepInfoImpl: boolean;
	  function asITraceSweepInfoImpl: ITraceSweepInfoImpl;
	  property vTable: PTraceSweepInfoVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getOIT(): Int64;
	  function getOST(): Int64;
	  function getOAT(): Int64;
	  function getNext(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceSweepInfoImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceSweepInfoVTable;
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function asITraceSweepInfo: ITraceSweepInfo;
	  class function isITraceSweepInfoImpl(intf: ITraceSweepInfo): boolean;
	  property vTable: PTraceSweepInfoVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getOIT(): Int64; virtual; abstract;
	  function getOST(): Int64; virtual; abstract;
	  function getOAT(): Int64; virtual; abstract;
	  function getNext(): Int64; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceLogWriterVTable = ^TraceLogWriterVTable;
	TraceLogWriterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  write: ITraceLogWriter_writePtr;
	  write_s: ITraceLogWriter_write_sPtr;
	end;

	ITraceLogWriterImpl = class;

	TTraceLogWriter = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceLogWriterVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceLogWriter; inline;
	public
	  function isITraceLogWriterImpl: boolean;
	  function asITraceLogWriterImpl: ITraceLogWriterImpl;
	  property vTable: PTraceLogWriterVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function write(buf: Pointer; size: Cardinal): Cardinal;
	  function write_s(status: IStatus; buf: Pointer; size: Cardinal): Cardinal;
	end;

	ITraceLogWriterImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PTraceLogWriterVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asITraceLogWriter: ITraceLogWriter;
	  class function isITraceLogWriterImpl(intf: ITraceLogWriter): boolean;
	  property vTable: PTraceLogWriterVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function write(buf: Pointer; size: Cardinal): Cardinal; virtual; abstract;
	  function write_s(status: IStatus; buf: Pointer; size: Cardinal): Cardinal; virtual; abstract;
	end;

	PTraceInitInfoVTable = ^TraceInitInfoVTable;
	TraceInitInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getConfigText: ITraceInitInfo_getConfigTextPtr;
	  getTraceSessionID: ITraceInitInfo_getTraceSessionIDPtr;
	  getTraceSessionName: ITraceInitInfo_getTraceSessionNamePtr;
	  getFirebirdRootDirectory: ITraceInitInfo_getFirebirdRootDirectoryPtr;
	  getDatabaseName: ITraceInitInfo_getDatabaseNamePtr;
	  getConnection: ITraceInitInfo_getConnectionPtr;
	  getLogWriter: ITraceInitInfo_getLogWriterPtr;
	end;

	ITraceInitInfoImpl = class;

	TTraceInitInfo = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceInitInfoVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceInitInfo; inline;
	public
	  function isITraceInitInfoImpl: boolean;
	  function asITraceInitInfoImpl: ITraceInitInfoImpl;
	  property vTable: PTraceInitInfoVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getConfigText(): PAnsiChar;
	  function getTraceSessionID(): Integer;
	  function getTraceSessionName(): PAnsiChar;
	  function getFirebirdRootDirectory(): PAnsiChar;
	  function getDatabaseName(): PAnsiChar;
	  function getConnection(): ITraceDatabaseConnection;
	  function getLogWriter(): ITraceLogWriter;
	end;

	ITraceInitInfoImpl = class(IVersionedImpl)
	private
	  function getVTable: PTraceInitInfoVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asITraceInitInfo: ITraceInitInfo;
	  class function isITraceInitInfoImpl(intf: ITraceInitInfo): boolean;
	  property vTable: PTraceInitInfoVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getConfigText(): PAnsiChar; virtual; abstract;
	  function getTraceSessionID(): Integer; virtual; abstract;
	  function getTraceSessionName(): PAnsiChar; virtual; abstract;
	  function getFirebirdRootDirectory(): PAnsiChar; virtual; abstract;
	  function getDatabaseName(): PAnsiChar; virtual; abstract;
	  function getConnection(): ITraceDatabaseConnection; virtual; abstract;
	  function getLogWriter(): ITraceLogWriter; virtual; abstract;
	end;

	PTracePluginVTable = ^TracePluginVTable;
	TracePluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  trace_get_error: ITracePlugin_trace_get_errorPtr;
	  trace_attach: ITracePlugin_trace_attachPtr;
	  trace_detach: ITracePlugin_trace_detachPtr;
	  trace_transaction_start: ITracePlugin_trace_transaction_startPtr;
	  trace_transaction_end: ITracePlugin_trace_transaction_endPtr;
	  trace_proc_execute: ITracePlugin_trace_proc_executePtr;
	  trace_trigger_execute: ITracePlugin_trace_trigger_executePtr;
	  trace_set_context: ITracePlugin_trace_set_contextPtr;
	  trace_dsql_prepare: ITracePlugin_trace_dsql_preparePtr;
	  trace_dsql_free: ITracePlugin_trace_dsql_freePtr;
	  trace_dsql_execute: ITracePlugin_trace_dsql_executePtr;
	  trace_blr_compile: ITracePlugin_trace_blr_compilePtr;
	  trace_blr_execute: ITracePlugin_trace_blr_executePtr;
	  trace_dyn_execute: ITracePlugin_trace_dyn_executePtr;
	  trace_service_attach: ITracePlugin_trace_service_attachPtr;
	  trace_service_start: ITracePlugin_trace_service_startPtr;
	  trace_service_query: ITracePlugin_trace_service_queryPtr;
	  trace_service_detach: ITracePlugin_trace_service_detachPtr;
	  trace_event_error: ITracePlugin_trace_event_errorPtr;
	  trace_event_sweep: ITracePlugin_trace_event_sweepPtr;
	  trace_func_execute: ITracePlugin_trace_func_executePtr;
	end;

	ITracePluginImpl = class;

	TTracePlugin = record
	private
	  FNullPtr: pointer;
	  FvTable: PTracePluginVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITracePlugin; inline;
	public
	  function isITracePluginImpl: boolean;
	  function asITracePluginImpl: ITracePluginImpl;
	  property vTable: PTracePluginVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function trace_get_error(): PAnsiChar;
	  function trace_attach(connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean;
	  function trace_detach(connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean;
	  function trace_transaction_start(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean;
	  function trace_transaction_end(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean;
	  function trace_proc_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean;
	  function trace_trigger_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean;
	  function trace_set_context(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean;
	  function trace_dsql_prepare(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_dsql_free(connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean;
	  function trace_dsql_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean;
	  function trace_blr_compile(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_blr_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean;
	  function trace_dyn_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_service_attach(service: ITraceServiceConnection; att_result: Cardinal): Boolean;
	  function trace_service_start(service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean;
	  function trace_service_query(service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean;
	  function trace_service_detach(service: ITraceServiceConnection; detach_result: Cardinal): Boolean;
	  function trace_event_error(connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean;
	  function trace_event_sweep(connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean;
	  function trace_func_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean;
	end;

	ITracePluginImpl = class(IReferenceCountedImpl)
	private
	  function getVTable: PTracePluginVTable;
	public
	  const VERSION = 23;
	  const RESULT_SUCCESS = Cardinal(0);
	  const RESULT_FAILED = Cardinal(1);
	  const RESULT_UNAUTHORIZED = Cardinal(2);
	  const SWEEP_STATE_STARTED = Cardinal(1);
	  const SWEEP_STATE_FINISHED = Cardinal(2);
	  const SWEEP_STATE_FAILED = Cardinal(3);
	  const SWEEP_STATE_PROGRESS = Cardinal(4);
	public
	  constructor create;
	  function asITracePlugin: ITracePlugin;
	  class function isITracePluginImpl(intf: ITracePlugin): boolean;
	  property vTable: PTracePluginVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function trace_get_error(): PAnsiChar; virtual; abstract;
	  function trace_attach(connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean; virtual; abstract;
	  function trace_detach(connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean; virtual; abstract;
	  function trace_transaction_start(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; virtual; abstract;
	  function trace_transaction_end(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; virtual; abstract;
	  function trace_proc_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean; virtual; abstract;
	  function trace_trigger_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean; virtual; abstract;
	  function trace_set_context(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean; virtual; abstract;
	  function trace_dsql_prepare(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_dsql_free(connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean; virtual; abstract;
	  function trace_dsql_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_blr_compile(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_blr_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_dyn_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_attach(service: ITraceServiceConnection; att_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_start(service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_query(service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_detach(service: ITraceServiceConnection; detach_result: Cardinal): Boolean; virtual; abstract;
	  function trace_event_error(connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean; virtual; abstract;
	  function trace_event_sweep(connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean; virtual; abstract;
	  function trace_func_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean; virtual; abstract;
	end;

	PTraceFactoryVTable = ^TraceFactoryVTable;
	TraceFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  trace_needs: ITraceFactory_trace_needsPtr;
	  trace_create: ITraceFactory_trace_createPtr;
	end;

	ITraceFactoryImpl = class;

	TTraceFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PTraceFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: ITraceFactory; inline;
	public
	  function isITraceFactoryImpl: boolean;
	  function asITraceFactoryImpl: ITraceFactoryImpl;
	  property vTable: PTraceFactoryVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function trace_needs(): QWord;
	  function trace_create(status: IStatus; init_info: ITraceInitInfo): ITracePlugin;
	end;

	ITraceFactoryImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PTraceFactoryVTable;
	public
	  const VERSION = 6;
	  const TRACE_EVENT_ATTACH = Cardinal(0);
	  const TRACE_EVENT_DETACH = Cardinal(1);
	  const TRACE_EVENT_TRANSACTION_START = Cardinal(2);
	  const TRACE_EVENT_TRANSACTION_END = Cardinal(3);
	  const TRACE_EVENT_SET_CONTEXT = Cardinal(4);
	  const TRACE_EVENT_PROC_EXECUTE = Cardinal(5);
	  const TRACE_EVENT_TRIGGER_EXECUTE = Cardinal(6);
	  const TRACE_EVENT_DSQL_PREPARE = Cardinal(7);
	  const TRACE_EVENT_DSQL_FREE = Cardinal(8);
	  const TRACE_EVENT_DSQL_EXECUTE = Cardinal(9);
	  const TRACE_EVENT_BLR_COMPILE = Cardinal(10);
	  const TRACE_EVENT_BLR_EXECUTE = Cardinal(11);
	  const TRACE_EVENT_DYN_EXECUTE = Cardinal(12);
	  const TRACE_EVENT_SERVICE_ATTACH = Cardinal(13);
	  const TRACE_EVENT_SERVICE_START = Cardinal(14);
	  const TRACE_EVENT_SERVICE_QUERY = Cardinal(15);
	  const TRACE_EVENT_SERVICE_DETACH = Cardinal(16);
	  const TRACE_EVENT_ERROR = Cardinal(17);
	  const TRACE_EVENT_SWEEP = Cardinal(18);
	  const TRACE_EVENT_FUNC_EXECUTE = Cardinal(19);
	  const TRACE_EVENT_MAX = Cardinal(20);
	public
	  constructor create;
	  function asITraceFactory: ITraceFactory;
	  class function isITraceFactoryImpl(intf: ITraceFactory): boolean;
	  property vTable: PTraceFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function trace_needs(): QWord; virtual; abstract;
	  function trace_create(status: IStatus; init_info: ITraceInitInfo): ITracePlugin; virtual; abstract;
	end;

	PUdrFunctionFactoryVTable = ^UdrFunctionFactoryVTable;
	UdrFunctionFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrFunctionFactory_setupPtr;
	  newItem: IUdrFunctionFactory_newItemPtr;
	end;

	IUdrFunctionFactoryImpl = class;

	TUdrFunctionFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PUdrFunctionFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUdrFunctionFactory; inline;
	public
	  function isIUdrFunctionFactoryImpl: boolean;
	  function asIUdrFunctionFactoryImpl: IUdrFunctionFactoryImpl;
	  property vTable: PUdrFunctionFactoryVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction;
	end;

	IUdrFunctionFactoryImpl = class(IDisposableImpl)
	private
	  function getVTable: PUdrFunctionFactoryVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIUdrFunctionFactory: IUdrFunctionFactory;
	  class function isIUdrFunctionFactoryImpl(intf: IUdrFunctionFactory): boolean;
	  property vTable: PUdrFunctionFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); virtual; abstract;
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction; virtual; abstract;
	end;

	PUdrProcedureFactoryVTable = ^UdrProcedureFactoryVTable;
	UdrProcedureFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrProcedureFactory_setupPtr;
	  newItem: IUdrProcedureFactory_newItemPtr;
	end;

	IUdrProcedureFactoryImpl = class;

	TUdrProcedureFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PUdrProcedureFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUdrProcedureFactory; inline;
	public
	  function isIUdrProcedureFactoryImpl: boolean;
	  function asIUdrProcedureFactoryImpl: IUdrProcedureFactoryImpl;
	  property vTable: PUdrProcedureFactoryVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure;
	end;

	IUdrProcedureFactoryImpl = class(IDisposableImpl)
	private
	  function getVTable: PUdrProcedureFactoryVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIUdrProcedureFactory: IUdrProcedureFactory;
	  class function isIUdrProcedureFactoryImpl(intf: IUdrProcedureFactory): boolean;
	  property vTable: PUdrProcedureFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); virtual; abstract;
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure; virtual; abstract;
	end;

	PUdrTriggerFactoryVTable = ^UdrTriggerFactoryVTable;
	UdrTriggerFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrTriggerFactory_setupPtr;
	  newItem: IUdrTriggerFactory_newItemPtr;
	end;

	IUdrTriggerFactoryImpl = class;

	TUdrTriggerFactory = record
	private
	  FNullPtr: pointer;
	  FvTable: PUdrTriggerFactoryVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUdrTriggerFactory; inline;
	public
	  function isIUdrTriggerFactoryImpl: boolean;
	  function asIUdrTriggerFactoryImpl: IUdrTriggerFactoryImpl;
	  property vTable: PUdrTriggerFactoryVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder);
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger;
	end;

	IUdrTriggerFactoryImpl = class(IDisposableImpl)
	private
	  function getVTable: PUdrTriggerFactoryVTable;
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function asIUdrTriggerFactory: IUdrTriggerFactory;
	  class function isIUdrTriggerFactoryImpl(intf: IUdrTriggerFactory): boolean;
	  property vTable: PUdrTriggerFactoryVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder); virtual; abstract;
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger; virtual; abstract;
	end;

	PUdrPluginVTable = ^UdrPluginVTable;
	UdrPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getMaster: IUdrPlugin_getMasterPtr;
	  registerFunction: IUdrPlugin_registerFunctionPtr;
	  registerProcedure: IUdrPlugin_registerProcedurePtr;
	  registerTrigger: IUdrPlugin_registerTriggerPtr;
	end;

	IUdrPluginImpl = class;

	TUdrPlugin = record
	private
	  FNullPtr: pointer;
	  FvTable: PUdrPluginVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IUdrPlugin; inline;
	public
	  function isIUdrPluginImpl: boolean;
	  function asIUdrPluginImpl: IUdrPluginImpl;
	  property vTable: PUdrPluginVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getMaster(): IMaster;
	  procedure registerFunction(status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory);
	  procedure registerProcedure(status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory);
	  procedure registerTrigger(status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory);
	end;

	IUdrPluginImpl = class(IVersionedImpl)
	private
	  function getVTable: PUdrPluginVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIUdrPlugin: IUdrPlugin;
	  class function isIUdrPluginImpl(intf: IUdrPlugin): boolean;
	  property vTable: PUdrPluginVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getMaster(): IMaster; virtual; abstract;
	  procedure registerFunction(status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory); virtual; abstract;
	  procedure registerProcedure(status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory); virtual; abstract;
	  procedure registerTrigger(status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory); virtual; abstract;
	end;

	PDecFloat16VTable = ^DecFloat16VTable;
	DecFloat16VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toBcd: IDecFloat16_toBcdPtr;
	  toString: IDecFloat16_toStringPtr;
	  fromBcd: IDecFloat16_fromBcdPtr;
	  fromString: IDecFloat16_fromStringPtr;
	end;

	IDecFloat16Impl = class;

	TDecFloat16 = record
	private
	  FNullPtr: pointer;
	  FvTable: PDecFloat16VTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDecFloat16; inline;
	public
	  function isIDecFloat16Impl: boolean;
	  function asIDecFloat16Impl: IDecFloat16Impl;
	  property vTable: PDecFloat16VTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
	  procedure toString(status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr);
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr);
	end;

	IDecFloat16Impl = class(IVersionedImpl)
	private
	  function getVTable: PDecFloat16VTable;
	public
	  const VERSION = 4;
	  const BCD_SIZE = Cardinal(16);
	  const STRING_SIZE = Cardinal(24);
	public
	  constructor create;
	  function asIDecFloat16: IDecFloat16;
	  class function isIDecFloat16Impl(intf: IDecFloat16): boolean;
	  property vTable: PDecFloat16VTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); virtual; abstract;
	  procedure toString(status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); virtual; abstract;
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr); virtual; abstract;
	end;

	PDecFloat34VTable = ^DecFloat34VTable;
	DecFloat34VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toBcd: IDecFloat34_toBcdPtr;
	  toString: IDecFloat34_toStringPtr;
	  fromBcd: IDecFloat34_fromBcdPtr;
	  fromString: IDecFloat34_fromStringPtr;
	end;

	IDecFloat34Impl = class;

	TDecFloat34 = record
	private
	  FNullPtr: pointer;
	  FvTable: PDecFloat34VTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IDecFloat34; inline;
	public
	  function isIDecFloat34Impl: boolean;
	  function asIDecFloat34Impl: IDecFloat34Impl;
	  property vTable: PDecFloat34VTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
	  procedure toString(status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr);
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr);
	end;

	IDecFloat34Impl = class(IVersionedImpl)
	private
	  function getVTable: PDecFloat34VTable;
	public
	  const VERSION = 4;
	  const BCD_SIZE = Cardinal(34);
	  const STRING_SIZE = Cardinal(43);
	public
	  constructor create;
	  function asIDecFloat34: IDecFloat34;
	  class function isIDecFloat34Impl(intf: IDecFloat34): boolean;
	  property vTable: PDecFloat34VTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); virtual; abstract;
	  procedure toString(status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); virtual; abstract;
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr); virtual; abstract;
	end;

	PInt128VTable = ^Int128VTable;
	Int128VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toString: IInt128_toStringPtr;
	  fromString: IInt128_fromStringPtr;
	end;

	IInt128Impl = class;

	TInt128 = record
	private
	  FNullPtr: pointer;
	  FvTable: PInt128VTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IInt128; inline;
	public
	  function isIInt128Impl: boolean;
	  function asIInt128Impl: IInt128Impl;
	  property vTable: PInt128VTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure toString(status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromString(status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr);
	end;

	IInt128Impl = class(IVersionedImpl)
	private
	  function getVTable: PInt128VTable;
	public
	  const VERSION = 2;
	  const STRING_SIZE = Cardinal(46);
	public
	  constructor create;
	  function asIInt128: IInt128;
	  class function isIInt128Impl(intf: IInt128): boolean;
	  property vTable: PInt128VTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure toString(status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
	  procedure fromString(status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); virtual; abstract;
	end;

	PReplicatedFieldVTable = ^ReplicatedFieldVTable;
	ReplicatedFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getName: IReplicatedField_getNamePtr;
	  getType: IReplicatedField_getTypePtr;
	  getSubType: IReplicatedField_getSubTypePtr;
	  getScale: IReplicatedField_getScalePtr;
	  getLength: IReplicatedField_getLengthPtr;
	  getCharSet: IReplicatedField_getCharSetPtr;
	  getData: IReplicatedField_getDataPtr;
	end;

	IReplicatedFieldImpl = class;

	TReplicatedField = record
	private
	  FNullPtr: pointer;
	  FvTable: PReplicatedFieldVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IReplicatedField; inline;
	public
	  function isIReplicatedFieldImpl: boolean;
	  function asIReplicatedFieldImpl: IReplicatedFieldImpl;
	  property vTable: PReplicatedFieldVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getName(): PAnsiChar;
	  function getType(): Cardinal;
	  function getSubType(): Integer;
	  function getScale(): Integer;
	  function getLength(): Cardinal;
	  function getCharSet(): Cardinal;
	  function getData(): Pointer;
	end;

	IReplicatedFieldImpl = class(IVersionedImpl)
	private
	  function getVTable: PReplicatedFieldVTable;
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function asIReplicatedField: IReplicatedField;
	  class function isIReplicatedFieldImpl(intf: IReplicatedField): boolean;
	  property vTable: PReplicatedFieldVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getName(): PAnsiChar; virtual; abstract;
	  function getType(): Cardinal; virtual; abstract;
	  function getSubType(): Integer; virtual; abstract;
	  function getScale(): Integer; virtual; abstract;
	  function getLength(): Cardinal; virtual; abstract;
	  function getCharSet(): Cardinal; virtual; abstract;
	  function getData(): Pointer; virtual; abstract;
	end;

	PReplicatedRecordVTable = ^ReplicatedRecordVTable;
	ReplicatedRecordVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getCount: IReplicatedRecord_getCountPtr;
	  getField: IReplicatedRecord_getFieldPtr;
	  getRawLength: IReplicatedRecord_getRawLengthPtr;
	  getRawData: IReplicatedRecord_getRawDataPtr;
	end;

	IReplicatedRecordImpl = class;

	TReplicatedRecord = record
	private
	  FNullPtr: pointer;
	  FvTable: PReplicatedRecordVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IReplicatedRecord; inline;
	public
	  function isIReplicatedRecordImpl: boolean;
	  function asIReplicatedRecordImpl: IReplicatedRecordImpl;
	  property vTable: PReplicatedRecordVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  function getCount(): Cardinal;
	  function getField(index: Cardinal): IReplicatedField;
	  function getRawLength(): Cardinal;
	  function getRawData(): BytePtr;
	end;

	IReplicatedRecordImpl = class(IVersionedImpl)
	private
	  function getVTable: PReplicatedRecordVTable;
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function asIReplicatedRecord: IReplicatedRecord;
	  class function isIReplicatedRecordImpl(intf: IReplicatedRecord): boolean;
	  property vTable: PReplicatedRecordVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function getCount(): Cardinal; virtual; abstract;
	  function getField(index: Cardinal): IReplicatedField; virtual; abstract;
	  function getRawLength(): Cardinal; virtual; abstract;
	  function getRawData(): BytePtr; virtual; abstract;
	end;

	PReplicatedTransactionVTable = ^ReplicatedTransactionVTable;
	ReplicatedTransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  prepare: IReplicatedTransaction_preparePtr;
	  commit: IReplicatedTransaction_commitPtr;
	  rollback: IReplicatedTransaction_rollbackPtr;
	  startSavepoint: IReplicatedTransaction_startSavepointPtr;
	  releaseSavepoint: IReplicatedTransaction_releaseSavepointPtr;
	  rollbackSavepoint: IReplicatedTransaction_rollbackSavepointPtr;
	  insertRecord: IReplicatedTransaction_insertRecordPtr;
	  updateRecord: IReplicatedTransaction_updateRecordPtr;
	  deleteRecord: IReplicatedTransaction_deleteRecordPtr;
	  executeSql: IReplicatedTransaction_executeSqlPtr;
	  executeSqlIntl: IReplicatedTransaction_executeSqlIntlPtr;
	end;

	IReplicatedTransactionImpl = class;

	TReplicatedTransaction = record
	private
	  FNullPtr: pointer;
	  FvTable: PReplicatedTransactionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IReplicatedTransaction; inline;
	public
	  function isIReplicatedTransactionImpl: boolean;
	  function asIReplicatedTransactionImpl: IReplicatedTransactionImpl;
	  property vTable: PReplicatedTransactionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure prepare(status: IStatus);
	  procedure commit(status: IStatus);
	  procedure rollback(status: IStatus);
	  procedure startSavepoint(status: IStatus);
	  procedure releaseSavepoint(status: IStatus);
	  procedure rollbackSavepoint(status: IStatus);
	  procedure insertRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
	  procedure updateRecord(status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord);
	  procedure deleteRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
	  procedure executeSql(status: IStatus; sql: PAnsiChar);
	  procedure executeSqlIntl(status: IStatus; charset: Cardinal; sql: PAnsiChar);
	end;

	IReplicatedTransactionImpl = class(IDisposableImpl)
	private
	  function getVTable: PReplicatedTransactionVTable;
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function asIReplicatedTransaction: IReplicatedTransaction;
	  class function isIReplicatedTransactionImpl(intf: IReplicatedTransaction): boolean;
	  property vTable: PReplicatedTransactionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  procedure prepare(status: IStatus); virtual; abstract;
	  procedure commit(status: IStatus); virtual; abstract;
	  procedure rollback(status: IStatus); virtual; abstract;
	  procedure startSavepoint(status: IStatus); virtual; abstract;
	  procedure releaseSavepoint(status: IStatus); virtual; abstract;
	  procedure rollbackSavepoint(status: IStatus); virtual; abstract;
	  procedure insertRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); virtual; abstract;
	  procedure updateRecord(status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord); virtual; abstract;
	  procedure deleteRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); virtual; abstract;
	  procedure executeSql(status: IStatus; sql: PAnsiChar); virtual; abstract;
	  procedure executeSqlIntl(status: IStatus; charset: Cardinal; sql: PAnsiChar); virtual; abstract;
	end;

	PReplicatedSessionVTable = ^ReplicatedSessionVTable;
	ReplicatedSessionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  init: IReplicatedSession_initPtr;
	  startTransaction: IReplicatedSession_startTransactionPtr;
	  cleanupTransaction: IReplicatedSession_cleanupTransactionPtr;
	  setSequence: IReplicatedSession_setSequencePtr;
	end;

	IReplicatedSessionImpl = class;

	TReplicatedSession = record
	private
	  FNullPtr: pointer;
	  FvTable: PReplicatedSessionVTable;
	  FObject: TObject; {Only valid when interface provided by an implementation class }
	  function this: IReplicatedSession; inline;
	public
	  function isIReplicatedSessionImpl: boolean;
	  function asIReplicatedSessionImpl: IReplicatedSessionImpl;
	  property vTable: PReplicatedSessionVTable read FvTable;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function init(status: IStatus; attachment: IAttachment): Boolean;
	  function startTransaction(status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction;
	  procedure cleanupTransaction(status: IStatus; number: Int64);
	  procedure setSequence(status: IStatus; name: PAnsiChar; value: Int64);
	end;

	IReplicatedSessionImpl = class(IPluginBaseImpl)
	private
	  function getVTable: PReplicatedSessionVTable;
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function asIReplicatedSession: IReplicatedSession;
	  class function isIReplicatedSessionImpl(intf: IReplicatedSession): boolean;
	  property vTable: PReplicatedSessionVTable read getVTable;
	public
	  {Firebird OOAPI interface}
	  function init(status: IStatus; attachment: IAttachment): Boolean; virtual; abstract;
	  function startTransaction(status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction; virtual; abstract;
	  procedure cleanupTransaction(status: IStatus; number: Int64); virtual; abstract;
	  procedure setSequence(status: IStatus; name: PAnsiChar; value: Int64); virtual; abstract;
	end;


{$IFDEF STATIC_LINK_TO_FIREBIRD_LIBRARY}
function fb_get_master_interface : IMaster; {$IFDEF WINDOWS} stdcall; {$ELSE} cdecl; {$ENDIF}; external 'fbclient';
{$ELSE}
type
    Tfb_get_master_interface = function: IMaster
                              {$IFDEF WINDOWS} stdcall; {$ELSE} cdecl; {$ENDIF}
{$ENDIF}
                              

implementation

resourcestring
	errNotImplementationObject = 'interface is not an implementation of %s';

function TVersioned.this: IVersioned;
begin
  Result := IVersioned(@FNullPtr);
end;

function TVersioned.isIVersionedImpl: boolean;
begin
  Result := IVersionedImpl.isIVersionedImpl(this);
end;

function TVersioned.asIVersionedImpl: IVersionedImpl;
begin
  if isIVersionedImpl then
    Result := FObject as IVersionedImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IVersionedImpl']);
end;

function TReferenceCounted.this: IReferenceCounted;
begin
  Result := IReferenceCounted(@FNullPtr);
end;

function TReferenceCounted.isIReferenceCountedImpl: boolean;
begin
  Result := IReferenceCountedImpl.isIReferenceCountedImpl(this);
end;

function TReferenceCounted.asIReferenceCountedImpl: IReferenceCountedImpl;
begin
  if isIReferenceCountedImpl then
    Result := FObject as IReferenceCountedImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IReferenceCountedImpl']);
end;

procedure TReferenceCounted.addRef();
begin
	vTable^.addRef(this);
end;

function TReferenceCounted.release(): Integer;
begin
	Result := vTable^.release(this);
end;

function TDisposable.this: IDisposable;
begin
  Result := IDisposable(@FNullPtr);
end;

function TDisposable.isIDisposableImpl: boolean;
begin
  Result := IDisposableImpl.isIDisposableImpl(this);
end;

function TDisposable.asIDisposableImpl: IDisposableImpl;
begin
  if isIDisposableImpl then
    Result := FObject as IDisposableImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDisposableImpl']);
end;

procedure TDisposable.dispose();
begin
	vTable^.dispose(this);
end;

function TStatus.this: IStatus;
begin
  Result := IStatus(@FNullPtr);
end;

function TStatus.isIStatusImpl: boolean;
begin
  Result := IStatusImpl.isIStatusImpl(this);
end;

function TStatus.asIStatusImpl: IStatusImpl;
begin
  if isIStatusImpl then
    Result := FObject as IStatusImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IStatusImpl']);
end;

procedure TStatus.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TStatus.init();
begin
	vTable^.init(this);
end;

function TStatus.getState(): Cardinal;
begin
	Result := vTable^.getState(this);
end;

procedure TStatus.setErrors2(length: Cardinal; value: NativeIntPtr);
begin
	vTable^.setErrors2(this, length, value);
end;

procedure TStatus.setWarnings2(length: Cardinal; value: NativeIntPtr);
begin
	vTable^.setWarnings2(this, length, value);
end;

procedure TStatus.setErrors(value: NativeIntPtr);
begin
	vTable^.setErrors(this, value);
end;

procedure TStatus.setWarnings(value: NativeIntPtr);
begin
	vTable^.setWarnings(this, value);
end;

function TStatus.getErrors(): NativeIntPtr;
begin
	Result := vTable^.getErrors(this);
end;

function TStatus.getWarnings(): NativeIntPtr;
begin
	Result := vTable^.getWarnings(this);
end;

function TStatus.clone(): IStatus;
begin
	Result := vTable^.clone(this);
end;

function TMaster.this: IMaster;
begin
  Result := IMaster(@FNullPtr);
end;

function TMaster.isIMasterImpl: boolean;
begin
  Result := IMasterImpl.isIMasterImpl(this);
end;

function TMaster.asIMasterImpl: IMasterImpl;
begin
  if isIMasterImpl then
    Result := FObject as IMasterImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IMasterImpl']);
end;

function TMaster.getStatus(): IStatus;
begin
	Result := vTable^.getStatus(this);
end;

function TMaster.getDispatcher(): IProvider;
begin
	Result := vTable^.getDispatcher(this);
end;

function TMaster.getPluginManager(): IPluginManager;
begin
	Result := vTable^.getPluginManager(this);
end;

function TMaster.getTimerControl(): ITimerControl;
begin
	Result := vTable^.getTimerControl(this);
end;

function TMaster.getDtc(): IDtc;
begin
	Result := vTable^.getDtc(this);
end;

function TMaster.registerAttachment(provider: IProvider; attachment: IAttachment): IAttachment;
begin
	Result := vTable^.registerAttachment(this, provider, attachment);
end;

function TMaster.registerTransaction(attachment: IAttachment; transaction: ITransaction): ITransaction;
begin
	Result := vTable^.registerTransaction(this, attachment, transaction);
end;

function TMaster.getMetadataBuilder(status: IStatus; fieldCount: Cardinal): IMetadataBuilder;
begin
	Result := vTable^.getMetadataBuilder(this, status, fieldCount);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMaster.serverMode(mode: Integer): Integer;
begin
	Result := vTable^.serverMode(this, mode);
end;

function TMaster.getUtilInterface(): IUtil;
begin
	Result := vTable^.getUtilInterface(this);
end;

function TMaster.getConfigManager(): IConfigManager;
begin
	Result := vTable^.getConfigManager(this);
end;

function TMaster.getProcessExiting(): Boolean;
begin
	Result := vTable^.getProcessExiting(this);
end;

function TPluginBase.this: IPluginBase;
begin
  Result := IPluginBase(@FNullPtr);
end;

function TPluginBase.isIPluginBaseImpl: boolean;
begin
  Result := IPluginBaseImpl.isIPluginBaseImpl(this);
end;

function TPluginBase.asIPluginBaseImpl: IPluginBaseImpl;
begin
  if isIPluginBaseImpl then
    Result := FObject as IPluginBaseImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IPluginBaseImpl']);
end;

procedure TPluginBase.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TPluginBase.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TPluginBase.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(this, r);
end;

function TPluginBase.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(this);
end;

function TPluginSet.this: IPluginSet;
begin
  Result := IPluginSet(@FNullPtr);
end;

function TPluginSet.isIPluginSetImpl: boolean;
begin
  Result := IPluginSetImpl.isIPluginSetImpl(this);
end;

function TPluginSet.asIPluginSetImpl: IPluginSetImpl;
begin
  if isIPluginSetImpl then
    Result := FObject as IPluginSetImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IPluginSetImpl']);
end;

procedure TPluginSet.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TPluginSet.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TPluginSet.getName(): PAnsiChar;
begin
	Result := vTable^.getName(this);
end;

function TPluginSet.getModuleName(): PAnsiChar;
begin
	Result := vTable^.getModuleName(this);
end;

function TPluginSet.getPlugin(status: IStatus): IPluginBase;
begin
	Result := vTable^.getPlugin(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginSet.next(status: IStatus);
begin
	vTable^.next(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginSet.set_(status: IStatus; s: PAnsiChar);
begin
	vTable^.set_(this, status, s);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfigEntry.this: IConfigEntry;
begin
  Result := IConfigEntry(@FNullPtr);
end;

function TConfigEntry.isIConfigEntryImpl: boolean;
begin
  Result := IConfigEntryImpl.isIConfigEntryImpl(this);
end;

function TConfigEntry.asIConfigEntryImpl: IConfigEntryImpl;
begin
  if isIConfigEntryImpl then
    Result := FObject as IConfigEntryImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IConfigEntryImpl']);
end;

procedure TConfigEntry.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TConfigEntry.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TConfigEntry.getName(): PAnsiChar;
begin
	Result := vTable^.getName(this);
end;

function TConfigEntry.getValue(): PAnsiChar;
begin
	Result := vTable^.getValue(this);
end;

function TConfigEntry.getIntValue(): Int64;
begin
	Result := vTable^.getIntValue(this);
end;

function TConfigEntry.getBoolValue(): Boolean;
begin
	Result := vTable^.getBoolValue(this);
end;

function TConfigEntry.getSubConfig(status: IStatus): IConfig;
begin
	Result := vTable^.getSubConfig(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfig.this: IConfig;
begin
  Result := IConfig(@FNullPtr);
end;

function TConfig.isIConfigImpl: boolean;
begin
  Result := IConfigImpl.isIConfigImpl(this);
end;

function TConfig.asIConfigImpl: IConfigImpl;
begin
  if isIConfigImpl then
    Result := FObject as IConfigImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IConfigImpl']);
end;

procedure TConfig.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TConfig.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TConfig.find(status: IStatus; name: PAnsiChar): IConfigEntry;
begin
	Result := vTable^.find(this, status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfig.findValue(status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry;
begin
	Result := vTable^.findValue(this, status, name, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfig.findPos(status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry;
begin
	Result := vTable^.findPos(this, status, name, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TFirebirdConf.this: IFirebirdConf;
begin
  Result := IFirebirdConf(@FNullPtr);
end;

function TFirebirdConf.isIFirebirdConfImpl: boolean;
begin
  Result := IFirebirdConfImpl.isIFirebirdConfImpl(this);
end;

function TFirebirdConf.asIFirebirdConfImpl: IFirebirdConfImpl;
begin
  if isIFirebirdConfImpl then
    Result := FObject as IFirebirdConfImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IFirebirdConfImpl']);
end;

procedure TFirebirdConf.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TFirebirdConf.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TFirebirdConf.getKey(name: PAnsiChar): Cardinal;
begin
	Result := vTable^.getKey(this, name);
end;

function TFirebirdConf.asInteger(key: Cardinal): Int64;
begin
	Result := vTable^.asInteger(this, key);
end;

function TFirebirdConf.asString(key: Cardinal): PAnsiChar;
begin
	Result := vTable^.asString(this, key);
end;

function TFirebirdConf.asBoolean(key: Cardinal): Boolean;
begin
	Result := vTable^.asBoolean(this, key);
end;

function TFirebirdConf.getVersion(status: IStatus): Cardinal;
begin
	Result := vTable^.getVersion(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginConfig.this: IPluginConfig;
begin
  Result := IPluginConfig(@FNullPtr);
end;

function TPluginConfig.isIPluginConfigImpl: boolean;
begin
  Result := IPluginConfigImpl.isIPluginConfigImpl(this);
end;

function TPluginConfig.asIPluginConfigImpl: IPluginConfigImpl;
begin
  if isIPluginConfigImpl then
    Result := FObject as IPluginConfigImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IPluginConfigImpl']);
end;

procedure TPluginConfig.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TPluginConfig.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TPluginConfig.getConfigFileName(): PAnsiChar;
begin
	Result := vTable^.getConfigFileName(this);
end;

function TPluginConfig.getDefaultConfig(status: IStatus): IConfig;
begin
	Result := vTable^.getDefaultConfig(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginConfig.getFirebirdConf(status: IStatus): IFirebirdConf;
begin
	Result := vTable^.getFirebirdConf(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginConfig.setReleaseDelay(status: IStatus; microSeconds: QWord);
begin
	vTable^.setReleaseDelay(this, status, microSeconds);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginFactory.this: IPluginFactory;
begin
  Result := IPluginFactory(@FNullPtr);
end;

function TPluginFactory.isIPluginFactoryImpl: boolean;
begin
  Result := IPluginFactoryImpl.isIPluginFactoryImpl(this);
end;

function TPluginFactory.asIPluginFactoryImpl: IPluginFactoryImpl;
begin
  if isIPluginFactoryImpl then
    Result := FObject as IPluginFactoryImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IPluginFactoryImpl']);
end;

function TPluginFactory.createPlugin(status: IStatus; factoryParameter: IPluginConfig): IPluginBase;
begin
	Result := vTable^.createPlugin(this, status, factoryParameter);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginModule.this: IPluginModule;
begin
  Result := IPluginModule(@FNullPtr);
end;

function TPluginModule.isIPluginModuleImpl: boolean;
begin
  Result := IPluginModuleImpl.isIPluginModuleImpl(this);
end;

function TPluginModule.asIPluginModuleImpl: IPluginModuleImpl;
begin
  if isIPluginModuleImpl then
    Result := FObject as IPluginModuleImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IPluginModuleImpl']);
end;

procedure TPluginModule.doClean();
begin
	vTable^.doClean(this);
end;

procedure TPluginModule.threadDetach();
begin
	vTable^.threadDetach(this);
end;

function TPluginManager.this: IPluginManager;
begin
  Result := IPluginManager(@FNullPtr);
end;

function TPluginManager.isIPluginManagerImpl: boolean;
begin
  Result := IPluginManagerImpl.isIPluginManagerImpl(this);
end;

function TPluginManager.asIPluginManagerImpl: IPluginManagerImpl;
begin
  if isIPluginManagerImpl then
    Result := FObject as IPluginManagerImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IPluginManagerImpl']);
end;

procedure TPluginManager.registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory);
begin
	vTable^.registerPluginFactory(this, pluginType, defaultName, factory);
end;

procedure TPluginManager.registerModule(cleanup: IPluginModule);
begin
	vTable^.registerModule(this, cleanup);
end;

procedure TPluginManager.unregisterModule(cleanup: IPluginModule);
begin
	vTable^.unregisterModule(this, cleanup);
end;

function TPluginManager.getPlugins(status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet;
begin
	Result := vTable^.getPlugins(this, status, pluginType, namesList, firebirdConf);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginManager.getConfig(status: IStatus; filename: PAnsiChar): IConfig;
begin
	Result := vTable^.getConfig(this, status, filename);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginManager.releasePlugin(plugin: IPluginBase);
begin
	vTable^.releasePlugin(this, plugin);
end;

function TCryptKey.this: ICryptKey;
begin
  Result := ICryptKey(@FNullPtr);
end;

function TCryptKey.isICryptKeyImpl: boolean;
begin
  Result := ICryptKeyImpl.isICryptKeyImpl(this);
end;

function TCryptKey.asICryptKeyImpl: ICryptKeyImpl;
begin
  if isICryptKeyImpl then
    Result := FObject as ICryptKeyImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ICryptKeyImpl']);
end;

procedure TCryptKey.setSymmetric(status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer);
begin
	vTable^.setSymmetric(this, status, type_, keyLength, key);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TCryptKey.setAsymmetric(status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer);
begin
	vTable^.setAsymmetric(this, status, type_, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCryptKey.getEncryptKey(length: CardinalPtr): Pointer;
begin
	Result := vTable^.getEncryptKey(this, length);
end;

function TCryptKey.getDecryptKey(length: CardinalPtr): Pointer;
begin
	Result := vTable^.getDecryptKey(this, length);
end;

function TConfigManager.this: IConfigManager;
begin
  Result := IConfigManager(@FNullPtr);
end;

function TConfigManager.isIConfigManagerImpl: boolean;
begin
  Result := IConfigManagerImpl.isIConfigManagerImpl(this);
end;

function TConfigManager.asIConfigManagerImpl: IConfigManagerImpl;
begin
  if isIConfigManagerImpl then
    Result := FObject as IConfigManagerImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IConfigManagerImpl']);
end;

function TConfigManager.getDirectory(code: Cardinal): PAnsiChar;
begin
	Result := vTable^.getDirectory(this, code);
end;

function TConfigManager.getFirebirdConf(): IFirebirdConf;
begin
	Result := vTable^.getFirebirdConf(this);
end;

function TConfigManager.getDatabaseConf(dbName: PAnsiChar): IFirebirdConf;
begin
	Result := vTable^.getDatabaseConf(this, dbName);
end;

function TConfigManager.getPluginConfig(configuredPlugin: PAnsiChar): IConfig;
begin
	Result := vTable^.getPluginConfig(this, configuredPlugin);
end;

function TConfigManager.getInstallDirectory(): PAnsiChar;
begin
	Result := vTable^.getInstallDirectory(this);
end;

function TConfigManager.getRootDirectory(): PAnsiChar;
begin
	Result := vTable^.getRootDirectory(this);
end;

function TConfigManager.getDefaultSecurityDb(): PAnsiChar;
begin
	Result := vTable^.getDefaultSecurityDb(this);
end;

function TEventCallback.this: IEventCallback;
begin
  Result := IEventCallback(@FNullPtr);
end;

function TEventCallback.isIEventCallbackImpl: boolean;
begin
  Result := IEventCallbackImpl.isIEventCallbackImpl(this);
end;

function TEventCallback.asIEventCallbackImpl: IEventCallbackImpl;
begin
  if isIEventCallbackImpl then
    Result := FObject as IEventCallbackImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IEventCallbackImpl']);
end;

procedure TEventCallback.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TEventCallback.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TEventCallback.eventCallbackFunction(length: Cardinal; events: BytePtr);
begin
	vTable^.eventCallbackFunction(this, length, events);
end;

function TBlob.this: IBlob;
begin
  Result := IBlob(@FNullPtr);
end;

function TBlob.isIBlobImpl: boolean;
begin
  Result := IBlobImpl.isIBlobImpl(this);
end;

function TBlob.asIBlobImpl: IBlobImpl;
begin
  if isIBlobImpl then
    Result := FObject as IBlobImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IBlobImpl']);
end;

procedure TBlob.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TBlob.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TBlob.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(this, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBlob.getSegment(status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer;
begin
	Result := vTable^.getSegment(this, status, bufferLength, buffer, segmentLength);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBlob.putSegment(status: IStatus; length: Cardinal; buffer: Pointer);
begin
	vTable^.putSegment(this, status, length, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBlob.cancel(status: IStatus);
begin
	vTable^.cancel(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBlob.close(status: IStatus);
begin
	vTable^.close(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBlob.seek(status: IStatus; mode: Integer; offset: Integer): Integer;
begin
	Result := vTable^.seek(this, status, mode, offset);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.this: ITransaction;
begin
  Result := ITransaction(@FNullPtr);
end;

function TTransaction.isITransactionImpl: boolean;
begin
  Result := ITransactionImpl.isITransactionImpl(this);
end;

function TTransaction.asITransactionImpl: ITransactionImpl;
begin
  if isITransactionImpl then
    Result := FObject as ITransactionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITransactionImpl']);
end;

procedure TTransaction.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TTransaction.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TTransaction.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(this, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.prepare(status: IStatus; msgLength: Cardinal; message: BytePtr);
begin
	vTable^.prepare(this, status, msgLength, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.commit(status: IStatus);
begin
	vTable^.commit(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.commitRetaining(status: IStatus);
begin
	vTable^.commitRetaining(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.rollback(status: IStatus);
begin
	vTable^.rollback(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.rollbackRetaining(status: IStatus);
begin
	vTable^.rollbackRetaining(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.disconnect(status: IStatus);
begin
	vTable^.disconnect(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.join(status: IStatus; transaction: ITransaction): ITransaction;
begin
	Result := vTable^.join(this, status, transaction);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.validate(status: IStatus; attachment: IAttachment): ITransaction;
begin
	Result := vTable^.validate(this, status, attachment);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.enterDtc(status: IStatus): ITransaction;
begin
	Result := vTable^.enterDtc(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.this: IMessageMetadata;
begin
  Result := IMessageMetadata(@FNullPtr);
end;

function TMessageMetadata.isIMessageMetadataImpl: boolean;
begin
  Result := IMessageMetadataImpl.isIMessageMetadataImpl(this);
end;

function TMessageMetadata.asIMessageMetadataImpl: IMessageMetadataImpl;
begin
  if isIMessageMetadataImpl then
    Result := FObject as IMessageMetadataImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IMessageMetadataImpl']);
end;

procedure TMessageMetadata.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TMessageMetadata.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TMessageMetadata.getCount(status: IStatus): Cardinal;
begin
	Result := vTable^.getCount(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getField(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getField(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getRelation(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getRelation(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getOwner(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getOwner(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getAlias(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getAlias(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getType(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getType(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.isNullable(status: IStatus; index: Cardinal): Boolean;
begin
	Result := vTable^.isNullable(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getSubType(status: IStatus; index: Cardinal): Integer;
begin
	Result := vTable^.getSubType(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getLength(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getLength(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getScale(status: IStatus; index: Cardinal): Integer;
begin
	Result := vTable^.getScale(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getCharSet(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getCharSet(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getOffset(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getOffset(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getNullOffset(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getNullOffset(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getBuilder(status: IStatus): IMetadataBuilder;
begin
	Result := vTable^.getBuilder(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getMessageLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getMessageLength(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getAlignment(status: IStatus): Cardinal;
begin
	Result := vTable^.getAlignment(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getAlignedLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getAlignedLength(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMetadataBuilder.this: IMetadataBuilder;
begin
  Result := IMetadataBuilder(@FNullPtr);
end;

function TMetadataBuilder.isIMetadataBuilderImpl: boolean;
begin
  Result := IMetadataBuilderImpl.isIMetadataBuilderImpl(this);
end;

function TMetadataBuilder.asIMetadataBuilderImpl: IMetadataBuilderImpl;
begin
  if isIMetadataBuilderImpl then
    Result := FObject as IMetadataBuilderImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IMetadataBuilderImpl']);
end;

procedure TMetadataBuilder.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TMetadataBuilder.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TMetadataBuilder.setType(status: IStatus; index: Cardinal; type_: Cardinal);
begin
	vTable^.setType(this, status, index, type_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setSubType(status: IStatus; index: Cardinal; subType: Integer);
begin
	vTable^.setSubType(this, status, index, subType);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setLength(status: IStatus; index: Cardinal; length: Cardinal);
begin
	vTable^.setLength(this, status, index, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setCharSet(status: IStatus; index: Cardinal; charSet: Cardinal);
begin
	vTable^.setCharSet(this, status, index, charSet);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setScale(status: IStatus; index: Cardinal; scale: Integer);
begin
	vTable^.setScale(this, status, index, scale);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.truncate(status: IStatus; count: Cardinal);
begin
	vTable^.truncate(this, status, count);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.moveNameToIndex(status: IStatus; name: PAnsiChar; index: Cardinal);
begin
	vTable^.moveNameToIndex(this, status, name, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.remove(status: IStatus; index: Cardinal);
begin
	vTable^.remove(this, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMetadataBuilder.addField(status: IStatus): Cardinal;
begin
	Result := vTable^.addField(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMetadataBuilder.getMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setField(status: IStatus; index: Cardinal; field: PAnsiChar);
begin
	vTable^.setField(this, status, index, field);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setRelation(status: IStatus; index: Cardinal; relation: PAnsiChar);
begin
	vTable^.setRelation(this, status, index, relation);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setOwner(status: IStatus; index: Cardinal; owner: PAnsiChar);
begin
	vTable^.setOwner(this, status, index, owner);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setAlias(status: IStatus; index: Cardinal; alias: PAnsiChar);
begin
	vTable^.setAlias(this, status, index, alias);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.this: IResultSet;
begin
  Result := IResultSet(@FNullPtr);
end;

function TResultSet.isIResultSetImpl: boolean;
begin
  Result := IResultSetImpl.isIResultSetImpl(this);
end;

function TResultSet.asIResultSetImpl: IResultSetImpl;
begin
  if isIResultSetImpl then
    Result := FObject as IResultSetImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IResultSetImpl']);
end;

procedure TResultSet.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TResultSet.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TResultSet.fetchNext(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchNext(this, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchPrior(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchPrior(this, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchFirst(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchFirst(this, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchLast(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchLast(this, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchAbsolute(status: IStatus; position: Integer; message: Pointer): Integer;
begin
	Result := vTable^.fetchAbsolute(this, status, position, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchRelative(status: IStatus; offset: Integer; message: Pointer): Integer;
begin
	Result := vTable^.fetchRelative(this, status, offset, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.isEof(status: IStatus): Boolean;
begin
	Result := vTable^.isEof(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.isBof(status: IStatus): Boolean;
begin
	Result := vTable^.isBof(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.getMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TResultSet.close(status: IStatus);
begin
	vTable^.close(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TResultSet.setDelayedOutputFormat(status: IStatus; format: IMessageMetadata);
begin
	vTable^.setDelayedOutputFormat(this, status, format);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.this: IStatement;
begin
  Result := IStatement(@FNullPtr);
end;

function TStatement.isIStatementImpl: boolean;
begin
  Result := IStatementImpl.isIStatementImpl(this);
end;

function TStatement.asIStatementImpl: IStatementImpl;
begin
  if isIStatementImpl then
    Result := FObject as IStatementImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IStatementImpl']);
end;

procedure TStatement.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TStatement.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TStatement.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(this, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getType(status: IStatus): Cardinal;
begin
	Result := vTable^.getType(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getPlan(status: IStatus; detailed: Boolean): PAnsiChar;
begin
	Result := vTable^.getPlan(this, status, detailed);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getAffectedRecords(status: IStatus): QWord;
begin
	Result := vTable^.getAffectedRecords(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getInputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getInputMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getOutputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getOutputMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.execute(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
begin
	Result := vTable^.execute(this, status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.openCursor(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet;
begin
	Result := vTable^.openCursor(this, status, transaction, inMetadata, inBuffer, outMetadata, flags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TStatement.setCursorName(status: IStatus; name: PAnsiChar);
begin
	vTable^.setCursorName(this, status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TStatement.free(status: IStatus);
begin
	vTable^.free(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getFlags(status: IStatus): Cardinal;
begin
	Result := vTable^.getFlags(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getTimeout(status: IStatus): Cardinal;
begin
	Result := vTable^.getTimeout(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TStatement.setTimeout(status: IStatus; timeOut: Cardinal);
begin
	vTable^.setTimeout(this, status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.createBatch(status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
begin
	Result := vTable^.createBatch(this, status, inMetadata, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.this: IBatch;
begin
  Result := IBatch(@FNullPtr);
end;

function TBatch.isIBatchImpl: boolean;
begin
  Result := IBatchImpl.isIBatchImpl(this);
end;

function TBatch.asIBatchImpl: IBatchImpl;
begin
  if isIBatchImpl then
    Result := FObject as IBatchImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IBatchImpl']);
end;

procedure TBatch.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TBatch.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TBatch.add(status: IStatus; count: Cardinal; inBuffer: Pointer);
begin
	vTable^.add(this, status, count, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.addBlob(status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr);
begin
	vTable^.addBlob(this, status, length, inBuffer, blobId, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.appendBlobData(status: IStatus; length: Cardinal; inBuffer: Pointer);
begin
	vTable^.appendBlobData(this, status, length, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.addBlobStream(status: IStatus; length: Cardinal; inBuffer: Pointer);
begin
	vTable^.addBlobStream(this, status, length, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.registerBlob(status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr);
begin
	vTable^.registerBlob(this, status, existingBlob, blobId);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.execute(status: IStatus; transaction: ITransaction): IBatchCompletionState;
begin
	Result := vTable^.execute(this, status, transaction);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.cancel(status: IStatus);
begin
	vTable^.cancel(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.getBlobAlignment(status: IStatus): Cardinal;
begin
	Result := vTable^.getBlobAlignment(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.getMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.setDefaultBpb(status: IStatus; parLength: Cardinal; par: BytePtr);
begin
	vTable^.setDefaultBpb(this, status, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.close(status: IStatus);
begin
	vTable^.close(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatchCompletionState.this: IBatchCompletionState;
begin
  Result := IBatchCompletionState(@FNullPtr);
end;

function TBatchCompletionState.isIBatchCompletionStateImpl: boolean;
begin
  Result := IBatchCompletionStateImpl.isIBatchCompletionStateImpl(this);
end;

function TBatchCompletionState.asIBatchCompletionStateImpl: IBatchCompletionStateImpl;
begin
  if isIBatchCompletionStateImpl then
    Result := FObject as IBatchCompletionStateImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IBatchCompletionStateImpl']);
end;

procedure TBatchCompletionState.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

function TBatchCompletionState.getSize(status: IStatus): Cardinal;
begin
	Result := vTable^.getSize(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatchCompletionState.getState(status: IStatus; pos: Cardinal): Integer;
begin
	Result := vTable^.getState(this, status, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatchCompletionState.findError(status: IStatus; pos: Cardinal): Cardinal;
begin
	Result := vTable^.findError(this, status, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatchCompletionState.getStatus(status: IStatus; to_: IStatus; pos: Cardinal);
begin
	vTable^.getStatus(this, status, to_, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicator.this: IReplicator;
begin
  Result := IReplicator(@FNullPtr);
end;

function TReplicator.isIReplicatorImpl: boolean;
begin
  Result := IReplicatorImpl.isIReplicatorImpl(this);
end;

function TReplicator.asIReplicatorImpl: IReplicatorImpl;
begin
  if isIReplicatorImpl then
    Result := FObject as IReplicatorImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IReplicatorImpl']);
end;

procedure TReplicator.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TReplicator.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TReplicator.process(status: IStatus; length: Cardinal; data: BytePtr);
begin
	vTable^.process(this, status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicator.close(status: IStatus);
begin
	vTable^.close(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRequest.this: IRequest;
begin
  Result := IRequest(@FNullPtr);
end;

function TRequest.isIRequestImpl: boolean;
begin
  Result := IRequestImpl.isIRequestImpl(this);
end;

function TRequest.asIRequestImpl: IRequestImpl;
begin
  if isIRequestImpl then
    Result := FObject as IRequestImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IRequestImpl']);
end;

procedure TRequest.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TRequest.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TRequest.receive(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.receive(this, status, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.send(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.send(this, status, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.getInfo(status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(this, status, level, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.start(status: IStatus; tra: ITransaction; level: Integer);
begin
	vTable^.start(this, status, tra, level);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.startAndSend(status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.startAndSend(this, status, tra, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.unwind(status: IStatus; level: Integer);
begin
	vTable^.unwind(this, status, level);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.free(status: IStatus);
begin
	vTable^.free(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TEvents.this: IEvents;
begin
  Result := IEvents(@FNullPtr);
end;

function TEvents.isIEventsImpl: boolean;
begin
  Result := IEventsImpl.isIEventsImpl(this);
end;

function TEvents.asIEventsImpl: IEventsImpl;
begin
  if isIEventsImpl then
    Result := FObject as IEventsImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IEventsImpl']);
end;

procedure TEvents.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TEvents.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TEvents.cancel(status: IStatus);
begin
	vTable^.cancel(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.this: IAttachment;
begin
  Result := IAttachment(@FNullPtr);
end;

function TAttachment.isIAttachmentImpl: boolean;
begin
  Result := IAttachmentImpl.isIAttachmentImpl(this);
end;

function TAttachment.asIAttachmentImpl: IAttachmentImpl;
begin
  if isIAttachmentImpl then
    Result := FObject as IAttachmentImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IAttachmentImpl']);
end;

procedure TAttachment.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TAttachment.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TAttachment.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(this, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.startTransaction(status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction;
begin
	Result := vTable^.startTransaction(this, status, tpbLength, tpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.reconnectTransaction(status: IStatus; length: Cardinal; id: BytePtr): ITransaction;
begin
	Result := vTable^.reconnectTransaction(this, status, length, id);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.compileRequest(status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest;
begin
	Result := vTable^.compileRequest(this, status, blrLength, blr);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.transactRequest(status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr);
begin
	vTable^.transactRequest(this, status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.createBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
begin
	Result := vTable^.createBlob(this, status, transaction, id, bpbLength, bpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.openBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
begin
	Result := vTable^.openBlob(this, status, transaction, id, bpbLength, bpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.getSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer;
begin
	Result := vTable^.getSlice(this, status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.putSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr);
begin
	vTable^.putSlice(this, status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.executeDyn(status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr);
begin
	vTable^.executeDyn(this, status, transaction, length, dyn);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.prepare(status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement;
begin
	Result := vTable^.prepare(this, status, tra, stmtLength, sqlStmt, dialect, flags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.execute(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
begin
	Result := vTable^.execute(this, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.openCursor(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet;
begin
	Result := vTable^.openCursor(this, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.queEvents(status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents;
begin
	Result := vTable^.queEvents(this, status, callback, length, events);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.cancelOperation(status: IStatus; option: Integer);
begin
	vTable^.cancelOperation(this, status, option);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.ping(status: IStatus);
begin
	vTable^.ping(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.detach(status: IStatus);
begin
	vTable^.detach(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.dropDatabase(status: IStatus);
begin
	vTable^.dropDatabase(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.getIdleTimeout(status: IStatus): Cardinal;
begin
	Result := vTable^.getIdleTimeout(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.setIdleTimeout(status: IStatus; timeOut: Cardinal);
begin
	vTable^.setIdleTimeout(this, status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.getStatementTimeout(status: IStatus): Cardinal;
begin
	Result := vTable^.getStatementTimeout(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.setStatementTimeout(status: IStatus; timeOut: Cardinal);
begin
	vTable^.setStatementTimeout(this, status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.createBatch(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
begin
	Result := vTable^.createBatch(this, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.createReplicator(status: IStatus): IReplicator;
begin
	Result := vTable^.createReplicator(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TService.this: IService;
begin
  Result := IService(@FNullPtr);
end;

function TService.isIServiceImpl: boolean;
begin
  Result := IServiceImpl.isIServiceImpl(this);
end;

function TService.asIServiceImpl: IServiceImpl;
begin
  if isIServiceImpl then
    Result := FObject as IServiceImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IServiceImpl']);
end;

procedure TService.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TService.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TService.detach(status: IStatus);
begin
	vTable^.detach(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TService.query(status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.query(this, status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TService.start(status: IStatus; spbLength: Cardinal; spb: BytePtr);
begin
	vTable^.start(this, status, spbLength, spb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TProvider.this: IProvider;
begin
  Result := IProvider(@FNullPtr);
end;

function TProvider.isIProviderImpl: boolean;
begin
  Result := IProviderImpl.isIProviderImpl(this);
end;

function TProvider.asIProviderImpl: IProviderImpl;
begin
  if isIProviderImpl then
    Result := FObject as IProviderImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IProviderImpl']);
end;

procedure TProvider.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TProvider.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TProvider.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TProvider.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TProvider.attachDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
begin
	Result := vTable^.attachDatabase(this, status, fileName, dpbLength, dpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TProvider.createDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
begin
	Result := vTable^.createDatabase(this, status, fileName, dpbLength, dpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TProvider.attachServiceManager(status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService;
begin
	Result := vTable^.attachServiceManager(this, status, service, spbLength, spb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TProvider.shutdown(status: IStatus; timeout: Cardinal; reason: Integer);
begin
	vTable^.shutdown(this, status, timeout, reason);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TProvider.setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
begin
	vTable^.setDbCryptCallback(this, status, cryptCallback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtcStart.this: IDtcStart;
begin
  Result := IDtcStart(@FNullPtr);
end;

function TDtcStart.isIDtcStartImpl: boolean;
begin
  Result := IDtcStartImpl.isIDtcStartImpl(this);
end;

function TDtcStart.asIDtcStartImpl: IDtcStartImpl;
begin
  if isIDtcStartImpl then
    Result := FObject as IDtcStartImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDtcStartImpl']);
end;

procedure TDtcStart.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TDtcStart.addAttachment(status: IStatus; att: IAttachment);
begin
	vTable^.addAttachment(this, status, att);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDtcStart.addWithTpb(status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr);
begin
	vTable^.addWithTpb(this, status, att, length, tpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtcStart.start(status: IStatus): ITransaction;
begin
	Result := vTable^.start(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtc.this: IDtc;
begin
  Result := IDtc(@FNullPtr);
end;

function TDtc.isIDtcImpl: boolean;
begin
  Result := IDtcImpl.isIDtcImpl(this);
end;

function TDtc.asIDtcImpl: IDtcImpl;
begin
  if isIDtcImpl then
    Result := FObject as IDtcImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDtcImpl']);
end;

function TDtc.join(status: IStatus; one: ITransaction; two: ITransaction): ITransaction;
begin
	Result := vTable^.join(this, status, one, two);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtc.startBuilder(status: IStatus): IDtcStart;
begin
	Result := vTable^.startBuilder(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAuth.this: IAuth;
begin
  Result := IAuth(@FNullPtr);
end;

function TAuth.isIAuthImpl: boolean;
begin
  Result := IAuthImpl.isIAuthImpl(this);
end;

function TAuth.asIAuthImpl: IAuthImpl;
begin
  if isIAuthImpl then
    Result := FObject as IAuthImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IAuthImpl']);
end;

procedure TAuth.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TAuth.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TAuth.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TAuth.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TWriter.this: IWriter;
begin
  Result := IWriter(@FNullPtr);
end;

function TWriter.isIWriterImpl: boolean;
begin
  Result := IWriterImpl.isIWriterImpl(this);
end;

function TWriter.asIWriterImpl: IWriterImpl;
begin
  if isIWriterImpl then
    Result := FObject as IWriterImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IWriterImpl']);
end;

procedure TWriter.reset();
begin
	vTable^.reset(this);
end;

procedure TWriter.add(status: IStatus; name: PAnsiChar);
begin
	vTable^.add(this, status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWriter.setType(status: IStatus; value: PAnsiChar);
begin
	vTable^.setType(this, status, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWriter.setDb(status: IStatus; value: PAnsiChar);
begin
	vTable^.setDb(this, status, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TServerBlock.this: IServerBlock;
begin
  Result := IServerBlock(@FNullPtr);
end;

function TServerBlock.isIServerBlockImpl: boolean;
begin
  Result := IServerBlockImpl.isIServerBlockImpl(this);
end;

function TServerBlock.asIServerBlockImpl: IServerBlockImpl;
begin
  if isIServerBlockImpl then
    Result := FObject as IServerBlockImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IServerBlockImpl']);
end;

function TServerBlock.getLogin(): PAnsiChar;
begin
	Result := vTable^.getLogin(this);
end;

function TServerBlock.getData(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getData(this, length);
end;

procedure TServerBlock.putData(status: IStatus; length: Cardinal; data: Pointer);
begin
	vTable^.putData(this, status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TServerBlock.newKey(status: IStatus): ICryptKey;
begin
	Result := vTable^.newKey(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClientBlock.this: IClientBlock;
begin
  Result := IClientBlock(@FNullPtr);
end;

function TClientBlock.isIClientBlockImpl: boolean;
begin
  Result := IClientBlockImpl.isIClientBlockImpl(this);
end;

function TClientBlock.asIClientBlockImpl: IClientBlockImpl;
begin
  if isIClientBlockImpl then
    Result := FObject as IClientBlockImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IClientBlockImpl']);
end;

procedure TClientBlock.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TClientBlock.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TClientBlock.getLogin(): PAnsiChar;
begin
	Result := vTable^.getLogin(this);
end;

function TClientBlock.getPassword(): PAnsiChar;
begin
	Result := vTable^.getPassword(this);
end;

function TClientBlock.getData(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getData(this, length);
end;

procedure TClientBlock.putData(status: IStatus; length: Cardinal; data: Pointer);
begin
	vTable^.putData(this, status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClientBlock.newKey(status: IStatus): ICryptKey;
begin
	Result := vTable^.newKey(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClientBlock.getAuthBlock(status: IStatus): IAuthBlock;
begin
	Result := vTable^.getAuthBlock(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TServer.this: IServer;
begin
  Result := IServer(@FNullPtr);
end;

function TServer.isIServerImpl: boolean;
begin
  Result := IServerImpl.isIServerImpl(this);
end;

function TServer.asIServerImpl: IServerImpl;
begin
  if isIServerImpl then
    Result := FObject as IServerImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IServerImpl']);
end;

procedure TServer.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TServer.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TServer.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TServer.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TServer.authenticate(status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer;
begin
	Result := vTable^.authenticate(this, status, sBlock, writerInterface);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TServer.setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
begin
	vTable^.setDbCryptCallback(this, status, cryptCallback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClient.this: IClient;
begin
  Result := IClient(@FNullPtr);
end;

function TClient.isIClientImpl: boolean;
begin
  Result := IClientImpl.isIClientImpl(this);
end;

function TClient.asIClientImpl: IClientImpl;
begin
  if isIClientImpl then
    Result := FObject as IClientImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IClientImpl']);
end;

procedure TClient.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TClient.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TClient.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TClient.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TClient.authenticate(status: IStatus; cBlock: IClientBlock): Integer;
begin
	Result := vTable^.authenticate(this, status, cBlock);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUserField.this: IUserField;
begin
  Result := IUserField(@FNullPtr);
end;

function TUserField.isIUserFieldImpl: boolean;
begin
  Result := IUserFieldImpl.isIUserFieldImpl(this);
end;

function TUserField.asIUserFieldImpl: IUserFieldImpl;
begin
  if isIUserFieldImpl then
    Result := FObject as IUserFieldImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUserFieldImpl']);
end;

function TUserField.entered(): Integer;
begin
	Result := vTable^.entered(this);
end;

function TUserField.specified(): Integer;
begin
	Result := vTable^.specified(this);
end;

procedure TUserField.setEntered(status: IStatus; newValue: Integer);
begin
	vTable^.setEntered(this, status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCharUserField.this: ICharUserField;
begin
  Result := ICharUserField(@FNullPtr);
end;

function TCharUserField.isICharUserFieldImpl: boolean;
begin
  Result := ICharUserFieldImpl.isICharUserFieldImpl(this);
end;

function TCharUserField.asICharUserFieldImpl: ICharUserFieldImpl;
begin
  if isICharUserFieldImpl then
    Result := FObject as ICharUserFieldImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ICharUserFieldImpl']);
end;

function TCharUserField.entered(): Integer;
begin
	Result := vTable^.entered(IUserField(this));
end;

function TCharUserField.specified(): Integer;
begin
	Result := vTable^.specified(IUserField(this));
end;

procedure TCharUserField.setEntered(status: IStatus; newValue: Integer);
begin
	vTable^.setEntered(IUserField(this), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCharUserField.get(): PAnsiChar;
begin
	Result := vTable^.get(this);
end;

procedure TCharUserField.set_(status: IStatus; newValue: PAnsiChar);
begin
	vTable^.set_(this, status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TIntUserField.this: IIntUserField;
begin
  Result := IIntUserField(@FNullPtr);
end;

function TIntUserField.isIIntUserFieldImpl: boolean;
begin
  Result := IIntUserFieldImpl.isIIntUserFieldImpl(this);
end;

function TIntUserField.asIIntUserFieldImpl: IIntUserFieldImpl;
begin
  if isIIntUserFieldImpl then
    Result := FObject as IIntUserFieldImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IIntUserFieldImpl']);
end;

function TIntUserField.entered(): Integer;
begin
	Result := vTable^.entered(IUserField(this));
end;

function TIntUserField.specified(): Integer;
begin
	Result := vTable^.specified(IUserField(this));
end;

procedure TIntUserField.setEntered(status: IStatus; newValue: Integer);
begin
	vTable^.setEntered(IUserField(this), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TIntUserField.get(): Integer;
begin
	Result := vTable^.get(this);
end;

procedure TIntUserField.set_(status: IStatus; newValue: Integer);
begin
	vTable^.set_(this, status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUser.this: IUser;
begin
  Result := IUser(@FNullPtr);
end;

function TUser.isIUserImpl: boolean;
begin
  Result := IUserImpl.isIUserImpl(this);
end;

function TUser.asIUserImpl: IUserImpl;
begin
  if isIUserImpl then
    Result := FObject as IUserImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUserImpl']);
end;

function TUser.operation(): Cardinal;
begin
	Result := vTable^.operation(this);
end;

function TUser.userName(): ICharUserField;
begin
	Result := vTable^.userName(this);
end;

function TUser.password(): ICharUserField;
begin
	Result := vTable^.password(this);
end;

function TUser.firstName(): ICharUserField;
begin
	Result := vTable^.firstName(this);
end;

function TUser.lastName(): ICharUserField;
begin
	Result := vTable^.lastName(this);
end;

function TUser.middleName(): ICharUserField;
begin
	Result := vTable^.middleName(this);
end;

function TUser.comment(): ICharUserField;
begin
	Result := vTable^.comment(this);
end;

function TUser.attributes(): ICharUserField;
begin
	Result := vTable^.attributes(this);
end;

function TUser.active(): IIntUserField;
begin
	Result := vTable^.active(this);
end;

function TUser.admin(): IIntUserField;
begin
	Result := vTable^.admin(this);
end;

procedure TUser.clear(status: IStatus);
begin
	vTable^.clear(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TListUsers.this: IListUsers;
begin
  Result := IListUsers(@FNullPtr);
end;

function TListUsers.isIListUsersImpl: boolean;
begin
  Result := IListUsersImpl.isIListUsersImpl(this);
end;

function TListUsers.asIListUsersImpl: IListUsersImpl;
begin
  if isIListUsersImpl then
    Result := FObject as IListUsersImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IListUsersImpl']);
end;

procedure TListUsers.list(status: IStatus; user: IUser);
begin
	vTable^.list(this, status, user);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TLogonInfo.this: ILogonInfo;
begin
  Result := ILogonInfo(@FNullPtr);
end;

function TLogonInfo.isILogonInfoImpl: boolean;
begin
  Result := ILogonInfoImpl.isILogonInfoImpl(this);
end;

function TLogonInfo.asILogonInfoImpl: ILogonInfoImpl;
begin
  if isILogonInfoImpl then
    Result := FObject as ILogonInfoImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ILogonInfoImpl']);
end;

function TLogonInfo.name(): PAnsiChar;
begin
	Result := vTable^.name(this);
end;

function TLogonInfo.role(): PAnsiChar;
begin
	Result := vTable^.role(this);
end;

function TLogonInfo.networkProtocol(): PAnsiChar;
begin
	Result := vTable^.networkProtocol(this);
end;

function TLogonInfo.remoteAddress(): PAnsiChar;
begin
	Result := vTable^.remoteAddress(this);
end;

function TLogonInfo.authBlock(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.authBlock(this, length);
end;

function TLogonInfo.attachment(status: IStatus): IAttachment;
begin
	Result := vTable^.attachment(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TLogonInfo.transaction(status: IStatus): ITransaction;
begin
	Result := vTable^.transaction(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TManagement.this: IManagement;
begin
  Result := IManagement(@FNullPtr);
end;

function TManagement.isIManagementImpl: boolean;
begin
  Result := IManagementImpl.isIManagementImpl(this);
end;

function TManagement.asIManagementImpl: IManagementImpl;
begin
  if isIManagementImpl then
    Result := FObject as IManagementImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IManagementImpl']);
end;

procedure TManagement.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TManagement.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TManagement.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TManagement.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

procedure TManagement.start(status: IStatus; logonInfo: ILogonInfo);
begin
	vTable^.start(this, status, logonInfo);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TManagement.execute(status: IStatus; user: IUser; callback: IListUsers): Integer;
begin
	Result := vTable^.execute(this, status, user, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TManagement.commit(status: IStatus);
begin
	vTable^.commit(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TManagement.rollback(status: IStatus);
begin
	vTable^.rollback(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAuthBlock.this: IAuthBlock;
begin
  Result := IAuthBlock(@FNullPtr);
end;

function TAuthBlock.isIAuthBlockImpl: boolean;
begin
  Result := IAuthBlockImpl.isIAuthBlockImpl(this);
end;

function TAuthBlock.asIAuthBlockImpl: IAuthBlockImpl;
begin
  if isIAuthBlockImpl then
    Result := FObject as IAuthBlockImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IAuthBlockImpl']);
end;

function TAuthBlock.getType(): PAnsiChar;
begin
	Result := vTable^.getType(this);
end;

function TAuthBlock.getName(): PAnsiChar;
begin
	Result := vTable^.getName(this);
end;

function TAuthBlock.getPlugin(): PAnsiChar;
begin
	Result := vTable^.getPlugin(this);
end;

function TAuthBlock.getSecurityDb(): PAnsiChar;
begin
	Result := vTable^.getSecurityDb(this);
end;

function TAuthBlock.getOriginalPlugin(): PAnsiChar;
begin
	Result := vTable^.getOriginalPlugin(this);
end;

function TAuthBlock.next(status: IStatus): Boolean;
begin
	Result := vTable^.next(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAuthBlock.first(status: IStatus): Boolean;
begin
	Result := vTable^.first(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TWireCryptPlugin.this: IWireCryptPlugin;
begin
  Result := IWireCryptPlugin(@FNullPtr);
end;

function TWireCryptPlugin.isIWireCryptPluginImpl: boolean;
begin
  Result := IWireCryptPluginImpl.isIWireCryptPluginImpl(this);
end;

function TWireCryptPlugin.asIWireCryptPluginImpl: IWireCryptPluginImpl;
begin
  if isIWireCryptPluginImpl then
    Result := FObject as IWireCryptPluginImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IWireCryptPluginImpl']);
end;

procedure TWireCryptPlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TWireCryptPlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TWireCryptPlugin.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TWireCryptPlugin.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TWireCryptPlugin.getKnownTypes(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getKnownTypes(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.setKey(status: IStatus; key: ICryptKey);
begin
	vTable^.setKey(this, status, key);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.encrypt(this, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.decrypt(this, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TWireCryptPlugin.getSpecificData(status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getSpecificData(this, status, keyType, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.setSpecificData(status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr);
begin
	vTable^.setSpecificData(this, status, keyType, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCryptKeyCallback.this: ICryptKeyCallback;
begin
  Result := ICryptKeyCallback(@FNullPtr);
end;

function TCryptKeyCallback.isICryptKeyCallbackImpl: boolean;
begin
  Result := ICryptKeyCallbackImpl.isICryptKeyCallbackImpl(this);
end;

function TCryptKeyCallback.asICryptKeyCallbackImpl: ICryptKeyCallbackImpl;
begin
  if isICryptKeyCallbackImpl then
    Result := FObject as ICryptKeyCallbackImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ICryptKeyCallbackImpl']);
end;

function TCryptKeyCallback.callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal;
begin
	Result := vTable^.callback(this, dataLength, data, bufferLength, buffer);
end;

function TKeyHolderPlugin.this: IKeyHolderPlugin;
begin
  Result := IKeyHolderPlugin(@FNullPtr);
end;

function TKeyHolderPlugin.isIKeyHolderPluginImpl: boolean;
begin
  Result := IKeyHolderPluginImpl.isIKeyHolderPluginImpl(this);
end;

function TKeyHolderPlugin.asIKeyHolderPluginImpl: IKeyHolderPluginImpl;
begin
  if isIKeyHolderPluginImpl then
    Result := FObject as IKeyHolderPluginImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IKeyHolderPluginImpl']);
end;

procedure TKeyHolderPlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TKeyHolderPlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TKeyHolderPlugin.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TKeyHolderPlugin.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TKeyHolderPlugin.keyCallback(status: IStatus; callback: ICryptKeyCallback): Integer;
begin
	Result := vTable^.keyCallback(this, status, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TKeyHolderPlugin.keyHandle(status: IStatus; keyName: PAnsiChar): ICryptKeyCallback;
begin
	Result := vTable^.keyHandle(this, status, keyName);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TKeyHolderPlugin.useOnlyOwnKeys(status: IStatus): Boolean;
begin
	Result := vTable^.useOnlyOwnKeys(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TKeyHolderPlugin.chainHandle(status: IStatus): ICryptKeyCallback;
begin
	Result := vTable^.chainHandle(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDbCryptInfo.this: IDbCryptInfo;
begin
  Result := IDbCryptInfo(@FNullPtr);
end;

function TDbCryptInfo.isIDbCryptInfoImpl: boolean;
begin
  Result := IDbCryptInfoImpl.isIDbCryptInfoImpl(this);
end;

function TDbCryptInfo.asIDbCryptInfoImpl: IDbCryptInfoImpl;
begin
  if isIDbCryptInfoImpl then
    Result := FObject as IDbCryptInfoImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDbCryptInfoImpl']);
end;

procedure TDbCryptInfo.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TDbCryptInfo.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TDbCryptInfo.getDatabaseFullPath(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getDatabaseFullPath(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDbCryptPlugin.this: IDbCryptPlugin;
begin
  Result := IDbCryptPlugin(@FNullPtr);
end;

function TDbCryptPlugin.isIDbCryptPluginImpl: boolean;
begin
  Result := IDbCryptPluginImpl.isIDbCryptPluginImpl(this);
end;

function TDbCryptPlugin.asIDbCryptPluginImpl: IDbCryptPluginImpl;
begin
  if isIDbCryptPluginImpl then
    Result := FObject as IDbCryptPluginImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDbCryptPluginImpl']);
end;

procedure TDbCryptPlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TDbCryptPlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TDbCryptPlugin.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TDbCryptPlugin.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

procedure TDbCryptPlugin.setKey(status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar);
begin
	vTable^.setKey(this, status, length, sources, keyName);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDbCryptPlugin.encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.encrypt(this, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDbCryptPlugin.decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.decrypt(this, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDbCryptPlugin.setInfo(status: IStatus; info: IDbCryptInfo);
begin
	vTable^.setInfo(this, status, info);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.this: IExternalContext;
begin
  Result := IExternalContext(@FNullPtr);
end;

function TExternalContext.isIExternalContextImpl: boolean;
begin
  Result := IExternalContextImpl.isIExternalContextImpl(this);
end;

function TExternalContext.asIExternalContextImpl: IExternalContextImpl;
begin
  if isIExternalContextImpl then
    Result := FObject as IExternalContextImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IExternalContextImpl']);
end;

function TExternalContext.getMaster(): IMaster;
begin
	Result := vTable^.getMaster(this);
end;

function TExternalContext.getEngine(status: IStatus): IExternalEngine;
begin
	Result := vTable^.getEngine(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.getAttachment(status: IStatus): IAttachment;
begin
	Result := vTable^.getAttachment(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.getTransaction(status: IStatus): ITransaction;
begin
	Result := vTable^.getTransaction(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(this);
end;

function TExternalContext.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(this);
end;

function TExternalContext.getClientCharSet(): PAnsiChar;
begin
	Result := vTable^.getClientCharSet(this);
end;

function TExternalContext.obtainInfoCode(): Integer;
begin
	Result := vTable^.obtainInfoCode(this);
end;

function TExternalContext.getInfo(code: Integer): Pointer;
begin
	Result := vTable^.getInfo(this, code);
end;

function TExternalContext.setInfo(code: Integer; value: Pointer): Pointer;
begin
	Result := vTable^.setInfo(this, code, value);
end;

function TExternalResultSet.this: IExternalResultSet;
begin
  Result := IExternalResultSet(@FNullPtr);
end;

function TExternalResultSet.isIExternalResultSetImpl: boolean;
begin
  Result := IExternalResultSetImpl.isIExternalResultSetImpl(this);
end;

function TExternalResultSet.asIExternalResultSetImpl: IExternalResultSetImpl;
begin
  if isIExternalResultSetImpl then
    Result := FObject as IExternalResultSetImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IExternalResultSetImpl']);
end;

procedure TExternalResultSet.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

function TExternalResultSet.fetch(status: IStatus): Boolean;
begin
	Result := vTable^.fetch(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalFunction.this: IExternalFunction;
begin
  Result := IExternalFunction(@FNullPtr);
end;

function TExternalFunction.isIExternalFunctionImpl: boolean;
begin
  Result := IExternalFunctionImpl.isIExternalFunctionImpl(this);
end;

function TExternalFunction.asIExternalFunctionImpl: IExternalFunctionImpl;
begin
  if isIExternalFunctionImpl then
    Result := FObject as IExternalFunctionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IExternalFunctionImpl']);
end;

procedure TExternalFunction.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TExternalFunction.getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(this, status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalFunction.execute(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer);
begin
	vTable^.execute(this, status, context, inMsg, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalProcedure.this: IExternalProcedure;
begin
  Result := IExternalProcedure(@FNullPtr);
end;

function TExternalProcedure.isIExternalProcedureImpl: boolean;
begin
  Result := IExternalProcedureImpl.isIExternalProcedureImpl(this);
end;

function TExternalProcedure.asIExternalProcedureImpl: IExternalProcedureImpl;
begin
  if isIExternalProcedureImpl then
    Result := FObject as IExternalProcedureImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IExternalProcedureImpl']);
end;

procedure TExternalProcedure.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TExternalProcedure.getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(this, status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalProcedure.open(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet;
begin
	Result := vTable^.open(this, status, context, inMsg, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalTrigger.this: IExternalTrigger;
begin
  Result := IExternalTrigger(@FNullPtr);
end;

function TExternalTrigger.isIExternalTriggerImpl: boolean;
begin
  Result := IExternalTriggerImpl.isIExternalTriggerImpl(this);
end;

function TExternalTrigger.asIExternalTriggerImpl: IExternalTriggerImpl;
begin
  if isIExternalTriggerImpl then
    Result := FObject as IExternalTriggerImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IExternalTriggerImpl']);
end;

procedure TExternalTrigger.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TExternalTrigger.getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(this, status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalTrigger.execute(status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer);
begin
	vTable^.execute(this, status, context, action, oldMsg, newMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.this: IRoutineMetadata;
begin
  Result := IRoutineMetadata(@FNullPtr);
end;

function TRoutineMetadata.isIRoutineMetadataImpl: boolean;
begin
  Result := IRoutineMetadataImpl.isIRoutineMetadataImpl(this);
end;

function TRoutineMetadata.asIRoutineMetadataImpl: IRoutineMetadataImpl;
begin
  if isIRoutineMetadataImpl then
    Result := FObject as IRoutineMetadataImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IRoutineMetadataImpl']);
end;

function TRoutineMetadata.getPackage(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getPackage(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getName(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getName(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getEntryPoint(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getEntryPoint(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getBody(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getBody(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getInputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getInputMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getOutputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getOutputMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getTriggerMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getTriggerMetadata(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getTriggerTable(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getTriggerTable(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getTriggerType(status: IStatus): Cardinal;
begin
	Result := vTable^.getTriggerType(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.this: IExternalEngine;
begin
  Result := IExternalEngine(@FNullPtr);
end;

function TExternalEngine.isIExternalEngineImpl: boolean;
begin
  Result := IExternalEngineImpl.isIExternalEngineImpl(this);
end;

function TExternalEngine.asIExternalEngineImpl: IExternalEngineImpl;
begin
  if isIExternalEngineImpl then
    Result := FObject as IExternalEngineImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IExternalEngineImpl']);
end;

procedure TExternalEngine.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TExternalEngine.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TExternalEngine.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TExternalEngine.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

procedure TExternalEngine.open(status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal);
begin
	vTable^.open(this, status, context, charSet, charSetSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalEngine.openAttachment(status: IStatus; context: IExternalContext);
begin
	vTable^.openAttachment(this, status, context);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalEngine.closeAttachment(status: IStatus; context: IExternalContext);
begin
	vTable^.closeAttachment(this, status, context);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.makeFunction(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction;
begin
	Result := vTable^.makeFunction(this, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.makeProcedure(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure;
begin
	Result := vTable^.makeProcedure(this, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.makeTrigger(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger;
begin
	Result := vTable^.makeTrigger(this, status, context, metadata, fieldsBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTimer.this: ITimer;
begin
  Result := ITimer(@FNullPtr);
end;

function TTimer.isITimerImpl: boolean;
begin
  Result := ITimerImpl.isITimerImpl(this);
end;

function TTimer.asITimerImpl: ITimerImpl;
begin
  if isITimerImpl then
    Result := FObject as ITimerImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITimerImpl']);
end;

procedure TTimer.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TTimer.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TTimer.handler();
begin
	vTable^.handler(this);
end;

function TTimerControl.this: ITimerControl;
begin
  Result := ITimerControl(@FNullPtr);
end;

function TTimerControl.isITimerControlImpl: boolean;
begin
  Result := ITimerControlImpl.isITimerControlImpl(this);
end;

function TTimerControl.asITimerControlImpl: ITimerControlImpl;
begin
  if isITimerControlImpl then
    Result := FObject as ITimerControlImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITimerControlImpl']);
end;

procedure TTimerControl.start(status: IStatus; timer: ITimer; microSeconds: QWord);
begin
	vTable^.start(this, status, timer, microSeconds);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTimerControl.stop(status: IStatus; timer: ITimer);
begin
	vTable^.stop(this, status, timer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TVersionCallback.this: IVersionCallback;
begin
  Result := IVersionCallback(@FNullPtr);
end;

function TVersionCallback.isIVersionCallbackImpl: boolean;
begin
  Result := IVersionCallbackImpl.isIVersionCallbackImpl(this);
end;

function TVersionCallback.asIVersionCallbackImpl: IVersionCallbackImpl;
begin
  if isIVersionCallbackImpl then
    Result := FObject as IVersionCallbackImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IVersionCallbackImpl']);
end;

procedure TVersionCallback.callback(status: IStatus; text: PAnsiChar);
begin
	vTable^.callback(this, status, text);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.this: IUtil;
begin
  Result := IUtil(@FNullPtr);
end;

function TUtil.isIUtilImpl: boolean;
begin
  Result := IUtilImpl.isIUtilImpl(this);
end;

function TUtil.asIUtilImpl: IUtilImpl;
begin
  if isIUtilImpl then
    Result := FObject as IUtilImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUtilImpl']);
end;

procedure TUtil.getFbVersion(status: IStatus; att: IAttachment; callback: IVersionCallback);
begin
	vTable^.getFbVersion(this, status, att, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.loadBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
begin
	vTable^.loadBlob(this, status, blobId, att, tra, file_, txt);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.dumpBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
begin
	vTable^.dumpBlob(this, status, blobId, att, tra, file_, txt);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.getPerfCounters(status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr);
begin
	vTable^.getPerfCounters(this, status, att, countersSet, counters);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.executeCreateDatabase(status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment;
begin
	Result := vTable^.executeCreateDatabase(this, status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr);
begin
	vTable^.decodeDate(this, date, year, month, day);
end;

procedure TUtil.decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr);
begin
	vTable^.decodeTime(this, time, hours, minutes, seconds, fractions);
end;

function TUtil.encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE;
begin
	Result := vTable^.encodeDate(this, year, month, day);
end;

function TUtil.encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME;
begin
	Result := vTable^.encodeTime(this, hours, minutes, seconds, fractions);
end;

function TUtil.formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal;
begin
	Result := vTable^.formatStatus(this, buffer, bufferSize, status);
end;

function TUtil.getClientVersion(): Cardinal;
begin
	Result := vTable^.getClientVersion(this);
end;

function TUtil.getXpbBuilder(status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder;
begin
	Result := vTable^.getXpbBuilder(this, status, kind, buf, len);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.setOffsets(status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal;
begin
	Result := vTable^.setOffsets(this, status, metadata, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.getDecFloat16(status: IStatus): IDecFloat16;
begin
	Result := vTable^.getDecFloat16(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.getDecFloat34(status: IStatus): IDecFloat34;
begin
	Result := vTable^.getDecFloat34(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeTz(this, status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeStampTz(this, status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.encodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
begin
	vTable^.encodeTimeTz(this, status, timeTz, hours, minutes, seconds, fractions, timeZone);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.encodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
begin
	vTable^.encodeTimeStampTz(this, status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZone);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.getInt128(status: IStatus): IInt128;
begin
	Result := vTable^.getInt128(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeTzEx(status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeTzEx(this, status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeStampTzEx(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeStampTzEx(this, status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TOffsetsCallback.this: IOffsetsCallback;
begin
  Result := IOffsetsCallback(@FNullPtr);
end;

function TOffsetsCallback.isIOffsetsCallbackImpl: boolean;
begin
  Result := IOffsetsCallbackImpl.isIOffsetsCallbackImpl(this);
end;

function TOffsetsCallback.asIOffsetsCallbackImpl: IOffsetsCallbackImpl;
begin
  if isIOffsetsCallbackImpl then
    Result := FObject as IOffsetsCallbackImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IOffsetsCallbackImpl']);
end;

procedure TOffsetsCallback.setOffset(status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal);
begin
	vTable^.setOffset(this, status, index, offset, nullOffset);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.this: IXpbBuilder;
begin
  Result := IXpbBuilder(@FNullPtr);
end;

function TXpbBuilder.isIXpbBuilderImpl: boolean;
begin
  Result := IXpbBuilderImpl.isIXpbBuilderImpl(this);
end;

function TXpbBuilder.asIXpbBuilderImpl: IXpbBuilderImpl;
begin
  if isIXpbBuilderImpl then
    Result := FObject as IXpbBuilderImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IXpbBuilderImpl']);
end;

procedure TXpbBuilder.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TXpbBuilder.clear(status: IStatus);
begin
	vTable^.clear(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.removeCurrent(status: IStatus);
begin
	vTable^.removeCurrent(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertInt(status: IStatus; tag: Byte; value: Integer);
begin
	vTable^.insertInt(this, status, tag, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertBigInt(status: IStatus; tag: Byte; value: Int64);
begin
	vTable^.insertBigInt(this, status, tag, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertBytes(status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal);
begin
	vTable^.insertBytes(this, status, tag, bytes, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertString(status: IStatus; tag: Byte; str: PAnsiChar);
begin
	vTable^.insertString(this, status, tag, str);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertTag(status: IStatus; tag: Byte);
begin
	vTable^.insertTag(this, status, tag);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.isEof(status: IStatus): Boolean;
begin
	Result := vTable^.isEof(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.moveNext(status: IStatus);
begin
	vTable^.moveNext(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.rewind(status: IStatus);
begin
	vTable^.rewind(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.findFirst(status: IStatus; tag: Byte): Boolean;
begin
	Result := vTable^.findFirst(this, status, tag);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.findNext(status: IStatus): Boolean;
begin
	Result := vTable^.findNext(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getTag(status: IStatus): Byte;
begin
	Result := vTable^.getTag(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getLength(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getInt(status: IStatus): Integer;
begin
	Result := vTable^.getInt(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBigInt(status: IStatus): Int64;
begin
	Result := vTable^.getBigInt(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getString(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getString(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBytes(status: IStatus): BytePtr;
begin
	Result := vTable^.getBytes(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBufferLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getBufferLength(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBuffer(status: IStatus): BytePtr;
begin
	Result := vTable^.getBuffer(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTraceConnection.this: ITraceConnection;
begin
  Result := ITraceConnection(@FNullPtr);
end;

function TTraceConnection.isITraceConnectionImpl: boolean;
begin
  Result := ITraceConnectionImpl.isITraceConnectionImpl(this);
end;

function TTraceConnection.asITraceConnectionImpl: ITraceConnectionImpl;
begin
  if isITraceConnectionImpl then
    Result := FObject as ITraceConnectionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceConnectionImpl']);
end;

function TTraceConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(this);
end;

function TTraceConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(this);
end;

function TTraceConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(this);
end;

function TTraceConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(this);
end;

function TTraceConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(this);
end;

function TTraceConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(this);
end;

function TTraceConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(this);
end;

function TTraceConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(this);
end;

function TTraceConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(this);
end;

function TTraceDatabaseConnection.this: ITraceDatabaseConnection;
begin
  Result := ITraceDatabaseConnection(@FNullPtr);
end;

function TTraceDatabaseConnection.isITraceDatabaseConnectionImpl: boolean;
begin
  Result := ITraceDatabaseConnectionImpl.isITraceDatabaseConnectionImpl(this);
end;

function TTraceDatabaseConnection.asITraceDatabaseConnectionImpl: ITraceDatabaseConnectionImpl;
begin
  if isITraceDatabaseConnectionImpl then
    Result := FObject as ITraceDatabaseConnectionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceDatabaseConnectionImpl']);
end;

function TTraceDatabaseConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(ITraceConnection(this));
end;

function TTraceDatabaseConnection.getConnectionID(): Int64;
begin
	Result := vTable^.getConnectionID(this);
end;

function TTraceDatabaseConnection.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(this);
end;

function TTraceTransaction.this: ITraceTransaction;
begin
  Result := ITraceTransaction(@FNullPtr);
end;

function TTraceTransaction.isITraceTransactionImpl: boolean;
begin
  Result := ITraceTransactionImpl.isITraceTransactionImpl(this);
end;

function TTraceTransaction.asITraceTransactionImpl: ITraceTransactionImpl;
begin
  if isITraceTransactionImpl then
    Result := FObject as ITraceTransactionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceTransactionImpl']);
end;

function TTraceTransaction.getTransactionID(): Int64;
begin
	Result := vTable^.getTransactionID(this);
end;

function TTraceTransaction.getReadOnly(): Boolean;
begin
	Result := vTable^.getReadOnly(this);
end;

function TTraceTransaction.getWait(): Integer;
begin
	Result := vTable^.getWait(this);
end;

function TTraceTransaction.getIsolation(): Cardinal;
begin
	Result := vTable^.getIsolation(this);
end;

function TTraceTransaction.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(this);
end;

function TTraceTransaction.getInitialID(): Int64;
begin
	Result := vTable^.getInitialID(this);
end;

function TTraceTransaction.getPreviousID(): Int64;
begin
	Result := vTable^.getPreviousID(this);
end;

function TTraceParams.this: ITraceParams;
begin
  Result := ITraceParams(@FNullPtr);
end;

function TTraceParams.isITraceParamsImpl: boolean;
begin
  Result := ITraceParamsImpl.isITraceParamsImpl(this);
end;

function TTraceParams.asITraceParamsImpl: ITraceParamsImpl;
begin
  if isITraceParamsImpl then
    Result := FObject as ITraceParamsImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceParamsImpl']);
end;

function TTraceParams.getCount(): Cardinal;
begin
	Result := vTable^.getCount(this);
end;

function TTraceParams.getParam(idx: Cardinal): dscPtr;
begin
	Result := vTable^.getParam(this, idx);
end;

function TTraceParams.getTextUTF8(status: IStatus; idx: Cardinal): PAnsiChar;
begin
	Result := vTable^.getTextUTF8(this, status, idx);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTraceStatement.this: ITraceStatement;
begin
  Result := ITraceStatement(@FNullPtr);
end;

function TTraceStatement.isITraceStatementImpl: boolean;
begin
  Result := ITraceStatementImpl.isITraceStatementImpl(this);
end;

function TTraceStatement.asITraceStatementImpl: ITraceStatementImpl;
begin
  if isITraceStatementImpl then
    Result := FObject as ITraceStatementImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceStatementImpl']);
end;

function TTraceStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(this);
end;

function TTraceStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(this);
end;

function TTraceSQLStatement.this: ITraceSQLStatement;
begin
  Result := ITraceSQLStatement(@FNullPtr);
end;

function TTraceSQLStatement.isITraceSQLStatementImpl: boolean;
begin
  Result := ITraceSQLStatementImpl.isITraceSQLStatementImpl(this);
end;

function TTraceSQLStatement.asITraceSQLStatementImpl: ITraceSQLStatementImpl;
begin
  if isITraceSQLStatementImpl then
    Result := FObject as ITraceSQLStatementImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceSQLStatementImpl']);
end;

function TTraceSQLStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(ITraceStatement(this));
end;

function TTraceSQLStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(ITraceStatement(this));
end;

function TTraceSQLStatement.getText(): PAnsiChar;
begin
	Result := vTable^.getText(this);
end;

function TTraceSQLStatement.getPlan(): PAnsiChar;
begin
	Result := vTable^.getPlan(this);
end;

function TTraceSQLStatement.getInputs(): ITraceParams;
begin
	Result := vTable^.getInputs(this);
end;

function TTraceSQLStatement.getTextUTF8(): PAnsiChar;
begin
	Result := vTable^.getTextUTF8(this);
end;

function TTraceSQLStatement.getExplainedPlan(): PAnsiChar;
begin
	Result := vTable^.getExplainedPlan(this);
end;

function TTraceBLRStatement.this: ITraceBLRStatement;
begin
  Result := ITraceBLRStatement(@FNullPtr);
end;

function TTraceBLRStatement.isITraceBLRStatementImpl: boolean;
begin
  Result := ITraceBLRStatementImpl.isITraceBLRStatementImpl(this);
end;

function TTraceBLRStatement.asITraceBLRStatementImpl: ITraceBLRStatementImpl;
begin
  if isITraceBLRStatementImpl then
    Result := FObject as ITraceBLRStatementImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceBLRStatementImpl']);
end;

function TTraceBLRStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(ITraceStatement(this));
end;

function TTraceBLRStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(ITraceStatement(this));
end;

function TTraceBLRStatement.getData(): BytePtr;
begin
	Result := vTable^.getData(this);
end;

function TTraceBLRStatement.getDataLength(): Cardinal;
begin
	Result := vTable^.getDataLength(this);
end;

function TTraceBLRStatement.getText(): PAnsiChar;
begin
	Result := vTable^.getText(this);
end;

function TTraceDYNRequest.this: ITraceDYNRequest;
begin
  Result := ITraceDYNRequest(@FNullPtr);
end;

function TTraceDYNRequest.isITraceDYNRequestImpl: boolean;
begin
  Result := ITraceDYNRequestImpl.isITraceDYNRequestImpl(this);
end;

function TTraceDYNRequest.asITraceDYNRequestImpl: ITraceDYNRequestImpl;
begin
  if isITraceDYNRequestImpl then
    Result := FObject as ITraceDYNRequestImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceDYNRequestImpl']);
end;

function TTraceDYNRequest.getData(): BytePtr;
begin
	Result := vTable^.getData(this);
end;

function TTraceDYNRequest.getDataLength(): Cardinal;
begin
	Result := vTable^.getDataLength(this);
end;

function TTraceDYNRequest.getText(): PAnsiChar;
begin
	Result := vTable^.getText(this);
end;

function TTraceContextVariable.this: ITraceContextVariable;
begin
  Result := ITraceContextVariable(@FNullPtr);
end;

function TTraceContextVariable.isITraceContextVariableImpl: boolean;
begin
  Result := ITraceContextVariableImpl.isITraceContextVariableImpl(this);
end;

function TTraceContextVariable.asITraceContextVariableImpl: ITraceContextVariableImpl;
begin
  if isITraceContextVariableImpl then
    Result := FObject as ITraceContextVariableImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceContextVariableImpl']);
end;

function TTraceContextVariable.getNameSpace(): PAnsiChar;
begin
	Result := vTable^.getNameSpace(this);
end;

function TTraceContextVariable.getVarName(): PAnsiChar;
begin
	Result := vTable^.getVarName(this);
end;

function TTraceContextVariable.getVarValue(): PAnsiChar;
begin
	Result := vTable^.getVarValue(this);
end;

function TTraceProcedure.this: ITraceProcedure;
begin
  Result := ITraceProcedure(@FNullPtr);
end;

function TTraceProcedure.isITraceProcedureImpl: boolean;
begin
  Result := ITraceProcedureImpl.isITraceProcedureImpl(this);
end;

function TTraceProcedure.asITraceProcedureImpl: ITraceProcedureImpl;
begin
  if isITraceProcedureImpl then
    Result := FObject as ITraceProcedureImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceProcedureImpl']);
end;

function TTraceProcedure.getProcName(): PAnsiChar;
begin
	Result := vTable^.getProcName(this);
end;

function TTraceProcedure.getInputs(): ITraceParams;
begin
	Result := vTable^.getInputs(this);
end;

function TTraceProcedure.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(this);
end;

function TTraceFunction.this: ITraceFunction;
begin
  Result := ITraceFunction(@FNullPtr);
end;

function TTraceFunction.isITraceFunctionImpl: boolean;
begin
  Result := ITraceFunctionImpl.isITraceFunctionImpl(this);
end;

function TTraceFunction.asITraceFunctionImpl: ITraceFunctionImpl;
begin
  if isITraceFunctionImpl then
    Result := FObject as ITraceFunctionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceFunctionImpl']);
end;

function TTraceFunction.getFuncName(): PAnsiChar;
begin
	Result := vTable^.getFuncName(this);
end;

function TTraceFunction.getInputs(): ITraceParams;
begin
	Result := vTable^.getInputs(this);
end;

function TTraceFunction.getResult(): ITraceParams;
begin
	Result := vTable^.getResult(this);
end;

function TTraceFunction.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(this);
end;

function TTraceTrigger.this: ITraceTrigger;
begin
  Result := ITraceTrigger(@FNullPtr);
end;

function TTraceTrigger.isITraceTriggerImpl: boolean;
begin
  Result := ITraceTriggerImpl.isITraceTriggerImpl(this);
end;

function TTraceTrigger.asITraceTriggerImpl: ITraceTriggerImpl;
begin
  if isITraceTriggerImpl then
    Result := FObject as ITraceTriggerImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceTriggerImpl']);
end;

function TTraceTrigger.getTriggerName(): PAnsiChar;
begin
	Result := vTable^.getTriggerName(this);
end;

function TTraceTrigger.getRelationName(): PAnsiChar;
begin
	Result := vTable^.getRelationName(this);
end;

function TTraceTrigger.getAction(): Integer;
begin
	Result := vTable^.getAction(this);
end;

function TTraceTrigger.getWhich(): Integer;
begin
	Result := vTable^.getWhich(this);
end;

function TTraceTrigger.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(this);
end;

function TTraceServiceConnection.this: ITraceServiceConnection;
begin
  Result := ITraceServiceConnection(@FNullPtr);
end;

function TTraceServiceConnection.isITraceServiceConnectionImpl: boolean;
begin
  Result := ITraceServiceConnectionImpl.isITraceServiceConnectionImpl(this);
end;

function TTraceServiceConnection.asITraceServiceConnectionImpl: ITraceServiceConnectionImpl;
begin
  if isITraceServiceConnectionImpl then
    Result := FObject as ITraceServiceConnectionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceServiceConnectionImpl']);
end;

function TTraceServiceConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(ITraceConnection(this));
end;

function TTraceServiceConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(ITraceConnection(this));
end;

function TTraceServiceConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(ITraceConnection(this));
end;

function TTraceServiceConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(ITraceConnection(this));
end;

function TTraceServiceConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(ITraceConnection(this));
end;

function TTraceServiceConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(ITraceConnection(this));
end;

function TTraceServiceConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(ITraceConnection(this));
end;

function TTraceServiceConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(ITraceConnection(this));
end;

function TTraceServiceConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(ITraceConnection(this));
end;

function TTraceServiceConnection.getServiceID(): Pointer;
begin
	Result := vTable^.getServiceID(this);
end;

function TTraceServiceConnection.getServiceMgr(): PAnsiChar;
begin
	Result := vTable^.getServiceMgr(this);
end;

function TTraceServiceConnection.getServiceName(): PAnsiChar;
begin
	Result := vTable^.getServiceName(this);
end;

function TTraceStatusVector.this: ITraceStatusVector;
begin
  Result := ITraceStatusVector(@FNullPtr);
end;

function TTraceStatusVector.isITraceStatusVectorImpl: boolean;
begin
  Result := ITraceStatusVectorImpl.isITraceStatusVectorImpl(this);
end;

function TTraceStatusVector.asITraceStatusVectorImpl: ITraceStatusVectorImpl;
begin
  if isITraceStatusVectorImpl then
    Result := FObject as ITraceStatusVectorImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceStatusVectorImpl']);
end;

function TTraceStatusVector.hasError(): Boolean;
begin
	Result := vTable^.hasError(this);
end;

function TTraceStatusVector.hasWarning(): Boolean;
begin
	Result := vTable^.hasWarning(this);
end;

function TTraceStatusVector.getStatus(): IStatus;
begin
	Result := vTable^.getStatus(this);
end;

function TTraceStatusVector.getText(): PAnsiChar;
begin
	Result := vTable^.getText(this);
end;

function TTraceSweepInfo.this: ITraceSweepInfo;
begin
  Result := ITraceSweepInfo(@FNullPtr);
end;

function TTraceSweepInfo.isITraceSweepInfoImpl: boolean;
begin
  Result := ITraceSweepInfoImpl.isITraceSweepInfoImpl(this);
end;

function TTraceSweepInfo.asITraceSweepInfoImpl: ITraceSweepInfoImpl;
begin
  if isITraceSweepInfoImpl then
    Result := FObject as ITraceSweepInfoImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceSweepInfoImpl']);
end;

function TTraceSweepInfo.getOIT(): Int64;
begin
	Result := vTable^.getOIT(this);
end;

function TTraceSweepInfo.getOST(): Int64;
begin
	Result := vTable^.getOST(this);
end;

function TTraceSweepInfo.getOAT(): Int64;
begin
	Result := vTable^.getOAT(this);
end;

function TTraceSweepInfo.getNext(): Int64;
begin
	Result := vTable^.getNext(this);
end;

function TTraceSweepInfo.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(this);
end;

function TTraceLogWriter.this: ITraceLogWriter;
begin
  Result := ITraceLogWriter(@FNullPtr);
end;

function TTraceLogWriter.isITraceLogWriterImpl: boolean;
begin
  Result := ITraceLogWriterImpl.isITraceLogWriterImpl(this);
end;

function TTraceLogWriter.asITraceLogWriterImpl: ITraceLogWriterImpl;
begin
  if isITraceLogWriterImpl then
    Result := FObject as ITraceLogWriterImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceLogWriterImpl']);
end;

procedure TTraceLogWriter.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TTraceLogWriter.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TTraceLogWriter.write(buf: Pointer; size: Cardinal): Cardinal;
begin
	Result := vTable^.write(this, buf, size);
end;

function TTraceLogWriter.write_s(status: IStatus; buf: Pointer; size: Cardinal): Cardinal;
begin
	Result := vTable^.write_s(this, status, buf, size);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTraceInitInfo.this: ITraceInitInfo;
begin
  Result := ITraceInitInfo(@FNullPtr);
end;

function TTraceInitInfo.isITraceInitInfoImpl: boolean;
begin
  Result := ITraceInitInfoImpl.isITraceInitInfoImpl(this);
end;

function TTraceInitInfo.asITraceInitInfoImpl: ITraceInitInfoImpl;
begin
  if isITraceInitInfoImpl then
    Result := FObject as ITraceInitInfoImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceInitInfoImpl']);
end;

function TTraceInitInfo.getConfigText(): PAnsiChar;
begin
	Result := vTable^.getConfigText(this);
end;

function TTraceInitInfo.getTraceSessionID(): Integer;
begin
	Result := vTable^.getTraceSessionID(this);
end;

function TTraceInitInfo.getTraceSessionName(): PAnsiChar;
begin
	Result := vTable^.getTraceSessionName(this);
end;

function TTraceInitInfo.getFirebirdRootDirectory(): PAnsiChar;
begin
	Result := vTable^.getFirebirdRootDirectory(this);
end;

function TTraceInitInfo.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(this);
end;

function TTraceInitInfo.getConnection(): ITraceDatabaseConnection;
begin
	Result := vTable^.getConnection(this);
end;

function TTraceInitInfo.getLogWriter(): ITraceLogWriter;
begin
	Result := vTable^.getLogWriter(this);
end;

function TTracePlugin.this: ITracePlugin;
begin
  Result := ITracePlugin(@FNullPtr);
end;

function TTracePlugin.isITracePluginImpl: boolean;
begin
  Result := ITracePluginImpl.isITracePluginImpl(this);
end;

function TTracePlugin.asITracePluginImpl: ITracePluginImpl;
begin
  if isITracePluginImpl then
    Result := FObject as ITracePluginImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITracePluginImpl']);
end;

procedure TTracePlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TTracePlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

function TTracePlugin.trace_get_error(): PAnsiChar;
begin
	Result := vTable^.trace_get_error(this);
end;

function TTracePlugin.trace_attach(connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_attach(this, connection, create_db, att_result);
end;

function TTracePlugin.trace_detach(connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean;
begin
	Result := vTable^.trace_detach(this, connection, drop_db);
end;

function TTracePlugin.trace_transaction_start(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_transaction_start(this, connection, transaction, tpb_length, tpb, tra_result);
end;

function TTracePlugin.trace_transaction_end(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_transaction_end(this, connection, transaction, commit, retain_context, tra_result);
end;

function TTracePlugin.trace_proc_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_proc_execute(this, connection, transaction, procedure_, started, proc_result);
end;

function TTracePlugin.trace_trigger_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_trigger_execute(this, connection, transaction, trigger, started, trig_result);
end;

function TTracePlugin.trace_set_context(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean;
begin
	Result := vTable^.trace_set_context(this, connection, transaction, variable);
end;

function TTracePlugin.trace_dsql_prepare(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_prepare(this, connection, transaction, statement, time_millis, req_result);
end;

function TTracePlugin.trace_dsql_free(connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_free(this, connection, statement, option);
end;

function TTracePlugin.trace_dsql_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_execute(this, connection, transaction, statement, started, req_result);
end;

function TTracePlugin.trace_blr_compile(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_blr_compile(this, connection, transaction, statement, time_millis, req_result);
end;

function TTracePlugin.trace_blr_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_blr_execute(this, connection, transaction, statement, req_result);
end;

function TTracePlugin.trace_dyn_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dyn_execute(this, connection, transaction, request, time_millis, req_result);
end;

function TTracePlugin.trace_service_attach(service: ITraceServiceConnection; att_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_attach(this, service, att_result);
end;

function TTracePlugin.trace_service_start(service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_start(this, service, switches_length, switches, start_result);
end;

function TTracePlugin.trace_service_query(service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_query(this, service, send_item_length, send_items, recv_item_length, recv_items, query_result);
end;

function TTracePlugin.trace_service_detach(service: ITraceServiceConnection; detach_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_detach(this, service, detach_result);
end;

function TTracePlugin.trace_event_error(connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean;
begin
	Result := vTable^.trace_event_error(this, connection, status, function_);
end;

function TTracePlugin.trace_event_sweep(connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean;
begin
	Result := vTable^.trace_event_sweep(this, connection, sweep, sweep_state);
end;

function TTracePlugin.trace_func_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_func_execute(this, connection, transaction, function_, started, func_result);
end;

function TTraceFactory.this: ITraceFactory;
begin
  Result := ITraceFactory(@FNullPtr);
end;

function TTraceFactory.isITraceFactoryImpl: boolean;
begin
  Result := ITraceFactoryImpl.isITraceFactoryImpl(this);
end;

function TTraceFactory.asITraceFactoryImpl: ITraceFactoryImpl;
begin
  if isITraceFactoryImpl then
    Result := FObject as ITraceFactoryImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['ITraceFactoryImpl']);
end;

procedure TTraceFactory.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TTraceFactory.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TTraceFactory.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TTraceFactory.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TTraceFactory.trace_needs(): QWord;
begin
	Result := vTable^.trace_needs(this);
end;

function TTraceFactory.trace_create(status: IStatus; init_info: ITraceInitInfo): ITracePlugin;
begin
	Result := vTable^.trace_create(this, status, init_info);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrFunctionFactory.this: IUdrFunctionFactory;
begin
  Result := IUdrFunctionFactory(@FNullPtr);
end;

function TUdrFunctionFactory.isIUdrFunctionFactoryImpl: boolean;
begin
  Result := IUdrFunctionFactoryImpl.isIUdrFunctionFactoryImpl(this);
end;

function TUdrFunctionFactory.asIUdrFunctionFactoryImpl: IUdrFunctionFactoryImpl;
begin
  if isIUdrFunctionFactoryImpl then
    Result := FObject as IUdrFunctionFactoryImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUdrFunctionFactoryImpl']);
end;

procedure TUdrFunctionFactory.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TUdrFunctionFactory.setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
begin
	vTable^.setup(this, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrFunctionFactory.newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction;
begin
	Result := vTable^.newItem(this, status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrProcedureFactory.this: IUdrProcedureFactory;
begin
  Result := IUdrProcedureFactory(@FNullPtr);
end;

function TUdrProcedureFactory.isIUdrProcedureFactoryImpl: boolean;
begin
  Result := IUdrProcedureFactoryImpl.isIUdrProcedureFactoryImpl(this);
end;

function TUdrProcedureFactory.asIUdrProcedureFactoryImpl: IUdrProcedureFactoryImpl;
begin
  if isIUdrProcedureFactoryImpl then
    Result := FObject as IUdrProcedureFactoryImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUdrProcedureFactoryImpl']);
end;

procedure TUdrProcedureFactory.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TUdrProcedureFactory.setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
begin
	vTable^.setup(this, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrProcedureFactory.newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure;
begin
	Result := vTable^.newItem(this, status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrTriggerFactory.this: IUdrTriggerFactory;
begin
  Result := IUdrTriggerFactory(@FNullPtr);
end;

function TUdrTriggerFactory.isIUdrTriggerFactoryImpl: boolean;
begin
  Result := IUdrTriggerFactoryImpl.isIUdrTriggerFactoryImpl(this);
end;

function TUdrTriggerFactory.asIUdrTriggerFactoryImpl: IUdrTriggerFactoryImpl;
begin
  if isIUdrTriggerFactoryImpl then
    Result := FObject as IUdrTriggerFactoryImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUdrTriggerFactoryImpl']);
end;

procedure TUdrTriggerFactory.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TUdrTriggerFactory.setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder);
begin
	vTable^.setup(this, status, context, metadata, fieldsBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrTriggerFactory.newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger;
begin
	Result := vTable^.newItem(this, status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrPlugin.this: IUdrPlugin;
begin
  Result := IUdrPlugin(@FNullPtr);
end;

function TUdrPlugin.isIUdrPluginImpl: boolean;
begin
  Result := IUdrPluginImpl.isIUdrPluginImpl(this);
end;

function TUdrPlugin.asIUdrPluginImpl: IUdrPluginImpl;
begin
  if isIUdrPluginImpl then
    Result := FObject as IUdrPluginImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IUdrPluginImpl']);
end;

function TUdrPlugin.getMaster(): IMaster;
begin
	Result := vTable^.getMaster(this);
end;

procedure TUdrPlugin.registerFunction(status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory);
begin
	vTable^.registerFunction(this, status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUdrPlugin.registerProcedure(status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory);
begin
	vTable^.registerProcedure(this, status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUdrPlugin.registerTrigger(status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory);
begin
	vTable^.registerTrigger(this, status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDecFloat16.this: IDecFloat16;
begin
  Result := IDecFloat16(@FNullPtr);
end;

function TDecFloat16.isIDecFloat16Impl: boolean;
begin
  Result := IDecFloat16Impl.isIDecFloat16Impl(this);
end;

function TDecFloat16.asIDecFloat16Impl: IDecFloat16Impl;
begin
  if isIDecFloat16Impl then
    Result := FObject as IDecFloat16Impl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDecFloat16Impl']);
end;

procedure TDecFloat16.toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
begin
	vTable^.toBcd(this, from, sign, bcd, exp);
end;

procedure TDecFloat16.toString(status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(this, status, from, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDecFloat16.fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr);
begin
	vTable^.fromBcd(this, sign, bcd, exp, to_);
end;

procedure TDecFloat16.fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr);
begin
	vTable^.fromString(this, status, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDecFloat34.this: IDecFloat34;
begin
  Result := IDecFloat34(@FNullPtr);
end;

function TDecFloat34.isIDecFloat34Impl: boolean;
begin
  Result := IDecFloat34Impl.isIDecFloat34Impl(this);
end;

function TDecFloat34.asIDecFloat34Impl: IDecFloat34Impl;
begin
  if isIDecFloat34Impl then
    Result := FObject as IDecFloat34Impl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IDecFloat34Impl']);
end;

procedure TDecFloat34.toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
begin
	vTable^.toBcd(this, from, sign, bcd, exp);
end;

procedure TDecFloat34.toString(status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(this, status, from, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDecFloat34.fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr);
begin
	vTable^.fromBcd(this, sign, bcd, exp, to_);
end;

procedure TDecFloat34.fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr);
begin
	vTable^.fromString(this, status, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TInt128.this: IInt128;
begin
  Result := IInt128(@FNullPtr);
end;

function TInt128.isIInt128Impl: boolean;
begin
  Result := IInt128Impl.isIInt128Impl(this);
end;

function TInt128.asIInt128Impl: IInt128Impl;
begin
  if isIInt128Impl then
    Result := FObject as IInt128Impl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IInt128Impl']);
end;

procedure TInt128.toString(status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(this, status, from, scale, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TInt128.fromString(status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr);
begin
	vTable^.fromString(this, status, scale, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicatedField.this: IReplicatedField;
begin
  Result := IReplicatedField(@FNullPtr);
end;

function TReplicatedField.isIReplicatedFieldImpl: boolean;
begin
  Result := IReplicatedFieldImpl.isIReplicatedFieldImpl(this);
end;

function TReplicatedField.asIReplicatedFieldImpl: IReplicatedFieldImpl;
begin
  if isIReplicatedFieldImpl then
    Result := FObject as IReplicatedFieldImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IReplicatedFieldImpl']);
end;

function TReplicatedField.getName(): PAnsiChar;
begin
	Result := vTable^.getName(this);
end;

function TReplicatedField.getType(): Cardinal;
begin
	Result := vTable^.getType(this);
end;

function TReplicatedField.getSubType(): Integer;
begin
	Result := vTable^.getSubType(this);
end;

function TReplicatedField.getScale(): Integer;
begin
	Result := vTable^.getScale(this);
end;

function TReplicatedField.getLength(): Cardinal;
begin
	Result := vTable^.getLength(this);
end;

function TReplicatedField.getCharSet(): Cardinal;
begin
	Result := vTable^.getCharSet(this);
end;

function TReplicatedField.getData(): Pointer;
begin
	Result := vTable^.getData(this);
end;

function TReplicatedRecord.this: IReplicatedRecord;
begin
  Result := IReplicatedRecord(@FNullPtr);
end;

function TReplicatedRecord.isIReplicatedRecordImpl: boolean;
begin
  Result := IReplicatedRecordImpl.isIReplicatedRecordImpl(this);
end;

function TReplicatedRecord.asIReplicatedRecordImpl: IReplicatedRecordImpl;
begin
  if isIReplicatedRecordImpl then
    Result := FObject as IReplicatedRecordImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IReplicatedRecordImpl']);
end;

function TReplicatedRecord.getCount(): Cardinal;
begin
	Result := vTable^.getCount(this);
end;

function TReplicatedRecord.getField(index: Cardinal): IReplicatedField;
begin
	Result := vTable^.getField(this, index);
end;

function TReplicatedRecord.getRawLength(): Cardinal;
begin
	Result := vTable^.getRawLength(this);
end;

function TReplicatedRecord.getRawData(): BytePtr;
begin
	Result := vTable^.getRawData(this);
end;

function TReplicatedTransaction.this: IReplicatedTransaction;
begin
  Result := IReplicatedTransaction(@FNullPtr);
end;

function TReplicatedTransaction.isIReplicatedTransactionImpl: boolean;
begin
  Result := IReplicatedTransactionImpl.isIReplicatedTransactionImpl(this);
end;

function TReplicatedTransaction.asIReplicatedTransactionImpl: IReplicatedTransactionImpl;
begin
  if isIReplicatedTransactionImpl then
    Result := FObject as IReplicatedTransactionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IReplicatedTransactionImpl']);
end;

procedure TReplicatedTransaction.dispose();
begin
	vTable^.dispose(IDisposable(this));
end;

procedure TReplicatedTransaction.prepare(status: IStatus);
begin
	vTable^.prepare(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.commit(status: IStatus);
begin
	vTable^.commit(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.rollback(status: IStatus);
begin
	vTable^.rollback(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.startSavepoint(status: IStatus);
begin
	vTable^.startSavepoint(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.releaseSavepoint(status: IStatus);
begin
	vTable^.releaseSavepoint(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.rollbackSavepoint(status: IStatus);
begin
	vTable^.rollbackSavepoint(this, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.insertRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
begin
	vTable^.insertRecord(this, status, name, record_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.updateRecord(status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord);
begin
	vTable^.updateRecord(this, status, name, orgRecord, newRecord);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.deleteRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
begin
	vTable^.deleteRecord(this, status, name, record_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.executeSql(status: IStatus; sql: PAnsiChar);
begin
	vTable^.executeSql(this, status, sql);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.executeSqlIntl(status: IStatus; charset: Cardinal; sql: PAnsiChar);
begin
	vTable^.executeSqlIntl(this, status, charset, sql);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicatedSession.this: IReplicatedSession;
begin
  Result := IReplicatedSession(@FNullPtr);
end;

function TReplicatedSession.isIReplicatedSessionImpl: boolean;
begin
  Result := IReplicatedSessionImpl.isIReplicatedSessionImpl(this);
end;

function TReplicatedSession.asIReplicatedSessionImpl: IReplicatedSessionImpl;
begin
  if isIReplicatedSessionImpl then
    Result := FObject as IReplicatedSessionImpl
  else
    raise FbException.CreateFmt(errNotImplementationObject,['IReplicatedSessionImpl']);
end;

procedure TReplicatedSession.addRef();
begin
	vTable^.addRef(IReferenceCounted(this));
end;

function TReplicatedSession.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(this));
end;

procedure TReplicatedSession.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(this), r);
end;

function TReplicatedSession.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(this));
end;

function TReplicatedSession.init(status: IStatus; attachment: IAttachment): Boolean;
begin
	Result := vTable^.init(this, status, attachment);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicatedSession.startTransaction(status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction;
begin
	Result := vTable^.startTransaction(this, status, transaction, number);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedSession.cleanupTransaction(status: IStatus; number: Int64);
begin
	vTable^.cleanupTransaction(this, status, number);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedSession.setSequence(status: IStatus; name: PAnsiChar; value: Int64);
begin
	vTable^.setSequence(this, status, name, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IVersionedImpl.asIVersioned:IVersioned;
begin
  Result := IVersioned(@FNullPtr);
end;

var IVersionedImpl_vTable: VersionedVTable = (
     NullPtr: nil;
     version: 0);

constructor IVersionedImpl.create;
begin
  inherited Create;
  FObject := self;
  FvTable := @IVersionedImpl_vTable;
end;

function IVersionedImpl.getVTable: PVersionedVTable;
begin
  Result := PVersionedVTable(FvTable);
end;

class function IVersionedImpl.isIVersionedImpl(intf: IVersioned): boolean;
begin
  Result := (intf.vTable = @IVersionedImpl_vTable) or
    IReferenceCountedImpl.isIReferenceCountedImpl(IReferenceCounted(intf)) or
    IDisposableImpl.isIDisposableImpl(IDisposable(intf)) or
    IMasterImpl.isIMasterImpl(IMaster(intf)) or
    IPluginFactoryImpl.isIPluginFactoryImpl(IPluginFactory(intf)) or
    IPluginModuleImpl.isIPluginModuleImpl(IPluginModule(intf)) or
    IPluginManagerImpl.isIPluginManagerImpl(IPluginManager(intf)) or
    ICryptKeyImpl.isICryptKeyImpl(ICryptKey(intf)) or
    IConfigManagerImpl.isIConfigManagerImpl(IConfigManager(intf)) or
    IDtcImpl.isIDtcImpl(IDtc(intf)) or
    IWriterImpl.isIWriterImpl(IWriter(intf)) or
    IServerBlockImpl.isIServerBlockImpl(IServerBlock(intf)) or
    IUserFieldImpl.isIUserFieldImpl(IUserField(intf)) or
    IUserImpl.isIUserImpl(IUser(intf)) or
    IListUsersImpl.isIListUsersImpl(IListUsers(intf)) or
    ILogonInfoImpl.isILogonInfoImpl(ILogonInfo(intf)) or
    IAuthBlockImpl.isIAuthBlockImpl(IAuthBlock(intf)) or
    ICryptKeyCallbackImpl.isICryptKeyCallbackImpl(ICryptKeyCallback(intf)) or
    IExternalContextImpl.isIExternalContextImpl(IExternalContext(intf)) or
    IRoutineMetadataImpl.isIRoutineMetadataImpl(IRoutineMetadata(intf)) or
    ITimerControlImpl.isITimerControlImpl(ITimerControl(intf)) or
    IVersionCallbackImpl.isIVersionCallbackImpl(IVersionCallback(intf)) or
    IUtilImpl.isIUtilImpl(IUtil(intf)) or
    IOffsetsCallbackImpl.isIOffsetsCallbackImpl(IOffsetsCallback(intf)) or
    ITraceConnectionImpl.isITraceConnectionImpl(ITraceConnection(intf)) or
    ITraceTransactionImpl.isITraceTransactionImpl(ITraceTransaction(intf)) or
    ITraceParamsImpl.isITraceParamsImpl(ITraceParams(intf)) or
    ITraceStatementImpl.isITraceStatementImpl(ITraceStatement(intf)) or
    ITraceDYNRequestImpl.isITraceDYNRequestImpl(ITraceDYNRequest(intf)) or
    ITraceContextVariableImpl.isITraceContextVariableImpl(ITraceContextVariable(intf)) or
    ITraceProcedureImpl.isITraceProcedureImpl(ITraceProcedure(intf)) or
    ITraceFunctionImpl.isITraceFunctionImpl(ITraceFunction(intf)) or
    ITraceTriggerImpl.isITraceTriggerImpl(ITraceTrigger(intf)) or
    ITraceStatusVectorImpl.isITraceStatusVectorImpl(ITraceStatusVector(intf)) or
    ITraceSweepInfoImpl.isITraceSweepInfoImpl(ITraceSweepInfo(intf)) or
    ITraceInitInfoImpl.isITraceInitInfoImpl(ITraceInitInfo(intf)) or
    IUdrPluginImpl.isIUdrPluginImpl(IUdrPlugin(intf)) or
    IDecFloat16Impl.isIDecFloat16Impl(IDecFloat16(intf)) or
    IDecFloat34Impl.isIDecFloat34Impl(IDecFloat34(intf)) or
    IInt128Impl.isIInt128Impl(IInt128(intf)) or
    IReplicatedFieldImpl.isIReplicatedFieldImpl(IReplicatedField(intf)) or
    IReplicatedRecordImpl.isIReplicatedRecordImpl(IReplicatedRecord(intf));
end;

function IReferenceCountedImpl.asIReferenceCounted:IReferenceCounted;
begin
  Result := IReferenceCounted(@FNullPtr);
end;

procedure IReferenceCountedImpl_addRefDispatcher(this: IReferenceCounted); cdecl;
begin
	try
		IReferenceCountedImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReferenceCountedImpl_releaseDispatcher(this: IReferenceCounted): Integer; cdecl;
begin
	try
		Result := IReferenceCountedImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IReferenceCountedImpl_vTable: ReferenceCountedVTable = (
     NullPtr: nil;
     version: 2;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher);

constructor IReferenceCountedImpl.create;
begin
  inherited Create;
  FvTable := @IReferenceCountedImpl_vTable;
end;

function IReferenceCountedImpl.getVTable: PReferenceCountedVTable;
begin
  Result := PReferenceCountedVTable(FvTable);
end;

class function IReferenceCountedImpl.isIReferenceCountedImpl(intf: IReferenceCounted): boolean;
begin
  Result := (intf.vTable = @IReferenceCountedImpl_vTable) or
    IPluginBaseImpl.isIPluginBaseImpl(IPluginBase(intf)) or
    IPluginSetImpl.isIPluginSetImpl(IPluginSet(intf)) or
    IConfigEntryImpl.isIConfigEntryImpl(IConfigEntry(intf)) or
    IConfigImpl.isIConfigImpl(IConfig(intf)) or
    IFirebirdConfImpl.isIFirebirdConfImpl(IFirebirdConf(intf)) or
    IPluginConfigImpl.isIPluginConfigImpl(IPluginConfig(intf)) or
    IEventCallbackImpl.isIEventCallbackImpl(IEventCallback(intf)) or
    IBlobImpl.isIBlobImpl(IBlob(intf)) or
    ITransactionImpl.isITransactionImpl(ITransaction(intf)) or
    IMessageMetadataImpl.isIMessageMetadataImpl(IMessageMetadata(intf)) or
    IMetadataBuilderImpl.isIMetadataBuilderImpl(IMetadataBuilder(intf)) or
    IResultSetImpl.isIResultSetImpl(IResultSet(intf)) or
    IStatementImpl.isIStatementImpl(IStatement(intf)) or
    IBatchImpl.isIBatchImpl(IBatch(intf)) or
    IReplicatorImpl.isIReplicatorImpl(IReplicator(intf)) or
    IRequestImpl.isIRequestImpl(IRequest(intf)) or
    IEventsImpl.isIEventsImpl(IEvents(intf)) or
    IAttachmentImpl.isIAttachmentImpl(IAttachment(intf)) or
    IServiceImpl.isIServiceImpl(IService(intf)) or
    IClientBlockImpl.isIClientBlockImpl(IClientBlock(intf)) or
    IDbCryptInfoImpl.isIDbCryptInfoImpl(IDbCryptInfo(intf)) or
    ITimerImpl.isITimerImpl(ITimer(intf)) or
    ITraceLogWriterImpl.isITraceLogWriterImpl(ITraceLogWriter(intf)) or
    ITracePluginImpl.isITracePluginImpl(ITracePlugin(intf));
end;

function IDisposableImpl.asIDisposable:IDisposable;
begin
  Result := IDisposable(@FNullPtr);
end;

procedure IDisposableImpl_disposeDispatcher(this: IDisposable); cdecl;
begin
	try
		IDisposableImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IDisposableImpl_vTable: DisposableVTable = (
     NullPtr: nil;
     version: 1;
     dispose: IDisposableImpl_disposeDispatcher);

constructor IDisposableImpl.create;
begin
  inherited Create;
  FvTable := @IDisposableImpl_vTable;
end;

function IDisposableImpl.getVTable: PDisposableVTable;
begin
  Result := PDisposableVTable(FvTable);
end;

class function IDisposableImpl.isIDisposableImpl(intf: IDisposable): boolean;
begin
  Result := (intf.vTable = @IDisposableImpl_vTable) or
    IStatusImpl.isIStatusImpl(IStatus(intf)) or
    IBatchCompletionStateImpl.isIBatchCompletionStateImpl(IBatchCompletionState(intf)) or
    IDtcStartImpl.isIDtcStartImpl(IDtcStart(intf)) or
    IExternalResultSetImpl.isIExternalResultSetImpl(IExternalResultSet(intf)) or
    IExternalFunctionImpl.isIExternalFunctionImpl(IExternalFunction(intf)) or
    IExternalProcedureImpl.isIExternalProcedureImpl(IExternalProcedure(intf)) or
    IExternalTriggerImpl.isIExternalTriggerImpl(IExternalTrigger(intf)) or
    IXpbBuilderImpl.isIXpbBuilderImpl(IXpbBuilder(intf)) or
    IUdrFunctionFactoryImpl.isIUdrFunctionFactoryImpl(IUdrFunctionFactory(intf)) or
    IUdrProcedureFactoryImpl.isIUdrProcedureFactoryImpl(IUdrProcedureFactory(intf)) or
    IUdrTriggerFactoryImpl.isIUdrTriggerFactoryImpl(IUdrTriggerFactory(intf)) or
    IReplicatedTransactionImpl.isIReplicatedTransactionImpl(IReplicatedTransaction(intf));
end;

function IStatusImpl.asIStatus:IStatus;
begin
  Result := IStatus(@FNullPtr);
end;

procedure IStatusImpl_disposeDispatcher(this: IStatus); cdecl;
begin
	try
		IStatusImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_initDispatcher(this: IStatus); cdecl;
begin
	try
		IStatusImpl(this.FObject).init();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getStateDispatcher(this: IStatus): Cardinal; cdecl;
begin
	try
		Result := IStatusImpl(this.FObject).getState();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setErrors2Dispatcher(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(this.FObject).setErrors2(length, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setWarnings2Dispatcher(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(this.FObject).setWarnings2(length, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setErrorsDispatcher(this: IStatus; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(this.FObject).setErrors(value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setWarningsDispatcher(this: IStatus; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(this.FObject).setWarnings(value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getErrorsDispatcher(this: IStatus): NativeIntPtr; cdecl;
begin
	try
		Result := IStatusImpl(this.FObject).getErrors();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getWarningsDispatcher(this: IStatus): NativeIntPtr; cdecl;
begin
	try
		Result := IStatusImpl(this.FObject).getWarnings();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_cloneDispatcher(this: IStatus): IStatus; cdecl;
begin
	try
		Result := IStatusImpl(this.FObject).clone();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IStatusImpl_vTable: StatusVTable = (
     NullPtr: nil;
     version: 10;
     dispose: IDisposableImpl_disposeDispatcher;
     init: IStatusImpl_initDispatcher;
     getState: IStatusImpl_getStateDispatcher;
     setErrors2: IStatusImpl_setErrors2Dispatcher;
     setWarnings2: IStatusImpl_setWarnings2Dispatcher;
     setErrors: IStatusImpl_setErrorsDispatcher;
     setWarnings: IStatusImpl_setWarningsDispatcher;
     getErrors: IStatusImpl_getErrorsDispatcher;
     getWarnings: IStatusImpl_getWarningsDispatcher;
     clone: IStatusImpl_cloneDispatcher);

constructor IStatusImpl.create;
begin
  inherited Create;
  FvTable := @IStatusImpl_vTable;
end;

function IStatusImpl.getVTable: PStatusVTable;
begin
  Result := PStatusVTable(FvTable);
end;

class function IStatusImpl.isIStatusImpl(intf: IStatus): boolean;
begin
  Result := (intf.vTable = @IStatusImpl_vTable);
end;

function IMasterImpl.asIMaster:IMaster;
begin
  Result := IMaster(@FNullPtr);
end;

function IMasterImpl_getStatusDispatcher(this: IMaster): IStatus; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getStatus();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getDispatcherDispatcher(this: IMaster): IProvider; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getDispatcher();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getPluginManagerDispatcher(this: IMaster): IPluginManager; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getPluginManager();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getTimerControlDispatcher(this: IMaster): ITimerControl; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getTimerControl();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getDtcDispatcher(this: IMaster): IDtc; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getDtc();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_registerAttachmentDispatcher(this: IMaster; provider: IProvider; attachment: IAttachment): IAttachment; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).registerAttachment(provider, attachment);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_registerTransactionDispatcher(this: IMaster; attachment: IAttachment; transaction: ITransaction): ITransaction; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).registerTransaction(attachment, transaction);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getMetadataBuilderDispatcher(this: IMaster; status: IStatus; fieldCount: Cardinal): IMetadataBuilder; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getMetadataBuilder(status, fieldCount);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMasterImpl_serverModeDispatcher(this: IMaster; mode: Integer): Integer; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).serverMode(mode);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getUtilInterfaceDispatcher(this: IMaster): IUtil; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getUtilInterface();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getConfigManagerDispatcher(this: IMaster): IConfigManager; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getConfigManager();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getProcessExitingDispatcher(this: IMaster): Boolean; cdecl;
begin
	try
		Result := IMasterImpl(this.FObject).getProcessExiting();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IMasterImpl_vTable: MasterVTable = (
     NullPtr: nil;
     version: 12;
     getStatus: IMasterImpl_getStatusDispatcher;
     getDispatcher: IMasterImpl_getDispatcherDispatcher;
     getPluginManager: IMasterImpl_getPluginManagerDispatcher;
     getTimerControl: IMasterImpl_getTimerControlDispatcher;
     getDtc: IMasterImpl_getDtcDispatcher;
     registerAttachment: IMasterImpl_registerAttachmentDispatcher;
     registerTransaction: IMasterImpl_registerTransactionDispatcher;
     getMetadataBuilder: IMasterImpl_getMetadataBuilderDispatcher;
     serverMode: IMasterImpl_serverModeDispatcher;
     getUtilInterface: IMasterImpl_getUtilInterfaceDispatcher;
     getConfigManager: IMasterImpl_getConfigManagerDispatcher;
     getProcessExiting: IMasterImpl_getProcessExitingDispatcher);

constructor IMasterImpl.create;
begin
  inherited Create;
  FvTable := @IMasterImpl_vTable;
end;

function IMasterImpl.getVTable: PMasterVTable;
begin
  Result := PMasterVTable(FvTable);
end;

class function IMasterImpl.isIMasterImpl(intf: IMaster): boolean;
begin
  Result := (intf.vTable = @IMasterImpl_vTable);
end;

function IPluginBaseImpl.asIPluginBase:IPluginBase;
begin
  Result := IPluginBase(@FNullPtr);
end;

procedure IPluginBaseImpl_addRefDispatcher(this: IPluginBase); cdecl;
begin
	try
		IPluginBaseImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginBaseImpl_releaseDispatcher(this: IPluginBase): Integer; cdecl;
begin
	try
		Result := IPluginBaseImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginBaseImpl_setOwnerDispatcher(this: IPluginBase; r: IReferenceCounted); cdecl;
begin
	try
		IPluginBaseImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginBaseImpl_getOwnerDispatcher(this: IPluginBase): IReferenceCounted; cdecl;
begin
	try
		Result := IPluginBaseImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IPluginBaseImpl_vTable: PluginBaseVTable = (
     NullPtr: nil;
     version: 4;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher);

constructor IPluginBaseImpl.create;
begin
  inherited Create;
  FvTable := @IPluginBaseImpl_vTable;
end;

function IPluginBaseImpl.getVTable: PPluginBaseVTable;
begin
  Result := PPluginBaseVTable(FvTable);
end;

class function IPluginBaseImpl.isIPluginBaseImpl(intf: IPluginBase): boolean;
begin
  Result := (intf.vTable = @IPluginBaseImpl_vTable) or
    IProviderImpl.isIProviderImpl(IProvider(intf)) or
    IAuthImpl.isIAuthImpl(IAuth(intf)) or
    IManagementImpl.isIManagementImpl(IManagement(intf)) or
    IWireCryptPluginImpl.isIWireCryptPluginImpl(IWireCryptPlugin(intf)) or
    IKeyHolderPluginImpl.isIKeyHolderPluginImpl(IKeyHolderPlugin(intf)) or
    IDbCryptPluginImpl.isIDbCryptPluginImpl(IDbCryptPlugin(intf)) or
    IExternalEngineImpl.isIExternalEngineImpl(IExternalEngine(intf)) or
    ITraceFactoryImpl.isITraceFactoryImpl(ITraceFactory(intf)) or
    IReplicatedSessionImpl.isIReplicatedSessionImpl(IReplicatedSession(intf));
end;

function IPluginSetImpl.asIPluginSet:IPluginSet;
begin
  Result := IPluginSet(@FNullPtr);
end;

procedure IPluginSetImpl_addRefDispatcher(this: IPluginSet); cdecl;
begin
	try
		IPluginSetImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_releaseDispatcher(this: IPluginSet): Integer; cdecl;
begin
	try
		Result := IPluginSetImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getNameDispatcher(this: IPluginSet): PAnsiChar; cdecl;
begin
	try
		Result := IPluginSetImpl(this.FObject).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getModuleNameDispatcher(this: IPluginSet): PAnsiChar; cdecl;
begin
	try
		Result := IPluginSetImpl(this.FObject).getModuleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getPluginDispatcher(this: IPluginSet; status: IStatus): IPluginBase; cdecl;
begin
	try
		Result := IPluginSetImpl(this.FObject).getPlugin(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginSetImpl_nextDispatcher(this: IPluginSet; status: IStatus); cdecl;
begin
	try
		IPluginSetImpl(this.FObject).next(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginSetImpl_set_Dispatcher(this: IPluginSet; status: IStatus; s: PAnsiChar); cdecl;
begin
	try
		IPluginSetImpl(this.FObject).set_(status, s);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IPluginSetImpl_vTable: PluginSetVTable = (
     NullPtr: nil;
     version: 7;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getName: IPluginSetImpl_getNameDispatcher;
     getModuleName: IPluginSetImpl_getModuleNameDispatcher;
     getPlugin: IPluginSetImpl_getPluginDispatcher;
     next: IPluginSetImpl_nextDispatcher;
     set_: IPluginSetImpl_set_Dispatcher);

constructor IPluginSetImpl.create;
begin
  inherited Create;
  FvTable := @IPluginSetImpl_vTable;
end;

function IPluginSetImpl.getVTable: PPluginSetVTable;
begin
  Result := PPluginSetVTable(FvTable);
end;

class function IPluginSetImpl.isIPluginSetImpl(intf: IPluginSet): boolean;
begin
  Result := (intf.vTable = @IPluginSetImpl_vTable);
end;

function IConfigEntryImpl.asIConfigEntry:IConfigEntry;
begin
  Result := IConfigEntry(@FNullPtr);
end;

procedure IConfigEntryImpl_addRefDispatcher(this: IConfigEntry); cdecl;
begin
	try
		IConfigEntryImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_releaseDispatcher(this: IConfigEntry): Integer; cdecl;
begin
	try
		Result := IConfigEntryImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getNameDispatcher(this: IConfigEntry): PAnsiChar; cdecl;
begin
	try
		Result := IConfigEntryImpl(this.FObject).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getValueDispatcher(this: IConfigEntry): PAnsiChar; cdecl;
begin
	try
		Result := IConfigEntryImpl(this.FObject).getValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getIntValueDispatcher(this: IConfigEntry): Int64; cdecl;
begin
	try
		Result := IConfigEntryImpl(this.FObject).getIntValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getBoolValueDispatcher(this: IConfigEntry): Boolean; cdecl;
begin
	try
		Result := IConfigEntryImpl(this.FObject).getBoolValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getSubConfigDispatcher(this: IConfigEntry; status: IStatus): IConfig; cdecl;
begin
	try
		Result := IConfigEntryImpl(this.FObject).getSubConfig(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IConfigEntryImpl_vTable: ConfigEntryVTable = (
     NullPtr: nil;
     version: 7;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getName: IConfigEntryImpl_getNameDispatcher;
     getValue: IConfigEntryImpl_getValueDispatcher;
     getIntValue: IConfigEntryImpl_getIntValueDispatcher;
     getBoolValue: IConfigEntryImpl_getBoolValueDispatcher;
     getSubConfig: IConfigEntryImpl_getSubConfigDispatcher);

constructor IConfigEntryImpl.create;
begin
  inherited Create;
  FvTable := @IConfigEntryImpl_vTable;
end;

function IConfigEntryImpl.getVTable: PConfigEntryVTable;
begin
  Result := PConfigEntryVTable(FvTable);
end;

class function IConfigEntryImpl.isIConfigEntryImpl(intf: IConfigEntry): boolean;
begin
  Result := (intf.vTable = @IConfigEntryImpl_vTable);
end;

function IConfigImpl.asIConfig:IConfig;
begin
  Result := IConfig(@FNullPtr);
end;

procedure IConfigImpl_addRefDispatcher(this: IConfig); cdecl;
begin
	try
		IConfigImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigImpl_releaseDispatcher(this: IConfig): Integer; cdecl;
begin
	try
		Result := IConfigImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigImpl_findDispatcher(this: IConfig; status: IStatus; name: PAnsiChar): IConfigEntry; cdecl;
begin
	try
		Result := IConfigImpl(this.FObject).find(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IConfigImpl_findValueDispatcher(this: IConfig; status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry; cdecl;
begin
	try
		Result := IConfigImpl(this.FObject).findValue(status, name, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IConfigImpl_findPosDispatcher(this: IConfig; status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry; cdecl;
begin
	try
		Result := IConfigImpl(this.FObject).findPos(status, name, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IConfigImpl_vTable: ConfigVTable = (
     NullPtr: nil;
     version: 5;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     find: IConfigImpl_findDispatcher;
     findValue: IConfigImpl_findValueDispatcher;
     findPos: IConfigImpl_findPosDispatcher);

constructor IConfigImpl.create;
begin
  inherited Create;
  FvTable := @IConfigImpl_vTable;
end;

function IConfigImpl.getVTable: PConfigVTable;
begin
  Result := PConfigVTable(FvTable);
end;

class function IConfigImpl.isIConfigImpl(intf: IConfig): boolean;
begin
  Result := (intf.vTable = @IConfigImpl_vTable);
end;

function IFirebirdConfImpl.asIFirebirdConf:IFirebirdConf;
begin
  Result := IFirebirdConf(@FNullPtr);
end;

procedure IFirebirdConfImpl_addRefDispatcher(this: IFirebirdConf); cdecl;
begin
	try
		IFirebirdConfImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_releaseDispatcher(this: IFirebirdConf): Integer; cdecl;
begin
	try
		Result := IFirebirdConfImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_getKeyDispatcher(this: IFirebirdConf; name: PAnsiChar): Cardinal; cdecl;
begin
	try
		Result := IFirebirdConfImpl(this.FObject).getKey(name);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asIntegerDispatcher(this: IFirebirdConf; key: Cardinal): Int64; cdecl;
begin
	try
		Result := IFirebirdConfImpl(this.FObject).asInteger(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asStringDispatcher(this: IFirebirdConf; key: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IFirebirdConfImpl(this.FObject).asString(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asBooleanDispatcher(this: IFirebirdConf; key: Cardinal): Boolean; cdecl;
begin
	try
		Result := IFirebirdConfImpl(this.FObject).asBoolean(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_getVersionDispatcher(this: IFirebirdConf; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IFirebirdConfImpl(this.FObject).getVersion(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IFirebirdConfImpl_vTable: FirebirdConfVTable = (
     NullPtr: nil;
     version: 7;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getKey: IFirebirdConfImpl_getKeyDispatcher;
     asInteger: IFirebirdConfImpl_asIntegerDispatcher;
     asString: IFirebirdConfImpl_asStringDispatcher;
     asBoolean: IFirebirdConfImpl_asBooleanDispatcher;
     getVersion: IFirebirdConfImpl_getVersionDispatcher);

constructor IFirebirdConfImpl.create;
begin
  inherited Create;
  FvTable := @IFirebirdConfImpl_vTable;
end;

function IFirebirdConfImpl.getVTable: PFirebirdConfVTable;
begin
  Result := PFirebirdConfVTable(FvTable);
end;

class function IFirebirdConfImpl.isIFirebirdConfImpl(intf: IFirebirdConf): boolean;
begin
  Result := (intf.vTable = @IFirebirdConfImpl_vTable);
end;

function IPluginConfigImpl.asIPluginConfig:IPluginConfig;
begin
  Result := IPluginConfig(@FNullPtr);
end;

procedure IPluginConfigImpl_addRefDispatcher(this: IPluginConfig); cdecl;
begin
	try
		IPluginConfigImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_releaseDispatcher(this: IPluginConfig): Integer; cdecl;
begin
	try
		Result := IPluginConfigImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_getConfigFileNameDispatcher(this: IPluginConfig): PAnsiChar; cdecl;
begin
	try
		Result := IPluginConfigImpl(this.FObject).getConfigFileName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_getDefaultConfigDispatcher(this: IPluginConfig; status: IStatus): IConfig; cdecl;
begin
	try
		Result := IPluginConfigImpl(this.FObject).getDefaultConfig(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IPluginConfigImpl_getFirebirdConfDispatcher(this: IPluginConfig; status: IStatus): IFirebirdConf; cdecl;
begin
	try
		Result := IPluginConfigImpl(this.FObject).getFirebirdConf(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginConfigImpl_setReleaseDelayDispatcher(this: IPluginConfig; status: IStatus; microSeconds: QWord); cdecl;
begin
	try
		IPluginConfigImpl(this.FObject).setReleaseDelay(status, microSeconds);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IPluginConfigImpl_vTable: PluginConfigVTable = (
     NullPtr: nil;
     version: 6;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getConfigFileName: IPluginConfigImpl_getConfigFileNameDispatcher;
     getDefaultConfig: IPluginConfigImpl_getDefaultConfigDispatcher;
     getFirebirdConf: IPluginConfigImpl_getFirebirdConfDispatcher;
     setReleaseDelay: IPluginConfigImpl_setReleaseDelayDispatcher);

constructor IPluginConfigImpl.create;
begin
  inherited Create;
  FvTable := @IPluginConfigImpl_vTable;
end;

function IPluginConfigImpl.getVTable: PPluginConfigVTable;
begin
  Result := PPluginConfigVTable(FvTable);
end;

class function IPluginConfigImpl.isIPluginConfigImpl(intf: IPluginConfig): boolean;
begin
  Result := (intf.vTable = @IPluginConfigImpl_vTable);
end;

function IPluginFactoryImpl.asIPluginFactory:IPluginFactory;
begin
  Result := IPluginFactory(@FNullPtr);
end;

function IPluginFactoryImpl_createPluginDispatcher(this: IPluginFactory; status: IStatus; factoryParameter: IPluginConfig): IPluginBase; cdecl;
begin
	try
		Result := IPluginFactoryImpl(this.FObject).createPlugin(status, factoryParameter);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IPluginFactoryImpl_vTable: PluginFactoryVTable = (
     NullPtr: nil;
     version: 1;
     createPlugin: IPluginFactoryImpl_createPluginDispatcher);

constructor IPluginFactoryImpl.create;
begin
  inherited Create;
  FvTable := @IPluginFactoryImpl_vTable;
end;

function IPluginFactoryImpl.getVTable: PPluginFactoryVTable;
begin
  Result := PPluginFactoryVTable(FvTable);
end;

class function IPluginFactoryImpl.isIPluginFactoryImpl(intf: IPluginFactory): boolean;
begin
  Result := (intf.vTable = @IPluginFactoryImpl_vTable);
end;

function IPluginModuleImpl.asIPluginModule:IPluginModule;
begin
  Result := IPluginModule(@FNullPtr);
end;

procedure IPluginModuleImpl_doCleanDispatcher(this: IPluginModule); cdecl;
begin
	try
		IPluginModuleImpl(this.FObject).doClean();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginModuleImpl_threadDetachDispatcher(this: IPluginModule); cdecl;
begin
	try
		IPluginModuleImpl(this.FObject).threadDetach();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IPluginModuleImpl_vTable: PluginModuleVTable = (
     NullPtr: nil;
     version: 2;
     doClean: IPluginModuleImpl_doCleanDispatcher;
     threadDetach: IPluginModuleImpl_threadDetachDispatcher);

constructor IPluginModuleImpl.create;
begin
  inherited Create;
  FvTable := @IPluginModuleImpl_vTable;
end;

function IPluginModuleImpl.getVTable: PPluginModuleVTable;
begin
  Result := PPluginModuleVTable(FvTable);
end;

class function IPluginModuleImpl.isIPluginModuleImpl(intf: IPluginModule): boolean;
begin
  Result := (intf.vTable = @IPluginModuleImpl_vTable);
end;

function IPluginManagerImpl.asIPluginManager:IPluginManager;
begin
  Result := IPluginManager(@FNullPtr);
end;

procedure IPluginManagerImpl_registerPluginFactoryDispatcher(this: IPluginManager; pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory); cdecl;
begin
	try
		IPluginManagerImpl(this.FObject).registerPluginFactory(pluginType, defaultName, factory);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginManagerImpl_registerModuleDispatcher(this: IPluginManager; cleanup: IPluginModule); cdecl;
begin
	try
		IPluginManagerImpl(this.FObject).registerModule(cleanup);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginManagerImpl_unregisterModuleDispatcher(this: IPluginManager; cleanup: IPluginModule); cdecl;
begin
	try
		IPluginManagerImpl(this.FObject).unregisterModule(cleanup);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginManagerImpl_getPluginsDispatcher(this: IPluginManager; status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet; cdecl;
begin
	try
		Result := IPluginManagerImpl(this.FObject).getPlugins(status, pluginType, namesList, firebirdConf);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IPluginManagerImpl_getConfigDispatcher(this: IPluginManager; status: IStatus; filename: PAnsiChar): IConfig; cdecl;
begin
	try
		Result := IPluginManagerImpl(this.FObject).getConfig(status, filename);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginManagerImpl_releasePluginDispatcher(this: IPluginManager; plugin: IPluginBase); cdecl;
begin
	try
		IPluginManagerImpl(this.FObject).releasePlugin(plugin);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IPluginManagerImpl_vTable: PluginManagerVTable = (
     NullPtr: nil;
     version: 6;
     registerPluginFactory: IPluginManagerImpl_registerPluginFactoryDispatcher;
     registerModule: IPluginManagerImpl_registerModuleDispatcher;
     unregisterModule: IPluginManagerImpl_unregisterModuleDispatcher;
     getPlugins: IPluginManagerImpl_getPluginsDispatcher;
     getConfig: IPluginManagerImpl_getConfigDispatcher;
     releasePlugin: IPluginManagerImpl_releasePluginDispatcher);

constructor IPluginManagerImpl.create;
begin
  inherited Create;
  FvTable := @IPluginManagerImpl_vTable;
end;

function IPluginManagerImpl.getVTable: PPluginManagerVTable;
begin
  Result := PPluginManagerVTable(FvTable);
end;

class function IPluginManagerImpl.isIPluginManagerImpl(intf: IPluginManager): boolean;
begin
  Result := (intf.vTable = @IPluginManagerImpl_vTable);
end;

function ICryptKeyImpl.asICryptKey:ICryptKey;
begin
  Result := ICryptKey(@FNullPtr);
end;

procedure ICryptKeyImpl_setSymmetricDispatcher(this: ICryptKey; status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); cdecl;
begin
	try
		ICryptKeyImpl(this.FObject).setSymmetric(status, type_, keyLength, key);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ICryptKeyImpl_setAsymmetricDispatcher(this: ICryptKey; status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); cdecl;
begin
	try
		ICryptKeyImpl(this.FObject).setAsymmetric(status, type_, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ICryptKeyImpl_getEncryptKeyDispatcher(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
begin
	try
		Result := ICryptKeyImpl(this.FObject).getEncryptKey(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ICryptKeyImpl_getDecryptKeyDispatcher(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
begin
	try
		Result := ICryptKeyImpl(this.FObject).getDecryptKey(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ICryptKeyImpl_vTable: CryptKeyVTable = (
     NullPtr: nil;
     version: 4;
     setSymmetric: ICryptKeyImpl_setSymmetricDispatcher;
     setAsymmetric: ICryptKeyImpl_setAsymmetricDispatcher;
     getEncryptKey: ICryptKeyImpl_getEncryptKeyDispatcher;
     getDecryptKey: ICryptKeyImpl_getDecryptKeyDispatcher);

constructor ICryptKeyImpl.create;
begin
  inherited Create;
  FvTable := @ICryptKeyImpl_vTable;
end;

function ICryptKeyImpl.getVTable: PCryptKeyVTable;
begin
  Result := PCryptKeyVTable(FvTable);
end;

class function ICryptKeyImpl.isICryptKeyImpl(intf: ICryptKey): boolean;
begin
  Result := (intf.vTable = @ICryptKeyImpl_vTable);
end;

function IConfigManagerImpl.asIConfigManager:IConfigManager;
begin
  Result := IConfigManager(@FNullPtr);
end;

function IConfigManagerImpl_getDirectoryDispatcher(this: IConfigManager; code: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getDirectory(code);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getFirebirdConfDispatcher(this: IConfigManager): IFirebirdConf; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getFirebirdConf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getDatabaseConfDispatcher(this: IConfigManager; dbName: PAnsiChar): IFirebirdConf; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getDatabaseConf(dbName);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getPluginConfigDispatcher(this: IConfigManager; configuredPlugin: PAnsiChar): IConfig; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getPluginConfig(configuredPlugin);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getInstallDirectoryDispatcher(this: IConfigManager): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getInstallDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getRootDirectoryDispatcher(this: IConfigManager): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getRootDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getDefaultSecurityDbDispatcher(this: IConfigManager): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(this.FObject).getDefaultSecurityDb();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IConfigManagerImpl_vTable: ConfigManagerVTable = (
     NullPtr: nil;
     version: 7;
     getDirectory: IConfigManagerImpl_getDirectoryDispatcher;
     getFirebirdConf: IConfigManagerImpl_getFirebirdConfDispatcher;
     getDatabaseConf: IConfigManagerImpl_getDatabaseConfDispatcher;
     getPluginConfig: IConfigManagerImpl_getPluginConfigDispatcher;
     getInstallDirectory: IConfigManagerImpl_getInstallDirectoryDispatcher;
     getRootDirectory: IConfigManagerImpl_getRootDirectoryDispatcher;
     getDefaultSecurityDb: IConfigManagerImpl_getDefaultSecurityDbDispatcher);

constructor IConfigManagerImpl.create;
begin
  inherited Create;
  FvTable := @IConfigManagerImpl_vTable;
end;

function IConfigManagerImpl.getVTable: PConfigManagerVTable;
begin
  Result := PConfigManagerVTable(FvTable);
end;

class function IConfigManagerImpl.isIConfigManagerImpl(intf: IConfigManager): boolean;
begin
  Result := (intf.vTable = @IConfigManagerImpl_vTable);
end;

function IEventCallbackImpl.asIEventCallback:IEventCallback;
begin
  Result := IEventCallback(@FNullPtr);
end;

procedure IEventCallbackImpl_addRefDispatcher(this: IEventCallback); cdecl;
begin
	try
		IEventCallbackImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IEventCallbackImpl_releaseDispatcher(this: IEventCallback): Integer; cdecl;
begin
	try
		Result := IEventCallbackImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IEventCallbackImpl_eventCallbackFunctionDispatcher(this: IEventCallback; length: Cardinal; events: BytePtr); cdecl;
begin
	try
		IEventCallbackImpl(this.FObject).eventCallbackFunction(length, events);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IEventCallbackImpl_vTable: EventCallbackVTable = (
     NullPtr: nil;
     version: 3;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     eventCallbackFunction: IEventCallbackImpl_eventCallbackFunctionDispatcher);

constructor IEventCallbackImpl.create;
begin
  inherited Create;
  FvTable := @IEventCallbackImpl_vTable;
end;

function IEventCallbackImpl.getVTable: PEventCallbackVTable;
begin
  Result := PEventCallbackVTable(FvTable);
end;

class function IEventCallbackImpl.isIEventCallbackImpl(intf: IEventCallback): boolean;
begin
  Result := (intf.vTable = @IEventCallbackImpl_vTable);
end;

function IBlobImpl.asIBlob:IBlob;
begin
  Result := IBlob(@FNullPtr);
end;

procedure IBlobImpl_addRefDispatcher(this: IBlob); cdecl;
begin
	try
		IBlobImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBlobImpl_releaseDispatcher(this: IBlob): Integer; cdecl;
begin
	try
		Result := IBlobImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IBlobImpl_getInfoDispatcher(this: IBlob; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IBlobImpl(this.FObject).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBlobImpl_getSegmentDispatcher(this: IBlob; status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; cdecl;
begin
	try
		Result := IBlobImpl(this.FObject).getSegment(status, bufferLength, buffer, segmentLength);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_putSegmentDispatcher(this: IBlob; status: IStatus; length: Cardinal; buffer: Pointer); cdecl;
begin
	try
		IBlobImpl(this.FObject).putSegment(status, length, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_cancelDispatcher(this: IBlob; status: IStatus); cdecl;
begin
	try
		IBlobImpl(this.FObject).cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_closeDispatcher(this: IBlob; status: IStatus); cdecl;
begin
	try
		IBlobImpl(this.FObject).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBlobImpl_seekDispatcher(this: IBlob; status: IStatus; mode: Integer; offset: Integer): Integer; cdecl;
begin
	try
		Result := IBlobImpl(this.FObject).seek(status, mode, offset);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IBlobImpl_vTable: BlobVTable = (
     NullPtr: nil;
     version: 8;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getInfo: IBlobImpl_getInfoDispatcher;
     getSegment: IBlobImpl_getSegmentDispatcher;
     putSegment: IBlobImpl_putSegmentDispatcher;
     cancel: IBlobImpl_cancelDispatcher;
     close: IBlobImpl_closeDispatcher;
     seek: IBlobImpl_seekDispatcher);

constructor IBlobImpl.create;
begin
  inherited Create;
  FvTable := @IBlobImpl_vTable;
end;

function IBlobImpl.getVTable: PBlobVTable;
begin
  Result := PBlobVTable(FvTable);
end;

class function IBlobImpl.isIBlobImpl(intf: IBlob): boolean;
begin
  Result := (intf.vTable = @IBlobImpl_vTable);
end;

function ITransactionImpl.asITransaction:ITransaction;
begin
  Result := ITransaction(@FNullPtr);
end;

procedure ITransactionImpl_addRefDispatcher(this: ITransaction); cdecl;
begin
	try
		ITransactionImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITransactionImpl_releaseDispatcher(this: ITransaction): Integer; cdecl;
begin
	try
		Result := ITransactionImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITransactionImpl_getInfoDispatcher(this: ITransaction; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		ITransactionImpl(this.FObject).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_prepareDispatcher(this: ITransaction; status: IStatus; msgLength: Cardinal; message: BytePtr); cdecl;
begin
	try
		ITransactionImpl(this.FObject).prepare(status, msgLength, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_commitDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		ITransactionImpl(this.FObject).commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_commitRetainingDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		ITransactionImpl(this.FObject).commitRetaining(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_rollbackDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		ITransactionImpl(this.FObject).rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_rollbackRetainingDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		ITransactionImpl(this.FObject).rollbackRetaining(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_disconnectDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		ITransactionImpl(this.FObject).disconnect(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_joinDispatcher(this: ITransaction; status: IStatus; transaction: ITransaction): ITransaction; cdecl;
begin
	try
		Result := ITransactionImpl(this.FObject).join(status, transaction);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_validateDispatcher(this: ITransaction; status: IStatus; attachment: IAttachment): ITransaction; cdecl;
begin
	try
		Result := ITransactionImpl(this.FObject).validate(status, attachment);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_enterDtcDispatcher(this: ITransaction; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := ITransactionImpl(this.FObject).enterDtc(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITransactionImpl_vTable: TransactionVTable = (
     NullPtr: nil;
     version: 12;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getInfo: ITransactionImpl_getInfoDispatcher;
     prepare: ITransactionImpl_prepareDispatcher;
     commit: ITransactionImpl_commitDispatcher;
     commitRetaining: ITransactionImpl_commitRetainingDispatcher;
     rollback: ITransactionImpl_rollbackDispatcher;
     rollbackRetaining: ITransactionImpl_rollbackRetainingDispatcher;
     disconnect: ITransactionImpl_disconnectDispatcher;
     join: ITransactionImpl_joinDispatcher;
     validate: ITransactionImpl_validateDispatcher;
     enterDtc: ITransactionImpl_enterDtcDispatcher);

constructor ITransactionImpl.create;
begin
  inherited Create;
  FvTable := @ITransactionImpl_vTable;
end;

function ITransactionImpl.getVTable: PTransactionVTable;
begin
  Result := PTransactionVTable(FvTable);
end;

class function ITransactionImpl.isITransactionImpl(intf: ITransaction): boolean;
begin
  Result := (intf.vTable = @ITransactionImpl_vTable);
end;

function IMessageMetadataImpl.asIMessageMetadata:IMessageMetadata;
begin
  Result := IMessageMetadata(@FNullPtr);
end;

procedure IMessageMetadataImpl_addRefDispatcher(this: IMessageMetadata); cdecl;
begin
	try
		IMessageMetadataImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMessageMetadataImpl_releaseDispatcher(this: IMessageMetadata): Integer; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMessageMetadataImpl_getCountDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getCount(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getFieldDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getField(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getRelationDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getRelation(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getOwnerDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getOwner(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAliasDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getAlias(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getTypeDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getType(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_isNullableDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Boolean; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).isNullable(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getSubTypeDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getSubType(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getLengthDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getLength(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getScaleDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getScale(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getCharSetDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getCharSet(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getOffsetDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getOffset(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getNullOffsetDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getNullOffset(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getBuilderDispatcher(this: IMessageMetadata; status: IStatus): IMetadataBuilder; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getBuilder(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getMessageLengthDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getMessageLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAlignmentDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getAlignment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAlignedLengthDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(this.FObject).getAlignedLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IMessageMetadataImpl_vTable: MessageMetadataVTable = (
     NullPtr: nil;
     version: 19;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getCount: IMessageMetadataImpl_getCountDispatcher;
     getField: IMessageMetadataImpl_getFieldDispatcher;
     getRelation: IMessageMetadataImpl_getRelationDispatcher;
     getOwner: IMessageMetadataImpl_getOwnerDispatcher;
     getAlias: IMessageMetadataImpl_getAliasDispatcher;
     getType: IMessageMetadataImpl_getTypeDispatcher;
     isNullable: IMessageMetadataImpl_isNullableDispatcher;
     getSubType: IMessageMetadataImpl_getSubTypeDispatcher;
     getLength: IMessageMetadataImpl_getLengthDispatcher;
     getScale: IMessageMetadataImpl_getScaleDispatcher;
     getCharSet: IMessageMetadataImpl_getCharSetDispatcher;
     getOffset: IMessageMetadataImpl_getOffsetDispatcher;
     getNullOffset: IMessageMetadataImpl_getNullOffsetDispatcher;
     getBuilder: IMessageMetadataImpl_getBuilderDispatcher;
     getMessageLength: IMessageMetadataImpl_getMessageLengthDispatcher;
     getAlignment: IMessageMetadataImpl_getAlignmentDispatcher;
     getAlignedLength: IMessageMetadataImpl_getAlignedLengthDispatcher);

constructor IMessageMetadataImpl.create;
begin
  inherited Create;
  FvTable := @IMessageMetadataImpl_vTable;
end;

function IMessageMetadataImpl.getVTable: PMessageMetadataVTable;
begin
  Result := PMessageMetadataVTable(FvTable);
end;

class function IMessageMetadataImpl.isIMessageMetadataImpl(intf: IMessageMetadata): boolean;
begin
  Result := (intf.vTable = @IMessageMetadataImpl_vTable);
end;

function IMetadataBuilderImpl.asIMetadataBuilder:IMetadataBuilder;
begin
  Result := IMetadataBuilder(@FNullPtr);
end;

procedure IMetadataBuilderImpl_addRefDispatcher(this: IMetadataBuilder); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMetadataBuilderImpl_releaseDispatcher(this: IMetadataBuilder): Integer; cdecl;
begin
	try
		Result := IMetadataBuilderImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IMetadataBuilderImpl_setTypeDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; type_: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setType(status, index, type_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setSubTypeDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; subType: Integer); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setSubType(status, index, subType);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setLengthDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; length: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setLength(status, index, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setCharSetDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; charSet: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setCharSet(status, index, charSet);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setScaleDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; scale: Integer); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setScale(status, index, scale);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_truncateDispatcher(this: IMetadataBuilder; status: IStatus; count: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).truncate(status, count);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_moveNameToIndexDispatcher(this: IMetadataBuilder; status: IStatus; name: PAnsiChar; index: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).moveNameToIndex(status, name, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_removeDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).remove(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMetadataBuilderImpl_addFieldDispatcher(this: IMetadataBuilder; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IMetadataBuilderImpl(this.FObject).addField(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMetadataBuilderImpl_getMetadataDispatcher(this: IMetadataBuilder; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IMetadataBuilderImpl(this.FObject).getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setFieldDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; field: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setField(status, index, field);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setRelationDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; relation: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setRelation(status, index, relation);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setOwnerDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; owner: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setOwner(status, index, owner);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setAliasDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; alias: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(this.FObject).setAlias(status, index, alias);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IMetadataBuilderImpl_vTable: MetadataBuilderVTable = (
     NullPtr: nil;
     version: 16;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setType: IMetadataBuilderImpl_setTypeDispatcher;
     setSubType: IMetadataBuilderImpl_setSubTypeDispatcher;
     setLength: IMetadataBuilderImpl_setLengthDispatcher;
     setCharSet: IMetadataBuilderImpl_setCharSetDispatcher;
     setScale: IMetadataBuilderImpl_setScaleDispatcher;
     truncate: IMetadataBuilderImpl_truncateDispatcher;
     moveNameToIndex: IMetadataBuilderImpl_moveNameToIndexDispatcher;
     remove: IMetadataBuilderImpl_removeDispatcher;
     addField: IMetadataBuilderImpl_addFieldDispatcher;
     getMetadata: IMetadataBuilderImpl_getMetadataDispatcher;
     setField: IMetadataBuilderImpl_setFieldDispatcher;
     setRelation: IMetadataBuilderImpl_setRelationDispatcher;
     setOwner: IMetadataBuilderImpl_setOwnerDispatcher;
     setAlias: IMetadataBuilderImpl_setAliasDispatcher);

constructor IMetadataBuilderImpl.create;
begin
  inherited Create;
  FvTable := @IMetadataBuilderImpl_vTable;
end;

function IMetadataBuilderImpl.getVTable: PMetadataBuilderVTable;
begin
  Result := PMetadataBuilderVTable(FvTable);
end;

class function IMetadataBuilderImpl.isIMetadataBuilderImpl(intf: IMetadataBuilder): boolean;
begin
  Result := (intf.vTable = @IMetadataBuilderImpl_vTable);
end;

function IResultSetImpl.asIResultSet:IResultSet;
begin
  Result := IResultSet(@FNullPtr);
end;

procedure IResultSetImpl_addRefDispatcher(this: IResultSet); cdecl;
begin
	try
		IResultSetImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IResultSetImpl_releaseDispatcher(this: IResultSet): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IResultSetImpl_fetchNextDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).fetchNext(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchPriorDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).fetchPrior(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchFirstDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).fetchFirst(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchLastDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).fetchLast(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchAbsoluteDispatcher(this: IResultSet; status: IStatus; position: Integer; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).fetchAbsolute(status, position, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchRelativeDispatcher(this: IResultSet; status: IStatus; offset: Integer; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).fetchRelative(status, offset, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_isEofDispatcher(this: IResultSet; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).isEof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_isBofDispatcher(this: IResultSet; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).isBof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_getMetadataDispatcher(this: IResultSet; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IResultSetImpl(this.FObject).getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IResultSetImpl_closeDispatcher(this: IResultSet; status: IStatus); cdecl;
begin
	try
		IResultSetImpl(this.FObject).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IResultSetImpl_setDelayedOutputFormatDispatcher(this: IResultSet; status: IStatus; format: IMessageMetadata); cdecl;
begin
	try
		IResultSetImpl(this.FObject).setDelayedOutputFormat(status, format);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IResultSetImpl_vTable: ResultSetVTable = (
     NullPtr: nil;
     version: 13;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     fetchNext: IResultSetImpl_fetchNextDispatcher;
     fetchPrior: IResultSetImpl_fetchPriorDispatcher;
     fetchFirst: IResultSetImpl_fetchFirstDispatcher;
     fetchLast: IResultSetImpl_fetchLastDispatcher;
     fetchAbsolute: IResultSetImpl_fetchAbsoluteDispatcher;
     fetchRelative: IResultSetImpl_fetchRelativeDispatcher;
     isEof: IResultSetImpl_isEofDispatcher;
     isBof: IResultSetImpl_isBofDispatcher;
     getMetadata: IResultSetImpl_getMetadataDispatcher;
     close: IResultSetImpl_closeDispatcher;
     setDelayedOutputFormat: IResultSetImpl_setDelayedOutputFormatDispatcher);

constructor IResultSetImpl.create;
begin
  inherited Create;
  FvTable := @IResultSetImpl_vTable;
end;

function IResultSetImpl.getVTable: PResultSetVTable;
begin
  Result := PResultSetVTable(FvTable);
end;

class function IResultSetImpl.isIResultSetImpl(intf: IResultSet): boolean;
begin
  Result := (intf.vTable = @IResultSetImpl_vTable);
end;

function IStatementImpl.asIStatement:IStatement;
begin
  Result := IStatement(@FNullPtr);
end;

procedure IStatementImpl_addRefDispatcher(this: IStatement); cdecl;
begin
	try
		IStatementImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatementImpl_releaseDispatcher(this: IStatement): Integer; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatementImpl_getInfoDispatcher(this: IStatement; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IStatementImpl(this.FObject).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getTypeDispatcher(this: IStatement; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getType(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getPlanDispatcher(this: IStatement; status: IStatus; detailed: Boolean): PAnsiChar; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getPlan(status, detailed);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getAffectedRecordsDispatcher(this: IStatement; status: IStatus): QWord; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getAffectedRecords(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getInputMetadataDispatcher(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getInputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getOutputMetadataDispatcher(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getOutputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_executeDispatcher(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).execute(status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_openCursorDispatcher(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).openCursor(status, transaction, inMetadata, inBuffer, outMetadata, flags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_setCursorNameDispatcher(this: IStatement; status: IStatus; name: PAnsiChar); cdecl;
begin
	try
		IStatementImpl(this.FObject).setCursorName(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_freeDispatcher(this: IStatement; status: IStatus); cdecl;
begin
	try
		IStatementImpl(this.FObject).free(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getFlagsDispatcher(this: IStatement; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getFlags(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getTimeoutDispatcher(this: IStatement; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).getTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_setTimeoutDispatcher(this: IStatement; status: IStatus; timeOut: Cardinal); cdecl;
begin
	try
		IStatementImpl(this.FObject).setTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_createBatchDispatcher(this: IStatement; status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
begin
	try
		Result := IStatementImpl(this.FObject).createBatch(status, inMetadata, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IStatementImpl_vTable: StatementVTable = (
     NullPtr: nil;
     version: 16;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getInfo: IStatementImpl_getInfoDispatcher;
     getType: IStatementImpl_getTypeDispatcher;
     getPlan: IStatementImpl_getPlanDispatcher;
     getAffectedRecords: IStatementImpl_getAffectedRecordsDispatcher;
     getInputMetadata: IStatementImpl_getInputMetadataDispatcher;
     getOutputMetadata: IStatementImpl_getOutputMetadataDispatcher;
     execute: IStatementImpl_executeDispatcher;
     openCursor: IStatementImpl_openCursorDispatcher;
     setCursorName: IStatementImpl_setCursorNameDispatcher;
     free: IStatementImpl_freeDispatcher;
     getFlags: IStatementImpl_getFlagsDispatcher;
     getTimeout: IStatementImpl_getTimeoutDispatcher;
     setTimeout: IStatementImpl_setTimeoutDispatcher;
     createBatch: IStatementImpl_createBatchDispatcher);

constructor IStatementImpl.create;
begin
  inherited Create;
  FvTable := @IStatementImpl_vTable;
end;

function IStatementImpl.getVTable: PStatementVTable;
begin
  Result := PStatementVTable(FvTable);
end;

class function IStatementImpl.isIStatementImpl(intf: IStatement): boolean;
begin
  Result := (intf.vTable = @IStatementImpl_vTable);
end;

function IBatchImpl.asIBatch:IBatch;
begin
  Result := IBatch(@FNullPtr);
end;

procedure IBatchImpl_addRefDispatcher(this: IBatch); cdecl;
begin
	try
		IBatchImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBatchImpl_releaseDispatcher(this: IBatch): Integer; cdecl;
begin
	try
		Result := IBatchImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IBatchImpl_addDispatcher(this: IBatch; status: IStatus; count: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		IBatchImpl(this.FObject).add(status, count, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_addBlobDispatcher(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); cdecl;
begin
	try
		IBatchImpl(this.FObject).addBlob(status, length, inBuffer, blobId, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_appendBlobDataDispatcher(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		IBatchImpl(this.FObject).appendBlobData(status, length, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_addBlobStreamDispatcher(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		IBatchImpl(this.FObject).addBlobStream(status, length, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_registerBlobDispatcher(this: IBatch; status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); cdecl;
begin
	try
		IBatchImpl(this.FObject).registerBlob(status, existingBlob, blobId);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_executeDispatcher(this: IBatch; status: IStatus; transaction: ITransaction): IBatchCompletionState; cdecl;
begin
	try
		Result := IBatchImpl(this.FObject).execute(status, transaction);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_cancelDispatcher(this: IBatch; status: IStatus); cdecl;
begin
	try
		IBatchImpl(this.FObject).cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_getBlobAlignmentDispatcher(this: IBatch; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IBatchImpl(this.FObject).getBlobAlignment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_getMetadataDispatcher(this: IBatch; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IBatchImpl(this.FObject).getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_setDefaultBpbDispatcher(this: IBatch; status: IStatus; parLength: Cardinal; par: BytePtr); cdecl;
begin
	try
		IBatchImpl(this.FObject).setDefaultBpb(status, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_closeDispatcher(this: IBatch; status: IStatus); cdecl;
begin
	try
		IBatchImpl(this.FObject).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IBatchImpl_vTable: BatchVTable = (
     NullPtr: nil;
     version: 13;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     add: IBatchImpl_addDispatcher;
     addBlob: IBatchImpl_addBlobDispatcher;
     appendBlobData: IBatchImpl_appendBlobDataDispatcher;
     addBlobStream: IBatchImpl_addBlobStreamDispatcher;
     registerBlob: IBatchImpl_registerBlobDispatcher;
     execute: IBatchImpl_executeDispatcher;
     cancel: IBatchImpl_cancelDispatcher;
     getBlobAlignment: IBatchImpl_getBlobAlignmentDispatcher;
     getMetadata: IBatchImpl_getMetadataDispatcher;
     setDefaultBpb: IBatchImpl_setDefaultBpbDispatcher;
     close: IBatchImpl_closeDispatcher);

constructor IBatchImpl.create;
begin
  inherited Create;
  FvTable := @IBatchImpl_vTable;
end;

function IBatchImpl.getVTable: PBatchVTable;
begin
  Result := PBatchVTable(FvTable);
end;

class function IBatchImpl.isIBatchImpl(intf: IBatch): boolean;
begin
  Result := (intf.vTable = @IBatchImpl_vTable);
end;

function IBatchCompletionStateImpl.asIBatchCompletionState:IBatchCompletionState;
begin
  Result := IBatchCompletionState(@FNullPtr);
end;

procedure IBatchCompletionStateImpl_disposeDispatcher(this: IBatchCompletionState); cdecl;
begin
	try
		IBatchCompletionStateImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBatchCompletionStateImpl_getSizeDispatcher(this: IBatchCompletionState; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IBatchCompletionStateImpl(this.FObject).getSize(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchCompletionStateImpl_getStateDispatcher(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Integer; cdecl;
begin
	try
		Result := IBatchCompletionStateImpl(this.FObject).getState(status, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchCompletionStateImpl_findErrorDispatcher(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IBatchCompletionStateImpl(this.FObject).findError(status, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchCompletionStateImpl_getStatusDispatcher(this: IBatchCompletionState; status: IStatus; to_: IStatus; pos: Cardinal); cdecl;
begin
	try
		IBatchCompletionStateImpl(this.FObject).getStatus(status, to_, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IBatchCompletionStateImpl_vTable: BatchCompletionStateVTable = (
     NullPtr: nil;
     version: 5;
     dispose: IDisposableImpl_disposeDispatcher;
     getSize: IBatchCompletionStateImpl_getSizeDispatcher;
     getState: IBatchCompletionStateImpl_getStateDispatcher;
     findError: IBatchCompletionStateImpl_findErrorDispatcher;
     getStatus: IBatchCompletionStateImpl_getStatusDispatcher);

constructor IBatchCompletionStateImpl.create;
begin
  inherited Create;
  FvTable := @IBatchCompletionStateImpl_vTable;
end;

function IBatchCompletionStateImpl.getVTable: PBatchCompletionStateVTable;
begin
  Result := PBatchCompletionStateVTable(FvTable);
end;

class function IBatchCompletionStateImpl.isIBatchCompletionStateImpl(intf: IBatchCompletionState): boolean;
begin
  Result := (intf.vTable = @IBatchCompletionStateImpl_vTable);
end;

function IReplicatorImpl.asIReplicator:IReplicator;
begin
  Result := IReplicator(@FNullPtr);
end;

procedure IReplicatorImpl_addRefDispatcher(this: IReplicator); cdecl;
begin
	try
		IReplicatorImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatorImpl_releaseDispatcher(this: IReplicator): Integer; cdecl;
begin
	try
		Result := IReplicatorImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatorImpl_processDispatcher(this: IReplicator; status: IStatus; length: Cardinal; data: BytePtr); cdecl;
begin
	try
		IReplicatorImpl(this.FObject).process(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatorImpl_closeDispatcher(this: IReplicator; status: IStatus); cdecl;
begin
	try
		IReplicatorImpl(this.FObject).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IReplicatorImpl_vTable: ReplicatorVTable = (
     NullPtr: nil;
     version: 4;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     process: IReplicatorImpl_processDispatcher;
     close: IReplicatorImpl_closeDispatcher);

constructor IReplicatorImpl.create;
begin
  inherited Create;
  FvTable := @IReplicatorImpl_vTable;
end;

function IReplicatorImpl.getVTable: PReplicatorVTable;
begin
  Result := PReplicatorVTable(FvTable);
end;

class function IReplicatorImpl.isIReplicatorImpl(intf: IReplicator): boolean;
begin
  Result := (intf.vTable = @IReplicatorImpl_vTable);
end;

function IRequestImpl.asIRequest:IRequest;
begin
  Result := IRequest(@FNullPtr);
end;

procedure IRequestImpl_addRefDispatcher(this: IRequest); cdecl;
begin
	try
		IRequestImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IRequestImpl_releaseDispatcher(this: IRequest): Integer; cdecl;
begin
	try
		Result := IRequestImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IRequestImpl_receiveDispatcher(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		IRequestImpl(this.FObject).receive(status, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_sendDispatcher(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		IRequestImpl(this.FObject).send(status, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_getInfoDispatcher(this: IRequest; status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IRequestImpl(this.FObject).getInfo(status, level, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_startDispatcher(this: IRequest; status: IStatus; tra: ITransaction; level: Integer); cdecl;
begin
	try
		IRequestImpl(this.FObject).start(status, tra, level);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_startAndSendDispatcher(this: IRequest; status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		IRequestImpl(this.FObject).startAndSend(status, tra, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_unwindDispatcher(this: IRequest; status: IStatus; level: Integer); cdecl;
begin
	try
		IRequestImpl(this.FObject).unwind(status, level);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_freeDispatcher(this: IRequest; status: IStatus); cdecl;
begin
	try
		IRequestImpl(this.FObject).free(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IRequestImpl_vTable: RequestVTable = (
     NullPtr: nil;
     version: 9;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     receive: IRequestImpl_receiveDispatcher;
     send: IRequestImpl_sendDispatcher;
     getInfo: IRequestImpl_getInfoDispatcher;
     start: IRequestImpl_startDispatcher;
     startAndSend: IRequestImpl_startAndSendDispatcher;
     unwind: IRequestImpl_unwindDispatcher;
     free: IRequestImpl_freeDispatcher);

constructor IRequestImpl.create;
begin
  inherited Create;
  FvTable := @IRequestImpl_vTable;
end;

function IRequestImpl.getVTable: PRequestVTable;
begin
  Result := PRequestVTable(FvTable);
end;

class function IRequestImpl.isIRequestImpl(intf: IRequest): boolean;
begin
  Result := (intf.vTable = @IRequestImpl_vTable);
end;

function IEventsImpl.asIEvents:IEvents;
begin
  Result := IEvents(@FNullPtr);
end;

procedure IEventsImpl_addRefDispatcher(this: IEvents); cdecl;
begin
	try
		IEventsImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IEventsImpl_releaseDispatcher(this: IEvents): Integer; cdecl;
begin
	try
		Result := IEventsImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IEventsImpl_cancelDispatcher(this: IEvents; status: IStatus); cdecl;
begin
	try
		IEventsImpl(this.FObject).cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IEventsImpl_vTable: EventsVTable = (
     NullPtr: nil;
     version: 3;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     cancel: IEventsImpl_cancelDispatcher);

constructor IEventsImpl.create;
begin
  inherited Create;
  FvTable := @IEventsImpl_vTable;
end;

function IEventsImpl.getVTable: PEventsVTable;
begin
  Result := PEventsVTable(FvTable);
end;

class function IEventsImpl.isIEventsImpl(intf: IEvents): boolean;
begin
  Result := (intf.vTable = @IEventsImpl_vTable);
end;

function IAttachmentImpl.asIAttachment:IAttachment;
begin
  Result := IAttachment(@FNullPtr);
end;

procedure IAttachmentImpl_addRefDispatcher(this: IAttachment); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAttachmentImpl_releaseDispatcher(this: IAttachment): Integer; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IAttachmentImpl_getInfoDispatcher(this: IAttachment; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_startTransactionDispatcher(this: IAttachment; status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).startTransaction(status, tpbLength, tpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_reconnectTransactionDispatcher(this: IAttachment; status: IStatus; length: Cardinal; id: BytePtr): ITransaction; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).reconnectTransaction(status, length, id);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_compileRequestDispatcher(this: IAttachment; status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).compileRequest(status, blrLength, blr);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_transactRequestDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).transactRequest(status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createBlobDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).createBlob(status, transaction, id, bpbLength, bpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_openBlobDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).openBlob(status, transaction, id, bpbLength, bpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getSliceDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).getSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_putSliceDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).putSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_executeDynDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).executeDyn(status, transaction, length, dyn);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_prepareDispatcher(this: IAttachment; status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).prepare(status, tra, stmtLength, sqlStmt, dialect, flags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_executeDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).execute(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_openCursorDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).openCursor(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_queEventsDispatcher(this: IAttachment; status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).queEvents(status, callback, length, events);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_cancelOperationDispatcher(this: IAttachment; status: IStatus; option: Integer); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).cancelOperation(status, option);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_pingDispatcher(this: IAttachment; status: IStatus); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).ping(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_detachDispatcher(this: IAttachment; status: IStatus); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).detach(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_dropDatabaseDispatcher(this: IAttachment; status: IStatus); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).dropDatabase(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getIdleTimeoutDispatcher(this: IAttachment; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).getIdleTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_setIdleTimeoutDispatcher(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).setIdleTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getStatementTimeoutDispatcher(this: IAttachment; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).getStatementTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_setStatementTimeoutDispatcher(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
begin
	try
		IAttachmentImpl(this.FObject).setStatementTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createBatchDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).createBatch(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createReplicatorDispatcher(this: IAttachment; status: IStatus): IReplicator; cdecl;
begin
	try
		Result := IAttachmentImpl(this.FObject).createReplicator(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IAttachmentImpl_vTable: AttachmentVTable = (
     NullPtr: nil;
     version: 26;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getInfo: IAttachmentImpl_getInfoDispatcher;
     startTransaction: IAttachmentImpl_startTransactionDispatcher;
     reconnectTransaction: IAttachmentImpl_reconnectTransactionDispatcher;
     compileRequest: IAttachmentImpl_compileRequestDispatcher;
     transactRequest: IAttachmentImpl_transactRequestDispatcher;
     createBlob: IAttachmentImpl_createBlobDispatcher;
     openBlob: IAttachmentImpl_openBlobDispatcher;
     getSlice: IAttachmentImpl_getSliceDispatcher;
     putSlice: IAttachmentImpl_putSliceDispatcher;
     executeDyn: IAttachmentImpl_executeDynDispatcher;
     prepare: IAttachmentImpl_prepareDispatcher;
     execute: IAttachmentImpl_executeDispatcher;
     openCursor: IAttachmentImpl_openCursorDispatcher;
     queEvents: IAttachmentImpl_queEventsDispatcher;
     cancelOperation: IAttachmentImpl_cancelOperationDispatcher;
     ping: IAttachmentImpl_pingDispatcher;
     detach: IAttachmentImpl_detachDispatcher;
     dropDatabase: IAttachmentImpl_dropDatabaseDispatcher;
     getIdleTimeout: IAttachmentImpl_getIdleTimeoutDispatcher;
     setIdleTimeout: IAttachmentImpl_setIdleTimeoutDispatcher;
     getStatementTimeout: IAttachmentImpl_getStatementTimeoutDispatcher;
     setStatementTimeout: IAttachmentImpl_setStatementTimeoutDispatcher;
     createBatch: IAttachmentImpl_createBatchDispatcher;
     createReplicator: IAttachmentImpl_createReplicatorDispatcher);

constructor IAttachmentImpl.create;
begin
  inherited Create;
  FvTable := @IAttachmentImpl_vTable;
end;

function IAttachmentImpl.getVTable: PAttachmentVTable;
begin
  Result := PAttachmentVTable(FvTable);
end;

class function IAttachmentImpl.isIAttachmentImpl(intf: IAttachment): boolean;
begin
  Result := (intf.vTable = @IAttachmentImpl_vTable);
end;

function IServiceImpl.asIService:IService;
begin
  Result := IService(@FNullPtr);
end;

procedure IServiceImpl_addRefDispatcher(this: IService); cdecl;
begin
	try
		IServiceImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServiceImpl_releaseDispatcher(this: IService): Integer; cdecl;
begin
	try
		Result := IServiceImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServiceImpl_detachDispatcher(this: IService; status: IStatus); cdecl;
begin
	try
		IServiceImpl(this.FObject).detach(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServiceImpl_queryDispatcher(this: IService; status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IServiceImpl(this.FObject).query(status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServiceImpl_startDispatcher(this: IService; status: IStatus; spbLength: Cardinal; spb: BytePtr); cdecl;
begin
	try
		IServiceImpl(this.FObject).start(status, spbLength, spb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IServiceImpl_vTable: ServiceVTable = (
     NullPtr: nil;
     version: 5;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     detach: IServiceImpl_detachDispatcher;
     query: IServiceImpl_queryDispatcher;
     start: IServiceImpl_startDispatcher);

constructor IServiceImpl.create;
begin
  inherited Create;
  FvTable := @IServiceImpl_vTable;
end;

function IServiceImpl.getVTable: PServiceVTable;
begin
  Result := PServiceVTable(FvTable);
end;

class function IServiceImpl.isIServiceImpl(intf: IService): boolean;
begin
  Result := (intf.vTable = @IServiceImpl_vTable);
end;

function IProviderImpl.asIProvider:IProvider;
begin
  Result := IProvider(@FNullPtr);
end;

procedure IProviderImpl_addRefDispatcher(this: IProvider); cdecl;
begin
	try
		IProviderImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_releaseDispatcher(this: IProvider): Integer; cdecl;
begin
	try
		Result := IProviderImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IProviderImpl_setOwnerDispatcher(this: IProvider; r: IReferenceCounted); cdecl;
begin
	try
		IProviderImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_getOwnerDispatcher(this: IProvider): IReferenceCounted; cdecl;
begin
	try
		Result := IProviderImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_attachDatabaseDispatcher(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
begin
	try
		Result := IProviderImpl(this.FObject).attachDatabase(status, fileName, dpbLength, dpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IProviderImpl_createDatabaseDispatcher(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
begin
	try
		Result := IProviderImpl(this.FObject).createDatabase(status, fileName, dpbLength, dpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IProviderImpl_attachServiceManagerDispatcher(this: IProvider; status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService; cdecl;
begin
	try
		Result := IProviderImpl(this.FObject).attachServiceManager(status, service, spbLength, spb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IProviderImpl_shutdownDispatcher(this: IProvider; status: IStatus; timeout: Cardinal; reason: Integer); cdecl;
begin
	try
		IProviderImpl(this.FObject).shutdown(status, timeout, reason);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IProviderImpl_setDbCryptCallbackDispatcher(this: IProvider; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
begin
	try
		IProviderImpl(this.FObject).setDbCryptCallback(status, cryptCallback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IProviderImpl_vTable: ProviderVTable = (
     NullPtr: nil;
     version: 9;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     attachDatabase: IProviderImpl_attachDatabaseDispatcher;
     createDatabase: IProviderImpl_createDatabaseDispatcher;
     attachServiceManager: IProviderImpl_attachServiceManagerDispatcher;
     shutdown: IProviderImpl_shutdownDispatcher;
     setDbCryptCallback: IProviderImpl_setDbCryptCallbackDispatcher);

constructor IProviderImpl.create;
begin
  inherited Create;
  FvTable := @IProviderImpl_vTable;
end;

function IProviderImpl.getVTable: PProviderVTable;
begin
  Result := PProviderVTable(FvTable);
end;

class function IProviderImpl.isIProviderImpl(intf: IProvider): boolean;
begin
  Result := (intf.vTable = @IProviderImpl_vTable);
end;

function IDtcStartImpl.asIDtcStart:IDtcStart;
begin
  Result := IDtcStart(@FNullPtr);
end;

procedure IDtcStartImpl_disposeDispatcher(this: IDtcStart); cdecl;
begin
	try
		IDtcStartImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDtcStartImpl_addAttachmentDispatcher(this: IDtcStart; status: IStatus; att: IAttachment); cdecl;
begin
	try
		IDtcStartImpl(this.FObject).addAttachment(status, att);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDtcStartImpl_addWithTpbDispatcher(this: IDtcStart; status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr); cdecl;
begin
	try
		IDtcStartImpl(this.FObject).addWithTpb(status, att, length, tpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IDtcStartImpl_startDispatcher(this: IDtcStart; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := IDtcStartImpl(this.FObject).start(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDtcStartImpl_vTable: DtcStartVTable = (
     NullPtr: nil;
     version: 4;
     dispose: IDisposableImpl_disposeDispatcher;
     addAttachment: IDtcStartImpl_addAttachmentDispatcher;
     addWithTpb: IDtcStartImpl_addWithTpbDispatcher;
     start: IDtcStartImpl_startDispatcher);

constructor IDtcStartImpl.create;
begin
  inherited Create;
  FvTable := @IDtcStartImpl_vTable;
end;

function IDtcStartImpl.getVTable: PDtcStartVTable;
begin
  Result := PDtcStartVTable(FvTable);
end;

class function IDtcStartImpl.isIDtcStartImpl(intf: IDtcStart): boolean;
begin
  Result := (intf.vTable = @IDtcStartImpl_vTable);
end;

function IDtcImpl.asIDtc:IDtc;
begin
  Result := IDtc(@FNullPtr);
end;

function IDtcImpl_joinDispatcher(this: IDtc; status: IStatus; one: ITransaction; two: ITransaction): ITransaction; cdecl;
begin
	try
		Result := IDtcImpl(this.FObject).join(status, one, two);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IDtcImpl_startBuilderDispatcher(this: IDtc; status: IStatus): IDtcStart; cdecl;
begin
	try
		Result := IDtcImpl(this.FObject).startBuilder(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDtcImpl_vTable: DtcVTable = (
     NullPtr: nil;
     version: 2;
     join: IDtcImpl_joinDispatcher;
     startBuilder: IDtcImpl_startBuilderDispatcher);

constructor IDtcImpl.create;
begin
  inherited Create;
  FvTable := @IDtcImpl_vTable;
end;

function IDtcImpl.getVTable: PDtcVTable;
begin
  Result := PDtcVTable(FvTable);
end;

class function IDtcImpl.isIDtcImpl(intf: IDtc): boolean;
begin
  Result := (intf.vTable = @IDtcImpl_vTable);
end;

function IAuthImpl.asIAuth:IAuth;
begin
  Result := IAuth(@FNullPtr);
end;

procedure IAuthImpl_addRefDispatcher(this: IAuth); cdecl;
begin
	try
		IAuthImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthImpl_releaseDispatcher(this: IAuth): Integer; cdecl;
begin
	try
		Result := IAuthImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IAuthImpl_setOwnerDispatcher(this: IAuth; r: IReferenceCounted); cdecl;
begin
	try
		IAuthImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthImpl_getOwnerDispatcher(this: IAuth): IReferenceCounted; cdecl;
begin
	try
		Result := IAuthImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IAuthImpl_vTable: AuthVTable = (
     NullPtr: nil;
     version: 4;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher);

constructor IAuthImpl.create;
begin
  inherited Create;
  FvTable := @IAuthImpl_vTable;
end;

function IAuthImpl.getVTable: PAuthVTable;
begin
  Result := PAuthVTable(FvTable);
end;

class function IAuthImpl.isIAuthImpl(intf: IAuth): boolean;
begin
  Result := (intf.vTable = @IAuthImpl_vTable) or
    IServerImpl.isIServerImpl(IServer(intf)) or
    IClientImpl.isIClientImpl(IClient(intf));
end;

function IWriterImpl.asIWriter:IWriter;
begin
  Result := IWriter(@FNullPtr);
end;

procedure IWriterImpl_resetDispatcher(this: IWriter); cdecl;
begin
	try
		IWriterImpl(this.FObject).reset();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IWriterImpl_addDispatcher(this: IWriter; status: IStatus; name: PAnsiChar); cdecl;
begin
	try
		IWriterImpl(this.FObject).add(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWriterImpl_setTypeDispatcher(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
begin
	try
		IWriterImpl(this.FObject).setType(status, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWriterImpl_setDbDispatcher(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
begin
	try
		IWriterImpl(this.FObject).setDb(status, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IWriterImpl_vTable: WriterVTable = (
     NullPtr: nil;
     version: 4;
     reset: IWriterImpl_resetDispatcher;
     add: IWriterImpl_addDispatcher;
     setType: IWriterImpl_setTypeDispatcher;
     setDb: IWriterImpl_setDbDispatcher);

constructor IWriterImpl.create;
begin
  inherited Create;
  FvTable := @IWriterImpl_vTable;
end;

function IWriterImpl.getVTable: PWriterVTable;
begin
  Result := PWriterVTable(FvTable);
end;

class function IWriterImpl.isIWriterImpl(intf: IWriter): boolean;
begin
  Result := (intf.vTable = @IWriterImpl_vTable);
end;

function IServerBlockImpl.asIServerBlock:IServerBlock;
begin
  Result := IServerBlock(@FNullPtr);
end;

function IServerBlockImpl_getLoginDispatcher(this: IServerBlock): PAnsiChar; cdecl;
begin
	try
		Result := IServerBlockImpl(this.FObject).getLogin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerBlockImpl_getDataDispatcher(this: IServerBlock; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := IServerBlockImpl(this.FObject).getData(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServerBlockImpl_putDataDispatcher(this: IServerBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
begin
	try
		IServerBlockImpl(this.FObject).putData(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IServerBlockImpl_newKeyDispatcher(this: IServerBlock; status: IStatus): ICryptKey; cdecl;
begin
	try
		Result := IServerBlockImpl(this.FObject).newKey(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IServerBlockImpl_vTable: ServerBlockVTable = (
     NullPtr: nil;
     version: 4;
     getLogin: IServerBlockImpl_getLoginDispatcher;
     getData: IServerBlockImpl_getDataDispatcher;
     putData: IServerBlockImpl_putDataDispatcher;
     newKey: IServerBlockImpl_newKeyDispatcher);

constructor IServerBlockImpl.create;
begin
  inherited Create;
  FvTable := @IServerBlockImpl_vTable;
end;

function IServerBlockImpl.getVTable: PServerBlockVTable;
begin
  Result := PServerBlockVTable(FvTable);
end;

class function IServerBlockImpl.isIServerBlockImpl(intf: IServerBlock): boolean;
begin
  Result := (intf.vTable = @IServerBlockImpl_vTable);
end;

function IClientBlockImpl.asIClientBlock:IClientBlock;
begin
  Result := IClientBlock(@FNullPtr);
end;

procedure IClientBlockImpl_addRefDispatcher(this: IClientBlock); cdecl;
begin
	try
		IClientBlockImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_releaseDispatcher(this: IClientBlock): Integer; cdecl;
begin
	try
		Result := IClientBlockImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getLoginDispatcher(this: IClientBlock): PAnsiChar; cdecl;
begin
	try
		Result := IClientBlockImpl(this.FObject).getLogin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getPasswordDispatcher(this: IClientBlock): PAnsiChar; cdecl;
begin
	try
		Result := IClientBlockImpl(this.FObject).getPassword();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getDataDispatcher(this: IClientBlock; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := IClientBlockImpl(this.FObject).getData(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IClientBlockImpl_putDataDispatcher(this: IClientBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
begin
	try
		IClientBlockImpl(this.FObject).putData(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IClientBlockImpl_newKeyDispatcher(this: IClientBlock; status: IStatus): ICryptKey; cdecl;
begin
	try
		Result := IClientBlockImpl(this.FObject).newKey(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IClientBlockImpl_getAuthBlockDispatcher(this: IClientBlock; status: IStatus): IAuthBlock; cdecl;
begin
	try
		Result := IClientBlockImpl(this.FObject).getAuthBlock(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IClientBlockImpl_vTable: ClientBlockVTable = (
     NullPtr: nil;
     version: 8;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getLogin: IClientBlockImpl_getLoginDispatcher;
     getPassword: IClientBlockImpl_getPasswordDispatcher;
     getData: IClientBlockImpl_getDataDispatcher;
     putData: IClientBlockImpl_putDataDispatcher;
     newKey: IClientBlockImpl_newKeyDispatcher;
     getAuthBlock: IClientBlockImpl_getAuthBlockDispatcher);

constructor IClientBlockImpl.create;
begin
  inherited Create;
  FvTable := @IClientBlockImpl_vTable;
end;

function IClientBlockImpl.getVTable: PClientBlockVTable;
begin
  Result := PClientBlockVTable(FvTable);
end;

class function IClientBlockImpl.isIClientBlockImpl(intf: IClientBlock): boolean;
begin
  Result := (intf.vTable = @IClientBlockImpl_vTable);
end;

function IServerImpl.asIServer:IServer;
begin
  Result := IServer(@FNullPtr);
end;

procedure IServerImpl_addRefDispatcher(this: IServer); cdecl;
begin
	try
		IServerImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_releaseDispatcher(this: IServer): Integer; cdecl;
begin
	try
		Result := IServerImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServerImpl_setOwnerDispatcher(this: IServer; r: IReferenceCounted); cdecl;
begin
	try
		IServerImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_getOwnerDispatcher(this: IServer): IReferenceCounted; cdecl;
begin
	try
		Result := IServerImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_authenticateDispatcher(this: IServer; status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer; cdecl;
begin
	try
		Result := IServerImpl(this.FObject).authenticate(status, sBlock, writerInterface);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServerImpl_setDbCryptCallbackDispatcher(this: IServer; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
begin
	try
		IServerImpl(this.FObject).setDbCryptCallback(status, cryptCallback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IServerImpl_vTable: ServerVTable = (
     NullPtr: nil;
     version: 6;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     authenticate: IServerImpl_authenticateDispatcher;
     setDbCryptCallback: IServerImpl_setDbCryptCallbackDispatcher);

constructor IServerImpl.create;
begin
  inherited Create;
  FvTable := @IServerImpl_vTable;
end;

function IServerImpl.getVTable: PServerVTable;
begin
  Result := PServerVTable(FvTable);
end;

class function IServerImpl.isIServerImpl(intf: IServer): boolean;
begin
  Result := (intf.vTable = @IServerImpl_vTable);
end;

function IClientImpl.asIClient:IClient;
begin
  Result := IClient(@FNullPtr);
end;

procedure IClientImpl_addRefDispatcher(this: IClient); cdecl;
begin
	try
		IClientImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_releaseDispatcher(this: IClient): Integer; cdecl;
begin
	try
		Result := IClientImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IClientImpl_setOwnerDispatcher(this: IClient; r: IReferenceCounted); cdecl;
begin
	try
		IClientImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_getOwnerDispatcher(this: IClient): IReferenceCounted; cdecl;
begin
	try
		Result := IClientImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_authenticateDispatcher(this: IClient; status: IStatus; cBlock: IClientBlock): Integer; cdecl;
begin
	try
		Result := IClientImpl(this.FObject).authenticate(status, cBlock);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IClientImpl_vTable: ClientVTable = (
     NullPtr: nil;
     version: 5;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     authenticate: IClientImpl_authenticateDispatcher);

constructor IClientImpl.create;
begin
  inherited Create;
  FvTable := @IClientImpl_vTable;
end;

function IClientImpl.getVTable: PClientVTable;
begin
  Result := PClientVTable(FvTable);
end;

class function IClientImpl.isIClientImpl(intf: IClient): boolean;
begin
  Result := (intf.vTable = @IClientImpl_vTable);
end;

function IUserFieldImpl.asIUserField:IUserField;
begin
  Result := IUserField(@FNullPtr);
end;

function IUserFieldImpl_enteredDispatcher(this: IUserField): Integer; cdecl;
begin
	try
		Result := IUserFieldImpl(this.FObject).entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserFieldImpl_specifiedDispatcher(this: IUserField): Integer; cdecl;
begin
	try
		Result := IUserFieldImpl(this.FObject).specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUserFieldImpl_setEnteredDispatcher(this: IUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		IUserFieldImpl(this.FObject).setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUserFieldImpl_vTable: UserFieldVTable = (
     NullPtr: nil;
     version: 3;
     entered: IUserFieldImpl_enteredDispatcher;
     specified: IUserFieldImpl_specifiedDispatcher;
     setEntered: IUserFieldImpl_setEnteredDispatcher);

constructor IUserFieldImpl.create;
begin
  inherited Create;
  FvTable := @IUserFieldImpl_vTable;
end;

function IUserFieldImpl.getVTable: PUserFieldVTable;
begin
  Result := PUserFieldVTable(FvTable);
end;

class function IUserFieldImpl.isIUserFieldImpl(intf: IUserField): boolean;
begin
  Result := (intf.vTable = @IUserFieldImpl_vTable) or
    ICharUserFieldImpl.isICharUserFieldImpl(ICharUserField(intf)) or
    IIntUserFieldImpl.isIIntUserFieldImpl(IIntUserField(intf));
end;

function ICharUserFieldImpl.asICharUserField:ICharUserField;
begin
  Result := ICharUserField(@FNullPtr);
end;

function ICharUserFieldImpl_enteredDispatcher(this: ICharUserField): Integer; cdecl;
begin
	try
		Result := ICharUserFieldImpl(this.FObject).entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ICharUserFieldImpl_specifiedDispatcher(this: ICharUserField): Integer; cdecl;
begin
	try
		Result := ICharUserFieldImpl(this.FObject).specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ICharUserFieldImpl_setEnteredDispatcher(this: ICharUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		ICharUserFieldImpl(this.FObject).setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ICharUserFieldImpl_getDispatcher(this: ICharUserField): PAnsiChar; cdecl;
begin
	try
		Result := ICharUserFieldImpl(this.FObject).get();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ICharUserFieldImpl_set_Dispatcher(this: ICharUserField; status: IStatus; newValue: PAnsiChar); cdecl;
begin
	try
		ICharUserFieldImpl(this.FObject).set_(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ICharUserFieldImpl_vTable: CharUserFieldVTable = (
     NullPtr: nil;
     version: 5;
     entered: IUserFieldImpl_enteredDispatcher;
     specified: IUserFieldImpl_specifiedDispatcher;
     setEntered: IUserFieldImpl_setEnteredDispatcher;
     get: ICharUserFieldImpl_getDispatcher;
     set_: ICharUserFieldImpl_set_Dispatcher);

constructor ICharUserFieldImpl.create;
begin
  inherited Create;
  FvTable := @ICharUserFieldImpl_vTable;
end;

function ICharUserFieldImpl.getVTable: PCharUserFieldVTable;
begin
  Result := PCharUserFieldVTable(FvTable);
end;

class function ICharUserFieldImpl.isICharUserFieldImpl(intf: ICharUserField): boolean;
begin
  Result := (intf.vTable = @ICharUserFieldImpl_vTable);
end;

function IIntUserFieldImpl.asIIntUserField:IIntUserField;
begin
  Result := IIntUserField(@FNullPtr);
end;

function IIntUserFieldImpl_enteredDispatcher(this: IIntUserField): Integer; cdecl;
begin
	try
		Result := IIntUserFieldImpl(this.FObject).entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IIntUserFieldImpl_specifiedDispatcher(this: IIntUserField): Integer; cdecl;
begin
	try
		Result := IIntUserFieldImpl(this.FObject).specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IIntUserFieldImpl_setEnteredDispatcher(this: IIntUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		IIntUserFieldImpl(this.FObject).setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IIntUserFieldImpl_getDispatcher(this: IIntUserField): Integer; cdecl;
begin
	try
		Result := IIntUserFieldImpl(this.FObject).get();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IIntUserFieldImpl_set_Dispatcher(this: IIntUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		IIntUserFieldImpl(this.FObject).set_(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IIntUserFieldImpl_vTable: IntUserFieldVTable = (
     NullPtr: nil;
     version: 5;
     entered: IUserFieldImpl_enteredDispatcher;
     specified: IUserFieldImpl_specifiedDispatcher;
     setEntered: IUserFieldImpl_setEnteredDispatcher;
     get: IIntUserFieldImpl_getDispatcher;
     set_: IIntUserFieldImpl_set_Dispatcher);

constructor IIntUserFieldImpl.create;
begin
  inherited Create;
  FvTable := @IIntUserFieldImpl_vTable;
end;

function IIntUserFieldImpl.getVTable: PIntUserFieldVTable;
begin
  Result := PIntUserFieldVTable(FvTable);
end;

class function IIntUserFieldImpl.isIIntUserFieldImpl(intf: IIntUserField): boolean;
begin
  Result := (intf.vTable = @IIntUserFieldImpl_vTable);
end;

function IUserImpl.asIUser:IUser;
begin
  Result := IUser(@FNullPtr);
end;

function IUserImpl_operationDispatcher(this: IUser): Cardinal; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).operation();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_userNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).userName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_passwordDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).password();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_firstNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).firstName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_lastNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).lastName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_middleNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).middleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_commentDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).comment();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_attributesDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).attributes();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_activeDispatcher(this: IUser): IIntUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).active();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_adminDispatcher(this: IUser): IIntUserField; cdecl;
begin
	try
		Result := IUserImpl(this.FObject).admin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUserImpl_clearDispatcher(this: IUser; status: IStatus); cdecl;
begin
	try
		IUserImpl(this.FObject).clear(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUserImpl_vTable: UserVTable = (
     NullPtr: nil;
     version: 11;
     operation: IUserImpl_operationDispatcher;
     userName: IUserImpl_userNameDispatcher;
     password: IUserImpl_passwordDispatcher;
     firstName: IUserImpl_firstNameDispatcher;
     lastName: IUserImpl_lastNameDispatcher;
     middleName: IUserImpl_middleNameDispatcher;
     comment: IUserImpl_commentDispatcher;
     attributes: IUserImpl_attributesDispatcher;
     active: IUserImpl_activeDispatcher;
     admin: IUserImpl_adminDispatcher;
     clear: IUserImpl_clearDispatcher);

constructor IUserImpl.create;
begin
  inherited Create;
  FvTable := @IUserImpl_vTable;
end;

function IUserImpl.getVTable: PUserVTable;
begin
  Result := PUserVTable(FvTable);
end;

class function IUserImpl.isIUserImpl(intf: IUser): boolean;
begin
  Result := (intf.vTable = @IUserImpl_vTable);
end;

function IListUsersImpl.asIListUsers:IListUsers;
begin
  Result := IListUsers(@FNullPtr);
end;

procedure IListUsersImpl_listDispatcher(this: IListUsers; status: IStatus; user: IUser); cdecl;
begin
	try
		IListUsersImpl(this.FObject).list(status, user);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IListUsersImpl_vTable: ListUsersVTable = (
     NullPtr: nil;
     version: 1;
     list: IListUsersImpl_listDispatcher);

constructor IListUsersImpl.create;
begin
  inherited Create;
  FvTable := @IListUsersImpl_vTable;
end;

function IListUsersImpl.getVTable: PListUsersVTable;
begin
  Result := PListUsersVTable(FvTable);
end;

class function IListUsersImpl.isIListUsersImpl(intf: IListUsers): boolean;
begin
  Result := (intf.vTable = @IListUsersImpl_vTable);
end;

function ILogonInfoImpl.asILogonInfo:ILogonInfo;
begin
  Result := ILogonInfo(@FNullPtr);
end;

function ILogonInfoImpl_nameDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).name();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_roleDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).role();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_networkProtocolDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).networkProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_remoteAddressDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).remoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_authBlockDispatcher(this: ILogonInfo; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).authBlock(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_attachmentDispatcher(this: ILogonInfo; status: IStatus): IAttachment; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).attachment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ILogonInfoImpl_transactionDispatcher(this: ILogonInfo; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := ILogonInfoImpl(this.FObject).transaction(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ILogonInfoImpl_vTable: LogonInfoVTable = (
     NullPtr: nil;
     version: 7;
     name: ILogonInfoImpl_nameDispatcher;
     role: ILogonInfoImpl_roleDispatcher;
     networkProtocol: ILogonInfoImpl_networkProtocolDispatcher;
     remoteAddress: ILogonInfoImpl_remoteAddressDispatcher;
     authBlock: ILogonInfoImpl_authBlockDispatcher;
     attachment: ILogonInfoImpl_attachmentDispatcher;
     transaction: ILogonInfoImpl_transactionDispatcher);

constructor ILogonInfoImpl.create;
begin
  inherited Create;
  FvTable := @ILogonInfoImpl_vTable;
end;

function ILogonInfoImpl.getVTable: PLogonInfoVTable;
begin
  Result := PLogonInfoVTable(FvTable);
end;

class function ILogonInfoImpl.isILogonInfoImpl(intf: ILogonInfo): boolean;
begin
  Result := (intf.vTable = @ILogonInfoImpl_vTable);
end;

function IManagementImpl.asIManagement:IManagement;
begin
  Result := IManagement(@FNullPtr);
end;

procedure IManagementImpl_addRefDispatcher(this: IManagement); cdecl;
begin
	try
		IManagementImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IManagementImpl_releaseDispatcher(this: IManagement): Integer; cdecl;
begin
	try
		Result := IManagementImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IManagementImpl_setOwnerDispatcher(this: IManagement; r: IReferenceCounted); cdecl;
begin
	try
		IManagementImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IManagementImpl_getOwnerDispatcher(this: IManagement): IReferenceCounted; cdecl;
begin
	try
		Result := IManagementImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IManagementImpl_startDispatcher(this: IManagement; status: IStatus; logonInfo: ILogonInfo); cdecl;
begin
	try
		IManagementImpl(this.FObject).start(status, logonInfo);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IManagementImpl_executeDispatcher(this: IManagement; status: IStatus; user: IUser; callback: IListUsers): Integer; cdecl;
begin
	try
		Result := IManagementImpl(this.FObject).execute(status, user, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IManagementImpl_commitDispatcher(this: IManagement; status: IStatus); cdecl;
begin
	try
		IManagementImpl(this.FObject).commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IManagementImpl_rollbackDispatcher(this: IManagement; status: IStatus); cdecl;
begin
	try
		IManagementImpl(this.FObject).rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IManagementImpl_vTable: ManagementVTable = (
     NullPtr: nil;
     version: 8;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     start: IManagementImpl_startDispatcher;
     execute: IManagementImpl_executeDispatcher;
     commit: IManagementImpl_commitDispatcher;
     rollback: IManagementImpl_rollbackDispatcher);

constructor IManagementImpl.create;
begin
  inherited Create;
  FvTable := @IManagementImpl_vTable;
end;

function IManagementImpl.getVTable: PManagementVTable;
begin
  Result := PManagementVTable(FvTable);
end;

class function IManagementImpl.isIManagementImpl(intf: IManagement): boolean;
begin
  Result := (intf.vTable = @IManagementImpl_vTable);
end;

function IAuthBlockImpl.asIAuthBlock:IAuthBlock;
begin
  Result := IAuthBlock(@FNullPtr);
end;

function IAuthBlockImpl_getTypeDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).getType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getNameDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getPluginDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).getPlugin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getSecurityDbDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).getSecurityDb();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getOriginalPluginDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).getOriginalPlugin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_nextDispatcher(this: IAuthBlock; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).next(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAuthBlockImpl_firstDispatcher(this: IAuthBlock; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IAuthBlockImpl(this.FObject).first(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IAuthBlockImpl_vTable: AuthBlockVTable = (
     NullPtr: nil;
     version: 7;
     getType: IAuthBlockImpl_getTypeDispatcher;
     getName: IAuthBlockImpl_getNameDispatcher;
     getPlugin: IAuthBlockImpl_getPluginDispatcher;
     getSecurityDb: IAuthBlockImpl_getSecurityDbDispatcher;
     getOriginalPlugin: IAuthBlockImpl_getOriginalPluginDispatcher;
     next: IAuthBlockImpl_nextDispatcher;
     first: IAuthBlockImpl_firstDispatcher);

constructor IAuthBlockImpl.create;
begin
  inherited Create;
  FvTable := @IAuthBlockImpl_vTable;
end;

function IAuthBlockImpl.getVTable: PAuthBlockVTable;
begin
  Result := PAuthBlockVTable(FvTable);
end;

class function IAuthBlockImpl.isIAuthBlockImpl(intf: IAuthBlock): boolean;
begin
  Result := (intf.vTable = @IAuthBlockImpl_vTable);
end;

function IWireCryptPluginImpl.asIWireCryptPlugin:IWireCryptPlugin;
begin
  Result := IWireCryptPlugin(@FNullPtr);
end;

procedure IWireCryptPluginImpl_addRefDispatcher(this: IWireCryptPlugin); cdecl;
begin
	try
		IWireCryptPluginImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_releaseDispatcher(this: IWireCryptPlugin): Integer; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IWireCryptPluginImpl_setOwnerDispatcher(this: IWireCryptPlugin; r: IReferenceCounted); cdecl;
begin
	try
		IWireCryptPluginImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_getOwnerDispatcher(this: IWireCryptPlugin): IReferenceCounted; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_getKnownTypesDispatcher(this: IWireCryptPlugin; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(this.FObject).getKnownTypes(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_setKeyDispatcher(this: IWireCryptPlugin; status: IStatus; key: ICryptKey); cdecl;
begin
	try
		IWireCryptPluginImpl(this.FObject).setKey(status, key);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_encryptDispatcher(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IWireCryptPluginImpl(this.FObject).encrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_decryptDispatcher(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IWireCryptPluginImpl(this.FObject).decrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IWireCryptPluginImpl_getSpecificDataDispatcher(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(this.FObject).getSpecificData(status, keyType, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_setSpecificDataDispatcher(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr); cdecl;
begin
	try
		IWireCryptPluginImpl(this.FObject).setSpecificData(status, keyType, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IWireCryptPluginImpl_vTable: WireCryptPluginVTable = (
     NullPtr: nil;
     version: 10;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     getKnownTypes: IWireCryptPluginImpl_getKnownTypesDispatcher;
     setKey: IWireCryptPluginImpl_setKeyDispatcher;
     encrypt: IWireCryptPluginImpl_encryptDispatcher;
     decrypt: IWireCryptPluginImpl_decryptDispatcher;
     getSpecificData: IWireCryptPluginImpl_getSpecificDataDispatcher;
     setSpecificData: IWireCryptPluginImpl_setSpecificDataDispatcher);

constructor IWireCryptPluginImpl.create;
begin
  inherited Create;
  FvTable := @IWireCryptPluginImpl_vTable;
end;

function IWireCryptPluginImpl.getVTable: PWireCryptPluginVTable;
begin
  Result := PWireCryptPluginVTable(FvTable);
end;

class function IWireCryptPluginImpl.isIWireCryptPluginImpl(intf: IWireCryptPlugin): boolean;
begin
  Result := (intf.vTable = @IWireCryptPluginImpl_vTable);
end;

function ICryptKeyCallbackImpl.asICryptKeyCallback:ICryptKeyCallback;
begin
  Result := ICryptKeyCallback(@FNullPtr);
end;

function ICryptKeyCallbackImpl_callbackDispatcher(this: ICryptKeyCallback; dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; cdecl;
begin
	try
		Result := ICryptKeyCallbackImpl(this.FObject).callback(dataLength, data, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ICryptKeyCallbackImpl_vTable: CryptKeyCallbackVTable = (
     NullPtr: nil;
     version: 1;
     callback: ICryptKeyCallbackImpl_callbackDispatcher);

constructor ICryptKeyCallbackImpl.create;
begin
  inherited Create;
  FvTable := @ICryptKeyCallbackImpl_vTable;
end;

function ICryptKeyCallbackImpl.getVTable: PCryptKeyCallbackVTable;
begin
  Result := PCryptKeyCallbackVTable(FvTable);
end;

class function ICryptKeyCallbackImpl.isICryptKeyCallbackImpl(intf: ICryptKeyCallback): boolean;
begin
  Result := (intf.vTable = @ICryptKeyCallbackImpl_vTable);
end;

function IKeyHolderPluginImpl.asIKeyHolderPlugin:IKeyHolderPlugin;
begin
  Result := IKeyHolderPlugin(@FNullPtr);
end;

procedure IKeyHolderPluginImpl_addRefDispatcher(this: IKeyHolderPlugin); cdecl;
begin
	try
		IKeyHolderPluginImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_releaseDispatcher(this: IKeyHolderPlugin): Integer; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IKeyHolderPluginImpl_setOwnerDispatcher(this: IKeyHolderPlugin; r: IReferenceCounted); cdecl;
begin
	try
		IKeyHolderPluginImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_getOwnerDispatcher(this: IKeyHolderPlugin): IReferenceCounted; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_keyCallbackDispatcher(this: IKeyHolderPlugin; status: IStatus; callback: ICryptKeyCallback): Integer; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(this.FObject).keyCallback(status, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_keyHandleDispatcher(this: IKeyHolderPlugin; status: IStatus; keyName: PAnsiChar): ICryptKeyCallback; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(this.FObject).keyHandle(status, keyName);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_useOnlyOwnKeysDispatcher(this: IKeyHolderPlugin; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(this.FObject).useOnlyOwnKeys(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_chainHandleDispatcher(this: IKeyHolderPlugin; status: IStatus): ICryptKeyCallback; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(this.FObject).chainHandle(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IKeyHolderPluginImpl_vTable: KeyHolderPluginVTable = (
     NullPtr: nil;
     version: 8;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     keyCallback: IKeyHolderPluginImpl_keyCallbackDispatcher;
     keyHandle: IKeyHolderPluginImpl_keyHandleDispatcher;
     useOnlyOwnKeys: IKeyHolderPluginImpl_useOnlyOwnKeysDispatcher;
     chainHandle: IKeyHolderPluginImpl_chainHandleDispatcher);

constructor IKeyHolderPluginImpl.create;
begin
  inherited Create;
  FvTable := @IKeyHolderPluginImpl_vTable;
end;

function IKeyHolderPluginImpl.getVTable: PKeyHolderPluginVTable;
begin
  Result := PKeyHolderPluginVTable(FvTable);
end;

class function IKeyHolderPluginImpl.isIKeyHolderPluginImpl(intf: IKeyHolderPlugin): boolean;
begin
  Result := (intf.vTable = @IKeyHolderPluginImpl_vTable);
end;

function IDbCryptInfoImpl.asIDbCryptInfo:IDbCryptInfo;
begin
  Result := IDbCryptInfo(@FNullPtr);
end;

procedure IDbCryptInfoImpl_addRefDispatcher(this: IDbCryptInfo); cdecl;
begin
	try
		IDbCryptInfoImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptInfoImpl_releaseDispatcher(this: IDbCryptInfo): Integer; cdecl;
begin
	try
		Result := IDbCryptInfoImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptInfoImpl_getDatabaseFullPathDispatcher(this: IDbCryptInfo; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IDbCryptInfoImpl(this.FObject).getDatabaseFullPath(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDbCryptInfoImpl_vTable: DbCryptInfoVTable = (
     NullPtr: nil;
     version: 3;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     getDatabaseFullPath: IDbCryptInfoImpl_getDatabaseFullPathDispatcher);

constructor IDbCryptInfoImpl.create;
begin
  inherited Create;
  FvTable := @IDbCryptInfoImpl_vTable;
end;

function IDbCryptInfoImpl.getVTable: PDbCryptInfoVTable;
begin
  Result := PDbCryptInfoVTable(FvTable);
end;

class function IDbCryptInfoImpl.isIDbCryptInfoImpl(intf: IDbCryptInfo): boolean;
begin
  Result := (intf.vTable = @IDbCryptInfoImpl_vTable);
end;

function IDbCryptPluginImpl.asIDbCryptPlugin:IDbCryptPlugin;
begin
  Result := IDbCryptPlugin(@FNullPtr);
end;

procedure IDbCryptPluginImpl_addRefDispatcher(this: IDbCryptPlugin); cdecl;
begin
	try
		IDbCryptPluginImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptPluginImpl_releaseDispatcher(this: IDbCryptPlugin): Integer; cdecl;
begin
	try
		Result := IDbCryptPluginImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDbCryptPluginImpl_setOwnerDispatcher(this: IDbCryptPlugin; r: IReferenceCounted); cdecl;
begin
	try
		IDbCryptPluginImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptPluginImpl_getOwnerDispatcher(this: IDbCryptPlugin): IReferenceCounted; cdecl;
begin
	try
		Result := IDbCryptPluginImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDbCryptPluginImpl_setKeyDispatcher(this: IDbCryptPlugin; status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar); cdecl;
begin
	try
		IDbCryptPluginImpl(this.FObject).setKey(status, length, sources, keyName);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_encryptDispatcher(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IDbCryptPluginImpl(this.FObject).encrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_decryptDispatcher(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IDbCryptPluginImpl(this.FObject).decrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_setInfoDispatcher(this: IDbCryptPlugin; status: IStatus; info: IDbCryptInfo); cdecl;
begin
	try
		IDbCryptPluginImpl(this.FObject).setInfo(status, info);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDbCryptPluginImpl_vTable: DbCryptPluginVTable = (
     NullPtr: nil;
     version: 8;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     setKey: IDbCryptPluginImpl_setKeyDispatcher;
     encrypt: IDbCryptPluginImpl_encryptDispatcher;
     decrypt: IDbCryptPluginImpl_decryptDispatcher;
     setInfo: IDbCryptPluginImpl_setInfoDispatcher);

constructor IDbCryptPluginImpl.create;
begin
  inherited Create;
  FvTable := @IDbCryptPluginImpl_vTable;
end;

function IDbCryptPluginImpl.getVTable: PDbCryptPluginVTable;
begin
  Result := PDbCryptPluginVTable(FvTable);
end;

class function IDbCryptPluginImpl.isIDbCryptPluginImpl(intf: IDbCryptPlugin): boolean;
begin
  Result := (intf.vTable = @IDbCryptPluginImpl_vTable);
end;

function IExternalContextImpl.asIExternalContext:IExternalContext;
begin
  Result := IExternalContext(@FNullPtr);
end;

function IExternalContextImpl_getMasterDispatcher(this: IExternalContext): IMaster; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getMaster();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getEngineDispatcher(this: IExternalContext; status: IStatus): IExternalEngine; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getEngine(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getAttachmentDispatcher(this: IExternalContext; status: IStatus): IAttachment; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getAttachment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getTransactionDispatcher(this: IExternalContext; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getTransaction(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getUserNameDispatcher(this: IExternalContext): PAnsiChar; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getDatabaseNameDispatcher(this: IExternalContext): PAnsiChar; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getClientCharSetDispatcher(this: IExternalContext): PAnsiChar; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getClientCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_obtainInfoCodeDispatcher(this: IExternalContext): Integer; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).obtainInfoCode();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getInfoDispatcher(this: IExternalContext; code: Integer): Pointer; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).getInfo(code);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_setInfoDispatcher(this: IExternalContext; code: Integer; value: Pointer): Pointer; cdecl;
begin
	try
		Result := IExternalContextImpl(this.FObject).setInfo(code, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IExternalContextImpl_vTable: ExternalContextVTable = (
     NullPtr: nil;
     version: 10;
     getMaster: IExternalContextImpl_getMasterDispatcher;
     getEngine: IExternalContextImpl_getEngineDispatcher;
     getAttachment: IExternalContextImpl_getAttachmentDispatcher;
     getTransaction: IExternalContextImpl_getTransactionDispatcher;
     getUserName: IExternalContextImpl_getUserNameDispatcher;
     getDatabaseName: IExternalContextImpl_getDatabaseNameDispatcher;
     getClientCharSet: IExternalContextImpl_getClientCharSetDispatcher;
     obtainInfoCode: IExternalContextImpl_obtainInfoCodeDispatcher;
     getInfo: IExternalContextImpl_getInfoDispatcher;
     setInfo: IExternalContextImpl_setInfoDispatcher);

constructor IExternalContextImpl.create;
begin
  inherited Create;
  FvTable := @IExternalContextImpl_vTable;
end;

function IExternalContextImpl.getVTable: PExternalContextVTable;
begin
  Result := PExternalContextVTable(FvTable);
end;

class function IExternalContextImpl.isIExternalContextImpl(intf: IExternalContext): boolean;
begin
  Result := (intf.vTable = @IExternalContextImpl_vTable);
end;

function IExternalResultSetImpl.asIExternalResultSet:IExternalResultSet;
begin
  Result := IExternalResultSet(@FNullPtr);
end;

procedure IExternalResultSetImpl_disposeDispatcher(this: IExternalResultSet); cdecl;
begin
	try
		IExternalResultSetImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalResultSetImpl_fetchDispatcher(this: IExternalResultSet; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IExternalResultSetImpl(this.FObject).fetch(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalResultSetImpl_vTable: ExternalResultSetVTable = (
     NullPtr: nil;
     version: 2;
     dispose: IDisposableImpl_disposeDispatcher;
     fetch: IExternalResultSetImpl_fetchDispatcher);

constructor IExternalResultSetImpl.create;
begin
  inherited Create;
  FvTable := @IExternalResultSetImpl_vTable;
end;

function IExternalResultSetImpl.getVTable: PExternalResultSetVTable;
begin
  Result := PExternalResultSetVTable(FvTable);
end;

class function IExternalResultSetImpl.isIExternalResultSetImpl(intf: IExternalResultSet): boolean;
begin
  Result := (intf.vTable = @IExternalResultSetImpl_vTable);
end;

function IExternalFunctionImpl.asIExternalFunction:IExternalFunction;
begin
  Result := IExternalFunction(@FNullPtr);
end;

procedure IExternalFunctionImpl_disposeDispatcher(this: IExternalFunction); cdecl;
begin
	try
		IExternalFunctionImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalFunctionImpl_getCharSetDispatcher(this: IExternalFunction; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		IExternalFunctionImpl(this.FObject).getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalFunctionImpl_executeDispatcher(this: IExternalFunction; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer); cdecl;
begin
	try
		IExternalFunctionImpl(this.FObject).execute(status, context, inMsg, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalFunctionImpl_vTable: ExternalFunctionVTable = (
     NullPtr: nil;
     version: 3;
     dispose: IDisposableImpl_disposeDispatcher;
     getCharSet: IExternalFunctionImpl_getCharSetDispatcher;
     execute: IExternalFunctionImpl_executeDispatcher);

constructor IExternalFunctionImpl.create;
begin
  inherited Create;
  FvTable := @IExternalFunctionImpl_vTable;
end;

function IExternalFunctionImpl.getVTable: PExternalFunctionVTable;
begin
  Result := PExternalFunctionVTable(FvTable);
end;

class function IExternalFunctionImpl.isIExternalFunctionImpl(intf: IExternalFunction): boolean;
begin
  Result := (intf.vTable = @IExternalFunctionImpl_vTable);
end;

function IExternalProcedureImpl.asIExternalProcedure:IExternalProcedure;
begin
  Result := IExternalProcedure(@FNullPtr);
end;

procedure IExternalProcedureImpl_disposeDispatcher(this: IExternalProcedure); cdecl;
begin
	try
		IExternalProcedureImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalProcedureImpl_getCharSetDispatcher(this: IExternalProcedure; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		IExternalProcedureImpl(this.FObject).getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalProcedureImpl_openDispatcher(this: IExternalProcedure; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet; cdecl;
begin
	try
		Result := IExternalProcedureImpl(this.FObject).open(status, context, inMsg, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalProcedureImpl_vTable: ExternalProcedureVTable = (
     NullPtr: nil;
     version: 3;
     dispose: IDisposableImpl_disposeDispatcher;
     getCharSet: IExternalProcedureImpl_getCharSetDispatcher;
     open: IExternalProcedureImpl_openDispatcher);

constructor IExternalProcedureImpl.create;
begin
  inherited Create;
  FvTable := @IExternalProcedureImpl_vTable;
end;

function IExternalProcedureImpl.getVTable: PExternalProcedureVTable;
begin
  Result := PExternalProcedureVTable(FvTable);
end;

class function IExternalProcedureImpl.isIExternalProcedureImpl(intf: IExternalProcedure): boolean;
begin
  Result := (intf.vTable = @IExternalProcedureImpl_vTable);
end;

function IExternalTriggerImpl.asIExternalTrigger:IExternalTrigger;
begin
  Result := IExternalTrigger(@FNullPtr);
end;

procedure IExternalTriggerImpl_disposeDispatcher(this: IExternalTrigger); cdecl;
begin
	try
		IExternalTriggerImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalTriggerImpl_getCharSetDispatcher(this: IExternalTrigger; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		IExternalTriggerImpl(this.FObject).getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalTriggerImpl_executeDispatcher(this: IExternalTrigger; status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); cdecl;
begin
	try
		IExternalTriggerImpl(this.FObject).execute(status, context, action, oldMsg, newMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalTriggerImpl_vTable: ExternalTriggerVTable = (
     NullPtr: nil;
     version: 3;
     dispose: IDisposableImpl_disposeDispatcher;
     getCharSet: IExternalTriggerImpl_getCharSetDispatcher;
     execute: IExternalTriggerImpl_executeDispatcher);

constructor IExternalTriggerImpl.create;
begin
  inherited Create;
  FvTable := @IExternalTriggerImpl_vTable;
end;

function IExternalTriggerImpl.getVTable: PExternalTriggerVTable;
begin
  Result := PExternalTriggerVTable(FvTable);
end;

class function IExternalTriggerImpl.isIExternalTriggerImpl(intf: IExternalTrigger): boolean;
begin
  Result := (intf.vTable = @IExternalTriggerImpl_vTable);
end;

function IRoutineMetadataImpl.asIRoutineMetadata:IRoutineMetadata;
begin
  Result := IRoutineMetadata(@FNullPtr);
end;

function IRoutineMetadataImpl_getPackageDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getPackage(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getNameDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getName(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getEntryPointDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getEntryPoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getBodyDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getBody(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getInputMetadataDispatcher(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getInputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getOutputMetadataDispatcher(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getOutputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerMetadataDispatcher(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getTriggerMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerTableDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getTriggerTable(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerTypeDispatcher(this: IRoutineMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(this.FObject).getTriggerType(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IRoutineMetadataImpl_vTable: RoutineMetadataVTable = (
     NullPtr: nil;
     version: 9;
     getPackage: IRoutineMetadataImpl_getPackageDispatcher;
     getName: IRoutineMetadataImpl_getNameDispatcher;
     getEntryPoint: IRoutineMetadataImpl_getEntryPointDispatcher;
     getBody: IRoutineMetadataImpl_getBodyDispatcher;
     getInputMetadata: IRoutineMetadataImpl_getInputMetadataDispatcher;
     getOutputMetadata: IRoutineMetadataImpl_getOutputMetadataDispatcher;
     getTriggerMetadata: IRoutineMetadataImpl_getTriggerMetadataDispatcher;
     getTriggerTable: IRoutineMetadataImpl_getTriggerTableDispatcher;
     getTriggerType: IRoutineMetadataImpl_getTriggerTypeDispatcher);

constructor IRoutineMetadataImpl.create;
begin
  inherited Create;
  FvTable := @IRoutineMetadataImpl_vTable;
end;

function IRoutineMetadataImpl.getVTable: PRoutineMetadataVTable;
begin
  Result := PRoutineMetadataVTable(FvTable);
end;

class function IRoutineMetadataImpl.isIRoutineMetadataImpl(intf: IRoutineMetadata): boolean;
begin
  Result := (intf.vTable = @IRoutineMetadataImpl_vTable);
end;

function IExternalEngineImpl.asIExternalEngine:IExternalEngine;
begin
  Result := IExternalEngine(@FNullPtr);
end;

procedure IExternalEngineImpl_addRefDispatcher(this: IExternalEngine); cdecl;
begin
	try
		IExternalEngineImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalEngineImpl_releaseDispatcher(this: IExternalEngine): Integer; cdecl;
begin
	try
		Result := IExternalEngineImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalEngineImpl_setOwnerDispatcher(this: IExternalEngine; r: IReferenceCounted); cdecl;
begin
	try
		IExternalEngineImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalEngineImpl_getOwnerDispatcher(this: IExternalEngine): IReferenceCounted; cdecl;
begin
	try
		Result := IExternalEngineImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalEngineImpl_openDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal); cdecl;
begin
	try
		IExternalEngineImpl(this.FObject).open(status, context, charSet, charSetSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalEngineImpl_openAttachmentDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
begin
	try
		IExternalEngineImpl(this.FObject).openAttachment(status, context);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalEngineImpl_closeAttachmentDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
begin
	try
		IExternalEngineImpl(this.FObject).closeAttachment(status, context);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeFunctionDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction; cdecl;
begin
	try
		Result := IExternalEngineImpl(this.FObject).makeFunction(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeProcedureDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure; cdecl;
begin
	try
		Result := IExternalEngineImpl(this.FObject).makeProcedure(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeTriggerDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger; cdecl;
begin
	try
		Result := IExternalEngineImpl(this.FObject).makeTrigger(status, context, metadata, fieldsBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalEngineImpl_vTable: ExternalEngineVTable = (
     NullPtr: nil;
     version: 10;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     open: IExternalEngineImpl_openDispatcher;
     openAttachment: IExternalEngineImpl_openAttachmentDispatcher;
     closeAttachment: IExternalEngineImpl_closeAttachmentDispatcher;
     makeFunction: IExternalEngineImpl_makeFunctionDispatcher;
     makeProcedure: IExternalEngineImpl_makeProcedureDispatcher;
     makeTrigger: IExternalEngineImpl_makeTriggerDispatcher);

constructor IExternalEngineImpl.create;
begin
  inherited Create;
  FvTable := @IExternalEngineImpl_vTable;
end;

function IExternalEngineImpl.getVTable: PExternalEngineVTable;
begin
  Result := PExternalEngineVTable(FvTable);
end;

class function IExternalEngineImpl.isIExternalEngineImpl(intf: IExternalEngine): boolean;
begin
  Result := (intf.vTable = @IExternalEngineImpl_vTable);
end;

function ITimerImpl.asITimer:ITimer;
begin
  Result := ITimer(@FNullPtr);
end;

procedure ITimerImpl_addRefDispatcher(this: ITimer); cdecl;
begin
	try
		ITimerImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITimerImpl_releaseDispatcher(this: ITimer): Integer; cdecl;
begin
	try
		Result := ITimerImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITimerImpl_handlerDispatcher(this: ITimer); cdecl;
begin
	try
		ITimerImpl(this.FObject).handler();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITimerImpl_vTable: TimerVTable = (
     NullPtr: nil;
     version: 3;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     handler: ITimerImpl_handlerDispatcher);

constructor ITimerImpl.create;
begin
  inherited Create;
  FvTable := @ITimerImpl_vTable;
end;

function ITimerImpl.getVTable: PTimerVTable;
begin
  Result := PTimerVTable(FvTable);
end;

class function ITimerImpl.isITimerImpl(intf: ITimer): boolean;
begin
  Result := (intf.vTable = @ITimerImpl_vTable);
end;

function ITimerControlImpl.asITimerControl:ITimerControl;
begin
  Result := ITimerControl(@FNullPtr);
end;

procedure ITimerControlImpl_startDispatcher(this: ITimerControl; status: IStatus; timer: ITimer; microSeconds: QWord); cdecl;
begin
	try
		ITimerControlImpl(this.FObject).start(status, timer, microSeconds);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITimerControlImpl_stopDispatcher(this: ITimerControl; status: IStatus; timer: ITimer); cdecl;
begin
	try
		ITimerControlImpl(this.FObject).stop(status, timer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITimerControlImpl_vTable: TimerControlVTable = (
     NullPtr: nil;
     version: 2;
     start: ITimerControlImpl_startDispatcher;
     stop: ITimerControlImpl_stopDispatcher);

constructor ITimerControlImpl.create;
begin
  inherited Create;
  FvTable := @ITimerControlImpl_vTable;
end;

function ITimerControlImpl.getVTable: PTimerControlVTable;
begin
  Result := PTimerControlVTable(FvTable);
end;

class function ITimerControlImpl.isITimerControlImpl(intf: ITimerControl): boolean;
begin
  Result := (intf.vTable = @ITimerControlImpl_vTable);
end;

function IVersionCallbackImpl.asIVersionCallback:IVersionCallback;
begin
  Result := IVersionCallback(@FNullPtr);
end;

procedure IVersionCallbackImpl_callbackDispatcher(this: IVersionCallback; status: IStatus; text: PAnsiChar); cdecl;
begin
	try
		IVersionCallbackImpl(this.FObject).callback(status, text);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IVersionCallbackImpl_vTable: VersionCallbackVTable = (
     NullPtr: nil;
     version: 1;
     callback: IVersionCallbackImpl_callbackDispatcher);

constructor IVersionCallbackImpl.create;
begin
  inherited Create;
  FvTable := @IVersionCallbackImpl_vTable;
end;

function IVersionCallbackImpl.getVTable: PVersionCallbackVTable;
begin
  Result := PVersionCallbackVTable(FvTable);
end;

class function IVersionCallbackImpl.isIVersionCallbackImpl(intf: IVersionCallback): boolean;
begin
  Result := (intf.vTable = @IVersionCallbackImpl_vTable);
end;

function IUtilImpl.asIUtil:IUtil;
begin
  Result := IUtil(@FNullPtr);
end;

procedure IUtilImpl_getFbVersionDispatcher(this: IUtil; status: IStatus; att: IAttachment; callback: IVersionCallback); cdecl;
begin
	try
		IUtilImpl(this.FObject).getFbVersion(status, att, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_loadBlobDispatcher(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
begin
	try
		IUtilImpl(this.FObject).loadBlob(status, blobId, att, tra, file_, txt);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_dumpBlobDispatcher(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
begin
	try
		IUtilImpl(this.FObject).dumpBlob(status, blobId, att, tra, file_, txt);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_getPerfCountersDispatcher(this: IUtil; status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr); cdecl;
begin
	try
		IUtilImpl(this.FObject).getPerfCounters(status, att, countersSet, counters);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_executeCreateDatabaseDispatcher(this: IUtil; status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).executeCreateDatabase(status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeDateDispatcher(this: IUtil; date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); cdecl;
begin
	try
		IUtilImpl(this.FObject).decodeDate(date, year, month, day);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUtilImpl_decodeTimeDispatcher(this: IUtil; time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); cdecl;
begin
	try
		IUtilImpl(this.FObject).decodeTime(time, hours, minutes, seconds, fractions);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_encodeDateDispatcher(this: IUtil; year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).encodeDate(year, month, day);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_encodeTimeDispatcher(this: IUtil; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).encodeTime(hours, minutes, seconds, fractions);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_formatStatusDispatcher(this: IUtil; buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).formatStatus(buffer, bufferSize, status);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_getClientVersionDispatcher(this: IUtil): Cardinal; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).getClientVersion();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_getXpbBuilderDispatcher(this: IUtil; status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).getXpbBuilder(status, kind, buf, len);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_setOffsetsDispatcher(this: IUtil; status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).setOffsets(status, metadata, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getDecFloat16Dispatcher(this: IUtil; status: IStatus): IDecFloat16; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).getDecFloat16(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getDecFloat34Dispatcher(this: IUtil; status: IStatus): IDecFloat34; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).getDecFloat34(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeTzDispatcher(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(this.FObject).decodeTimeTz(status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeStampTzDispatcher(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(this.FObject).decodeTimeStampTz(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_encodeTimeTzDispatcher(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(this.FObject).encodeTimeTz(status, timeTz, hours, minutes, seconds, fractions, timeZone);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_encodeTimeStampTzDispatcher(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(this.FObject).encodeTimeStampTz(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZone);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getInt128Dispatcher(this: IUtil; status: IStatus): IInt128; cdecl;
begin
	try
		Result := IUtilImpl(this.FObject).getInt128(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeTzExDispatcher(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(this.FObject).decodeTimeTzEx(status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeStampTzExDispatcher(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(this.FObject).decodeTimeStampTzEx(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUtilImpl_vTable: UtilVTable = (
     NullPtr: nil;
     version: 22;
     getFbVersion: IUtilImpl_getFbVersionDispatcher;
     loadBlob: IUtilImpl_loadBlobDispatcher;
     dumpBlob: IUtilImpl_dumpBlobDispatcher;
     getPerfCounters: IUtilImpl_getPerfCountersDispatcher;
     executeCreateDatabase: IUtilImpl_executeCreateDatabaseDispatcher;
     decodeDate: IUtilImpl_decodeDateDispatcher;
     decodeTime: IUtilImpl_decodeTimeDispatcher;
     encodeDate: IUtilImpl_encodeDateDispatcher;
     encodeTime: IUtilImpl_encodeTimeDispatcher;
     formatStatus: IUtilImpl_formatStatusDispatcher;
     getClientVersion: IUtilImpl_getClientVersionDispatcher;
     getXpbBuilder: IUtilImpl_getXpbBuilderDispatcher;
     setOffsets: IUtilImpl_setOffsetsDispatcher;
     getDecFloat16: IUtilImpl_getDecFloat16Dispatcher;
     getDecFloat34: IUtilImpl_getDecFloat34Dispatcher;
     decodeTimeTz: IUtilImpl_decodeTimeTzDispatcher;
     decodeTimeStampTz: IUtilImpl_decodeTimeStampTzDispatcher;
     encodeTimeTz: IUtilImpl_encodeTimeTzDispatcher;
     encodeTimeStampTz: IUtilImpl_encodeTimeStampTzDispatcher;
     getInt128: IUtilImpl_getInt128Dispatcher;
     decodeTimeTzEx: IUtilImpl_decodeTimeTzExDispatcher;
     decodeTimeStampTzEx: IUtilImpl_decodeTimeStampTzExDispatcher);

constructor IUtilImpl.create;
begin
  inherited Create;
  FvTable := @IUtilImpl_vTable;
end;

function IUtilImpl.getVTable: PUtilVTable;
begin
  Result := PUtilVTable(FvTable);
end;

class function IUtilImpl.isIUtilImpl(intf: IUtil): boolean;
begin
  Result := (intf.vTable = @IUtilImpl_vTable);
end;

function IOffsetsCallbackImpl.asIOffsetsCallback:IOffsetsCallback;
begin
  Result := IOffsetsCallback(@FNullPtr);
end;

procedure IOffsetsCallbackImpl_setOffsetDispatcher(this: IOffsetsCallback; status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); cdecl;
begin
	try
		IOffsetsCallbackImpl(this.FObject).setOffset(status, index, offset, nullOffset);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IOffsetsCallbackImpl_vTable: OffsetsCallbackVTable = (
     NullPtr: nil;
     version: 1;
     setOffset: IOffsetsCallbackImpl_setOffsetDispatcher);

constructor IOffsetsCallbackImpl.create;
begin
  inherited Create;
  FvTable := @IOffsetsCallbackImpl_vTable;
end;

function IOffsetsCallbackImpl.getVTable: POffsetsCallbackVTable;
begin
  Result := POffsetsCallbackVTable(FvTable);
end;

class function IOffsetsCallbackImpl.isIOffsetsCallbackImpl(intf: IOffsetsCallback): boolean;
begin
  Result := (intf.vTable = @IOffsetsCallbackImpl_vTable);
end;

function IXpbBuilderImpl.asIXpbBuilder:IXpbBuilder;
begin
  Result := IXpbBuilder(@FNullPtr);
end;

procedure IXpbBuilderImpl_disposeDispatcher(this: IXpbBuilder); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IXpbBuilderImpl_clearDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).clear(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_removeCurrentDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).removeCurrent(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertIntDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; value: Integer); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).insertInt(status, tag, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertBigIntDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; value: Int64); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).insertBigInt(status, tag, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertBytesDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).insertBytes(status, tag, bytes, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertStringDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; str: PAnsiChar); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).insertString(status, tag, str);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertTagDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).insertTag(status, tag);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_isEofDispatcher(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).isEof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_moveNextDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).moveNext(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_rewindDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		IXpbBuilderImpl(this.FObject).rewind(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_findFirstDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte): Boolean; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).findFirst(status, tag);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_findNextDispatcher(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).findNext(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getTagDispatcher(this: IXpbBuilder; status: IStatus): Byte; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getTag(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getLengthDispatcher(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getIntDispatcher(this: IXpbBuilder; status: IStatus): Integer; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getInt(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBigIntDispatcher(this: IXpbBuilder; status: IStatus): Int64; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getBigInt(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getStringDispatcher(this: IXpbBuilder; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getString(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBytesDispatcher(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getBytes(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBufferLengthDispatcher(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getBufferLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBufferDispatcher(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
begin
	try
		Result := IXpbBuilderImpl(this.FObject).getBuffer(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IXpbBuilderImpl_vTable: XpbBuilderVTable = (
     NullPtr: nil;
     version: 21;
     dispose: IDisposableImpl_disposeDispatcher;
     clear: IXpbBuilderImpl_clearDispatcher;
     removeCurrent: IXpbBuilderImpl_removeCurrentDispatcher;
     insertInt: IXpbBuilderImpl_insertIntDispatcher;
     insertBigInt: IXpbBuilderImpl_insertBigIntDispatcher;
     insertBytes: IXpbBuilderImpl_insertBytesDispatcher;
     insertString: IXpbBuilderImpl_insertStringDispatcher;
     insertTag: IXpbBuilderImpl_insertTagDispatcher;
     isEof: IXpbBuilderImpl_isEofDispatcher;
     moveNext: IXpbBuilderImpl_moveNextDispatcher;
     rewind: IXpbBuilderImpl_rewindDispatcher;
     findFirst: IXpbBuilderImpl_findFirstDispatcher;
     findNext: IXpbBuilderImpl_findNextDispatcher;
     getTag: IXpbBuilderImpl_getTagDispatcher;
     getLength: IXpbBuilderImpl_getLengthDispatcher;
     getInt: IXpbBuilderImpl_getIntDispatcher;
     getBigInt: IXpbBuilderImpl_getBigIntDispatcher;
     getString: IXpbBuilderImpl_getStringDispatcher;
     getBytes: IXpbBuilderImpl_getBytesDispatcher;
     getBufferLength: IXpbBuilderImpl_getBufferLengthDispatcher;
     getBuffer: IXpbBuilderImpl_getBufferDispatcher);

constructor IXpbBuilderImpl.create;
begin
  inherited Create;
  FvTable := @IXpbBuilderImpl_vTable;
end;

function IXpbBuilderImpl.getVTable: PXpbBuilderVTable;
begin
  Result := PXpbBuilderVTable(FvTable);
end;

class function IXpbBuilderImpl.isIXpbBuilderImpl(intf: IXpbBuilder): boolean;
begin
  Result := (intf.vTable = @IXpbBuilderImpl_vTable);
end;

function ITraceConnectionImpl.asITraceConnection:ITraceConnection;
begin
  Result := ITraceConnection(@FNullPtr);
end;

function ITraceConnectionImpl_getKindDispatcher(this: ITraceConnection): Cardinal; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getProcessIDDispatcher(this: ITraceConnection): Integer; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getUserNameDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRoleNameDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getCharSetDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProtocolDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteAddressDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProcessIDDispatcher(this: ITraceConnection): Integer; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProcessNameDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(this.FObject).getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceConnectionImpl_vTable: TraceConnectionVTable = (
     NullPtr: nil;
     version: 9;
     getKind: ITraceConnectionImpl_getKindDispatcher;
     getProcessID: ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName: ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName: ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet: ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol: ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress: ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID: ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName: ITraceConnectionImpl_getRemoteProcessNameDispatcher);

constructor ITraceConnectionImpl.create;
begin
  inherited Create;
  FvTable := @ITraceConnectionImpl_vTable;
end;

function ITraceConnectionImpl.getVTable: PTraceConnectionVTable;
begin
  Result := PTraceConnectionVTable(FvTable);
end;

class function ITraceConnectionImpl.isITraceConnectionImpl(intf: ITraceConnection): boolean;
begin
  Result := (intf.vTable = @ITraceConnectionImpl_vTable) or
    ITraceDatabaseConnectionImpl.isITraceDatabaseConnectionImpl(ITraceDatabaseConnection(intf)) or
    ITraceServiceConnectionImpl.isITraceServiceConnectionImpl(ITraceServiceConnection(intf));
end;

function ITraceDatabaseConnectionImpl.asITraceDatabaseConnection:ITraceDatabaseConnection;
begin
  Result := ITraceDatabaseConnection(@FNullPtr);
end;

function ITraceDatabaseConnectionImpl_getKindDispatcher(this: ITraceDatabaseConnection): Cardinal; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getProcessIDDispatcher(this: ITraceDatabaseConnection): Integer; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getUserNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRoleNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getCharSetDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProtocolDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteAddressDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProcessIDDispatcher(this: ITraceDatabaseConnection): Integer; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProcessNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getConnectionIDDispatcher(this: ITraceDatabaseConnection): Int64; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getConnectionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getDatabaseNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(this.FObject).getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceDatabaseConnectionImpl_vTable: TraceDatabaseConnectionVTable = (
     NullPtr: nil;
     version: 11;
     getKind: ITraceConnectionImpl_getKindDispatcher;
     getProcessID: ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName: ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName: ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet: ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol: ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress: ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID: ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName: ITraceConnectionImpl_getRemoteProcessNameDispatcher;
     getConnectionID: ITraceDatabaseConnectionImpl_getConnectionIDDispatcher;
     getDatabaseName: ITraceDatabaseConnectionImpl_getDatabaseNameDispatcher);

constructor ITraceDatabaseConnectionImpl.create;
begin
  inherited Create;
  FvTable := @ITraceDatabaseConnectionImpl_vTable;
end;

function ITraceDatabaseConnectionImpl.getVTable: PTraceDatabaseConnectionVTable;
begin
  Result := PTraceDatabaseConnectionVTable(FvTable);
end;

class function ITraceDatabaseConnectionImpl.isITraceDatabaseConnectionImpl(intf: ITraceDatabaseConnection): boolean;
begin
  Result := (intf.vTable = @ITraceDatabaseConnectionImpl_vTable);
end;

function ITraceTransactionImpl.asITraceTransaction:ITraceTransaction;
begin
  Result := ITraceTransaction(@FNullPtr);
end;

function ITraceTransactionImpl_getTransactionIDDispatcher(this: ITraceTransaction): Int64; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getTransactionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getReadOnlyDispatcher(this: ITraceTransaction): Boolean; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getReadOnly();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getWaitDispatcher(this: ITraceTransaction): Integer; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getWait();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getIsolationDispatcher(this: ITraceTransaction): Cardinal; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getIsolation();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getPerfDispatcher(this: ITraceTransaction): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getInitialIDDispatcher(this: ITraceTransaction): Int64; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getInitialID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getPreviousIDDispatcher(this: ITraceTransaction): Int64; cdecl;
begin
	try
		Result := ITraceTransactionImpl(this.FObject).getPreviousID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceTransactionImpl_vTable: TraceTransactionVTable = (
     NullPtr: nil;
     version: 7;
     getTransactionID: ITraceTransactionImpl_getTransactionIDDispatcher;
     getReadOnly: ITraceTransactionImpl_getReadOnlyDispatcher;
     getWait: ITraceTransactionImpl_getWaitDispatcher;
     getIsolation: ITraceTransactionImpl_getIsolationDispatcher;
     getPerf: ITraceTransactionImpl_getPerfDispatcher;
     getInitialID: ITraceTransactionImpl_getInitialIDDispatcher;
     getPreviousID: ITraceTransactionImpl_getPreviousIDDispatcher);

constructor ITraceTransactionImpl.create;
begin
  inherited Create;
  FvTable := @ITraceTransactionImpl_vTable;
end;

function ITraceTransactionImpl.getVTable: PTraceTransactionVTable;
begin
  Result := PTraceTransactionVTable(FvTable);
end;

class function ITraceTransactionImpl.isITraceTransactionImpl(intf: ITraceTransaction): boolean;
begin
  Result := (intf.vTable = @ITraceTransactionImpl_vTable);
end;

function ITraceParamsImpl.asITraceParams:ITraceParams;
begin
  Result := ITraceParams(@FNullPtr);
end;

function ITraceParamsImpl_getCountDispatcher(this: ITraceParams): Cardinal; cdecl;
begin
	try
		Result := ITraceParamsImpl(this.FObject).getCount();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceParamsImpl_getParamDispatcher(this: ITraceParams; idx: Cardinal): dscPtr; cdecl;
begin
	try
		Result := ITraceParamsImpl(this.FObject).getParam(idx);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceParamsImpl_getTextUTF8Dispatcher(this: ITraceParams; status: IStatus; idx: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := ITraceParamsImpl(this.FObject).getTextUTF8(status, idx);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITraceParamsImpl_vTable: TraceParamsVTable = (
     NullPtr: nil;
     version: 3;
     getCount: ITraceParamsImpl_getCountDispatcher;
     getParam: ITraceParamsImpl_getParamDispatcher;
     getTextUTF8: ITraceParamsImpl_getTextUTF8Dispatcher);

constructor ITraceParamsImpl.create;
begin
  inherited Create;
  FvTable := @ITraceParamsImpl_vTable;
end;

function ITraceParamsImpl.getVTable: PTraceParamsVTable;
begin
  Result := PTraceParamsVTable(FvTable);
end;

class function ITraceParamsImpl.isITraceParamsImpl(intf: ITraceParams): boolean;
begin
  Result := (intf.vTable = @ITraceParamsImpl_vTable);
end;

function ITraceStatementImpl.asITraceStatement:ITraceStatement;
begin
  Result := ITraceStatement(@FNullPtr);
end;

function ITraceStatementImpl_getStmtIDDispatcher(this: ITraceStatement): Int64; cdecl;
begin
	try
		Result := ITraceStatementImpl(this.FObject).getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatementImpl_getPerfDispatcher(this: ITraceStatement): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceStatementImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceStatementImpl_vTable: TraceStatementVTable = (
     NullPtr: nil;
     version: 2;
     getStmtID: ITraceStatementImpl_getStmtIDDispatcher;
     getPerf: ITraceStatementImpl_getPerfDispatcher);

constructor ITraceStatementImpl.create;
begin
  inherited Create;
  FvTable := @ITraceStatementImpl_vTable;
end;

function ITraceStatementImpl.getVTable: PTraceStatementVTable;
begin
  Result := PTraceStatementVTable(FvTable);
end;

class function ITraceStatementImpl.isITraceStatementImpl(intf: ITraceStatement): boolean;
begin
  Result := (intf.vTable = @ITraceStatementImpl_vTable) or
    ITraceSQLStatementImpl.isITraceSQLStatementImpl(ITraceSQLStatement(intf)) or
    ITraceBLRStatementImpl.isITraceBLRStatementImpl(ITraceBLRStatement(intf));
end;

function ITraceSQLStatementImpl.asITraceSQLStatement:ITraceSQLStatement;
begin
  Result := ITraceSQLStatement(@FNullPtr);
end;

function ITraceSQLStatementImpl_getStmtIDDispatcher(this: ITraceSQLStatement): Int64; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getPerfDispatcher(this: ITraceSQLStatement): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getTextDispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getPlanDispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getPlan();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getInputsDispatcher(this: ITraceSQLStatement): ITraceParams; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getTextUTF8Dispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getTextUTF8();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getExplainedPlanDispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(this.FObject).getExplainedPlan();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceSQLStatementImpl_vTable: TraceSQLStatementVTable = (
     NullPtr: nil;
     version: 7;
     getStmtID: ITraceStatementImpl_getStmtIDDispatcher;
     getPerf: ITraceStatementImpl_getPerfDispatcher;
     getText: ITraceSQLStatementImpl_getTextDispatcher;
     getPlan: ITraceSQLStatementImpl_getPlanDispatcher;
     getInputs: ITraceSQLStatementImpl_getInputsDispatcher;
     getTextUTF8: ITraceSQLStatementImpl_getTextUTF8Dispatcher;
     getExplainedPlan: ITraceSQLStatementImpl_getExplainedPlanDispatcher);

constructor ITraceSQLStatementImpl.create;
begin
  inherited Create;
  FvTable := @ITraceSQLStatementImpl_vTable;
end;

function ITraceSQLStatementImpl.getVTable: PTraceSQLStatementVTable;
begin
  Result := PTraceSQLStatementVTable(FvTable);
end;

class function ITraceSQLStatementImpl.isITraceSQLStatementImpl(intf: ITraceSQLStatement): boolean;
begin
  Result := (intf.vTable = @ITraceSQLStatementImpl_vTable);
end;

function ITraceBLRStatementImpl.asITraceBLRStatement:ITraceBLRStatement;
begin
  Result := ITraceBLRStatement(@FNullPtr);
end;

function ITraceBLRStatementImpl_getStmtIDDispatcher(this: ITraceBLRStatement): Int64; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(this.FObject).getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getPerfDispatcher(this: ITraceBLRStatement): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getDataDispatcher(this: ITraceBLRStatement): BytePtr; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(this.FObject).getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getDataLengthDispatcher(this: ITraceBLRStatement): Cardinal; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(this.FObject).getDataLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getTextDispatcher(this: ITraceBLRStatement): PAnsiChar; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(this.FObject).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceBLRStatementImpl_vTable: TraceBLRStatementVTable = (
     NullPtr: nil;
     version: 5;
     getStmtID: ITraceStatementImpl_getStmtIDDispatcher;
     getPerf: ITraceStatementImpl_getPerfDispatcher;
     getData: ITraceBLRStatementImpl_getDataDispatcher;
     getDataLength: ITraceBLRStatementImpl_getDataLengthDispatcher;
     getText: ITraceBLRStatementImpl_getTextDispatcher);

constructor ITraceBLRStatementImpl.create;
begin
  inherited Create;
  FvTable := @ITraceBLRStatementImpl_vTable;
end;

function ITraceBLRStatementImpl.getVTable: PTraceBLRStatementVTable;
begin
  Result := PTraceBLRStatementVTable(FvTable);
end;

class function ITraceBLRStatementImpl.isITraceBLRStatementImpl(intf: ITraceBLRStatement): boolean;
begin
  Result := (intf.vTable = @ITraceBLRStatementImpl_vTable);
end;

function ITraceDYNRequestImpl.asITraceDYNRequest:ITraceDYNRequest;
begin
  Result := ITraceDYNRequest(@FNullPtr);
end;

function ITraceDYNRequestImpl_getDataDispatcher(this: ITraceDYNRequest): BytePtr; cdecl;
begin
	try
		Result := ITraceDYNRequestImpl(this.FObject).getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDYNRequestImpl_getDataLengthDispatcher(this: ITraceDYNRequest): Cardinal; cdecl;
begin
	try
		Result := ITraceDYNRequestImpl(this.FObject).getDataLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDYNRequestImpl_getTextDispatcher(this: ITraceDYNRequest): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDYNRequestImpl(this.FObject).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceDYNRequestImpl_vTable: TraceDYNRequestVTable = (
     NullPtr: nil;
     version: 3;
     getData: ITraceDYNRequestImpl_getDataDispatcher;
     getDataLength: ITraceDYNRequestImpl_getDataLengthDispatcher;
     getText: ITraceDYNRequestImpl_getTextDispatcher);

constructor ITraceDYNRequestImpl.create;
begin
  inherited Create;
  FvTable := @ITraceDYNRequestImpl_vTable;
end;

function ITraceDYNRequestImpl.getVTable: PTraceDYNRequestVTable;
begin
  Result := PTraceDYNRequestVTable(FvTable);
end;

class function ITraceDYNRequestImpl.isITraceDYNRequestImpl(intf: ITraceDYNRequest): boolean;
begin
  Result := (intf.vTable = @ITraceDYNRequestImpl_vTable);
end;

function ITraceContextVariableImpl.asITraceContextVariable:ITraceContextVariable;
begin
  Result := ITraceContextVariable(@FNullPtr);
end;

function ITraceContextVariableImpl_getNameSpaceDispatcher(this: ITraceContextVariable): PAnsiChar; cdecl;
begin
	try
		Result := ITraceContextVariableImpl(this.FObject).getNameSpace();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceContextVariableImpl_getVarNameDispatcher(this: ITraceContextVariable): PAnsiChar; cdecl;
begin
	try
		Result := ITraceContextVariableImpl(this.FObject).getVarName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceContextVariableImpl_getVarValueDispatcher(this: ITraceContextVariable): PAnsiChar; cdecl;
begin
	try
		Result := ITraceContextVariableImpl(this.FObject).getVarValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceContextVariableImpl_vTable: TraceContextVariableVTable = (
     NullPtr: nil;
     version: 3;
     getNameSpace: ITraceContextVariableImpl_getNameSpaceDispatcher;
     getVarName: ITraceContextVariableImpl_getVarNameDispatcher;
     getVarValue: ITraceContextVariableImpl_getVarValueDispatcher);

constructor ITraceContextVariableImpl.create;
begin
  inherited Create;
  FvTable := @ITraceContextVariableImpl_vTable;
end;

function ITraceContextVariableImpl.getVTable: PTraceContextVariableVTable;
begin
  Result := PTraceContextVariableVTable(FvTable);
end;

class function ITraceContextVariableImpl.isITraceContextVariableImpl(intf: ITraceContextVariable): boolean;
begin
  Result := (intf.vTable = @ITraceContextVariableImpl_vTable);
end;

function ITraceProcedureImpl.asITraceProcedure:ITraceProcedure;
begin
  Result := ITraceProcedure(@FNullPtr);
end;

function ITraceProcedureImpl_getProcNameDispatcher(this: ITraceProcedure): PAnsiChar; cdecl;
begin
	try
		Result := ITraceProcedureImpl(this.FObject).getProcName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceProcedureImpl_getInputsDispatcher(this: ITraceProcedure): ITraceParams; cdecl;
begin
	try
		Result := ITraceProcedureImpl(this.FObject).getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceProcedureImpl_getPerfDispatcher(this: ITraceProcedure): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceProcedureImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceProcedureImpl_vTable: TraceProcedureVTable = (
     NullPtr: nil;
     version: 3;
     getProcName: ITraceProcedureImpl_getProcNameDispatcher;
     getInputs: ITraceProcedureImpl_getInputsDispatcher;
     getPerf: ITraceProcedureImpl_getPerfDispatcher);

constructor ITraceProcedureImpl.create;
begin
  inherited Create;
  FvTable := @ITraceProcedureImpl_vTable;
end;

function ITraceProcedureImpl.getVTable: PTraceProcedureVTable;
begin
  Result := PTraceProcedureVTable(FvTable);
end;

class function ITraceProcedureImpl.isITraceProcedureImpl(intf: ITraceProcedure): boolean;
begin
  Result := (intf.vTable = @ITraceProcedureImpl_vTable);
end;

function ITraceFunctionImpl.asITraceFunction:ITraceFunction;
begin
  Result := ITraceFunction(@FNullPtr);
end;

function ITraceFunctionImpl_getFuncNameDispatcher(this: ITraceFunction): PAnsiChar; cdecl;
begin
	try
		Result := ITraceFunctionImpl(this.FObject).getFuncName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getInputsDispatcher(this: ITraceFunction): ITraceParams; cdecl;
begin
	try
		Result := ITraceFunctionImpl(this.FObject).getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getResultDispatcher(this: ITraceFunction): ITraceParams; cdecl;
begin
	try
		Result := ITraceFunctionImpl(this.FObject).getResult();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getPerfDispatcher(this: ITraceFunction): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceFunctionImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceFunctionImpl_vTable: TraceFunctionVTable = (
     NullPtr: nil;
     version: 4;
     getFuncName: ITraceFunctionImpl_getFuncNameDispatcher;
     getInputs: ITraceFunctionImpl_getInputsDispatcher;
     getResult: ITraceFunctionImpl_getResultDispatcher;
     getPerf: ITraceFunctionImpl_getPerfDispatcher);

constructor ITraceFunctionImpl.create;
begin
  inherited Create;
  FvTable := @ITraceFunctionImpl_vTable;
end;

function ITraceFunctionImpl.getVTable: PTraceFunctionVTable;
begin
  Result := PTraceFunctionVTable(FvTable);
end;

class function ITraceFunctionImpl.isITraceFunctionImpl(intf: ITraceFunction): boolean;
begin
  Result := (intf.vTable = @ITraceFunctionImpl_vTable);
end;

function ITraceTriggerImpl.asITraceTrigger:ITraceTrigger;
begin
  Result := ITraceTrigger(@FNullPtr);
end;

function ITraceTriggerImpl_getTriggerNameDispatcher(this: ITraceTrigger): PAnsiChar; cdecl;
begin
	try
		Result := ITraceTriggerImpl(this.FObject).getTriggerName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getRelationNameDispatcher(this: ITraceTrigger): PAnsiChar; cdecl;
begin
	try
		Result := ITraceTriggerImpl(this.FObject).getRelationName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getActionDispatcher(this: ITraceTrigger): Integer; cdecl;
begin
	try
		Result := ITraceTriggerImpl(this.FObject).getAction();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getWhichDispatcher(this: ITraceTrigger): Integer; cdecl;
begin
	try
		Result := ITraceTriggerImpl(this.FObject).getWhich();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getPerfDispatcher(this: ITraceTrigger): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceTriggerImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceTriggerImpl_vTable: TraceTriggerVTable = (
     NullPtr: nil;
     version: 5;
     getTriggerName: ITraceTriggerImpl_getTriggerNameDispatcher;
     getRelationName: ITraceTriggerImpl_getRelationNameDispatcher;
     getAction: ITraceTriggerImpl_getActionDispatcher;
     getWhich: ITraceTriggerImpl_getWhichDispatcher;
     getPerf: ITraceTriggerImpl_getPerfDispatcher);

constructor ITraceTriggerImpl.create;
begin
  inherited Create;
  FvTable := @ITraceTriggerImpl_vTable;
end;

function ITraceTriggerImpl.getVTable: PTraceTriggerVTable;
begin
  Result := PTraceTriggerVTable(FvTable);
end;

class function ITraceTriggerImpl.isITraceTriggerImpl(intf: ITraceTrigger): boolean;
begin
  Result := (intf.vTable = @ITraceTriggerImpl_vTable);
end;

function ITraceServiceConnectionImpl.asITraceServiceConnection:ITraceServiceConnection;
begin
  Result := ITraceServiceConnection(@FNullPtr);
end;

function ITraceServiceConnectionImpl_getKindDispatcher(this: ITraceServiceConnection): Cardinal; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getProcessIDDispatcher(this: ITraceServiceConnection): Integer; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getUserNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRoleNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getCharSetDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProtocolDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteAddressDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProcessIDDispatcher(this: ITraceServiceConnection): Integer; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProcessNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceIDDispatcher(this: ITraceServiceConnection): Pointer; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getServiceID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceMgrDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getServiceMgr();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(this.FObject).getServiceName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceServiceConnectionImpl_vTable: TraceServiceConnectionVTable = (
     NullPtr: nil;
     version: 12;
     getKind: ITraceConnectionImpl_getKindDispatcher;
     getProcessID: ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName: ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName: ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet: ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol: ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress: ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID: ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName: ITraceConnectionImpl_getRemoteProcessNameDispatcher;
     getServiceID: ITraceServiceConnectionImpl_getServiceIDDispatcher;
     getServiceMgr: ITraceServiceConnectionImpl_getServiceMgrDispatcher;
     getServiceName: ITraceServiceConnectionImpl_getServiceNameDispatcher);

constructor ITraceServiceConnectionImpl.create;
begin
  inherited Create;
  FvTable := @ITraceServiceConnectionImpl_vTable;
end;

function ITraceServiceConnectionImpl.getVTable: PTraceServiceConnectionVTable;
begin
  Result := PTraceServiceConnectionVTable(FvTable);
end;

class function ITraceServiceConnectionImpl.isITraceServiceConnectionImpl(intf: ITraceServiceConnection): boolean;
begin
  Result := (intf.vTable = @ITraceServiceConnectionImpl_vTable);
end;

function ITraceStatusVectorImpl.asITraceStatusVector:ITraceStatusVector;
begin
  Result := ITraceStatusVector(@FNullPtr);
end;

function ITraceStatusVectorImpl_hasErrorDispatcher(this: ITraceStatusVector): Boolean; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(this.FObject).hasError();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_hasWarningDispatcher(this: ITraceStatusVector): Boolean; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(this.FObject).hasWarning();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_getStatusDispatcher(this: ITraceStatusVector): IStatus; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(this.FObject).getStatus();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_getTextDispatcher(this: ITraceStatusVector): PAnsiChar; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(this.FObject).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceStatusVectorImpl_vTable: TraceStatusVectorVTable = (
     NullPtr: nil;
     version: 4;
     hasError: ITraceStatusVectorImpl_hasErrorDispatcher;
     hasWarning: ITraceStatusVectorImpl_hasWarningDispatcher;
     getStatus: ITraceStatusVectorImpl_getStatusDispatcher;
     getText: ITraceStatusVectorImpl_getTextDispatcher);

constructor ITraceStatusVectorImpl.create;
begin
  inherited Create;
  FvTable := @ITraceStatusVectorImpl_vTable;
end;

function ITraceStatusVectorImpl.getVTable: PTraceStatusVectorVTable;
begin
  Result := PTraceStatusVectorVTable(FvTable);
end;

class function ITraceStatusVectorImpl.isITraceStatusVectorImpl(intf: ITraceStatusVector): boolean;
begin
  Result := (intf.vTable = @ITraceStatusVectorImpl_vTable);
end;

function ITraceSweepInfoImpl.asITraceSweepInfo:ITraceSweepInfo;
begin
  Result := ITraceSweepInfo(@FNullPtr);
end;

function ITraceSweepInfoImpl_getOITDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(this.FObject).getOIT();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getOSTDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(this.FObject).getOST();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getOATDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(this.FObject).getOAT();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getNextDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(this.FObject).getNext();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getPerfDispatcher(this: ITraceSweepInfo): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(this.FObject).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceSweepInfoImpl_vTable: TraceSweepInfoVTable = (
     NullPtr: nil;
     version: 5;
     getOIT: ITraceSweepInfoImpl_getOITDispatcher;
     getOST: ITraceSweepInfoImpl_getOSTDispatcher;
     getOAT: ITraceSweepInfoImpl_getOATDispatcher;
     getNext: ITraceSweepInfoImpl_getNextDispatcher;
     getPerf: ITraceSweepInfoImpl_getPerfDispatcher);

constructor ITraceSweepInfoImpl.create;
begin
  inherited Create;
  FvTable := @ITraceSweepInfoImpl_vTable;
end;

function ITraceSweepInfoImpl.getVTable: PTraceSweepInfoVTable;
begin
  Result := PTraceSweepInfoVTable(FvTable);
end;

class function ITraceSweepInfoImpl.isITraceSweepInfoImpl(intf: ITraceSweepInfo): boolean;
begin
  Result := (intf.vTable = @ITraceSweepInfoImpl_vTable);
end;

function ITraceLogWriterImpl.asITraceLogWriter:ITraceLogWriter;
begin
  Result := ITraceLogWriter(@FNullPtr);
end;

procedure ITraceLogWriterImpl_addRefDispatcher(this: ITraceLogWriter); cdecl;
begin
	try
		ITraceLogWriterImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_releaseDispatcher(this: ITraceLogWriter): Integer; cdecl;
begin
	try
		Result := ITraceLogWriterImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_writeDispatcher(this: ITraceLogWriter; buf: Pointer; size: Cardinal): Cardinal; cdecl;
begin
	try
		Result := ITraceLogWriterImpl(this.FObject).write(buf, size);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_write_sDispatcher(this: ITraceLogWriter; status: IStatus; buf: Pointer; size: Cardinal): Cardinal; cdecl;
begin
	try
		Result := ITraceLogWriterImpl(this.FObject).write_s(status, buf, size);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITraceLogWriterImpl_vTable: TraceLogWriterVTable = (
     NullPtr: nil;
     version: 4;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     write: ITraceLogWriterImpl_writeDispatcher;
     write_s: ITraceLogWriterImpl_write_sDispatcher);

constructor ITraceLogWriterImpl.create;
begin
  inherited Create;
  FvTable := @ITraceLogWriterImpl_vTable;
end;

function ITraceLogWriterImpl.getVTable: PTraceLogWriterVTable;
begin
  Result := PTraceLogWriterVTable(FvTable);
end;

class function ITraceLogWriterImpl.isITraceLogWriterImpl(intf: ITraceLogWriter): boolean;
begin
  Result := (intf.vTable = @ITraceLogWriterImpl_vTable);
end;

function ITraceInitInfoImpl.asITraceInitInfo:ITraceInitInfo;
begin
  Result := ITraceInitInfo(@FNullPtr);
end;

function ITraceInitInfoImpl_getConfigTextDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getConfigText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getTraceSessionIDDispatcher(this: ITraceInitInfo): Integer; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getTraceSessionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getTraceSessionNameDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getTraceSessionName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getFirebirdRootDirectoryDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getFirebirdRootDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getDatabaseNameDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getConnectionDispatcher(this: ITraceInitInfo): ITraceDatabaseConnection; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getConnection();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getLogWriterDispatcher(this: ITraceInitInfo): ITraceLogWriter; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(this.FObject).getLogWriter();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceInitInfoImpl_vTable: TraceInitInfoVTable = (
     NullPtr: nil;
     version: 7;
     getConfigText: ITraceInitInfoImpl_getConfigTextDispatcher;
     getTraceSessionID: ITraceInitInfoImpl_getTraceSessionIDDispatcher;
     getTraceSessionName: ITraceInitInfoImpl_getTraceSessionNameDispatcher;
     getFirebirdRootDirectory: ITraceInitInfoImpl_getFirebirdRootDirectoryDispatcher;
     getDatabaseName: ITraceInitInfoImpl_getDatabaseNameDispatcher;
     getConnection: ITraceInitInfoImpl_getConnectionDispatcher;
     getLogWriter: ITraceInitInfoImpl_getLogWriterDispatcher);

constructor ITraceInitInfoImpl.create;
begin
  inherited Create;
  FvTable := @ITraceInitInfoImpl_vTable;
end;

function ITraceInitInfoImpl.getVTable: PTraceInitInfoVTable;
begin
  Result := PTraceInitInfoVTable(FvTable);
end;

class function ITraceInitInfoImpl.isITraceInitInfoImpl(intf: ITraceInitInfo): boolean;
begin
  Result := (intf.vTable = @ITraceInitInfoImpl_vTable);
end;

function ITracePluginImpl.asITracePlugin:ITracePlugin;
begin
  Result := ITracePlugin(@FNullPtr);
end;

procedure ITracePluginImpl_addRefDispatcher(this: ITracePlugin); cdecl;
begin
	try
		ITracePluginImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_releaseDispatcher(this: ITracePlugin): Integer; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_get_errorDispatcher(this: ITracePlugin): PAnsiChar; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_get_error();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_attachDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_attach(connection, create_db, att_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_detachDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_detach(connection, drop_db);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_transaction_startDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_transaction_start(connection, transaction, tpb_length, tpb, tra_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_transaction_endDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_transaction_end(connection, transaction, commit, retain_context, tra_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_proc_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_proc_execute(connection, transaction, procedure_, started, proc_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_trigger_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_trigger_execute(connection, transaction, trigger, started, trig_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_set_contextDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_set_context(connection, transaction, variable);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_prepareDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_dsql_prepare(connection, transaction, statement, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_freeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_dsql_free(connection, statement, option);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_dsql_execute(connection, transaction, statement, started, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_blr_compileDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_blr_compile(connection, transaction, statement, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_blr_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_blr_execute(connection, transaction, statement, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dyn_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_dyn_execute(connection, transaction, request, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_attachDispatcher(this: ITracePlugin; service: ITraceServiceConnection; att_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_service_attach(service, att_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_startDispatcher(this: ITracePlugin; service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_service_start(service, switches_length, switches, start_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_queryDispatcher(this: ITracePlugin; service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_service_query(service, send_item_length, send_items, recv_item_length, recv_items, query_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_detachDispatcher(this: ITracePlugin; service: ITraceServiceConnection; detach_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_service_detach(service, detach_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_event_errorDispatcher(this: ITracePlugin; connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_event_error(connection, status, function_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_event_sweepDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_event_sweep(connection, sweep, sweep_state);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_func_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(this.FObject).trace_func_execute(connection, transaction, function_, started, func_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITracePluginImpl_vTable: TracePluginVTable = (
     NullPtr: nil;
     version: 23;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     trace_get_error: ITracePluginImpl_trace_get_errorDispatcher;
     trace_attach: ITracePluginImpl_trace_attachDispatcher;
     trace_detach: ITracePluginImpl_trace_detachDispatcher;
     trace_transaction_start: ITracePluginImpl_trace_transaction_startDispatcher;
     trace_transaction_end: ITracePluginImpl_trace_transaction_endDispatcher;
     trace_proc_execute: ITracePluginImpl_trace_proc_executeDispatcher;
     trace_trigger_execute: ITracePluginImpl_trace_trigger_executeDispatcher;
     trace_set_context: ITracePluginImpl_trace_set_contextDispatcher;
     trace_dsql_prepare: ITracePluginImpl_trace_dsql_prepareDispatcher;
     trace_dsql_free: ITracePluginImpl_trace_dsql_freeDispatcher;
     trace_dsql_execute: ITracePluginImpl_trace_dsql_executeDispatcher;
     trace_blr_compile: ITracePluginImpl_trace_blr_compileDispatcher;
     trace_blr_execute: ITracePluginImpl_trace_blr_executeDispatcher;
     trace_dyn_execute: ITracePluginImpl_trace_dyn_executeDispatcher;
     trace_service_attach: ITracePluginImpl_trace_service_attachDispatcher;
     trace_service_start: ITracePluginImpl_trace_service_startDispatcher;
     trace_service_query: ITracePluginImpl_trace_service_queryDispatcher;
     trace_service_detach: ITracePluginImpl_trace_service_detachDispatcher;
     trace_event_error: ITracePluginImpl_trace_event_errorDispatcher;
     trace_event_sweep: ITracePluginImpl_trace_event_sweepDispatcher;
     trace_func_execute: ITracePluginImpl_trace_func_executeDispatcher);

constructor ITracePluginImpl.create;
begin
  inherited Create;
  FvTable := @ITracePluginImpl_vTable;
end;

function ITracePluginImpl.getVTable: PTracePluginVTable;
begin
  Result := PTracePluginVTable(FvTable);
end;

class function ITracePluginImpl.isITracePluginImpl(intf: ITracePlugin): boolean;
begin
  Result := (intf.vTable = @ITracePluginImpl_vTable);
end;

function ITraceFactoryImpl.asITraceFactory:ITraceFactory;
begin
  Result := ITraceFactory(@FNullPtr);
end;

procedure ITraceFactoryImpl_addRefDispatcher(this: ITraceFactory); cdecl;
begin
	try
		ITraceFactoryImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_releaseDispatcher(this: ITraceFactory): Integer; cdecl;
begin
	try
		Result := ITraceFactoryImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITraceFactoryImpl_setOwnerDispatcher(this: ITraceFactory; r: IReferenceCounted); cdecl;
begin
	try
		ITraceFactoryImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_getOwnerDispatcher(this: ITraceFactory): IReferenceCounted; cdecl;
begin
	try
		Result := ITraceFactoryImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_trace_needsDispatcher(this: ITraceFactory): QWord; cdecl;
begin
	try
		Result := ITraceFactoryImpl(this.FObject).trace_needs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_trace_createDispatcher(this: ITraceFactory; status: IStatus; init_info: ITraceInitInfo): ITracePlugin; cdecl;
begin
	try
		Result := ITraceFactoryImpl(this.FObject).trace_create(status, init_info);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITraceFactoryImpl_vTable: TraceFactoryVTable = (
     NullPtr: nil;
     version: 6;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     trace_needs: ITraceFactoryImpl_trace_needsDispatcher;
     trace_create: ITraceFactoryImpl_trace_createDispatcher);

constructor ITraceFactoryImpl.create;
begin
  inherited Create;
  FvTable := @ITraceFactoryImpl_vTable;
end;

function ITraceFactoryImpl.getVTable: PTraceFactoryVTable;
begin
  Result := PTraceFactoryVTable(FvTable);
end;

class function ITraceFactoryImpl.isITraceFactoryImpl(intf: ITraceFactory): boolean;
begin
  Result := (intf.vTable = @ITraceFactoryImpl_vTable);
end;

function IUdrFunctionFactoryImpl.asIUdrFunctionFactory:IUdrFunctionFactory;
begin
  Result := IUdrFunctionFactory(@FNullPtr);
end;

procedure IUdrFunctionFactoryImpl_disposeDispatcher(this: IUdrFunctionFactory); cdecl;
begin
	try
		IUdrFunctionFactoryImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrFunctionFactoryImpl_setupDispatcher(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
begin
	try
		IUdrFunctionFactoryImpl(this.FObject).setup(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrFunctionFactoryImpl_newItemDispatcher(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction; cdecl;
begin
	try
		Result := IUdrFunctionFactoryImpl(this.FObject).newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrFunctionFactoryImpl_vTable: UdrFunctionFactoryVTable = (
     NullPtr: nil;
     version: 3;
     dispose: IDisposableImpl_disposeDispatcher;
     setup: IUdrFunctionFactoryImpl_setupDispatcher;
     newItem: IUdrFunctionFactoryImpl_newItemDispatcher);

constructor IUdrFunctionFactoryImpl.create;
begin
  inherited Create;
  FvTable := @IUdrFunctionFactoryImpl_vTable;
end;

function IUdrFunctionFactoryImpl.getVTable: PUdrFunctionFactoryVTable;
begin
  Result := PUdrFunctionFactoryVTable(FvTable);
end;

class function IUdrFunctionFactoryImpl.isIUdrFunctionFactoryImpl(intf: IUdrFunctionFactory): boolean;
begin
  Result := (intf.vTable = @IUdrFunctionFactoryImpl_vTable);
end;

function IUdrProcedureFactoryImpl.asIUdrProcedureFactory:IUdrProcedureFactory;
begin
  Result := IUdrProcedureFactory(@FNullPtr);
end;

procedure IUdrProcedureFactoryImpl_disposeDispatcher(this: IUdrProcedureFactory); cdecl;
begin
	try
		IUdrProcedureFactoryImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrProcedureFactoryImpl_setupDispatcher(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
begin
	try
		IUdrProcedureFactoryImpl(this.FObject).setup(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrProcedureFactoryImpl_newItemDispatcher(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure; cdecl;
begin
	try
		Result := IUdrProcedureFactoryImpl(this.FObject).newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrProcedureFactoryImpl_vTable: UdrProcedureFactoryVTable = (
     NullPtr: nil;
     version: 3;
     dispose: IDisposableImpl_disposeDispatcher;
     setup: IUdrProcedureFactoryImpl_setupDispatcher;
     newItem: IUdrProcedureFactoryImpl_newItemDispatcher);

constructor IUdrProcedureFactoryImpl.create;
begin
  inherited Create;
  FvTable := @IUdrProcedureFactoryImpl_vTable;
end;

function IUdrProcedureFactoryImpl.getVTable: PUdrProcedureFactoryVTable;
begin
  Result := PUdrProcedureFactoryVTable(FvTable);
end;

class function IUdrProcedureFactoryImpl.isIUdrProcedureFactoryImpl(intf: IUdrProcedureFactory): boolean;
begin
  Result := (intf.vTable = @IUdrProcedureFactoryImpl_vTable);
end;

function IUdrTriggerFactoryImpl.asIUdrTriggerFactory:IUdrTriggerFactory;
begin
  Result := IUdrTriggerFactory(@FNullPtr);
end;

procedure IUdrTriggerFactoryImpl_disposeDispatcher(this: IUdrTriggerFactory); cdecl;
begin
	try
		IUdrTriggerFactoryImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrTriggerFactoryImpl_setupDispatcher(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder); cdecl;
begin
	try
		IUdrTriggerFactoryImpl(this.FObject).setup(status, context, metadata, fieldsBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrTriggerFactoryImpl_newItemDispatcher(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger; cdecl;
begin
	try
		Result := IUdrTriggerFactoryImpl(this.FObject).newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrTriggerFactoryImpl_vTable: UdrTriggerFactoryVTable = (
     NullPtr: nil;
     version: 3;
     dispose: IDisposableImpl_disposeDispatcher;
     setup: IUdrTriggerFactoryImpl_setupDispatcher;
     newItem: IUdrTriggerFactoryImpl_newItemDispatcher);

constructor IUdrTriggerFactoryImpl.create;
begin
  inherited Create;
  FvTable := @IUdrTriggerFactoryImpl_vTable;
end;

function IUdrTriggerFactoryImpl.getVTable: PUdrTriggerFactoryVTable;
begin
  Result := PUdrTriggerFactoryVTable(FvTable);
end;

class function IUdrTriggerFactoryImpl.isIUdrTriggerFactoryImpl(intf: IUdrTriggerFactory): boolean;
begin
  Result := (intf.vTable = @IUdrTriggerFactoryImpl_vTable);
end;

function IUdrPluginImpl.asIUdrPlugin:IUdrPlugin;
begin
  Result := IUdrPlugin(@FNullPtr);
end;

function IUdrPluginImpl_getMasterDispatcher(this: IUdrPlugin): IMaster; cdecl;
begin
	try
		Result := IUdrPluginImpl(this.FObject).getMaster();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrPluginImpl_registerFunctionDispatcher(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory); cdecl;
begin
	try
		IUdrPluginImpl(this.FObject).registerFunction(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUdrPluginImpl_registerProcedureDispatcher(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory); cdecl;
begin
	try
		IUdrPluginImpl(this.FObject).registerProcedure(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUdrPluginImpl_registerTriggerDispatcher(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory); cdecl;
begin
	try
		IUdrPluginImpl(this.FObject).registerTrigger(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrPluginImpl_vTable: UdrPluginVTable = (
     NullPtr: nil;
     version: 4;
     getMaster: IUdrPluginImpl_getMasterDispatcher;
     registerFunction: IUdrPluginImpl_registerFunctionDispatcher;
     registerProcedure: IUdrPluginImpl_registerProcedureDispatcher;
     registerTrigger: IUdrPluginImpl_registerTriggerDispatcher);

constructor IUdrPluginImpl.create;
begin
  inherited Create;
  FvTable := @IUdrPluginImpl_vTable;
end;

function IUdrPluginImpl.getVTable: PUdrPluginVTable;
begin
  Result := PUdrPluginVTable(FvTable);
end;

class function IUdrPluginImpl.isIUdrPluginImpl(intf: IUdrPlugin): boolean;
begin
  Result := (intf.vTable = @IUdrPluginImpl_vTable);
end;

function IDecFloat16Impl.asIDecFloat16:IDecFloat16;
begin
  Result := IDecFloat16(@FNullPtr);
end;

procedure IDecFloat16Impl_toBcdDispatcher(this: IDecFloat16; from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
begin
	try
		IDecFloat16Impl(this.FObject).toBcd(from, sign, bcd, exp);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat16Impl_toStringDispatcher(this: IDecFloat16; status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		IDecFloat16Impl(this.FObject).toString(status, from, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDecFloat16Impl_fromBcdDispatcher(this: IDecFloat16; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); cdecl;
begin
	try
		IDecFloat16Impl(this.FObject).fromBcd(sign, bcd, exp, to_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat16Impl_fromStringDispatcher(this: IDecFloat16; status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr); cdecl;
begin
	try
		IDecFloat16Impl(this.FObject).fromString(status, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDecFloat16Impl_vTable: DecFloat16VTable = (
     NullPtr: nil;
     version: 4;
     toBcd: IDecFloat16Impl_toBcdDispatcher;
     toString: IDecFloat16Impl_toStringDispatcher;
     fromBcd: IDecFloat16Impl_fromBcdDispatcher;
     fromString: IDecFloat16Impl_fromStringDispatcher);

constructor IDecFloat16Impl.create;
begin
  inherited Create;
  FvTable := @IDecFloat16Impl_vTable;
end;

function IDecFloat16Impl.getVTable: PDecFloat16VTable;
begin
  Result := PDecFloat16VTable(FvTable);
end;

class function IDecFloat16Impl.isIDecFloat16Impl(intf: IDecFloat16): boolean;
begin
  Result := (intf.vTable = @IDecFloat16Impl_vTable);
end;

function IDecFloat34Impl.asIDecFloat34:IDecFloat34;
begin
  Result := IDecFloat34(@FNullPtr);
end;

procedure IDecFloat34Impl_toBcdDispatcher(this: IDecFloat34; from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
begin
	try
		IDecFloat34Impl(this.FObject).toBcd(from, sign, bcd, exp);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat34Impl_toStringDispatcher(this: IDecFloat34; status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		IDecFloat34Impl(this.FObject).toString(status, from, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDecFloat34Impl_fromBcdDispatcher(this: IDecFloat34; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); cdecl;
begin
	try
		IDecFloat34Impl(this.FObject).fromBcd(sign, bcd, exp, to_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat34Impl_fromStringDispatcher(this: IDecFloat34; status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr); cdecl;
begin
	try
		IDecFloat34Impl(this.FObject).fromString(status, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDecFloat34Impl_vTable: DecFloat34VTable = (
     NullPtr: nil;
     version: 4;
     toBcd: IDecFloat34Impl_toBcdDispatcher;
     toString: IDecFloat34Impl_toStringDispatcher;
     fromBcd: IDecFloat34Impl_fromBcdDispatcher;
     fromString: IDecFloat34Impl_fromStringDispatcher);

constructor IDecFloat34Impl.create;
begin
  inherited Create;
  FvTable := @IDecFloat34Impl_vTable;
end;

function IDecFloat34Impl.getVTable: PDecFloat34VTable;
begin
  Result := PDecFloat34VTable(FvTable);
end;

class function IDecFloat34Impl.isIDecFloat34Impl(intf: IDecFloat34): boolean;
begin
  Result := (intf.vTable = @IDecFloat34Impl_vTable);
end;

function IInt128Impl.asIInt128:IInt128;
begin
  Result := IInt128(@FNullPtr);
end;

procedure IInt128Impl_toStringDispatcher(this: IInt128; status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		IInt128Impl(this.FObject).toString(status, from, scale, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IInt128Impl_fromStringDispatcher(this: IInt128; status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); cdecl;
begin
	try
		IInt128Impl(this.FObject).fromString(status, scale, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IInt128Impl_vTable: Int128VTable = (
     NullPtr: nil;
     version: 2;
     toString: IInt128Impl_toStringDispatcher;
     fromString: IInt128Impl_fromStringDispatcher);

constructor IInt128Impl.create;
begin
  inherited Create;
  FvTable := @IInt128Impl_vTable;
end;

function IInt128Impl.getVTable: PInt128VTable;
begin
  Result := PInt128VTable(FvTable);
end;

class function IInt128Impl.isIInt128Impl(intf: IInt128): boolean;
begin
  Result := (intf.vTable = @IInt128Impl_vTable);
end;

function IReplicatedFieldImpl.asIReplicatedField:IReplicatedField;
begin
  Result := IReplicatedField(@FNullPtr);
end;

function IReplicatedFieldImpl_getNameDispatcher(this: IReplicatedField): PAnsiChar; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getTypeDispatcher(this: IReplicatedField): Cardinal; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getSubTypeDispatcher(this: IReplicatedField): Integer; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getSubType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getScaleDispatcher(this: IReplicatedField): Integer; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getScale();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getLengthDispatcher(this: IReplicatedField): Cardinal; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getCharSetDispatcher(this: IReplicatedField): Cardinal; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getDataDispatcher(this: IReplicatedField): Pointer; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(this.FObject).getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IReplicatedFieldImpl_vTable: ReplicatedFieldVTable = (
     NullPtr: nil;
     version: 7;
     getName: IReplicatedFieldImpl_getNameDispatcher;
     getType: IReplicatedFieldImpl_getTypeDispatcher;
     getSubType: IReplicatedFieldImpl_getSubTypeDispatcher;
     getScale: IReplicatedFieldImpl_getScaleDispatcher;
     getLength: IReplicatedFieldImpl_getLengthDispatcher;
     getCharSet: IReplicatedFieldImpl_getCharSetDispatcher;
     getData: IReplicatedFieldImpl_getDataDispatcher);

constructor IReplicatedFieldImpl.create;
begin
  inherited Create;
  FvTable := @IReplicatedFieldImpl_vTable;
end;

function IReplicatedFieldImpl.getVTable: PReplicatedFieldVTable;
begin
  Result := PReplicatedFieldVTable(FvTable);
end;

class function IReplicatedFieldImpl.isIReplicatedFieldImpl(intf: IReplicatedField): boolean;
begin
  Result := (intf.vTable = @IReplicatedFieldImpl_vTable);
end;

function IReplicatedRecordImpl.asIReplicatedRecord:IReplicatedRecord;
begin
  Result := IReplicatedRecord(@FNullPtr);
end;

function IReplicatedRecordImpl_getCountDispatcher(this: IReplicatedRecord): Cardinal; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(this.FObject).getCount();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getFieldDispatcher(this: IReplicatedRecord; index: Cardinal): IReplicatedField; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(this.FObject).getField(index);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getRawLengthDispatcher(this: IReplicatedRecord): Cardinal; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(this.FObject).getRawLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getRawDataDispatcher(this: IReplicatedRecord): BytePtr; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(this.FObject).getRawData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IReplicatedRecordImpl_vTable: ReplicatedRecordVTable = (
     NullPtr: nil;
     version: 4;
     getCount: IReplicatedRecordImpl_getCountDispatcher;
     getField: IReplicatedRecordImpl_getFieldDispatcher;
     getRawLength: IReplicatedRecordImpl_getRawLengthDispatcher;
     getRawData: IReplicatedRecordImpl_getRawDataDispatcher);

constructor IReplicatedRecordImpl.create;
begin
  inherited Create;
  FvTable := @IReplicatedRecordImpl_vTable;
end;

function IReplicatedRecordImpl.getVTable: PReplicatedRecordVTable;
begin
  Result := PReplicatedRecordVTable(FvTable);
end;

class function IReplicatedRecordImpl.isIReplicatedRecordImpl(intf: IReplicatedRecord): boolean;
begin
  Result := (intf.vTable = @IReplicatedRecordImpl_vTable);
end;

function IReplicatedTransactionImpl.asIReplicatedTransaction:IReplicatedTransaction;
begin
  Result := IReplicatedTransaction(@FNullPtr);
end;

procedure IReplicatedTransactionImpl_disposeDispatcher(this: IReplicatedTransaction); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatedTransactionImpl_prepareDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).prepare(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_commitDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_rollbackDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_startSavepointDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).startSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_releaseSavepointDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).releaseSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_rollbackSavepointDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).rollbackSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_insertRecordDispatcher(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).insertRecord(status, name, record_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_updateRecordDispatcher(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).updateRecord(status, name, orgRecord, newRecord);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_deleteRecordDispatcher(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).deleteRecord(status, name, record_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_executeSqlDispatcher(this: IReplicatedTransaction; status: IStatus; sql: PAnsiChar); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).executeSql(status, sql);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_executeSqlIntlDispatcher(this: IReplicatedTransaction; status: IStatus; charset: Cardinal; sql: PAnsiChar); cdecl;
begin
	try
		IReplicatedTransactionImpl(this.FObject).executeSqlIntl(status, charset, sql);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IReplicatedTransactionImpl_vTable: ReplicatedTransactionVTable = (
     NullPtr: nil;
     version: 12;
     dispose: IDisposableImpl_disposeDispatcher;
     prepare: IReplicatedTransactionImpl_prepareDispatcher;
     commit: IReplicatedTransactionImpl_commitDispatcher;
     rollback: IReplicatedTransactionImpl_rollbackDispatcher;
     startSavepoint: IReplicatedTransactionImpl_startSavepointDispatcher;
     releaseSavepoint: IReplicatedTransactionImpl_releaseSavepointDispatcher;
     rollbackSavepoint: IReplicatedTransactionImpl_rollbackSavepointDispatcher;
     insertRecord: IReplicatedTransactionImpl_insertRecordDispatcher;
     updateRecord: IReplicatedTransactionImpl_updateRecordDispatcher;
     deleteRecord: IReplicatedTransactionImpl_deleteRecordDispatcher;
     executeSql: IReplicatedTransactionImpl_executeSqlDispatcher;
     executeSqlIntl: IReplicatedTransactionImpl_executeSqlIntlDispatcher);

constructor IReplicatedTransactionImpl.create;
begin
  inherited Create;
  FvTable := @IReplicatedTransactionImpl_vTable;
end;

function IReplicatedTransactionImpl.getVTable: PReplicatedTransactionVTable;
begin
  Result := PReplicatedTransactionVTable(FvTable);
end;

class function IReplicatedTransactionImpl.isIReplicatedTransactionImpl(intf: IReplicatedTransaction): boolean;
begin
  Result := (intf.vTable = @IReplicatedTransactionImpl_vTable);
end;

function IReplicatedSessionImpl.asIReplicatedSession:IReplicatedSession;
begin
  Result := IReplicatedSession(@FNullPtr);
end;

procedure IReplicatedSessionImpl_addRefDispatcher(this: IReplicatedSession); cdecl;
begin
	try
		IReplicatedSessionImpl(this.FObject).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_releaseDispatcher(this: IReplicatedSession): Integer; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(this.FObject).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatedSessionImpl_setOwnerDispatcher(this: IReplicatedSession; r: IReferenceCounted); cdecl;
begin
	try
		IReplicatedSessionImpl(this.FObject).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_getOwnerDispatcher(this: IReplicatedSession): IReferenceCounted; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(this.FObject).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_initDispatcher(this: IReplicatedSession; status: IStatus; attachment: IAttachment): Boolean; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(this.FObject).init(status, attachment);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IReplicatedSessionImpl_startTransactionDispatcher(this: IReplicatedSession; status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(this.FObject).startTransaction(status, transaction, number);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedSessionImpl_cleanupTransactionDispatcher(this: IReplicatedSession; status: IStatus; number: Int64); cdecl;
begin
	try
		IReplicatedSessionImpl(this.FObject).cleanupTransaction(status, number);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedSessionImpl_setSequenceDispatcher(this: IReplicatedSession; status: IStatus; name: PAnsiChar; value: Int64); cdecl;
begin
	try
		IReplicatedSessionImpl(this.FObject).setSequence(status, name, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IReplicatedSessionImpl_vTable: ReplicatedSessionVTable = (
     NullPtr: nil;
     version: 8;
     addRef: IReferenceCountedImpl_addRefDispatcher;
     release: IReferenceCountedImpl_releaseDispatcher;
     setOwner: IPluginBaseImpl_setOwnerDispatcher;
     getOwner: IPluginBaseImpl_getOwnerDispatcher;
     init: IReplicatedSessionImpl_initDispatcher;
     startTransaction: IReplicatedSessionImpl_startTransactionDispatcher;
     cleanupTransaction: IReplicatedSessionImpl_cleanupTransactionDispatcher;
     setSequence: IReplicatedSessionImpl_setSequenceDispatcher);

constructor IReplicatedSessionImpl.create;
begin
  inherited Create;
  FvTable := @IReplicatedSessionImpl_vTable;
end;

function IReplicatedSessionImpl.getVTable: PReplicatedSessionVTable;
begin
  Result := PReplicatedSessionVTable(FvTable);
end;

class function IReplicatedSessionImpl.isIReplicatedSessionImpl(intf: IReplicatedSession): boolean;
begin
  Result := (intf.vTable = @IReplicatedSessionImpl_vTable);
end;

constructor FbException.create(status: IStatus);
begin
	inherited Create('FbException');
	self.status := status.clone;
end;

destructor FbException.Destroy();
begin
	status.dispose;
	inherited Destroy;
end;

function FbException.getStatus: IStatus;
begin
	Result := status;
end;

class procedure FbException.checkException(status: IStatus);
begin
	if ((status.getState and IStatusImpl.STATE_ERRORS) <> 0) then
		raise FbException.create(status);
end;

class procedure FbException.catchException(status: IStatus; e: Exception);
var
	statusVector: array[0..4] of NativeIntPtr;
	msg: AnsiString;
begin
	if (e.inheritsFrom(FbException)) then
		status.setErrors(FbException(e).getStatus.getErrors)
	else
	begin
		msg := e.message;

		statusVector[0] := NativeIntPtr(isc_arg_gds);
		statusVector[1] := NativeIntPtr(isc_random);
		statusVector[2] := NativeIntPtr(isc_arg_string);
		statusVector[3] := NativeIntPtr(PAnsiChar(msg));
		statusVector[4] := NativeIntPtr(isc_arg_end);

		status.setErrors(@statusVector);
	end
end;


end.
