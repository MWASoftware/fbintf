{ This file was autogenerated by cloop - Cross Language Object Oriented Programming }

{ $DEFINE USEFBEXCEPTION}

{$IFDEF FPC}
{$MODE DELPHI}
{$OBJECTCHECKS OFF}
{$ENDIF}

unit Firebird;

interface

uses Classes, Sysutils, IBErrorCodes;

type
{$IFNDEF FPC}
	QWord = UInt64;
{$ENDIF}

 	TFBInterfaceToken = record
	  NullPtr: pointer;
	  vTable: pointer;
	end;

	PFBImplementationToken = ^TFBImplementationToken;
	TFBImplementationToken = record
	  NullPtr: pointer;
	  vTable: pointer;
	  Owner: TObject; 
	end;

	IVersionedToken = type TFBInterfaceToken;
	PVersionedToken = ^IVersionedToken;
	IReferenceCountedToken = type TFBInterfaceToken;
	PReferenceCountedToken = ^IReferenceCountedToken;
	IDisposableToken = type TFBInterfaceToken;
	PDisposableToken = ^IDisposableToken;
	IStatusToken = type TFBInterfaceToken;
	PStatusToken = ^IStatusToken;
	IMasterToken = type TFBInterfaceToken;
	PMasterToken = ^IMasterToken;
	IPluginBaseToken = type TFBInterfaceToken;
	PPluginBaseToken = ^IPluginBaseToken;
	IPluginSetToken = type TFBInterfaceToken;
	PPluginSetToken = ^IPluginSetToken;
	IConfigEntryToken = type TFBInterfaceToken;
	PConfigEntryToken = ^IConfigEntryToken;
	IConfigToken = type TFBInterfaceToken;
	PConfigToken = ^IConfigToken;
	IFirebirdConfToken = type TFBInterfaceToken;
	PFirebirdConfToken = ^IFirebirdConfToken;
	IPluginConfigToken = type TFBInterfaceToken;
	PPluginConfigToken = ^IPluginConfigToken;
	IPluginFactoryToken = type TFBInterfaceToken;
	PPluginFactoryToken = ^IPluginFactoryToken;
	IPluginModuleToken = type TFBInterfaceToken;
	PPluginModuleToken = ^IPluginModuleToken;
	IPluginManagerToken = type TFBInterfaceToken;
	PPluginManagerToken = ^IPluginManagerToken;
	ICryptKeyToken = type TFBInterfaceToken;
	PCryptKeyToken = ^ICryptKeyToken;
	IConfigManagerToken = type TFBInterfaceToken;
	PConfigManagerToken = ^IConfigManagerToken;
	IEventCallbackToken = type TFBInterfaceToken;
	PEventCallbackToken = ^IEventCallbackToken;
	IBlobToken = type TFBInterfaceToken;
	PBlobToken = ^IBlobToken;
	ITransactionToken = type TFBInterfaceToken;
	PTransactionToken = ^ITransactionToken;
	IMessageMetadataToken = type TFBInterfaceToken;
	PMessageMetadataToken = ^IMessageMetadataToken;
	IMetadataBuilderToken = type TFBInterfaceToken;
	PMetadataBuilderToken = ^IMetadataBuilderToken;
	IResultSetToken = type TFBInterfaceToken;
	PResultSetToken = ^IResultSetToken;
	IStatementToken = type TFBInterfaceToken;
	PStatementToken = ^IStatementToken;
	IBatchToken = type TFBInterfaceToken;
	PBatchToken = ^IBatchToken;
	IBatchCompletionStateToken = type TFBInterfaceToken;
	PBatchCompletionStateToken = ^IBatchCompletionStateToken;
	IReplicatorToken = type TFBInterfaceToken;
	PReplicatorToken = ^IReplicatorToken;
	IRequestToken = type TFBInterfaceToken;
	PRequestToken = ^IRequestToken;
	IEventsToken = type TFBInterfaceToken;
	PEventsToken = ^IEventsToken;
	IAttachmentToken = type TFBInterfaceToken;
	PAttachmentToken = ^IAttachmentToken;
	IServiceToken = type TFBInterfaceToken;
	PServiceToken = ^IServiceToken;
	IProviderToken = type TFBInterfaceToken;
	PProviderToken = ^IProviderToken;
	IDtcStartToken = type TFBInterfaceToken;
	PDtcStartToken = ^IDtcStartToken;
	IDtcToken = type TFBInterfaceToken;
	PDtcToken = ^IDtcToken;
	IAuthToken = type TFBInterfaceToken;
	PAuthToken = ^IAuthToken;
	IWriterToken = type TFBInterfaceToken;
	PWriterToken = ^IWriterToken;
	IServerBlockToken = type TFBInterfaceToken;
	PServerBlockToken = ^IServerBlockToken;
	IClientBlockToken = type TFBInterfaceToken;
	PClientBlockToken = ^IClientBlockToken;
	IServerToken = type TFBInterfaceToken;
	PServerToken = ^IServerToken;
	IClientToken = type TFBInterfaceToken;
	PClientToken = ^IClientToken;
	IUserFieldToken = type TFBInterfaceToken;
	PUserFieldToken = ^IUserFieldToken;
	ICharUserFieldToken = type TFBInterfaceToken;
	PCharUserFieldToken = ^ICharUserFieldToken;
	IIntUserFieldToken = type TFBInterfaceToken;
	PIntUserFieldToken = ^IIntUserFieldToken;
	IUserToken = type TFBInterfaceToken;
	PUserToken = ^IUserToken;
	IListUsersToken = type TFBInterfaceToken;
	PListUsersToken = ^IListUsersToken;
	ILogonInfoToken = type TFBInterfaceToken;
	PLogonInfoToken = ^ILogonInfoToken;
	IManagementToken = type TFBInterfaceToken;
	PManagementToken = ^IManagementToken;
	IAuthBlockToken = type TFBInterfaceToken;
	PAuthBlockToken = ^IAuthBlockToken;
	IWireCryptPluginToken = type TFBInterfaceToken;
	PWireCryptPluginToken = ^IWireCryptPluginToken;
	ICryptKeyCallbackToken = type TFBInterfaceToken;
	PCryptKeyCallbackToken = ^ICryptKeyCallbackToken;
	IKeyHolderPluginToken = type TFBInterfaceToken;
	PKeyHolderPluginToken = ^IKeyHolderPluginToken;
	IDbCryptInfoToken = type TFBInterfaceToken;
	PDbCryptInfoToken = ^IDbCryptInfoToken;
	IDbCryptPluginToken = type TFBInterfaceToken;
	PDbCryptPluginToken = ^IDbCryptPluginToken;
	IExternalContextToken = type TFBInterfaceToken;
	PExternalContextToken = ^IExternalContextToken;
	IExternalResultSetToken = type TFBInterfaceToken;
	PExternalResultSetToken = ^IExternalResultSetToken;
	IExternalFunctionToken = type TFBInterfaceToken;
	PExternalFunctionToken = ^IExternalFunctionToken;
	IExternalProcedureToken = type TFBInterfaceToken;
	PExternalProcedureToken = ^IExternalProcedureToken;
	IExternalTriggerToken = type TFBInterfaceToken;
	PExternalTriggerToken = ^IExternalTriggerToken;
	IRoutineMetadataToken = type TFBInterfaceToken;
	PRoutineMetadataToken = ^IRoutineMetadataToken;
	IExternalEngineToken = type TFBInterfaceToken;
	PExternalEngineToken = ^IExternalEngineToken;
	ITimerToken = type TFBInterfaceToken;
	PTimerToken = ^ITimerToken;
	ITimerControlToken = type TFBInterfaceToken;
	PTimerControlToken = ^ITimerControlToken;
	IVersionCallbackToken = type TFBInterfaceToken;
	PVersionCallbackToken = ^IVersionCallbackToken;
	IUtilToken = type TFBInterfaceToken;
	PUtilToken = ^IUtilToken;
	IOffsetsCallbackToken = type TFBInterfaceToken;
	POffsetsCallbackToken = ^IOffsetsCallbackToken;
	IXpbBuilderToken = type TFBInterfaceToken;
	PXpbBuilderToken = ^IXpbBuilderToken;
	ITraceConnectionToken = type TFBInterfaceToken;
	PTraceConnectionToken = ^ITraceConnectionToken;
	ITraceDatabaseConnectionToken = type TFBInterfaceToken;
	PTraceDatabaseConnectionToken = ^ITraceDatabaseConnectionToken;
	ITraceTransactionToken = type TFBInterfaceToken;
	PTraceTransactionToken = ^ITraceTransactionToken;
	ITraceParamsToken = type TFBInterfaceToken;
	PTraceParamsToken = ^ITraceParamsToken;
	ITraceStatementToken = type TFBInterfaceToken;
	PTraceStatementToken = ^ITraceStatementToken;
	ITraceSQLStatementToken = type TFBInterfaceToken;
	PTraceSQLStatementToken = ^ITraceSQLStatementToken;
	ITraceBLRStatementToken = type TFBInterfaceToken;
	PTraceBLRStatementToken = ^ITraceBLRStatementToken;
	ITraceDYNRequestToken = type TFBInterfaceToken;
	PTraceDYNRequestToken = ^ITraceDYNRequestToken;
	ITraceContextVariableToken = type TFBInterfaceToken;
	PTraceContextVariableToken = ^ITraceContextVariableToken;
	ITraceProcedureToken = type TFBInterfaceToken;
	PTraceProcedureToken = ^ITraceProcedureToken;
	ITraceFunctionToken = type TFBInterfaceToken;
	PTraceFunctionToken = ^ITraceFunctionToken;
	ITraceTriggerToken = type TFBInterfaceToken;
	PTraceTriggerToken = ^ITraceTriggerToken;
	ITraceServiceConnectionToken = type TFBInterfaceToken;
	PTraceServiceConnectionToken = ^ITraceServiceConnectionToken;
	ITraceStatusVectorToken = type TFBInterfaceToken;
	PTraceStatusVectorToken = ^ITraceStatusVectorToken;
	ITraceSweepInfoToken = type TFBInterfaceToken;
	PTraceSweepInfoToken = ^ITraceSweepInfoToken;
	ITraceLogWriterToken = type TFBInterfaceToken;
	PTraceLogWriterToken = ^ITraceLogWriterToken;
	ITraceInitInfoToken = type TFBInterfaceToken;
	PTraceInitInfoToken = ^ITraceInitInfoToken;
	ITracePluginToken = type TFBInterfaceToken;
	PTracePluginToken = ^ITracePluginToken;
	ITraceFactoryToken = type TFBInterfaceToken;
	PTraceFactoryToken = ^ITraceFactoryToken;
	IUdrFunctionFactoryToken = type TFBInterfaceToken;
	PUdrFunctionFactoryToken = ^IUdrFunctionFactoryToken;
	IUdrProcedureFactoryToken = type TFBInterfaceToken;
	PUdrProcedureFactoryToken = ^IUdrProcedureFactoryToken;
	IUdrTriggerFactoryToken = type TFBInterfaceToken;
	PUdrTriggerFactoryToken = ^IUdrTriggerFactoryToken;
	IUdrPluginToken = type TFBInterfaceToken;
	PUdrPluginToken = ^IUdrPluginToken;
	IDecFloat16Token = type TFBInterfaceToken;
	PDecFloat16Token = ^IDecFloat16Token;
	IDecFloat34Token = type TFBInterfaceToken;
	PDecFloat34Token = ^IDecFloat34Token;
	IInt128Token = type TFBInterfaceToken;
	PInt128Token = ^IInt128Token;
	IReplicatedFieldToken = type TFBInterfaceToken;
	PReplicatedFieldToken = ^IReplicatedFieldToken;
	IReplicatedRecordToken = type TFBInterfaceToken;
	PReplicatedRecordToken = ^IReplicatedRecordToken;
	IReplicatedTransactionToken = type TFBInterfaceToken;
	PReplicatedTransactionToken = ^IReplicatedTransactionToken;
	IReplicatedSessionToken = type TFBInterfaceToken;
	PReplicatedSessionToken = ^IReplicatedSessionToken;

     
	ISC_DATE = Integer;
	ISC_TIME = Integer;
	ISC_QUAD = array [1..2] of Integer;
	FB_DEC16 = array [1..1] of Int64;
	FB_DEC34 = array [1..2] of Int64;
	FB_I128 = array [1..2] of Int64;

	isc_tr_handle = ^Integer;
	isc_stmt_handle = ^Integer;

	ISC_USHORT = word;		{ 16 bit unsigned }
	ISC_SHORT = smallint;	{ 16 bit signed }

	ISC_TIME_TZ = record
		utc_time: ISC_TIME;
		time_zone: ISC_USHORT;
	end;

	ISC_TIME_TZ_EX = record
		utc_time: ISC_TIME;
		time_zone: ISC_USHORT;
		ext_offset: ISC_SHORT;
	end;

	ISC_TIMESTAMP = record
		timestamp_date: ISC_DATE;
		timestamp_time: ISC_TIME;
	end;

	ISC_TIMESTAMP_TZ = record
		utc_timestamp: ISC_TIMESTAMP;
		time_zone: ISC_USHORT;
	end;

	ISC_TIMESTAMP_TZ_EX = record
		utc_timestamp: ISC_TIMESTAMP;
		time_zone: ISC_USHORT;
		ext_offset: ISC_SHORT;
	end;

	ntrace_relation_t = Integer;
	TraceCounts = Record
		trc_relation_id		: ntrace_relation_t;
		trc_relation_name	: PAnsiChar;
		trc_counters		: ^Int64;
	end;
	TraceCountsPtr = ^TraceCounts;
	PerformanceInfo = Record
		pin_time			: Int64;
		pin_counters		: ^Int64;
		pin_count			: NativeUInt;
		pin_tables			: TraceCountsPtr;
		pin_records_fetched	: Int64;
	end;

	Dsc = Record
		dsc_dtype, dsc_scale: Byte;
		dsc_length, dsc_sub_type, dsc_flags: Int16;
		dsc_address: ^Byte;
	end;
	BooleanPtr = ^Boolean;
	BytePtr = ^Byte;
	CardinalPtr = ^Cardinal;
	FB_DEC16Ptr = ^FB_DEC16;
	FB_DEC34Ptr = ^FB_DEC34;
	FB_I128Ptr = ^FB_I128;
	ISC_QUADPtr = ^ISC_QUAD;
	ISC_TIMESTAMP_TZPtr = ^ISC_TIMESTAMP_TZ;
	ISC_TIMESTAMP_TZ_EXPtr = ^ISC_TIMESTAMP_TZ_EX;
	ISC_TIME_TZPtr = ^ISC_TIME_TZ;
	ISC_TIME_TZ_EXPtr = ^ISC_TIME_TZ_EX;
	Int64Ptr = ^Int64;
	IntegerPtr = ^Integer;
	NativeIntPtr = ^NativeInt;
	PKeyHolderPluginTokenPtr = ^PKeyHolderPluginToken;
	PerformanceInfoPtr = ^PerformanceInfo;
	dscPtr = ^dsc;

	IReferenceCounted_addRefPtr = procedure(this: PReferenceCountedToken); cdecl;
	IReferenceCounted_releasePtr = function(this: PReferenceCountedToken): Integer; cdecl;
	IDisposable_disposePtr = procedure(this: PDisposableToken); cdecl;
	IStatus_initPtr = procedure(this: PStatusToken); cdecl;
	IStatus_getStatePtr = function(this: PStatusToken): Cardinal; cdecl;
	IStatus_setErrors2Ptr = procedure(this: PStatusToken; length: Cardinal; value: NativeIntPtr); cdecl;
	IStatus_setWarnings2Ptr = procedure(this: PStatusToken; length: Cardinal; value: NativeIntPtr); cdecl;
	IStatus_setErrorsPtr = procedure(this: PStatusToken; value: NativeIntPtr); cdecl;
	IStatus_setWarningsPtr = procedure(this: PStatusToken; value: NativeIntPtr); cdecl;
	IStatus_getErrorsPtr = function(this: PStatusToken): NativeIntPtr; cdecl;
	IStatus_getWarningsPtr = function(this: PStatusToken): NativeIntPtr; cdecl;
	IStatus_clonePtr = function(this: PStatusToken): PStatusToken; cdecl;
	IMaster_getStatusPtr = function(this: PMasterToken): PStatusToken; cdecl;
	IMaster_getDispatcherPtr = function(this: PMasterToken): PProviderToken; cdecl;
	IMaster_getPluginManagerPtr = function(this: PMasterToken): PPluginManagerToken; cdecl;
	IMaster_getTimerControlPtr = function(this: PMasterToken): PTimerControlToken; cdecl;
	IMaster_getDtcPtr = function(this: PMasterToken): PDtcToken; cdecl;
	IMaster_registerAttachmentPtr = function(this: PMasterToken; provider: PProviderToken; attachment: PAttachmentToken): PAttachmentToken; cdecl;
	IMaster_registerTransactionPtr = function(this: PMasterToken; attachment: PAttachmentToken; transaction: PTransactionToken): PTransactionToken; cdecl;
	IMaster_getMetadataBuilderPtr = function(this: PMasterToken; status: PStatusToken; fieldCount: Cardinal): PMetadataBuilderToken; cdecl;
	IMaster_serverModePtr = function(this: PMasterToken; mode: Integer): Integer; cdecl;
	IMaster_getUtilInterfacePtr = function(this: PMasterToken): PUtilToken; cdecl;
	IMaster_getConfigManagerPtr = function(this: PMasterToken): PConfigManagerToken; cdecl;
	IMaster_getProcessExitingPtr = function(this: PMasterToken): Boolean; cdecl;
	IPluginBase_setOwnerPtr = procedure(this: PPluginBaseToken; r: PReferenceCountedToken); cdecl;
	IPluginBase_getOwnerPtr = function(this: PPluginBaseToken): PReferenceCountedToken; cdecl;
	IPluginSet_getNamePtr = function(this: PPluginSetToken): PAnsiChar; cdecl;
	IPluginSet_getModuleNamePtr = function(this: PPluginSetToken): PAnsiChar; cdecl;
	IPluginSet_getPluginPtr = function(this: PPluginSetToken; status: PStatusToken): PPluginBaseToken; cdecl;
	IPluginSet_nextPtr = procedure(this: PPluginSetToken; status: PStatusToken); cdecl;
	IPluginSet_set_Ptr = procedure(this: PPluginSetToken; status: PStatusToken; s: PAnsiChar); cdecl;
	IConfigEntry_getNamePtr = function(this: PConfigEntryToken): PAnsiChar; cdecl;
	IConfigEntry_getValuePtr = function(this: PConfigEntryToken): PAnsiChar; cdecl;
	IConfigEntry_getIntValuePtr = function(this: PConfigEntryToken): Int64; cdecl;
	IConfigEntry_getBoolValuePtr = function(this: PConfigEntryToken): Boolean; cdecl;
	IConfigEntry_getSubConfigPtr = function(this: PConfigEntryToken; status: PStatusToken): PConfigToken; cdecl;
	IConfig_findPtr = function(this: PConfigToken; status: PStatusToken; name: PAnsiChar): PConfigEntryToken; cdecl;
	IConfig_findValuePtr = function(this: PConfigToken; status: PStatusToken; name: PAnsiChar; value: PAnsiChar): PConfigEntryToken; cdecl;
	IConfig_findPosPtr = function(this: PConfigToken; status: PStatusToken; name: PAnsiChar; pos: Cardinal): PConfigEntryToken; cdecl;
	IFirebirdConf_getKeyPtr = function(this: PFirebirdConfToken; name: PAnsiChar): Cardinal; cdecl;
	IFirebirdConf_asIntegerPtr = function(this: PFirebirdConfToken; key: Cardinal): Int64; cdecl;
	IFirebirdConf_asStringPtr = function(this: PFirebirdConfToken; key: Cardinal): PAnsiChar; cdecl;
	IFirebirdConf_asBooleanPtr = function(this: PFirebirdConfToken; key: Cardinal): Boolean; cdecl;
	IFirebirdConf_getVersionPtr = function(this: PFirebirdConfToken; status: PStatusToken): Cardinal; cdecl;
	IPluginConfig_getConfigFileNamePtr = function(this: PPluginConfigToken): PAnsiChar; cdecl;
	IPluginConfig_getDefaultConfigPtr = function(this: PPluginConfigToken; status: PStatusToken): PConfigToken; cdecl;
	IPluginConfig_getFirebirdConfPtr = function(this: PPluginConfigToken; status: PStatusToken): PFirebirdConfToken; cdecl;
	IPluginConfig_setReleaseDelayPtr = procedure(this: PPluginConfigToken; status: PStatusToken; microSeconds: QWord); cdecl;
	IPluginFactory_createPluginPtr = function(this: PPluginFactoryToken; status: PStatusToken; factoryParameter: PPluginConfigToken): PPluginBaseToken; cdecl;
	IPluginModule_doCleanPtr = procedure(this: PPluginModuleToken); cdecl;
	IPluginModule_threadDetachPtr = procedure(this: PPluginModuleToken); cdecl;
	IPluginManager_registerPluginFactoryPtr = procedure(this: PPluginManagerToken; pluginType: Cardinal; defaultName: PAnsiChar; factory: PPluginFactoryToken); cdecl;
	IPluginManager_registerModulePtr = procedure(this: PPluginManagerToken; cleanup: PPluginModuleToken); cdecl;
	IPluginManager_unregisterModulePtr = procedure(this: PPluginManagerToken; cleanup: PPluginModuleToken); cdecl;
	IPluginManager_getPluginsPtr = function(this: PPluginManagerToken; status: PStatusToken; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: PFirebirdConfToken): PPluginSetToken; cdecl;
	IPluginManager_getConfigPtr = function(this: PPluginManagerToken; status: PStatusToken; filename: PAnsiChar): PConfigToken; cdecl;
	IPluginManager_releasePluginPtr = procedure(this: PPluginManagerToken; plugin: PPluginBaseToken); cdecl;
	ICryptKey_setSymmetricPtr = procedure(this: PCryptKeyToken; status: PStatusToken; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); cdecl;
	ICryptKey_setAsymmetricPtr = procedure(this: PCryptKeyToken; status: PStatusToken; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); cdecl;
	ICryptKey_getEncryptKeyPtr = function(this: PCryptKeyToken; length: CardinalPtr): Pointer; cdecl;
	ICryptKey_getDecryptKeyPtr = function(this: PCryptKeyToken; length: CardinalPtr): Pointer; cdecl;
	IConfigManager_getDirectoryPtr = function(this: PConfigManagerToken; code: Cardinal): PAnsiChar; cdecl;
	IConfigManager_getFirebirdConfPtr = function(this: PConfigManagerToken): PFirebirdConfToken; cdecl;
	IConfigManager_getDatabaseConfPtr = function(this: PConfigManagerToken; dbName: PAnsiChar): PFirebirdConfToken; cdecl;
	IConfigManager_getPluginConfigPtr = function(this: PConfigManagerToken; configuredPlugin: PAnsiChar): PConfigToken; cdecl;
	IConfigManager_getInstallDirectoryPtr = function(this: PConfigManagerToken): PAnsiChar; cdecl;
	IConfigManager_getRootDirectoryPtr = function(this: PConfigManagerToken): PAnsiChar; cdecl;
	IConfigManager_getDefaultSecurityDbPtr = function(this: PConfigManagerToken): PAnsiChar; cdecl;
	IEventCallback_eventCallbackFunctionPtr = procedure(this: PEventCallbackToken; length: Cardinal; events: BytePtr); cdecl;
	IBlob_getInfoPtr = procedure(this: PBlobToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IBlob_getSegmentPtr = function(this: PBlobToken; status: PStatusToken; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; cdecl;
	IBlob_putSegmentPtr = procedure(this: PBlobToken; status: PStatusToken; length: Cardinal; buffer: Pointer); cdecl;
	IBlob_cancelPtr = procedure(this: PBlobToken; status: PStatusToken); cdecl;
	IBlob_closePtr = procedure(this: PBlobToken; status: PStatusToken); cdecl;
	IBlob_seekPtr = function(this: PBlobToken; status: PStatusToken; mode: Integer; offset: Integer): Integer; cdecl;
	ITransaction_getInfoPtr = procedure(this: PTransactionToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	ITransaction_preparePtr = procedure(this: PTransactionToken; status: PStatusToken; msgLength: Cardinal; message: BytePtr); cdecl;
	ITransaction_commitPtr = procedure(this: PTransactionToken; status: PStatusToken); cdecl;
	ITransaction_commitRetainingPtr = procedure(this: PTransactionToken; status: PStatusToken); cdecl;
	ITransaction_rollbackPtr = procedure(this: PTransactionToken; status: PStatusToken); cdecl;
	ITransaction_rollbackRetainingPtr = procedure(this: PTransactionToken; status: PStatusToken); cdecl;
	ITransaction_disconnectPtr = procedure(this: PTransactionToken; status: PStatusToken); cdecl;
	ITransaction_joinPtr = function(this: PTransactionToken; status: PStatusToken; transaction: PTransactionToken): PTransactionToken; cdecl;
	ITransaction_validatePtr = function(this: PTransactionToken; status: PStatusToken; attachment: PAttachmentToken): PTransactionToken; cdecl;
	ITransaction_enterDtcPtr = function(this: PTransactionToken; status: PStatusToken): PTransactionToken; cdecl;
	IMessageMetadata_getCountPtr = function(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
	IMessageMetadata_getFieldPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getRelationPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getOwnerPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getAliasPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getTypePtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_isNullablePtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Boolean; cdecl;
	IMessageMetadata_getSubTypePtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Integer; cdecl;
	IMessageMetadata_getLengthPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getScalePtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Integer; cdecl;
	IMessageMetadata_getCharSetPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getOffsetPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getNullOffsetPtr = function(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getBuilderPtr = function(this: PMessageMetadataToken; status: PStatusToken): PMetadataBuilderToken; cdecl;
	IMessageMetadata_getMessageLengthPtr = function(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
	IMessageMetadata_getAlignmentPtr = function(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
	IMessageMetadata_getAlignedLengthPtr = function(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
	IMetadataBuilder_setTypePtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; type_: Cardinal); cdecl;
	IMetadataBuilder_setSubTypePtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; subType: Integer); cdecl;
	IMetadataBuilder_setLengthPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; length: Cardinal); cdecl;
	IMetadataBuilder_setCharSetPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; charSet: Cardinal); cdecl;
	IMetadataBuilder_setScalePtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; scale: Integer); cdecl;
	IMetadataBuilder_truncatePtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; count: Cardinal); cdecl;
	IMetadataBuilder_moveNameToIndexPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; name: PAnsiChar; index: Cardinal); cdecl;
	IMetadataBuilder_removePtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal); cdecl;
	IMetadataBuilder_addFieldPtr = function(this: PMetadataBuilderToken; status: PStatusToken): Cardinal; cdecl;
	IMetadataBuilder_getMetadataPtr = function(this: PMetadataBuilderToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IMetadataBuilder_setFieldPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; field: PAnsiChar); cdecl;
	IMetadataBuilder_setRelationPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; relation: PAnsiChar); cdecl;
	IMetadataBuilder_setOwnerPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; owner: PAnsiChar); cdecl;
	IMetadataBuilder_setAliasPtr = procedure(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; alias: PAnsiChar); cdecl;
	IResultSet_fetchNextPtr = function(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
	IResultSet_fetchPriorPtr = function(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
	IResultSet_fetchFirstPtr = function(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
	IResultSet_fetchLastPtr = function(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
	IResultSet_fetchAbsolutePtr = function(this: PResultSetToken; status: PStatusToken; position: Integer; message: Pointer): Integer; cdecl;
	IResultSet_fetchRelativePtr = function(this: PResultSetToken; status: PStatusToken; offset: Integer; message: Pointer): Integer; cdecl;
	IResultSet_isEofPtr = function(this: PResultSetToken; status: PStatusToken): Boolean; cdecl;
	IResultSet_isBofPtr = function(this: PResultSetToken; status: PStatusToken): Boolean; cdecl;
	IResultSet_getMetadataPtr = function(this: PResultSetToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IResultSet_closePtr = procedure(this: PResultSetToken; status: PStatusToken); cdecl;
	IResultSet_setDelayedOutputFormatPtr = procedure(this: PResultSetToken; status: PStatusToken; format: PMessageMetadataToken); cdecl;
	IStatement_getInfoPtr = procedure(this: PStatementToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IStatement_getTypePtr = function(this: PStatementToken; status: PStatusToken): Cardinal; cdecl;
	IStatement_getPlanPtr = function(this: PStatementToken; status: PStatusToken; detailed: Boolean): PAnsiChar; cdecl;
	IStatement_getAffectedRecordsPtr = function(this: PStatementToken; status: PStatusToken): QWord; cdecl;
	IStatement_getInputMetadataPtr = function(this: PStatementToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IStatement_getOutputMetadataPtr = function(this: PStatementToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IStatement_executePtr = function(this: PStatementToken; status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken; cdecl;
	IStatement_openCursorPtr = function(this: PStatementToken; status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; flags: Cardinal): PResultSetToken; cdecl;
	IStatement_setCursorNamePtr = procedure(this: PStatementToken; status: PStatusToken; name: PAnsiChar); cdecl;
	IStatement_freePtr = procedure(this: PStatementToken; status: PStatusToken); cdecl;
	IStatement_getFlagsPtr = function(this: PStatementToken; status: PStatusToken): Cardinal; cdecl;
	IStatement_getTimeoutPtr = function(this: PStatementToken; status: PStatusToken): Cardinal; cdecl;
	IStatement_setTimeoutPtr = procedure(this: PStatementToken; status: PStatusToken; timeOut: Cardinal); cdecl;
	IStatement_createBatchPtr = function(this: PStatementToken; status: PStatusToken; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken; cdecl;
	IBatch_addPtr = procedure(this: PBatchToken; status: PStatusToken; count: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_addBlobPtr = procedure(this: PBatchToken; status: PStatusToken; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); cdecl;
	IBatch_appendBlobDataPtr = procedure(this: PBatchToken; status: PStatusToken; length: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_addBlobStreamPtr = procedure(this: PBatchToken; status: PStatusToken; length: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_registerBlobPtr = procedure(this: PBatchToken; status: PStatusToken; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); cdecl;
	IBatch_executePtr = function(this: PBatchToken; status: PStatusToken; transaction: PTransactionToken): PBatchCompletionStateToken; cdecl;
	IBatch_cancelPtr = procedure(this: PBatchToken; status: PStatusToken); cdecl;
	IBatch_getBlobAlignmentPtr = function(this: PBatchToken; status: PStatusToken): Cardinal; cdecl;
	IBatch_getMetadataPtr = function(this: PBatchToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IBatch_setDefaultBpbPtr = procedure(this: PBatchToken; status: PStatusToken; parLength: Cardinal; par: BytePtr); cdecl;
	IBatch_closePtr = procedure(this: PBatchToken; status: PStatusToken); cdecl;
	IBatchCompletionState_getSizePtr = function(this: PBatchCompletionStateToken; status: PStatusToken): Cardinal; cdecl;
	IBatchCompletionState_getStatePtr = function(this: PBatchCompletionStateToken; status: PStatusToken; pos: Cardinal): Integer; cdecl;
	IBatchCompletionState_findErrorPtr = function(this: PBatchCompletionStateToken; status: PStatusToken; pos: Cardinal): Cardinal; cdecl;
	IBatchCompletionState_getStatusPtr = procedure(this: PBatchCompletionStateToken; status: PStatusToken; to_: PStatusToken; pos: Cardinal); cdecl;
	IReplicator_processPtr = procedure(this: PReplicatorToken; status: PStatusToken; length: Cardinal; data: BytePtr); cdecl;
	IReplicator_closePtr = procedure(this: PReplicatorToken; status: PStatusToken); cdecl;
	IRequest_receivePtr = procedure(this: PRequestToken; status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_sendPtr = procedure(this: PRequestToken; status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_getInfoPtr = procedure(this: PRequestToken; status: PStatusToken; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IRequest_startPtr = procedure(this: PRequestToken; status: PStatusToken; tra: PTransactionToken; level: Integer); cdecl;
	IRequest_startAndSendPtr = procedure(this: PRequestToken; status: PStatusToken; tra: PTransactionToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_unwindPtr = procedure(this: PRequestToken; status: PStatusToken; level: Integer); cdecl;
	IRequest_freePtr = procedure(this: PRequestToken; status: PStatusToken); cdecl;
	IEvents_cancelPtr = procedure(this: PEventsToken; status: PStatusToken); cdecl;
	IAttachment_getInfoPtr = procedure(this: PAttachmentToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IAttachment_startTransactionPtr = function(this: PAttachmentToken; status: PStatusToken; tpbLength: Cardinal; tpb: BytePtr): PTransactionToken; cdecl;
	IAttachment_reconnectTransactionPtr = function(this: PAttachmentToken; status: PStatusToken; length: Cardinal; id: BytePtr): PTransactionToken; cdecl;
	IAttachment_compileRequestPtr = function(this: PAttachmentToken; status: PStatusToken; blrLength: Cardinal; blr: BytePtr): PRequestToken; cdecl;
	IAttachment_transactRequestPtr = procedure(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); cdecl;
	IAttachment_createBlobPtr = function(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken; cdecl;
	IAttachment_openBlobPtr = function(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken; cdecl;
	IAttachment_getSlicePtr = function(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; cdecl;
	IAttachment_putSlicePtr = procedure(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); cdecl;
	IAttachment_executeDynPtr = procedure(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; length: Cardinal; dyn: BytePtr); cdecl;
	IAttachment_preparePtr = function(this: PAttachmentToken; status: PStatusToken; tra: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): PStatementToken; cdecl;
	IAttachment_executePtr = function(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken; cdecl;
	IAttachment_openCursorPtr = function(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; cursorName: PAnsiChar; cursorFlags: Cardinal): PResultSetToken; cdecl;
	IAttachment_queEventsPtr = function(this: PAttachmentToken; status: PStatusToken; callback: PEventCallbackToken; length: Cardinal; events: BytePtr): PEventsToken; cdecl;
	IAttachment_cancelOperationPtr = procedure(this: PAttachmentToken; status: PStatusToken; option: Integer); cdecl;
	IAttachment_pingPtr = procedure(this: PAttachmentToken; status: PStatusToken); cdecl;
	IAttachment_detachPtr = procedure(this: PAttachmentToken; status: PStatusToken); cdecl;
	IAttachment_dropDatabasePtr = procedure(this: PAttachmentToken; status: PStatusToken); cdecl;
	IAttachment_getIdleTimeoutPtr = function(this: PAttachmentToken; status: PStatusToken): Cardinal; cdecl;
	IAttachment_setIdleTimeoutPtr = procedure(this: PAttachmentToken; status: PStatusToken; timeOut: Cardinal); cdecl;
	IAttachment_getStatementTimeoutPtr = function(this: PAttachmentToken; status: PStatusToken): Cardinal; cdecl;
	IAttachment_setStatementTimeoutPtr = procedure(this: PAttachmentToken; status: PStatusToken; timeOut: Cardinal); cdecl;
	IAttachment_createBatchPtr = function(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken; cdecl;
	IAttachment_createReplicatorPtr = function(this: PAttachmentToken; status: PStatusToken): PReplicatorToken; cdecl;
	IService_detachPtr = procedure(this: PServiceToken; status: PStatusToken); cdecl;
	IService_queryPtr = procedure(this: PServiceToken; status: PStatusToken; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IService_startPtr = procedure(this: PServiceToken; status: PStatusToken; spbLength: Cardinal; spb: BytePtr); cdecl;
	IProvider_attachDatabasePtr = function(this: PProviderToken; status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken; cdecl;
	IProvider_createDatabasePtr = function(this: PProviderToken; status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken; cdecl;
	IProvider_attachServiceManagerPtr = function(this: PProviderToken; status: PStatusToken; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): PServiceToken; cdecl;
	IProvider_shutdownPtr = procedure(this: PProviderToken; status: PStatusToken; timeout: Cardinal; reason: Integer); cdecl;
	IProvider_setDbCryptCallbackPtr = procedure(this: PProviderToken; status: PStatusToken; cryptCallback: PCryptKeyCallbackToken); cdecl;
	IDtcStart_addAttachmentPtr = procedure(this: PDtcStartToken; status: PStatusToken; att: PAttachmentToken); cdecl;
	IDtcStart_addWithTpbPtr = procedure(this: PDtcStartToken; status: PStatusToken; att: PAttachmentToken; length: Cardinal; tpb: BytePtr); cdecl;
	IDtcStart_startPtr = function(this: PDtcStartToken; status: PStatusToken): PTransactionToken; cdecl;
	IDtc_joinPtr = function(this: PDtcToken; status: PStatusToken; one: PTransactionToken; two: PTransactionToken): PTransactionToken; cdecl;
	IDtc_startBuilderPtr = function(this: PDtcToken; status: PStatusToken): PDtcStartToken; cdecl;
	IWriter_resetPtr = procedure(this: PWriterToken); cdecl;
	IWriter_addPtr = procedure(this: PWriterToken; status: PStatusToken; name: PAnsiChar); cdecl;
	IWriter_setTypePtr = procedure(this: PWriterToken; status: PStatusToken; value: PAnsiChar); cdecl;
	IWriter_setDbPtr = procedure(this: PWriterToken; status: PStatusToken; value: PAnsiChar); cdecl;
	IServerBlock_getLoginPtr = function(this: PServerBlockToken): PAnsiChar; cdecl;
	IServerBlock_getDataPtr = function(this: PServerBlockToken; length: CardinalPtr): BytePtr; cdecl;
	IServerBlock_putDataPtr = procedure(this: PServerBlockToken; status: PStatusToken; length: Cardinal; data: Pointer); cdecl;
	IServerBlock_newKeyPtr = function(this: PServerBlockToken; status: PStatusToken): PCryptKeyToken; cdecl;
	IClientBlock_getLoginPtr = function(this: PClientBlockToken): PAnsiChar; cdecl;
	IClientBlock_getPasswordPtr = function(this: PClientBlockToken): PAnsiChar; cdecl;
	IClientBlock_getDataPtr = function(this: PClientBlockToken; length: CardinalPtr): BytePtr; cdecl;
	IClientBlock_putDataPtr = procedure(this: PClientBlockToken; status: PStatusToken; length: Cardinal; data: Pointer); cdecl;
	IClientBlock_newKeyPtr = function(this: PClientBlockToken; status: PStatusToken): PCryptKeyToken; cdecl;
	IClientBlock_getAuthBlockPtr = function(this: PClientBlockToken; status: PStatusToken): PAuthBlockToken; cdecl;
	IServer_authenticatePtr = function(this: PServerToken; status: PStatusToken; sBlock: PServerBlockToken; writerInterface: PWriterToken): Integer; cdecl;
	IServer_setDbCryptCallbackPtr = procedure(this: PServerToken; status: PStatusToken; cryptCallback: PCryptKeyCallbackToken); cdecl;
	IClient_authenticatePtr = function(this: PClientToken; status: PStatusToken; cBlock: PClientBlockToken): Integer; cdecl;
	IUserField_enteredPtr = function(this: PUserFieldToken): Integer; cdecl;
	IUserField_specifiedPtr = function(this: PUserFieldToken): Integer; cdecl;
	IUserField_setEnteredPtr = procedure(this: PUserFieldToken; status: PStatusToken; newValue: Integer); cdecl;
	ICharUserField_getPtr = function(this: PCharUserFieldToken): PAnsiChar; cdecl;
	ICharUserField_set_Ptr = procedure(this: PCharUserFieldToken; status: PStatusToken; newValue: PAnsiChar); cdecl;
	IIntUserField_getPtr = function(this: PIntUserFieldToken): Integer; cdecl;
	IIntUserField_set_Ptr = procedure(this: PIntUserFieldToken; status: PStatusToken; newValue: Integer); cdecl;
	IUser_operationPtr = function(this: PUserToken): Cardinal; cdecl;
	IUser_userNamePtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_passwordPtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_firstNamePtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_lastNamePtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_middleNamePtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_commentPtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_attributesPtr = function(this: PUserToken): PCharUserFieldToken; cdecl;
	IUser_activePtr = function(this: PUserToken): PIntUserFieldToken; cdecl;
	IUser_adminPtr = function(this: PUserToken): PIntUserFieldToken; cdecl;
	IUser_clearPtr = procedure(this: PUserToken; status: PStatusToken); cdecl;
	IListUsers_listPtr = procedure(this: PListUsersToken; status: PStatusToken; user: PUserToken); cdecl;
	ILogonInfo_namePtr = function(this: PLogonInfoToken): PAnsiChar; cdecl;
	ILogonInfo_rolePtr = function(this: PLogonInfoToken): PAnsiChar; cdecl;
	ILogonInfo_networkProtocolPtr = function(this: PLogonInfoToken): PAnsiChar; cdecl;
	ILogonInfo_remoteAddressPtr = function(this: PLogonInfoToken): PAnsiChar; cdecl;
	ILogonInfo_authBlockPtr = function(this: PLogonInfoToken; length: CardinalPtr): BytePtr; cdecl;
	ILogonInfo_attachmentPtr = function(this: PLogonInfoToken; status: PStatusToken): PAttachmentToken; cdecl;
	ILogonInfo_transactionPtr = function(this: PLogonInfoToken; status: PStatusToken): PTransactionToken; cdecl;
	IManagement_startPtr = procedure(this: PManagementToken; status: PStatusToken; logonInfo: PLogonInfoToken); cdecl;
	IManagement_executePtr = function(this: PManagementToken; status: PStatusToken; user: PUserToken; callback: PListUsersToken): Integer; cdecl;
	IManagement_commitPtr = procedure(this: PManagementToken; status: PStatusToken); cdecl;
	IManagement_rollbackPtr = procedure(this: PManagementToken; status: PStatusToken); cdecl;
	IAuthBlock_getTypePtr = function(this: PAuthBlockToken): PAnsiChar; cdecl;
	IAuthBlock_getNamePtr = function(this: PAuthBlockToken): PAnsiChar; cdecl;
	IAuthBlock_getPluginPtr = function(this: PAuthBlockToken): PAnsiChar; cdecl;
	IAuthBlock_getSecurityDbPtr = function(this: PAuthBlockToken): PAnsiChar; cdecl;
	IAuthBlock_getOriginalPluginPtr = function(this: PAuthBlockToken): PAnsiChar; cdecl;
	IAuthBlock_nextPtr = function(this: PAuthBlockToken; status: PStatusToken): Boolean; cdecl;
	IAuthBlock_firstPtr = function(this: PAuthBlockToken; status: PStatusToken): Boolean; cdecl;
	IWireCryptPlugin_getKnownTypesPtr = function(this: PWireCryptPluginToken; status: PStatusToken): PAnsiChar; cdecl;
	IWireCryptPlugin_setKeyPtr = procedure(this: PWireCryptPluginToken; status: PStatusToken; key: PCryptKeyToken); cdecl;
	IWireCryptPlugin_encryptPtr = procedure(this: PWireCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IWireCryptPlugin_decryptPtr = procedure(this: PWireCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IWireCryptPlugin_getSpecificDataPtr = function(this: PWireCryptPluginToken; status: PStatusToken; keyType: PAnsiChar; length: CardinalPtr): BytePtr; cdecl;
	IWireCryptPlugin_setSpecificDataPtr = procedure(this: PWireCryptPluginToken; status: PStatusToken; keyType: PAnsiChar; length: Cardinal; data: BytePtr); cdecl;
	ICryptKeyCallback_callbackPtr = function(this: PCryptKeyCallbackToken; dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; cdecl;
	IKeyHolderPlugin_keyCallbackPtr = function(this: PKeyHolderPluginToken; status: PStatusToken; callback: PCryptKeyCallbackToken): Integer; cdecl;
	IKeyHolderPlugin_keyHandlePtr = function(this: PKeyHolderPluginToken; status: PStatusToken; keyName: PAnsiChar): PCryptKeyCallbackToken; cdecl;
	IKeyHolderPlugin_useOnlyOwnKeysPtr = function(this: PKeyHolderPluginToken; status: PStatusToken): Boolean; cdecl;
	IKeyHolderPlugin_chainHandlePtr = function(this: PKeyHolderPluginToken; status: PStatusToken): PCryptKeyCallbackToken; cdecl;
	IDbCryptInfo_getDatabaseFullPathPtr = function(this: PDbCryptInfoToken; status: PStatusToken): PAnsiChar; cdecl;
	IDbCryptPlugin_setKeyPtr = procedure(this: PDbCryptPluginToken; status: PStatusToken; length: Cardinal; sources: PKeyHolderPluginTokenPtr; keyName: PAnsiChar); cdecl;
	IDbCryptPlugin_encryptPtr = procedure(this: PDbCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IDbCryptPlugin_decryptPtr = procedure(this: PDbCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IDbCryptPlugin_setInfoPtr = procedure(this: PDbCryptPluginToken; status: PStatusToken; info: PDbCryptInfoToken); cdecl;
	IExternalContext_getMasterPtr = function(this: PExternalContextToken): PMasterToken; cdecl;
	IExternalContext_getEnginePtr = function(this: PExternalContextToken; status: PStatusToken): PExternalEngineToken; cdecl;
	IExternalContext_getAttachmentPtr = function(this: PExternalContextToken; status: PStatusToken): PAttachmentToken; cdecl;
	IExternalContext_getTransactionPtr = function(this: PExternalContextToken; status: PStatusToken): PTransactionToken; cdecl;
	IExternalContext_getUserNamePtr = function(this: PExternalContextToken): PAnsiChar; cdecl;
	IExternalContext_getDatabaseNamePtr = function(this: PExternalContextToken): PAnsiChar; cdecl;
	IExternalContext_getClientCharSetPtr = function(this: PExternalContextToken): PAnsiChar; cdecl;
	IExternalContext_obtainInfoCodePtr = function(this: PExternalContextToken): Integer; cdecl;
	IExternalContext_getInfoPtr = function(this: PExternalContextToken; code: Integer): Pointer; cdecl;
	IExternalContext_setInfoPtr = function(this: PExternalContextToken; code: Integer; value: Pointer): Pointer; cdecl;
	IExternalResultSet_fetchPtr = function(this: PExternalResultSetToken; status: PStatusToken): Boolean; cdecl;
	IExternalFunction_getCharSetPtr = procedure(this: PExternalFunctionToken; status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalFunction_executePtr = procedure(this: PExternalFunctionToken; status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer); cdecl;
	IExternalProcedure_getCharSetPtr = procedure(this: PExternalProcedureToken; status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalProcedure_openPtr = function(this: PExternalProcedureToken; status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer): PExternalResultSetToken; cdecl;
	IExternalTrigger_getCharSetPtr = procedure(this: PExternalTriggerToken; status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalTrigger_executePtr = procedure(this: PExternalTriggerToken; status: PStatusToken; context: PExternalContextToken; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); cdecl;
	IRoutineMetadata_getPackagePtr = function(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
	IRoutineMetadata_getNamePtr = function(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
	IRoutineMetadata_getEntryPointPtr = function(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
	IRoutineMetadata_getBodyPtr = function(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
	IRoutineMetadata_getInputMetadataPtr = function(this: PRoutineMetadataToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IRoutineMetadata_getOutputMetadataPtr = function(this: PRoutineMetadataToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IRoutineMetadata_getTriggerMetadataPtr = function(this: PRoutineMetadataToken; status: PStatusToken): PMessageMetadataToken; cdecl;
	IRoutineMetadata_getTriggerTablePtr = function(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
	IRoutineMetadata_getTriggerTypePtr = function(this: PRoutineMetadataToken; status: PStatusToken): Cardinal; cdecl;
	IExternalEngine_openPtr = procedure(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; charSet: PAnsiChar; charSetSize: Cardinal); cdecl;
	IExternalEngine_openAttachmentPtr = procedure(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken); cdecl;
	IExternalEngine_closeAttachmentPtr = procedure(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken); cdecl;
	IExternalEngine_makeFunctionPtr = function(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalFunctionToken; cdecl;
	IExternalEngine_makeProcedurePtr = function(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalProcedureToken; cdecl;
	IExternalEngine_makeTriggerPtr = function(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken): PExternalTriggerToken; cdecl;
	ITimer_handlerPtr = procedure(this: PTimerToken); cdecl;
	ITimerControl_startPtr = procedure(this: PTimerControlToken; status: PStatusToken; timer: PTimerToken; microSeconds: QWord); cdecl;
	ITimerControl_stopPtr = procedure(this: PTimerControlToken; status: PStatusToken; timer: PTimerToken); cdecl;
	IVersionCallback_callbackPtr = procedure(this: PVersionCallbackToken; status: PStatusToken; text: PAnsiChar); cdecl;
	IUtil_getFbVersionPtr = procedure(this: PUtilToken; status: PStatusToken; att: PAttachmentToken; callback: PVersionCallbackToken); cdecl;
	IUtil_loadBlobPtr = procedure(this: PUtilToken; status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean); cdecl;
	IUtil_dumpBlobPtr = procedure(this: PUtilToken; status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean); cdecl;
	IUtil_getPerfCountersPtr = procedure(this: PUtilToken; status: PStatusToken; att: PAttachmentToken; countersSet: PAnsiChar; counters: Int64Ptr); cdecl;
	IUtil_executeCreateDatabasePtr = function(this: PUtilToken; status: PStatusToken; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): PAttachmentToken; cdecl;
	IUtil_decodeDatePtr = procedure(this: PUtilToken; date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); cdecl;
	IUtil_decodeTimePtr = procedure(this: PUtilToken; time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); cdecl;
	IUtil_encodeDatePtr = function(this: PUtilToken; year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; cdecl;
	IUtil_encodeTimePtr = function(this: PUtilToken; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; cdecl;
	IUtil_formatStatusPtr = function(this: PUtilToken; buffer: PAnsiChar; bufferSize: Cardinal; status: PStatusToken): Cardinal; cdecl;
	IUtil_getClientVersionPtr = function(this: PUtilToken): Cardinal; cdecl;
	IUtil_getXpbBuilderPtr = function(this: PUtilToken; status: PStatusToken; kind: Cardinal; buf: BytePtr; len: Cardinal): PXpbBuilderToken; cdecl;
	IUtil_setOffsetsPtr = function(this: PUtilToken; status: PStatusToken; metadata: PMessageMetadataToken; callback: POffsetsCallbackToken): Cardinal; cdecl;
	IUtil_getDecFloat16Ptr = function(this: PUtilToken; status: PStatusToken): PDecFloat16Token; cdecl;
	IUtil_getDecFloat34Ptr = function(this: PUtilToken; status: PStatusToken): PDecFloat34Token; cdecl;
	IUtil_decodeTimeTzPtr = procedure(this: PUtilToken; status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_decodeTimeStampTzPtr = procedure(this: PUtilToken; status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_encodeTimeTzPtr = procedure(this: PUtilToken; status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
	IUtil_encodeTimeStampTzPtr = procedure(this: PUtilToken; status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
	IUtil_getInt128Ptr = function(this: PUtilToken; status: PStatusToken): PInt128Token; cdecl;
	IUtil_decodeTimeTzExPtr = procedure(this: PUtilToken; status: PStatusToken; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_decodeTimeStampTzExPtr = procedure(this: PUtilToken; status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IOffsetsCallback_setOffsetPtr = procedure(this: POffsetsCallbackToken; status: PStatusToken; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); cdecl;
	IXpbBuilder_clearPtr = procedure(this: PXpbBuilderToken; status: PStatusToken); cdecl;
	IXpbBuilder_removeCurrentPtr = procedure(this: PXpbBuilderToken; status: PStatusToken); cdecl;
	IXpbBuilder_insertIntPtr = procedure(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; value: Integer); cdecl;
	IXpbBuilder_insertBigIntPtr = procedure(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; value: Int64); cdecl;
	IXpbBuilder_insertBytesPtr = procedure(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; bytes: Pointer; length: Cardinal); cdecl;
	IXpbBuilder_insertStringPtr = procedure(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; str: PAnsiChar); cdecl;
	IXpbBuilder_insertTagPtr = procedure(this: PXpbBuilderToken; status: PStatusToken; tag: Byte); cdecl;
	IXpbBuilder_isEofPtr = function(this: PXpbBuilderToken; status: PStatusToken): Boolean; cdecl;
	IXpbBuilder_moveNextPtr = procedure(this: PXpbBuilderToken; status: PStatusToken); cdecl;
	IXpbBuilder_rewindPtr = procedure(this: PXpbBuilderToken; status: PStatusToken); cdecl;
	IXpbBuilder_findFirstPtr = function(this: PXpbBuilderToken; status: PStatusToken; tag: Byte): Boolean; cdecl;
	IXpbBuilder_findNextPtr = function(this: PXpbBuilderToken; status: PStatusToken): Boolean; cdecl;
	IXpbBuilder_getTagPtr = function(this: PXpbBuilderToken; status: PStatusToken): Byte; cdecl;
	IXpbBuilder_getLengthPtr = function(this: PXpbBuilderToken; status: PStatusToken): Cardinal; cdecl;
	IXpbBuilder_getIntPtr = function(this: PXpbBuilderToken; status: PStatusToken): Integer; cdecl;
	IXpbBuilder_getBigIntPtr = function(this: PXpbBuilderToken; status: PStatusToken): Int64; cdecl;
	IXpbBuilder_getStringPtr = function(this: PXpbBuilderToken; status: PStatusToken): PAnsiChar; cdecl;
	IXpbBuilder_getBytesPtr = function(this: PXpbBuilderToken; status: PStatusToken): BytePtr; cdecl;
	IXpbBuilder_getBufferLengthPtr = function(this: PXpbBuilderToken; status: PStatusToken): Cardinal; cdecl;
	IXpbBuilder_getBufferPtr = function(this: PXpbBuilderToken; status: PStatusToken): BytePtr; cdecl;
	ITraceConnection_getKindPtr = function(this: PTraceConnectionToken): Cardinal; cdecl;
	ITraceConnection_getProcessIDPtr = function(this: PTraceConnectionToken): Integer; cdecl;
	ITraceConnection_getUserNamePtr = function(this: PTraceConnectionToken): PAnsiChar; cdecl;
	ITraceConnection_getRoleNamePtr = function(this: PTraceConnectionToken): PAnsiChar; cdecl;
	ITraceConnection_getCharSetPtr = function(this: PTraceConnectionToken): PAnsiChar; cdecl;
	ITraceConnection_getRemoteProtocolPtr = function(this: PTraceConnectionToken): PAnsiChar; cdecl;
	ITraceConnection_getRemoteAddressPtr = function(this: PTraceConnectionToken): PAnsiChar; cdecl;
	ITraceConnection_getRemoteProcessIDPtr = function(this: PTraceConnectionToken): Integer; cdecl;
	ITraceConnection_getRemoteProcessNamePtr = function(this: PTraceConnectionToken): PAnsiChar; cdecl;
	ITraceDatabaseConnection_getConnectionIDPtr = function(this: PTraceDatabaseConnectionToken): Int64; cdecl;
	ITraceDatabaseConnection_getDatabaseNamePtr = function(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
	ITraceTransaction_getTransactionIDPtr = function(this: PTraceTransactionToken): Int64; cdecl;
	ITraceTransaction_getReadOnlyPtr = function(this: PTraceTransactionToken): Boolean; cdecl;
	ITraceTransaction_getWaitPtr = function(this: PTraceTransactionToken): Integer; cdecl;
	ITraceTransaction_getIsolationPtr = function(this: PTraceTransactionToken): Cardinal; cdecl;
	ITraceTransaction_getPerfPtr = function(this: PTraceTransactionToken): PerformanceInfoPtr; cdecl;
	ITraceTransaction_getInitialIDPtr = function(this: PTraceTransactionToken): Int64; cdecl;
	ITraceTransaction_getPreviousIDPtr = function(this: PTraceTransactionToken): Int64; cdecl;
	ITraceParams_getCountPtr = function(this: PTraceParamsToken): Cardinal; cdecl;
	ITraceParams_getParamPtr = function(this: PTraceParamsToken; idx: Cardinal): dscPtr; cdecl;
	ITraceParams_getTextUTF8Ptr = function(this: PTraceParamsToken; status: PStatusToken; idx: Cardinal): PAnsiChar; cdecl;
	ITraceStatement_getStmtIDPtr = function(this: PTraceStatementToken): Int64; cdecl;
	ITraceStatement_getPerfPtr = function(this: PTraceStatementToken): PerformanceInfoPtr; cdecl;
	ITraceSQLStatement_getTextPtr = function(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
	ITraceSQLStatement_getPlanPtr = function(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
	ITraceSQLStatement_getInputsPtr = function(this: PTraceSQLStatementToken): PTraceParamsToken; cdecl;
	ITraceSQLStatement_getTextUTF8Ptr = function(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
	ITraceSQLStatement_getExplainedPlanPtr = function(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
	ITraceBLRStatement_getDataPtr = function(this: PTraceBLRStatementToken): BytePtr; cdecl;
	ITraceBLRStatement_getDataLengthPtr = function(this: PTraceBLRStatementToken): Cardinal; cdecl;
	ITraceBLRStatement_getTextPtr = function(this: PTraceBLRStatementToken): PAnsiChar; cdecl;
	ITraceDYNRequest_getDataPtr = function(this: PTraceDYNRequestToken): BytePtr; cdecl;
	ITraceDYNRequest_getDataLengthPtr = function(this: PTraceDYNRequestToken): Cardinal; cdecl;
	ITraceDYNRequest_getTextPtr = function(this: PTraceDYNRequestToken): PAnsiChar; cdecl;
	ITraceContextVariable_getNameSpacePtr = function(this: PTraceContextVariableToken): PAnsiChar; cdecl;
	ITraceContextVariable_getVarNamePtr = function(this: PTraceContextVariableToken): PAnsiChar; cdecl;
	ITraceContextVariable_getVarValuePtr = function(this: PTraceContextVariableToken): PAnsiChar; cdecl;
	ITraceProcedure_getProcNamePtr = function(this: PTraceProcedureToken): PAnsiChar; cdecl;
	ITraceProcedure_getInputsPtr = function(this: PTraceProcedureToken): PTraceParamsToken; cdecl;
	ITraceProcedure_getPerfPtr = function(this: PTraceProcedureToken): PerformanceInfoPtr; cdecl;
	ITraceFunction_getFuncNamePtr = function(this: PTraceFunctionToken): PAnsiChar; cdecl;
	ITraceFunction_getInputsPtr = function(this: PTraceFunctionToken): PTraceParamsToken; cdecl;
	ITraceFunction_getResultPtr = function(this: PTraceFunctionToken): PTraceParamsToken; cdecl;
	ITraceFunction_getPerfPtr = function(this: PTraceFunctionToken): PerformanceInfoPtr; cdecl;
	ITraceTrigger_getTriggerNamePtr = function(this: PTraceTriggerToken): PAnsiChar; cdecl;
	ITraceTrigger_getRelationNamePtr = function(this: PTraceTriggerToken): PAnsiChar; cdecl;
	ITraceTrigger_getActionPtr = function(this: PTraceTriggerToken): Integer; cdecl;
	ITraceTrigger_getWhichPtr = function(this: PTraceTriggerToken): Integer; cdecl;
	ITraceTrigger_getPerfPtr = function(this: PTraceTriggerToken): PerformanceInfoPtr; cdecl;
	ITraceServiceConnection_getServiceIDPtr = function(this: PTraceServiceConnectionToken): Pointer; cdecl;
	ITraceServiceConnection_getServiceMgrPtr = function(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
	ITraceServiceConnection_getServiceNamePtr = function(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
	ITraceStatusVector_hasErrorPtr = function(this: PTraceStatusVectorToken): Boolean; cdecl;
	ITraceStatusVector_hasWarningPtr = function(this: PTraceStatusVectorToken): Boolean; cdecl;
	ITraceStatusVector_getStatusPtr = function(this: PTraceStatusVectorToken): PStatusToken; cdecl;
	ITraceStatusVector_getTextPtr = function(this: PTraceStatusVectorToken): PAnsiChar; cdecl;
	ITraceSweepInfo_getOITPtr = function(this: PTraceSweepInfoToken): Int64; cdecl;
	ITraceSweepInfo_getOSTPtr = function(this: PTraceSweepInfoToken): Int64; cdecl;
	ITraceSweepInfo_getOATPtr = function(this: PTraceSweepInfoToken): Int64; cdecl;
	ITraceSweepInfo_getNextPtr = function(this: PTraceSweepInfoToken): Int64; cdecl;
	ITraceSweepInfo_getPerfPtr = function(this: PTraceSweepInfoToken): PerformanceInfoPtr; cdecl;
	ITraceLogWriter_writePtr = function(this: PTraceLogWriterToken; buf: Pointer; size: Cardinal): Cardinal; cdecl;
	ITraceLogWriter_write_sPtr = function(this: PTraceLogWriterToken; status: PStatusToken; buf: Pointer; size: Cardinal): Cardinal; cdecl;
	ITraceInitInfo_getConfigTextPtr = function(this: PTraceInitInfoToken): PAnsiChar; cdecl;
	ITraceInitInfo_getTraceSessionIDPtr = function(this: PTraceInitInfoToken): Integer; cdecl;
	ITraceInitInfo_getTraceSessionNamePtr = function(this: PTraceInitInfoToken): PAnsiChar; cdecl;
	ITraceInitInfo_getFirebirdRootDirectoryPtr = function(this: PTraceInitInfoToken): PAnsiChar; cdecl;
	ITraceInitInfo_getDatabaseNamePtr = function(this: PTraceInitInfoToken): PAnsiChar; cdecl;
	ITraceInitInfo_getConnectionPtr = function(this: PTraceInitInfoToken): PTraceDatabaseConnectionToken; cdecl;
	ITraceInitInfo_getLogWriterPtr = function(this: PTraceInitInfoToken): PTraceLogWriterToken; cdecl;
	ITracePlugin_trace_get_errorPtr = function(this: PTracePluginToken): PAnsiChar; cdecl;
	ITracePlugin_trace_attachPtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; create_db: Boolean; att_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_detachPtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; drop_db: Boolean): Boolean; cdecl;
	ITracePlugin_trace_transaction_startPtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_transaction_endPtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_proc_executePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; procedure_: PTraceProcedureToken; started: Boolean; proc_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_trigger_executePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; trigger: PTraceTriggerToken; started: Boolean; trig_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_set_contextPtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; variable: PTraceContextVariableToken): Boolean; cdecl;
	ITracePlugin_trace_dsql_preparePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dsql_freePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; statement: PTraceSQLStatementToken; option: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dsql_executePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; started: Boolean; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_blr_compilePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_blr_executePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dyn_executePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; request: PTraceDYNRequestToken; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_attachPtr = function(this: PTracePluginToken; service: PTraceServiceConnectionToken; att_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_startPtr = function(this: PTracePluginToken; service: PTraceServiceConnectionToken; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_queryPtr = function(this: PTracePluginToken; service: PTraceServiceConnectionToken; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_detachPtr = function(this: PTracePluginToken; service: PTraceServiceConnectionToken; detach_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_event_errorPtr = function(this: PTracePluginToken; connection: PTraceConnectionToken; status: PTraceStatusVectorToken; function_: PAnsiChar): Boolean; cdecl;
	ITracePlugin_trace_event_sweepPtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; sweep: PTraceSweepInfoToken; sweep_state: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_func_executePtr = function(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; function_: PTraceFunctionToken; started: Boolean; func_result: Cardinal): Boolean; cdecl;
	ITraceFactory_trace_needsPtr = function(this: PTraceFactoryToken): QWord; cdecl;
	ITraceFactory_trace_createPtr = function(this: PTraceFactoryToken; status: PStatusToken; init_info: PTraceInitInfoToken): PTracePluginToken; cdecl;
	IUdrFunctionFactory_setupPtr = procedure(this: PUdrFunctionFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken); cdecl;
	IUdrFunctionFactory_newItemPtr = function(this: PUdrFunctionFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalFunctionToken; cdecl;
	IUdrProcedureFactory_setupPtr = procedure(this: PUdrProcedureFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken); cdecl;
	IUdrProcedureFactory_newItemPtr = function(this: PUdrProcedureFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalProcedureToken; cdecl;
	IUdrTriggerFactory_setupPtr = procedure(this: PUdrTriggerFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken); cdecl;
	IUdrTriggerFactory_newItemPtr = function(this: PUdrTriggerFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalTriggerToken; cdecl;
	IUdrPlugin_getMasterPtr = function(this: PUdrPluginToken): PMasterToken; cdecl;
	IUdrPlugin_registerFunctionPtr = procedure(this: PUdrPluginToken; status: PStatusToken; name: PAnsiChar; factory: PUdrFunctionFactoryToken); cdecl;
	IUdrPlugin_registerProcedurePtr = procedure(this: PUdrPluginToken; status: PStatusToken; name: PAnsiChar; factory: PUdrProcedureFactoryToken); cdecl;
	IUdrPlugin_registerTriggerPtr = procedure(this: PUdrPluginToken; status: PStatusToken; name: PAnsiChar; factory: PUdrTriggerFactoryToken); cdecl;
	IDecFloat16_toBcdPtr = procedure(this: PDecFloat16Token; from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
	IDecFloat16_toStringPtr = procedure(this: PDecFloat16Token; status: PStatusToken; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IDecFloat16_fromBcdPtr = procedure(this: PDecFloat16Token; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); cdecl;
	IDecFloat16_fromStringPtr = procedure(this: PDecFloat16Token; status: PStatusToken; from: PAnsiChar; to_: FB_DEC16Ptr); cdecl;
	IDecFloat34_toBcdPtr = procedure(this: PDecFloat34Token; from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
	IDecFloat34_toStringPtr = procedure(this: PDecFloat34Token; status: PStatusToken; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IDecFloat34_fromBcdPtr = procedure(this: PDecFloat34Token; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); cdecl;
	IDecFloat34_fromStringPtr = procedure(this: PDecFloat34Token; status: PStatusToken; from: PAnsiChar; to_: FB_DEC34Ptr); cdecl;
	IInt128_toStringPtr = procedure(this: PInt128Token; status: PStatusToken; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IInt128_fromStringPtr = procedure(this: PInt128Token; status: PStatusToken; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); cdecl;
	IReplicatedField_getNamePtr = function(this: PReplicatedFieldToken): PAnsiChar; cdecl;
	IReplicatedField_getTypePtr = function(this: PReplicatedFieldToken): Cardinal; cdecl;
	IReplicatedField_getSubTypePtr = function(this: PReplicatedFieldToken): Integer; cdecl;
	IReplicatedField_getScalePtr = function(this: PReplicatedFieldToken): Integer; cdecl;
	IReplicatedField_getLengthPtr = function(this: PReplicatedFieldToken): Cardinal; cdecl;
	IReplicatedField_getCharSetPtr = function(this: PReplicatedFieldToken): Cardinal; cdecl;
	IReplicatedField_getDataPtr = function(this: PReplicatedFieldToken): Pointer; cdecl;
	IReplicatedRecord_getCountPtr = function(this: PReplicatedRecordToken): Cardinal; cdecl;
	IReplicatedRecord_getFieldPtr = function(this: PReplicatedRecordToken; index: Cardinal): PReplicatedFieldToken; cdecl;
	IReplicatedRecord_getRawLengthPtr = function(this: PReplicatedRecordToken): Cardinal; cdecl;
	IReplicatedRecord_getRawDataPtr = function(this: PReplicatedRecordToken): BytePtr; cdecl;
	IReplicatedTransaction_preparePtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
	IReplicatedTransaction_commitPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
	IReplicatedTransaction_rollbackPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
	IReplicatedTransaction_startSavepointPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
	IReplicatedTransaction_releaseSavepointPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
	IReplicatedTransaction_rollbackSavepointPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
	IReplicatedTransaction_insertRecordPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken); cdecl;
	IReplicatedTransaction_updateRecordPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken; name: PAnsiChar; orgRecord: PReplicatedRecordToken; newRecord: PReplicatedRecordToken); cdecl;
	IReplicatedTransaction_deleteRecordPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken); cdecl;
	IReplicatedTransaction_executeSqlPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken; sql: PAnsiChar); cdecl;
	IReplicatedTransaction_executeSqlIntlPtr = procedure(this: PReplicatedTransactionToken; status: PStatusToken; charset: Cardinal; sql: PAnsiChar); cdecl;
	IReplicatedSession_initPtr = function(this: PReplicatedSessionToken; status: PStatusToken; attachment: PAttachmentToken): Boolean; cdecl;
	IReplicatedSession_startTransactionPtr = function(this: PReplicatedSessionToken; status: PStatusToken; transaction: PTransactionToken; number: Int64): PReplicatedTransactionToken; cdecl;
	IReplicatedSession_cleanupTransactionPtr = procedure(this: PReplicatedSessionToken; status: PStatusToken; number: Int64); cdecl;
	IReplicatedSession_setSequencePtr = procedure(this: PReplicatedSessionToken; status: PStatusToken; name: PAnsiChar; value: Int64); cdecl;

	PVersionedVTable = ^VersionedVTable;
	VersionedVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	end;

	IVersionedImpl = class;

	IVersioned = record
	private
	  token: PVersionedToken;
	public
	  const VERSION = 0;

	  function vTable: PVersionedVTable inline;
	  class operator := (aToken:  PVersionedToken): IVersioned;
	  class operator := (intf: IVersioned): PVersionedToken;
	  class operator := (impl: IVersionedImpl): IVersioned;
	  class operator = (a: IVersioned; b: pointer): boolean;
class operator = (a,b: IVersioned): boolean;
	end;

	IVersionedImpl = class
	private
	  class var vTable: VersionedVTable; 
	  class var FInitialized: boolean;
	  intf: IVersioned;
	  class procedure Initialize;
	protected
	  token: TFBImplementationToken;
	public
	  constructor create;
	  function getInterfaceToken: PVersionedToken inline;
	  function getInterface: IVersioned inline;
	end;

	PReferenceCountedVTable = ^ReferenceCountedVTable;
	ReferenceCountedVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	end;

	IReferenceCountedImpl = class;

	IReferenceCounted = record
	private
	  token: PReferenceCountedToken;
	public
	  const VERSION = 2;

	  function vTable: PReferenceCountedVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  class operator := (aToken:  PReferenceCountedToken): IReferenceCounted;
	  class operator := (intf: IReferenceCounted): PReferenceCountedToken;
	  class operator := (impl: IReferenceCountedImpl): IReferenceCounted;
	  class operator = (a: IReferenceCounted; b: pointer): boolean;
class operator = (a,b: IReferenceCounted): boolean;
	end;

	IReferenceCountedImpl = class(IVersionedImpl)
	private
	  class var vTable: ReferenceCountedVTable; 
	  class var FInitialized: boolean;
	  intf: IReferenceCounted;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PReferenceCountedToken inline;
	  function getInterface: IReferenceCounted inline;
		procedure addRef(); virtual; abstract;
		function release(): Integer; virtual; abstract;
	end;

	PDisposableVTable = ^DisposableVTable;
	DisposableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	end;

	IDisposableImpl = class;

	IDisposable = record
	private
	  token: PDisposableToken;
	public
	  const VERSION = 1;

	  function vTable: PDisposableVTable inline;
	  procedure dispose();
	  class operator := (aToken:  PDisposableToken): IDisposable;
	  class operator := (intf: IDisposable): PDisposableToken;
	  class operator := (impl: IDisposableImpl): IDisposable;
	  class operator = (a: IDisposable; b: pointer): boolean;
class operator = (a,b: IDisposable): boolean;
	end;

	IDisposableImpl = class(IVersionedImpl)
	private
	  class var vTable: DisposableVTable; 
	  class var FInitialized: boolean;
	  intf: IDisposable;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDisposableToken inline;
	  function getInterface: IDisposable inline;
		procedure dispose(); virtual; abstract;
	end;

	PStatusVTable = ^StatusVTable;
	StatusVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  init: IStatus_initPtr;
	  getState: IStatus_getStatePtr;
	  setErrors2: IStatus_setErrors2Ptr;
	  setWarnings2: IStatus_setWarnings2Ptr;
	  setErrors: IStatus_setErrorsPtr;
	  setWarnings: IStatus_setWarningsPtr;
	  getErrors: IStatus_getErrorsPtr;
	  getWarnings: IStatus_getWarningsPtr;
	  clone: IStatus_clonePtr;
	end;

	IStatusImpl = class;

	IStatus = record
	private
	  token: PStatusToken;
	public
	  const VERSION = 10;
	  const STATE_WARNINGS = Cardinal($1);
	  const STATE_ERRORS = Cardinal($2);
	  const RESULT_ERROR = Integer(-1);
	  const RESULT_OK = Integer(0);
	  const RESULT_NO_DATA = Integer(1);
	  const RESULT_SEGMENT = Integer(2);

	  function vTable: PStatusVTable inline;
	  procedure dispose();
	  procedure init();
	  function getState(): Cardinal;
	  procedure setErrors2(length: Cardinal; value: NativeIntPtr);
	  procedure setWarnings2(length: Cardinal; value: NativeIntPtr);
	  procedure setErrors(value: NativeIntPtr);
	  procedure setWarnings(value: NativeIntPtr);
	  function getErrors(): NativeIntPtr;
	  function getWarnings(): NativeIntPtr;
	  function clone(): PStatusToken;
	  class operator := (aToken:  PStatusToken): IStatus;
	  class operator := (intf: IStatus): PStatusToken;
	  class operator := (impl: IStatusImpl): IStatus;
	  class operator = (a: IStatus; b: pointer): boolean;
class operator = (a,b: IStatus): boolean;
	end;

	IStatusImpl = class(IDisposableImpl)
	private
	  class var vTable: StatusVTable; 
	  class var FInitialized: boolean;
	  intf: IStatus;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PStatusToken inline;
	  function getInterface: IStatus inline;
		procedure init(); virtual; abstract;
		function getState(): Cardinal; virtual; abstract;
		procedure setErrors2(length: Cardinal; value: NativeIntPtr); virtual; abstract;
		procedure setWarnings2(length: Cardinal; value: NativeIntPtr); virtual; abstract;
		procedure setErrors(value: NativeIntPtr); virtual; abstract;
		procedure setWarnings(value: NativeIntPtr); virtual; abstract;
		function getErrors(): NativeIntPtr; virtual; abstract;
		function getWarnings(): NativeIntPtr; virtual; abstract;
		function clone(): PStatusToken; virtual; abstract;
	end;

	PMasterVTable = ^MasterVTable;
	MasterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStatus: IMaster_getStatusPtr;
	  getDispatcher: IMaster_getDispatcherPtr;
	  getPluginManager: IMaster_getPluginManagerPtr;
	  getTimerControl: IMaster_getTimerControlPtr;
	  getDtc: IMaster_getDtcPtr;
	  registerAttachment: IMaster_registerAttachmentPtr;
	  registerTransaction: IMaster_registerTransactionPtr;
	  getMetadataBuilder: IMaster_getMetadataBuilderPtr;
	  serverMode: IMaster_serverModePtr;
	  getUtilInterface: IMaster_getUtilInterfacePtr;
	  getConfigManager: IMaster_getConfigManagerPtr;
	  getProcessExiting: IMaster_getProcessExitingPtr;
	end;

	IMasterImpl = class;

	IMaster = record
	private
	  token: PMasterToken;
	public
	  const VERSION = 12;

	  function vTable: PMasterVTable inline;
	  function getStatus(): PStatusToken;
	  function getDispatcher(): PProviderToken;
	  function getPluginManager(): PPluginManagerToken;
	  function getTimerControl(): PTimerControlToken;
	  function getDtc(): PDtcToken;
	  function registerAttachment(provider: PProviderToken; attachment: PAttachmentToken): PAttachmentToken;
	  function registerTransaction(attachment: PAttachmentToken; transaction: PTransactionToken): PTransactionToken;
	  function getMetadataBuilder(status: PStatusToken; fieldCount: Cardinal): PMetadataBuilderToken;
	  function serverMode(mode: Integer): Integer;
	  function getUtilInterface(): PUtilToken;
	  function getConfigManager(): PConfigManagerToken;
	  function getProcessExiting(): Boolean;
	  class operator := (aToken:  PMasterToken): IMaster;
	  class operator := (intf: IMaster): PMasterToken;
	  class operator := (impl: IMasterImpl): IMaster;
	  class operator = (a: IMaster; b: pointer): boolean;
class operator = (a,b: IMaster): boolean;
	end;

	IMasterImpl = class(IVersionedImpl)
	private
	  class var vTable: MasterVTable; 
	  class var FInitialized: boolean;
	  intf: IMaster;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PMasterToken inline;
	  function getInterface: IMaster inline;
		function getStatus(): PStatusToken; virtual; abstract;
		function getDispatcher(): PProviderToken; virtual; abstract;
		function getPluginManager(): PPluginManagerToken; virtual; abstract;
		function getTimerControl(): PTimerControlToken; virtual; abstract;
		function getDtc(): PDtcToken; virtual; abstract;
		function registerAttachment(provider: PProviderToken; attachment: PAttachmentToken): PAttachmentToken; virtual; abstract;
		function registerTransaction(attachment: PAttachmentToken; transaction: PTransactionToken): PTransactionToken; virtual; abstract;
		function getMetadataBuilder(status: PStatusToken; fieldCount: Cardinal): PMetadataBuilderToken; virtual; abstract;
		function serverMode(mode: Integer): Integer; virtual; abstract;
		function getUtilInterface(): PUtilToken; virtual; abstract;
		function getConfigManager(): PConfigManagerToken; virtual; abstract;
		function getProcessExiting(): Boolean; virtual; abstract;
	end;

	PPluginBaseVTable = ^PluginBaseVTable;
	PluginBaseVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	end;

	IPluginBaseImpl = class;

	IPluginBase = record
	private
	  token: PPluginBaseToken;
	public
	  const VERSION = 4;

	  function vTable: PPluginBaseVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  class operator := (aToken:  PPluginBaseToken): IPluginBase;
	  class operator := (intf: IPluginBase): PPluginBaseToken;
	  class operator := (impl: IPluginBaseImpl): IPluginBase;
	  class operator = (a: IPluginBase; b: pointer): boolean;
class operator = (a,b: IPluginBase): boolean;
	end;

	IPluginBaseImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: PluginBaseVTable; 
	  class var FInitialized: boolean;
	  intf: IPluginBase;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PPluginBaseToken inline;
	  function getInterface: IPluginBase inline;
		procedure setOwner(r: PReferenceCountedToken); virtual; abstract;
		function getOwner(): PReferenceCountedToken; virtual; abstract;
	end;

	PPluginSetVTable = ^PluginSetVTable;
	PluginSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getName: IPluginSet_getNamePtr;
	  getModuleName: IPluginSet_getModuleNamePtr;
	  getPlugin: IPluginSet_getPluginPtr;
	  next: IPluginSet_nextPtr;
	  set_: IPluginSet_set_Ptr;
	end;

	IPluginSetImpl = class;

	IPluginSet = record
	private
	  token: PPluginSetToken;
	public
	  const VERSION = 7;

	  function vTable: PPluginSetVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getName(): PAnsiChar;
	  function getModuleName(): PAnsiChar;
	  function getPlugin(status: PStatusToken): PPluginBaseToken;
	  procedure next(status: PStatusToken);
	  procedure set_(status: PStatusToken; s: PAnsiChar);
	  class operator := (aToken:  PPluginSetToken): IPluginSet;
	  class operator := (intf: IPluginSet): PPluginSetToken;
	  class operator := (impl: IPluginSetImpl): IPluginSet;
	  class operator = (a: IPluginSet; b: pointer): boolean;
class operator = (a,b: IPluginSet): boolean;
	end;

	IPluginSetImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: PluginSetVTable; 
	  class var FInitialized: boolean;
	  intf: IPluginSet;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PPluginSetToken inline;
	  function getInterface: IPluginSet inline;
		function getName(): PAnsiChar; virtual; abstract;
		function getModuleName(): PAnsiChar; virtual; abstract;
		function getPlugin(status: PStatusToken): PPluginBaseToken; virtual; abstract;
		procedure next(status: PStatusToken); virtual; abstract;
		procedure set_(status: PStatusToken; s: PAnsiChar); virtual; abstract;
	end;

	PConfigEntryVTable = ^ConfigEntryVTable;
	ConfigEntryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getName: IConfigEntry_getNamePtr;
	  getValue: IConfigEntry_getValuePtr;
	  getIntValue: IConfigEntry_getIntValuePtr;
	  getBoolValue: IConfigEntry_getBoolValuePtr;
	  getSubConfig: IConfigEntry_getSubConfigPtr;
	end;

	IConfigEntryImpl = class;

	IConfigEntry = record
	private
	  token: PConfigEntryToken;
	public
	  const VERSION = 7;

	  function vTable: PConfigEntryVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getName(): PAnsiChar;
	  function getValue(): PAnsiChar;
	  function getIntValue(): Int64;
	  function getBoolValue(): Boolean;
	  function getSubConfig(status: PStatusToken): PConfigToken;
	  class operator := (aToken:  PConfigEntryToken): IConfigEntry;
	  class operator := (intf: IConfigEntry): PConfigEntryToken;
	  class operator := (impl: IConfigEntryImpl): IConfigEntry;
	  class operator = (a: IConfigEntry; b: pointer): boolean;
class operator = (a,b: IConfigEntry): boolean;
	end;

	IConfigEntryImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: ConfigEntryVTable; 
	  class var FInitialized: boolean;
	  intf: IConfigEntry;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PConfigEntryToken inline;
	  function getInterface: IConfigEntry inline;
		function getName(): PAnsiChar; virtual; abstract;
		function getValue(): PAnsiChar; virtual; abstract;
		function getIntValue(): Int64; virtual; abstract;
		function getBoolValue(): Boolean; virtual; abstract;
		function getSubConfig(status: PStatusToken): PConfigToken; virtual; abstract;
	end;

	PConfigVTable = ^ConfigVTable;
	ConfigVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  find: IConfig_findPtr;
	  findValue: IConfig_findValuePtr;
	  findPos: IConfig_findPosPtr;
	end;

	IConfigImpl = class;

	IConfig = record
	private
	  token: PConfigToken;
	public
	  const VERSION = 5;

	  function vTable: PConfigVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function find(status: PStatusToken; name: PAnsiChar): PConfigEntryToken;
	  function findValue(status: PStatusToken; name: PAnsiChar; value: PAnsiChar): PConfigEntryToken;
	  function findPos(status: PStatusToken; name: PAnsiChar; pos: Cardinal): PConfigEntryToken;
	  class operator := (aToken:  PConfigToken): IConfig;
	  class operator := (intf: IConfig): PConfigToken;
	  class operator := (impl: IConfigImpl): IConfig;
	  class operator = (a: IConfig; b: pointer): boolean;
class operator = (a,b: IConfig): boolean;
	end;

	IConfigImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: ConfigVTable; 
	  class var FInitialized: boolean;
	  intf: IConfig;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PConfigToken inline;
	  function getInterface: IConfig inline;
		function find(status: PStatusToken; name: PAnsiChar): PConfigEntryToken; virtual; abstract;
		function findValue(status: PStatusToken; name: PAnsiChar; value: PAnsiChar): PConfigEntryToken; virtual; abstract;
		function findPos(status: PStatusToken; name: PAnsiChar; pos: Cardinal): PConfigEntryToken; virtual; abstract;
	end;

	PFirebirdConfVTable = ^FirebirdConfVTable;
	FirebirdConfVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getKey: IFirebirdConf_getKeyPtr;
	  asInteger: IFirebirdConf_asIntegerPtr;
	  asString: IFirebirdConf_asStringPtr;
	  asBoolean: IFirebirdConf_asBooleanPtr;
	  getVersion: IFirebirdConf_getVersionPtr;
	end;

	IFirebirdConfImpl = class;

	IFirebirdConf = record
	private
	  token: PFirebirdConfToken;
	public
	  const VERSION = 7;

	  function vTable: PFirebirdConfVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getKey(name: PAnsiChar): Cardinal;
	  function asInteger(key: Cardinal): Int64;
	  function asString(key: Cardinal): PAnsiChar;
	  function asBoolean(key: Cardinal): Boolean;
	  function getVersion(status: PStatusToken): Cardinal;
	  class operator := (aToken:  PFirebirdConfToken): IFirebirdConf;
	  class operator := (intf: IFirebirdConf): PFirebirdConfToken;
	  class operator := (impl: IFirebirdConfImpl): IFirebirdConf;
	  class operator = (a: IFirebirdConf; b: pointer): boolean;
class operator = (a,b: IFirebirdConf): boolean;
	end;

	IFirebirdConfImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: FirebirdConfVTable; 
	  class var FInitialized: boolean;
	  intf: IFirebirdConf;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PFirebirdConfToken inline;
	  function getInterface: IFirebirdConf inline;
		function getKey(name: PAnsiChar): Cardinal; virtual; abstract;
		function asInteger(key: Cardinal): Int64; virtual; abstract;
		function asString(key: Cardinal): PAnsiChar; virtual; abstract;
		function asBoolean(key: Cardinal): Boolean; virtual; abstract;
		function getVersion(status: PStatusToken): Cardinal; virtual; abstract;
	end;

	PPluginConfigVTable = ^PluginConfigVTable;
	PluginConfigVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getConfigFileName: IPluginConfig_getConfigFileNamePtr;
	  getDefaultConfig: IPluginConfig_getDefaultConfigPtr;
	  getFirebirdConf: IPluginConfig_getFirebirdConfPtr;
	  setReleaseDelay: IPluginConfig_setReleaseDelayPtr;
	end;

	IPluginConfigImpl = class;

	IPluginConfig = record
	private
	  token: PPluginConfigToken;
	public
	  const VERSION = 6;

	  function vTable: PPluginConfigVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getConfigFileName(): PAnsiChar;
	  function getDefaultConfig(status: PStatusToken): PConfigToken;
	  function getFirebirdConf(status: PStatusToken): PFirebirdConfToken;
	  procedure setReleaseDelay(status: PStatusToken; microSeconds: QWord);
	  class operator := (aToken:  PPluginConfigToken): IPluginConfig;
	  class operator := (intf: IPluginConfig): PPluginConfigToken;
	  class operator := (impl: IPluginConfigImpl): IPluginConfig;
	  class operator = (a: IPluginConfig; b: pointer): boolean;
class operator = (a,b: IPluginConfig): boolean;
	end;

	IPluginConfigImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: PluginConfigVTable; 
	  class var FInitialized: boolean;
	  intf: IPluginConfig;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PPluginConfigToken inline;
	  function getInterface: IPluginConfig inline;
		function getConfigFileName(): PAnsiChar; virtual; abstract;
		function getDefaultConfig(status: PStatusToken): PConfigToken; virtual; abstract;
		function getFirebirdConf(status: PStatusToken): PFirebirdConfToken; virtual; abstract;
		procedure setReleaseDelay(status: PStatusToken; microSeconds: QWord); virtual; abstract;
	end;

	PPluginFactoryVTable = ^PluginFactoryVTable;
	PluginFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  createPlugin: IPluginFactory_createPluginPtr;
	end;

	IPluginFactoryImpl = class;

	IPluginFactory = record
	private
	  token: PPluginFactoryToken;
	public
	  const VERSION = 1;

	  function vTable: PPluginFactoryVTable inline;
	  function createPlugin(status: PStatusToken; factoryParameter: PPluginConfigToken): PPluginBaseToken;
	  class operator := (aToken:  PPluginFactoryToken): IPluginFactory;
	  class operator := (intf: IPluginFactory): PPluginFactoryToken;
	  class operator := (impl: IPluginFactoryImpl): IPluginFactory;
	  class operator = (a: IPluginFactory; b: pointer): boolean;
class operator = (a,b: IPluginFactory): boolean;
	end;

	IPluginFactoryImpl = class(IVersionedImpl)
	private
	  class var vTable: PluginFactoryVTable; 
	  class var FInitialized: boolean;
	  intf: IPluginFactory;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PPluginFactoryToken inline;
	  function getInterface: IPluginFactory inline;
		function createPlugin(status: PStatusToken; factoryParameter: PPluginConfigToken): PPluginBaseToken; virtual; abstract;
	end;

	PPluginModuleVTable = ^PluginModuleVTable;
	PluginModuleVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  doClean: IPluginModule_doCleanPtr;
	  threadDetach: IPluginModule_threadDetachPtr;
	end;

	IPluginModuleImpl = class;

	IPluginModule = record
	private
	  token: PPluginModuleToken;
	public
	  const VERSION = 2;

	  function vTable: PPluginModuleVTable inline;
	  procedure doClean();
	  procedure threadDetach();
	  class operator := (aToken:  PPluginModuleToken): IPluginModule;
	  class operator := (intf: IPluginModule): PPluginModuleToken;
	  class operator := (impl: IPluginModuleImpl): IPluginModule;
	  class operator = (a: IPluginModule; b: pointer): boolean;
class operator = (a,b: IPluginModule): boolean;
	end;

	IPluginModuleImpl = class(IVersionedImpl)
	private
	  class var vTable: PluginModuleVTable; 
	  class var FInitialized: boolean;
	  intf: IPluginModule;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PPluginModuleToken inline;
	  function getInterface: IPluginModule inline;
		procedure doClean(); virtual; abstract;
		procedure threadDetach(); virtual; abstract;
	end;

	PPluginManagerVTable = ^PluginManagerVTable;
	PluginManagerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  registerPluginFactory: IPluginManager_registerPluginFactoryPtr;
	  registerModule: IPluginManager_registerModulePtr;
	  unregisterModule: IPluginManager_unregisterModulePtr;
	  getPlugins: IPluginManager_getPluginsPtr;
	  getConfig: IPluginManager_getConfigPtr;
	  releasePlugin: IPluginManager_releasePluginPtr;
	end;

	IPluginManagerImpl = class;

	IPluginManager = record
	private
	  token: PPluginManagerToken;
	public
	  const VERSION = 6;
	  const TYPE_PROVIDER = Cardinal(1);
	  const TYPE_FIRST_NON_LIB = Cardinal(2);
	  const TYPE_AUTH_SERVER = Cardinal(3);
	  const TYPE_AUTH_CLIENT = Cardinal(4);
	  const TYPE_AUTH_USER_MANAGEMENT = Cardinal(5);
	  const TYPE_EXTERNAL_ENGINE = Cardinal(6);
	  const TYPE_TRACE = Cardinal(7);
	  const TYPE_WIRE_CRYPT = Cardinal(8);
	  const TYPE_DB_CRYPT = Cardinal(9);
	  const TYPE_KEY_HOLDER = Cardinal(10);
	  const TYPE_REPLICATOR = Cardinal(11);
	  const TYPE_COUNT = Cardinal(12);

	  function vTable: PPluginManagerVTable inline;
	  procedure registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: PPluginFactoryToken);
	  procedure registerModule(cleanup: PPluginModuleToken);
	  procedure unregisterModule(cleanup: PPluginModuleToken);
	  function getPlugins(status: PStatusToken; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: PFirebirdConfToken): PPluginSetToken;
	  function getConfig(status: PStatusToken; filename: PAnsiChar): PConfigToken;
	  procedure releasePlugin(plugin: PPluginBaseToken);
	  class operator := (aToken:  PPluginManagerToken): IPluginManager;
	  class operator := (intf: IPluginManager): PPluginManagerToken;
	  class operator := (impl: IPluginManagerImpl): IPluginManager;
	  class operator = (a: IPluginManager; b: pointer): boolean;
class operator = (a,b: IPluginManager): boolean;
	end;

	IPluginManagerImpl = class(IVersionedImpl)
	private
	  class var vTable: PluginManagerVTable; 
	  class var FInitialized: boolean;
	  intf: IPluginManager;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PPluginManagerToken inline;
	  function getInterface: IPluginManager inline;
		procedure registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: PPluginFactoryToken); virtual; abstract;
		procedure registerModule(cleanup: PPluginModuleToken); virtual; abstract;
		procedure unregisterModule(cleanup: PPluginModuleToken); virtual; abstract;
		function getPlugins(status: PStatusToken; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: PFirebirdConfToken): PPluginSetToken; virtual; abstract;
		function getConfig(status: PStatusToken; filename: PAnsiChar): PConfigToken; virtual; abstract;
		procedure releasePlugin(plugin: PPluginBaseToken); virtual; abstract;
	end;

	PCryptKeyVTable = ^CryptKeyVTable;
	CryptKeyVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  setSymmetric: ICryptKey_setSymmetricPtr;
	  setAsymmetric: ICryptKey_setAsymmetricPtr;
	  getEncryptKey: ICryptKey_getEncryptKeyPtr;
	  getDecryptKey: ICryptKey_getDecryptKeyPtr;
	end;

	ICryptKeyImpl = class;

	ICryptKey = record
	private
	  token: PCryptKeyToken;
	public
	  const VERSION = 4;

	  function vTable: PCryptKeyVTable inline;
	  procedure setSymmetric(status: PStatusToken; type_: PAnsiChar; keyLength: Cardinal; key: Pointer);
	  procedure setAsymmetric(status: PStatusToken; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer);
	  function getEncryptKey(length: CardinalPtr): Pointer;
	  function getDecryptKey(length: CardinalPtr): Pointer;
	  class operator := (aToken:  PCryptKeyToken): ICryptKey;
	  class operator := (intf: ICryptKey): PCryptKeyToken;
	  class operator := (impl: ICryptKeyImpl): ICryptKey;
	  class operator = (a: ICryptKey; b: pointer): boolean;
class operator = (a,b: ICryptKey): boolean;
	end;

	ICryptKeyImpl = class(IVersionedImpl)
	private
	  class var vTable: CryptKeyVTable; 
	  class var FInitialized: boolean;
	  intf: ICryptKey;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PCryptKeyToken inline;
	  function getInterface: ICryptKey inline;
		procedure setSymmetric(status: PStatusToken; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); virtual; abstract;
		procedure setAsymmetric(status: PStatusToken; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); virtual; abstract;
		function getEncryptKey(length: CardinalPtr): Pointer; virtual; abstract;
		function getDecryptKey(length: CardinalPtr): Pointer; virtual; abstract;
	end;

	PConfigManagerVTable = ^ConfigManagerVTable;
	ConfigManagerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getDirectory: IConfigManager_getDirectoryPtr;
	  getFirebirdConf: IConfigManager_getFirebirdConfPtr;
	  getDatabaseConf: IConfigManager_getDatabaseConfPtr;
	  getPluginConfig: IConfigManager_getPluginConfigPtr;
	  getInstallDirectory: IConfigManager_getInstallDirectoryPtr;
	  getRootDirectory: IConfigManager_getRootDirectoryPtr;
	  getDefaultSecurityDb: IConfigManager_getDefaultSecurityDbPtr;
	end;

	IConfigManagerImpl = class;

	IConfigManager = record
	private
	  token: PConfigManagerToken;
	public
	  const VERSION = 7;
	  const DIR_BIN = Cardinal(0);
	  const DIR_SBIN = Cardinal(1);
	  const DIR_CONF = Cardinal(2);
	  const DIR_LIB = Cardinal(3);
	  const DIR_INC = Cardinal(4);
	  const DIR_DOC = Cardinal(5);
	  const DIR_UDF = Cardinal(6);
	  const DIR_SAMPLE = Cardinal(7);
	  const DIR_SAMPLEDB = Cardinal(8);
	  const DIR_HELP = Cardinal(9);
	  const DIR_INTL = Cardinal(10);
	  const DIR_MISC = Cardinal(11);
	  const DIR_SECDB = Cardinal(12);
	  const DIR_MSG = Cardinal(13);
	  const DIR_LOG = Cardinal(14);
	  const DIR_GUARD = Cardinal(15);
	  const DIR_PLUGINS = Cardinal(16);
	  const DIR_TZDATA = Cardinal(17);
	  const DIR_COUNT = Cardinal(18);

	  function vTable: PConfigManagerVTable inline;
	  function getDirectory(code: Cardinal): PAnsiChar;
	  function getFirebirdConf(): PFirebirdConfToken;
	  function getDatabaseConf(dbName: PAnsiChar): PFirebirdConfToken;
	  function getPluginConfig(configuredPlugin: PAnsiChar): PConfigToken;
	  function getInstallDirectory(): PAnsiChar;
	  function getRootDirectory(): PAnsiChar;
	  function getDefaultSecurityDb(): PAnsiChar;
	  class operator := (aToken:  PConfigManagerToken): IConfigManager;
	  class operator := (intf: IConfigManager): PConfigManagerToken;
	  class operator := (impl: IConfigManagerImpl): IConfigManager;
	  class operator = (a: IConfigManager; b: pointer): boolean;
class operator = (a,b: IConfigManager): boolean;
	end;

	IConfigManagerImpl = class(IVersionedImpl)
	private
	  class var vTable: ConfigManagerVTable; 
	  class var FInitialized: boolean;
	  intf: IConfigManager;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PConfigManagerToken inline;
	  function getInterface: IConfigManager inline;
		function getDirectory(code: Cardinal): PAnsiChar; virtual; abstract;
		function getFirebirdConf(): PFirebirdConfToken; virtual; abstract;
		function getDatabaseConf(dbName: PAnsiChar): PFirebirdConfToken; virtual; abstract;
		function getPluginConfig(configuredPlugin: PAnsiChar): PConfigToken; virtual; abstract;
		function getInstallDirectory(): PAnsiChar; virtual; abstract;
		function getRootDirectory(): PAnsiChar; virtual; abstract;
		function getDefaultSecurityDb(): PAnsiChar; virtual; abstract;
	end;

	PEventCallbackVTable = ^EventCallbackVTable;
	EventCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  eventCallbackFunction: IEventCallback_eventCallbackFunctionPtr;
	end;

	IEventCallbackImpl = class;

	IEventCallback = record
	private
	  token: PEventCallbackToken;
	public
	  const VERSION = 3;

	  function vTable: PEventCallbackVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure eventCallbackFunction(length: Cardinal; events: BytePtr);
	  class operator := (aToken:  PEventCallbackToken): IEventCallback;
	  class operator := (intf: IEventCallback): PEventCallbackToken;
	  class operator := (impl: IEventCallbackImpl): IEventCallback;
	  class operator = (a: IEventCallback; b: pointer): boolean;
class operator = (a,b: IEventCallback): boolean;
	end;

	IEventCallbackImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: EventCallbackVTable; 
	  class var FInitialized: boolean;
	  intf: IEventCallback;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PEventCallbackToken inline;
	  function getInterface: IEventCallback inline;
		procedure eventCallbackFunction(length: Cardinal; events: BytePtr); virtual; abstract;
	end;

	PBlobVTable = ^BlobVTable;
	BlobVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IBlob_getInfoPtr;
	  getSegment: IBlob_getSegmentPtr;
	  putSegment: IBlob_putSegmentPtr;
	  cancel: IBlob_cancelPtr;
	  close: IBlob_closePtr;
	  seek: IBlob_seekPtr;
	end;

	IBlobImpl = class;

	IBlob = record
	private
	  token: PBlobToken;
	public
	  const VERSION = 8;

	  function vTable: PBlobVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function getSegment(status: PStatusToken; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer;
	  procedure putSegment(status: PStatusToken; length: Cardinal; buffer: Pointer);
	  procedure cancel(status: PStatusToken);
	  procedure close(status: PStatusToken);
	  function seek(status: PStatusToken; mode: Integer; offset: Integer): Integer;
	  class operator := (aToken:  PBlobToken): IBlob;
	  class operator := (intf: IBlob): PBlobToken;
	  class operator := (impl: IBlobImpl): IBlob;
	  class operator = (a: IBlob; b: pointer): boolean;
class operator = (a,b: IBlob): boolean;
	end;

	IBlobImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: BlobVTable; 
	  class var FInitialized: boolean;
	  intf: IBlob;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PBlobToken inline;
	  function getInterface: IBlob inline;
		procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
		function getSegment(status: PStatusToken; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; virtual; abstract;
		procedure putSegment(status: PStatusToken; length: Cardinal; buffer: Pointer); virtual; abstract;
		procedure cancel(status: PStatusToken); virtual; abstract;
		procedure close(status: PStatusToken); virtual; abstract;
		function seek(status: PStatusToken; mode: Integer; offset: Integer): Integer; virtual; abstract;
	end;

	PTransactionVTable = ^TransactionVTable;
	TransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: ITransaction_getInfoPtr;
	  prepare: ITransaction_preparePtr;
	  commit: ITransaction_commitPtr;
	  commitRetaining: ITransaction_commitRetainingPtr;
	  rollback: ITransaction_rollbackPtr;
	  rollbackRetaining: ITransaction_rollbackRetainingPtr;
	  disconnect: ITransaction_disconnectPtr;
	  join: ITransaction_joinPtr;
	  validate: ITransaction_validatePtr;
	  enterDtc: ITransaction_enterDtcPtr;
	end;

	ITransactionImpl = class;

	ITransaction = record
	private
	  token: PTransactionToken;
	public
	  const VERSION = 12;

	  function vTable: PTransactionVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure prepare(status: PStatusToken; msgLength: Cardinal; message: BytePtr);
	  procedure commit(status: PStatusToken);
	  procedure commitRetaining(status: PStatusToken);
	  procedure rollback(status: PStatusToken);
	  procedure rollbackRetaining(status: PStatusToken);
	  procedure disconnect(status: PStatusToken);
	  function join(status: PStatusToken; transaction: PTransactionToken): PTransactionToken;
	  function validate(status: PStatusToken; attachment: PAttachmentToken): PTransactionToken;
	  function enterDtc(status: PStatusToken): PTransactionToken;
	  class operator := (aToken:  PTransactionToken): ITransaction;
	  class operator := (intf: ITransaction): PTransactionToken;
	  class operator := (impl: ITransactionImpl): ITransaction;
	  class operator = (a: ITransaction; b: pointer): boolean;
class operator = (a,b: ITransaction): boolean;
	end;

	ITransactionImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: TransactionVTable; 
	  class var FInitialized: boolean;
	  intf: ITransaction;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTransactionToken inline;
	  function getInterface: ITransaction inline;
		procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
		procedure prepare(status: PStatusToken; msgLength: Cardinal; message: BytePtr); virtual; abstract;
		procedure commit(status: PStatusToken); virtual; abstract;
		procedure commitRetaining(status: PStatusToken); virtual; abstract;
		procedure rollback(status: PStatusToken); virtual; abstract;
		procedure rollbackRetaining(status: PStatusToken); virtual; abstract;
		procedure disconnect(status: PStatusToken); virtual; abstract;
		function join(status: PStatusToken; transaction: PTransactionToken): PTransactionToken; virtual; abstract;
		function validate(status: PStatusToken; attachment: PAttachmentToken): PTransactionToken; virtual; abstract;
		function enterDtc(status: PStatusToken): PTransactionToken; virtual; abstract;
	end;

	PMessageMetadataVTable = ^MessageMetadataVTable;
	MessageMetadataVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getCount: IMessageMetadata_getCountPtr;
	  getField: IMessageMetadata_getFieldPtr;
	  getRelation: IMessageMetadata_getRelationPtr;
	  getOwner: IMessageMetadata_getOwnerPtr;
	  getAlias: IMessageMetadata_getAliasPtr;
	  getType: IMessageMetadata_getTypePtr;
	  isNullable: IMessageMetadata_isNullablePtr;
	  getSubType: IMessageMetadata_getSubTypePtr;
	  getLength: IMessageMetadata_getLengthPtr;
	  getScale: IMessageMetadata_getScalePtr;
	  getCharSet: IMessageMetadata_getCharSetPtr;
	  getOffset: IMessageMetadata_getOffsetPtr;
	  getNullOffset: IMessageMetadata_getNullOffsetPtr;
	  getBuilder: IMessageMetadata_getBuilderPtr;
	  getMessageLength: IMessageMetadata_getMessageLengthPtr;
	  getAlignment: IMessageMetadata_getAlignmentPtr;
	  getAlignedLength: IMessageMetadata_getAlignedLengthPtr;
	end;

	IMessageMetadataImpl = class;

	IMessageMetadata = record
	private
	  token: PMessageMetadataToken;
	public
	  const VERSION = 19;

	  function vTable: PMessageMetadataVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getCount(status: PStatusToken): Cardinal;
	  function getField(status: PStatusToken; index: Cardinal): PAnsiChar;
	  function getRelation(status: PStatusToken; index: Cardinal): PAnsiChar;
	  function getOwner(status: PStatusToken; index: Cardinal): PAnsiChar;
	  function getAlias(status: PStatusToken; index: Cardinal): PAnsiChar;
	  function getType(status: PStatusToken; index: Cardinal): Cardinal;
	  function isNullable(status: PStatusToken; index: Cardinal): Boolean;
	  function getSubType(status: PStatusToken; index: Cardinal): Integer;
	  function getLength(status: PStatusToken; index: Cardinal): Cardinal;
	  function getScale(status: PStatusToken; index: Cardinal): Integer;
	  function getCharSet(status: PStatusToken; index: Cardinal): Cardinal;
	  function getOffset(status: PStatusToken; index: Cardinal): Cardinal;
	  function getNullOffset(status: PStatusToken; index: Cardinal): Cardinal;
	  function getBuilder(status: PStatusToken): PMetadataBuilderToken;
	  function getMessageLength(status: PStatusToken): Cardinal;
	  function getAlignment(status: PStatusToken): Cardinal;
	  function getAlignedLength(status: PStatusToken): Cardinal;
	  class operator := (aToken:  PMessageMetadataToken): IMessageMetadata;
	  class operator := (intf: IMessageMetadata): PMessageMetadataToken;
	  class operator := (impl: IMessageMetadataImpl): IMessageMetadata;
	  class operator = (a: IMessageMetadata; b: pointer): boolean;
class operator = (a,b: IMessageMetadata): boolean;
	end;

	IMessageMetadataImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: MessageMetadataVTable; 
	  class var FInitialized: boolean;
	  intf: IMessageMetadata;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PMessageMetadataToken inline;
	  function getInterface: IMessageMetadata inline;
		function getCount(status: PStatusToken): Cardinal; virtual; abstract;
		function getField(status: PStatusToken; index: Cardinal): PAnsiChar; virtual; abstract;
		function getRelation(status: PStatusToken; index: Cardinal): PAnsiChar; virtual; abstract;
		function getOwner(status: PStatusToken; index: Cardinal): PAnsiChar; virtual; abstract;
		function getAlias(status: PStatusToken; index: Cardinal): PAnsiChar; virtual; abstract;
		function getType(status: PStatusToken; index: Cardinal): Cardinal; virtual; abstract;
		function isNullable(status: PStatusToken; index: Cardinal): Boolean; virtual; abstract;
		function getSubType(status: PStatusToken; index: Cardinal): Integer; virtual; abstract;
		function getLength(status: PStatusToken; index: Cardinal): Cardinal; virtual; abstract;
		function getScale(status: PStatusToken; index: Cardinal): Integer; virtual; abstract;
		function getCharSet(status: PStatusToken; index: Cardinal): Cardinal; virtual; abstract;
		function getOffset(status: PStatusToken; index: Cardinal): Cardinal; virtual; abstract;
		function getNullOffset(status: PStatusToken; index: Cardinal): Cardinal; virtual; abstract;
		function getBuilder(status: PStatusToken): PMetadataBuilderToken; virtual; abstract;
		function getMessageLength(status: PStatusToken): Cardinal; virtual; abstract;
		function getAlignment(status: PStatusToken): Cardinal; virtual; abstract;
		function getAlignedLength(status: PStatusToken): Cardinal; virtual; abstract;
	end;

	PMetadataBuilderVTable = ^MetadataBuilderVTable;
	MetadataBuilderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setType: IMetadataBuilder_setTypePtr;
	  setSubType: IMetadataBuilder_setSubTypePtr;
	  setLength: IMetadataBuilder_setLengthPtr;
	  setCharSet: IMetadataBuilder_setCharSetPtr;
	  setScale: IMetadataBuilder_setScalePtr;
	  truncate: IMetadataBuilder_truncatePtr;
	  moveNameToIndex: IMetadataBuilder_moveNameToIndexPtr;
	  remove: IMetadataBuilder_removePtr;
	  addField: IMetadataBuilder_addFieldPtr;
	  getMetadata: IMetadataBuilder_getMetadataPtr;
	  setField: IMetadataBuilder_setFieldPtr;
	  setRelation: IMetadataBuilder_setRelationPtr;
	  setOwner: IMetadataBuilder_setOwnerPtr;
	  setAlias: IMetadataBuilder_setAliasPtr;
	end;

	IMetadataBuilderImpl = class;

	IMetadataBuilder = record
	private
	  token: PMetadataBuilderToken;
	public
	  const VERSION = 16;

	  function vTable: PMetadataBuilderVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setType(status: PStatusToken; index: Cardinal; type_: Cardinal);
	  procedure setSubType(status: PStatusToken; index: Cardinal; subType: Integer);
	  procedure setLength(status: PStatusToken; index: Cardinal; length: Cardinal);
	  procedure setCharSet(status: PStatusToken; index: Cardinal; charSet: Cardinal);
	  procedure setScale(status: PStatusToken; index: Cardinal; scale: Integer);
	  procedure truncate(status: PStatusToken; count: Cardinal);
	  procedure moveNameToIndex(status: PStatusToken; name: PAnsiChar; index: Cardinal);
	  procedure remove(status: PStatusToken; index: Cardinal);
	  function addField(status: PStatusToken): Cardinal;
	  function getMetadata(status: PStatusToken): PMessageMetadataToken;
	  procedure setField(status: PStatusToken; index: Cardinal; field: PAnsiChar);
	  procedure setRelation(status: PStatusToken; index: Cardinal; relation: PAnsiChar);
	  procedure setOwner(status: PStatusToken; index: Cardinal; owner: PAnsiChar);
	  procedure setAlias(status: PStatusToken; index: Cardinal; alias: PAnsiChar);
	  class operator := (aToken:  PMetadataBuilderToken): IMetadataBuilder;
	  class operator := (intf: IMetadataBuilder): PMetadataBuilderToken;
	  class operator := (impl: IMetadataBuilderImpl): IMetadataBuilder;
	  class operator = (a: IMetadataBuilder; b: pointer): boolean;
class operator = (a,b: IMetadataBuilder): boolean;
	end;

	IMetadataBuilderImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: MetadataBuilderVTable; 
	  class var FInitialized: boolean;
	  intf: IMetadataBuilder;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PMetadataBuilderToken inline;
	  function getInterface: IMetadataBuilder inline;
		procedure setType(status: PStatusToken; index: Cardinal; type_: Cardinal); virtual; abstract;
		procedure setSubType(status: PStatusToken; index: Cardinal; subType: Integer); virtual; abstract;
		procedure setLength(status: PStatusToken; index: Cardinal; length: Cardinal); virtual; abstract;
		procedure setCharSet(status: PStatusToken; index: Cardinal; charSet: Cardinal); virtual; abstract;
		procedure setScale(status: PStatusToken; index: Cardinal; scale: Integer); virtual; abstract;
		procedure truncate(status: PStatusToken; count: Cardinal); virtual; abstract;
		procedure moveNameToIndex(status: PStatusToken; name: PAnsiChar; index: Cardinal); virtual; abstract;
		procedure remove(status: PStatusToken; index: Cardinal); virtual; abstract;
		function addField(status: PStatusToken): Cardinal; virtual; abstract;
		function getMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		procedure setField(status: PStatusToken; index: Cardinal; field: PAnsiChar); virtual; abstract;
		procedure setRelation(status: PStatusToken; index: Cardinal; relation: PAnsiChar); virtual; abstract;
		procedure setOwner(status: PStatusToken; index: Cardinal; owner: PAnsiChar); virtual; abstract;
		procedure setAlias(status: PStatusToken; index: Cardinal; alias: PAnsiChar); virtual; abstract;
	end;

	PResultSetVTable = ^ResultSetVTable;
	ResultSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  fetchNext: IResultSet_fetchNextPtr;
	  fetchPrior: IResultSet_fetchPriorPtr;
	  fetchFirst: IResultSet_fetchFirstPtr;
	  fetchLast: IResultSet_fetchLastPtr;
	  fetchAbsolute: IResultSet_fetchAbsolutePtr;
	  fetchRelative: IResultSet_fetchRelativePtr;
	  isEof: IResultSet_isEofPtr;
	  isBof: IResultSet_isBofPtr;
	  getMetadata: IResultSet_getMetadataPtr;
	  close: IResultSet_closePtr;
	  setDelayedOutputFormat: IResultSet_setDelayedOutputFormatPtr;
	end;

	IResultSetImpl = class;

	IResultSet = record
	private
	  token: PResultSetToken;
	public
	  const VERSION = 13;

	  function vTable: PResultSetVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function fetchNext(status: PStatusToken; message: Pointer): Integer;
	  function fetchPrior(status: PStatusToken; message: Pointer): Integer;
	  function fetchFirst(status: PStatusToken; message: Pointer): Integer;
	  function fetchLast(status: PStatusToken; message: Pointer): Integer;
	  function fetchAbsolute(status: PStatusToken; position: Integer; message: Pointer): Integer;
	  function fetchRelative(status: PStatusToken; offset: Integer; message: Pointer): Integer;
	  function isEof(status: PStatusToken): Boolean;
	  function isBof(status: PStatusToken): Boolean;
	  function getMetadata(status: PStatusToken): PMessageMetadataToken;
	  procedure close(status: PStatusToken);
	  procedure setDelayedOutputFormat(status: PStatusToken; format: PMessageMetadataToken);
	  class operator := (aToken:  PResultSetToken): IResultSet;
	  class operator := (intf: IResultSet): PResultSetToken;
	  class operator := (impl: IResultSetImpl): IResultSet;
	  class operator = (a: IResultSet; b: pointer): boolean;
class operator = (a,b: IResultSet): boolean;
	end;

	IResultSetImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: ResultSetVTable; 
	  class var FInitialized: boolean;
	  intf: IResultSet;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PResultSetToken inline;
	  function getInterface: IResultSet inline;
		function fetchNext(status: PStatusToken; message: Pointer): Integer; virtual; abstract;
		function fetchPrior(status: PStatusToken; message: Pointer): Integer; virtual; abstract;
		function fetchFirst(status: PStatusToken; message: Pointer): Integer; virtual; abstract;
		function fetchLast(status: PStatusToken; message: Pointer): Integer; virtual; abstract;
		function fetchAbsolute(status: PStatusToken; position: Integer; message: Pointer): Integer; virtual; abstract;
		function fetchRelative(status: PStatusToken; offset: Integer; message: Pointer): Integer; virtual; abstract;
		function isEof(status: PStatusToken): Boolean; virtual; abstract;
		function isBof(status: PStatusToken): Boolean; virtual; abstract;
		function getMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		procedure close(status: PStatusToken); virtual; abstract;
		procedure setDelayedOutputFormat(status: PStatusToken; format: PMessageMetadataToken); virtual; abstract;
	end;

	PStatementVTable = ^StatementVTable;
	StatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IStatement_getInfoPtr;
	  getType: IStatement_getTypePtr;
	  getPlan: IStatement_getPlanPtr;
	  getAffectedRecords: IStatement_getAffectedRecordsPtr;
	  getInputMetadata: IStatement_getInputMetadataPtr;
	  getOutputMetadata: IStatement_getOutputMetadataPtr;
	  execute: IStatement_executePtr;
	  openCursor: IStatement_openCursorPtr;
	  setCursorName: IStatement_setCursorNamePtr;
	  free: IStatement_freePtr;
	  getFlags: IStatement_getFlagsPtr;
	  getTimeout: IStatement_getTimeoutPtr;
	  setTimeout: IStatement_setTimeoutPtr;
	  createBatch: IStatement_createBatchPtr;
	end;

	IStatementImpl = class;

	IStatement = record
	private
	  token: PStatementToken;
	public
	  const VERSION = 16;
	  const PREPARE_PREFETCH_NONE = Cardinal($0);
	  const PREPARE_PREFETCH_TYPE = Cardinal($1);
	  const PREPARE_PREFETCH_INPUT_PARAMETERS = Cardinal($2);
	  const PREPARE_PREFETCH_OUTPUT_PARAMETERS = Cardinal($4);
	  const PREPARE_PREFETCH_LEGACY_PLAN = Cardinal($8);
	  const PREPARE_PREFETCH_DETAILED_PLAN = Cardinal($10);
	  const PREPARE_PREFETCH_AFFECTED_RECORDS = Cardinal($20);
	  const PREPARE_PREFETCH_FLAGS = Cardinal($40);
	  const PREPARE_PREFETCH_METADATA = Cardinal(IStatement.PREPARE_PREFETCH_TYPE or IStatement.PREPARE_PREFETCH_FLAGS or IStatement.PREPARE_PREFETCH_INPUT_PARAMETERS or IStatement.PREPARE_PREFETCH_OUTPUT_PARAMETERS);
	  const PREPARE_PREFETCH_ALL = Cardinal(IStatement.PREPARE_PREFETCH_METADATA or IStatement.PREPARE_PREFETCH_LEGACY_PLAN or IStatement.PREPARE_PREFETCH_DETAILED_PLAN or IStatement.PREPARE_PREFETCH_AFFECTED_RECORDS);
	  const FLAG_HAS_CURSOR = Cardinal($1);
	  const FLAG_REPEAT_EXECUTE = Cardinal($2);
	  const CURSOR_TYPE_SCROLLABLE = Cardinal($1);

	  function vTable: PStatementVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function getType(status: PStatusToken): Cardinal;
	  function getPlan(status: PStatusToken; detailed: Boolean): PAnsiChar;
	  function getAffectedRecords(status: PStatusToken): QWord;
	  function getInputMetadata(status: PStatusToken): PMessageMetadataToken;
	  function getOutputMetadata(status: PStatusToken): PMessageMetadataToken;
	  function execute(status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken;
	  function openCursor(status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; flags: Cardinal): PResultSetToken;
	  procedure setCursorName(status: PStatusToken; name: PAnsiChar);
	  procedure free(status: PStatusToken);
	  function getFlags(status: PStatusToken): Cardinal;
	  function getTimeout(status: PStatusToken): Cardinal;
	  procedure setTimeout(status: PStatusToken; timeOut: Cardinal);
	  function createBatch(status: PStatusToken; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken;
	  class operator := (aToken:  PStatementToken): IStatement;
	  class operator := (intf: IStatement): PStatementToken;
	  class operator := (impl: IStatementImpl): IStatement;
	  class operator = (a: IStatement; b: pointer): boolean;
class operator = (a,b: IStatement): boolean;
	end;

	IStatementImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: StatementVTable; 
	  class var FInitialized: boolean;
	  intf: IStatement;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PStatementToken inline;
	  function getInterface: IStatement inline;
		procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
		function getType(status: PStatusToken): Cardinal; virtual; abstract;
		function getPlan(status: PStatusToken; detailed: Boolean): PAnsiChar; virtual; abstract;
		function getAffectedRecords(status: PStatusToken): QWord; virtual; abstract;
		function getInputMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		function getOutputMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		function execute(status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken; virtual; abstract;
		function openCursor(status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; flags: Cardinal): PResultSetToken; virtual; abstract;
		procedure setCursorName(status: PStatusToken; name: PAnsiChar); virtual; abstract;
		procedure free(status: PStatusToken); virtual; abstract;
		function getFlags(status: PStatusToken): Cardinal; virtual; abstract;
		function getTimeout(status: PStatusToken): Cardinal; virtual; abstract;
		procedure setTimeout(status: PStatusToken; timeOut: Cardinal); virtual; abstract;
		function createBatch(status: PStatusToken; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken; virtual; abstract;
	end;

	PBatchVTable = ^BatchVTable;
	BatchVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  add: IBatch_addPtr;
	  addBlob: IBatch_addBlobPtr;
	  appendBlobData: IBatch_appendBlobDataPtr;
	  addBlobStream: IBatch_addBlobStreamPtr;
	  registerBlob: IBatch_registerBlobPtr;
	  execute: IBatch_executePtr;
	  cancel: IBatch_cancelPtr;
	  getBlobAlignment: IBatch_getBlobAlignmentPtr;
	  getMetadata: IBatch_getMetadataPtr;
	  setDefaultBpb: IBatch_setDefaultBpbPtr;
	  close: IBatch_closePtr;
	end;

	IBatchImpl = class;

	IBatch = record
	private
	  token: PBatchToken;
	public
	  const VERSION = 13;
	  const VERSION1 = Byte(1);
	  const TAG_MULTIERROR = Byte(1);
	  const TAG_RECORD_COUNTS = Byte(2);
	  const TAG_BUFFER_BYTES_SIZE = Byte(3);
	  const TAG_BLOB_POLICY = Byte(4);
	  const TAG_DETAILED_ERRORS = Byte(5);
	  const BLOB_NONE = Byte(0);
	  const BLOB_ID_ENGINE = Byte(1);
	  const BLOB_ID_USER = Byte(2);
	  const BLOB_STREAM = Byte(3);
	  const BLOB_SEGHDR_ALIGN = Cardinal(2);

	  function vTable: PBatchVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure add(status: PStatusToken; count: Cardinal; inBuffer: Pointer);
	  procedure addBlob(status: PStatusToken; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr);
	  procedure appendBlobData(status: PStatusToken; length: Cardinal; inBuffer: Pointer);
	  procedure addBlobStream(status: PStatusToken; length: Cardinal; inBuffer: Pointer);
	  procedure registerBlob(status: PStatusToken; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr);
	  function execute(status: PStatusToken; transaction: PTransactionToken): PBatchCompletionStateToken;
	  procedure cancel(status: PStatusToken);
	  function getBlobAlignment(status: PStatusToken): Cardinal;
	  function getMetadata(status: PStatusToken): PMessageMetadataToken;
	  procedure setDefaultBpb(status: PStatusToken; parLength: Cardinal; par: BytePtr);
	  procedure close(status: PStatusToken);
	  class operator := (aToken:  PBatchToken): IBatch;
	  class operator := (intf: IBatch): PBatchToken;
	  class operator := (impl: IBatchImpl): IBatch;
	  class operator = (a: IBatch; b: pointer): boolean;
class operator = (a,b: IBatch): boolean;
	end;

	IBatchImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: BatchVTable; 
	  class var FInitialized: boolean;
	  intf: IBatch;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PBatchToken inline;
	  function getInterface: IBatch inline;
		procedure add(status: PStatusToken; count: Cardinal; inBuffer: Pointer); virtual; abstract;
		procedure addBlob(status: PStatusToken; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); virtual; abstract;
		procedure appendBlobData(status: PStatusToken; length: Cardinal; inBuffer: Pointer); virtual; abstract;
		procedure addBlobStream(status: PStatusToken; length: Cardinal; inBuffer: Pointer); virtual; abstract;
		procedure registerBlob(status: PStatusToken; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); virtual; abstract;
		function execute(status: PStatusToken; transaction: PTransactionToken): PBatchCompletionStateToken; virtual; abstract;
		procedure cancel(status: PStatusToken); virtual; abstract;
		function getBlobAlignment(status: PStatusToken): Cardinal; virtual; abstract;
		function getMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		procedure setDefaultBpb(status: PStatusToken; parLength: Cardinal; par: BytePtr); virtual; abstract;
		procedure close(status: PStatusToken); virtual; abstract;
	end;

	PBatchCompletionStateVTable = ^BatchCompletionStateVTable;
	BatchCompletionStateVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getSize: IBatchCompletionState_getSizePtr;
	  getState: IBatchCompletionState_getStatePtr;
	  findError: IBatchCompletionState_findErrorPtr;
	  getStatus: IBatchCompletionState_getStatusPtr;
	end;

	IBatchCompletionStateImpl = class;

	IBatchCompletionState = record
	private
	  token: PBatchCompletionStateToken;
	public
	  const VERSION = 5;
	  const EXECUTE_FAILED = Integer(-1);
	  const SUCCESS_NO_INFO = Integer(-2);
	  const NO_MORE_ERRORS = Cardinal($ffffffff);

	  function vTable: PBatchCompletionStateVTable inline;
	  procedure dispose();
	  function getSize(status: PStatusToken): Cardinal;
	  function getState(status: PStatusToken; pos: Cardinal): Integer;
	  function findError(status: PStatusToken; pos: Cardinal): Cardinal;
	  procedure getStatus(status: PStatusToken; to_: PStatusToken; pos: Cardinal);
	  class operator := (aToken:  PBatchCompletionStateToken): IBatchCompletionState;
	  class operator := (intf: IBatchCompletionState): PBatchCompletionStateToken;
	  class operator := (impl: IBatchCompletionStateImpl): IBatchCompletionState;
	  class operator = (a: IBatchCompletionState; b: pointer): boolean;
class operator = (a,b: IBatchCompletionState): boolean;
	end;

	IBatchCompletionStateImpl = class(IDisposableImpl)
	private
	  class var vTable: BatchCompletionStateVTable; 
	  class var FInitialized: boolean;
	  intf: IBatchCompletionState;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PBatchCompletionStateToken inline;
	  function getInterface: IBatchCompletionState inline;
		function getSize(status: PStatusToken): Cardinal; virtual; abstract;
		function getState(status: PStatusToken; pos: Cardinal): Integer; virtual; abstract;
		function findError(status: PStatusToken; pos: Cardinal): Cardinal; virtual; abstract;
		procedure getStatus(status: PStatusToken; to_: PStatusToken; pos: Cardinal); virtual; abstract;
	end;

	PReplicatorVTable = ^ReplicatorVTable;
	ReplicatorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  process: IReplicator_processPtr;
	  close: IReplicator_closePtr;
	end;

	IReplicatorImpl = class;

	IReplicator = record
	private
	  token: PReplicatorToken;
	public
	  const VERSION = 4;

	  function vTable: PReplicatorVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure process(status: PStatusToken; length: Cardinal; data: BytePtr);
	  procedure close(status: PStatusToken);
	  class operator := (aToken:  PReplicatorToken): IReplicator;
	  class operator := (intf: IReplicator): PReplicatorToken;
	  class operator := (impl: IReplicatorImpl): IReplicator;
	  class operator = (a: IReplicator; b: pointer): boolean;
class operator = (a,b: IReplicator): boolean;
	end;

	IReplicatorImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: ReplicatorVTable; 
	  class var FInitialized: boolean;
	  intf: IReplicator;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PReplicatorToken inline;
	  function getInterface: IReplicator inline;
		procedure process(status: PStatusToken; length: Cardinal; data: BytePtr); virtual; abstract;
		procedure close(status: PStatusToken); virtual; abstract;
	end;

	PRequestVTable = ^RequestVTable;
	RequestVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  receive: IRequest_receivePtr;
	  send: IRequest_sendPtr;
	  getInfo: IRequest_getInfoPtr;
	  start: IRequest_startPtr;
	  startAndSend: IRequest_startAndSendPtr;
	  unwind: IRequest_unwindPtr;
	  free: IRequest_freePtr;
	end;

	IRequestImpl = class;

	IRequest = record
	private
	  token: PRequestToken;
	public
	  const VERSION = 9;

	  function vTable: PRequestVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure receive(status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure send(status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure getInfo(status: PStatusToken; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure start(status: PStatusToken; tra: PTransactionToken; level: Integer);
	  procedure startAndSend(status: PStatusToken; tra: PTransactionToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure unwind(status: PStatusToken; level: Integer);
	  procedure free(status: PStatusToken);
	  class operator := (aToken:  PRequestToken): IRequest;
	  class operator := (intf: IRequest): PRequestToken;
	  class operator := (impl: IRequestImpl): IRequest;
	  class operator = (a: IRequest; b: pointer): boolean;
class operator = (a,b: IRequest): boolean;
	end;

	IRequestImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: RequestVTable; 
	  class var FInitialized: boolean;
	  intf: IRequest;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PRequestToken inline;
	  function getInterface: IRequest inline;
		procedure receive(status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
		procedure send(status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
		procedure getInfo(status: PStatusToken; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
		procedure start(status: PStatusToken; tra: PTransactionToken; level: Integer); virtual; abstract;
		procedure startAndSend(status: PStatusToken; tra: PTransactionToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
		procedure unwind(status: PStatusToken; level: Integer); virtual; abstract;
		procedure free(status: PStatusToken); virtual; abstract;
	end;

	PEventsVTable = ^EventsVTable;
	EventsVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  cancel: IEvents_cancelPtr;
	end;

	IEventsImpl = class;

	IEvents = record
	private
	  token: PEventsToken;
	public
	  const VERSION = 3;

	  function vTable: PEventsVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure cancel(status: PStatusToken);
	  class operator := (aToken:  PEventsToken): IEvents;
	  class operator := (intf: IEvents): PEventsToken;
	  class operator := (impl: IEventsImpl): IEvents;
	  class operator = (a: IEvents; b: pointer): boolean;
class operator = (a,b: IEvents): boolean;
	end;

	IEventsImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: EventsVTable; 
	  class var FInitialized: boolean;
	  intf: IEvents;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PEventsToken inline;
	  function getInterface: IEvents inline;
		procedure cancel(status: PStatusToken); virtual; abstract;
	end;

	PAttachmentVTable = ^AttachmentVTable;
	AttachmentVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IAttachment_getInfoPtr;
	  startTransaction: IAttachment_startTransactionPtr;
	  reconnectTransaction: IAttachment_reconnectTransactionPtr;
	  compileRequest: IAttachment_compileRequestPtr;
	  transactRequest: IAttachment_transactRequestPtr;
	  createBlob: IAttachment_createBlobPtr;
	  openBlob: IAttachment_openBlobPtr;
	  getSlice: IAttachment_getSlicePtr;
	  putSlice: IAttachment_putSlicePtr;
	  executeDyn: IAttachment_executeDynPtr;
	  prepare: IAttachment_preparePtr;
	  execute: IAttachment_executePtr;
	  openCursor: IAttachment_openCursorPtr;
	  queEvents: IAttachment_queEventsPtr;
	  cancelOperation: IAttachment_cancelOperationPtr;
	  ping: IAttachment_pingPtr;
	  detach: IAttachment_detachPtr;
	  dropDatabase: IAttachment_dropDatabasePtr;
	  getIdleTimeout: IAttachment_getIdleTimeoutPtr;
	  setIdleTimeout: IAttachment_setIdleTimeoutPtr;
	  getStatementTimeout: IAttachment_getStatementTimeoutPtr;
	  setStatementTimeout: IAttachment_setStatementTimeoutPtr;
	  createBatch: IAttachment_createBatchPtr;
	  createReplicator: IAttachment_createReplicatorPtr;
	end;

	IAttachmentImpl = class;

	IAttachment = record
	private
	  token: PAttachmentToken;
	public
	  const VERSION = 26;

	  function vTable: PAttachmentVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function startTransaction(status: PStatusToken; tpbLength: Cardinal; tpb: BytePtr): PTransactionToken;
	  function reconnectTransaction(status: PStatusToken; length: Cardinal; id: BytePtr): PTransactionToken;
	  function compileRequest(status: PStatusToken; blrLength: Cardinal; blr: BytePtr): PRequestToken;
	  procedure transactRequest(status: PStatusToken; transaction: PTransactionToken; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr);
	  function createBlob(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken;
	  function openBlob(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken;
	  function getSlice(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer;
	  procedure putSlice(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr);
	  procedure executeDyn(status: PStatusToken; transaction: PTransactionToken; length: Cardinal; dyn: BytePtr);
	  function prepare(status: PStatusToken; tra: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): PStatementToken;
	  function execute(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken;
	  function openCursor(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; cursorName: PAnsiChar; cursorFlags: Cardinal): PResultSetToken;
	  function queEvents(status: PStatusToken; callback: PEventCallbackToken; length: Cardinal; events: BytePtr): PEventsToken;
	  procedure cancelOperation(status: PStatusToken; option: Integer);
	  procedure ping(status: PStatusToken);
	  procedure detach(status: PStatusToken);
	  procedure dropDatabase(status: PStatusToken);
	  function getIdleTimeout(status: PStatusToken): Cardinal;
	  procedure setIdleTimeout(status: PStatusToken; timeOut: Cardinal);
	  function getStatementTimeout(status: PStatusToken): Cardinal;
	  procedure setStatementTimeout(status: PStatusToken; timeOut: Cardinal);
	  function createBatch(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken;
	  function createReplicator(status: PStatusToken): PReplicatorToken;
	  class operator := (aToken:  PAttachmentToken): IAttachment;
	  class operator := (intf: IAttachment): PAttachmentToken;
	  class operator := (impl: IAttachmentImpl): IAttachment;
	  class operator = (a: IAttachment; b: pointer): boolean;
class operator = (a,b: IAttachment): boolean;
	end;

	IAttachmentImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: AttachmentVTable; 
	  class var FInitialized: boolean;
	  intf: IAttachment;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PAttachmentToken inline;
	  function getInterface: IAttachment inline;
		procedure getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
		function startTransaction(status: PStatusToken; tpbLength: Cardinal; tpb: BytePtr): PTransactionToken; virtual; abstract;
		function reconnectTransaction(status: PStatusToken; length: Cardinal; id: BytePtr): PTransactionToken; virtual; abstract;
		function compileRequest(status: PStatusToken; blrLength: Cardinal; blr: BytePtr): PRequestToken; virtual; abstract;
		procedure transactRequest(status: PStatusToken; transaction: PTransactionToken; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); virtual; abstract;
		function createBlob(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken; virtual; abstract;
		function openBlob(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken; virtual; abstract;
		function getSlice(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; virtual; abstract;
		procedure putSlice(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); virtual; abstract;
		procedure executeDyn(status: PStatusToken; transaction: PTransactionToken; length: Cardinal; dyn: BytePtr); virtual; abstract;
		function prepare(status: PStatusToken; tra: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): PStatementToken; virtual; abstract;
		function execute(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken; virtual; abstract;
		function openCursor(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; cursorName: PAnsiChar; cursorFlags: Cardinal): PResultSetToken; virtual; abstract;
		function queEvents(status: PStatusToken; callback: PEventCallbackToken; length: Cardinal; events: BytePtr): PEventsToken; virtual; abstract;
		procedure cancelOperation(status: PStatusToken; option: Integer); virtual; abstract;
		procedure ping(status: PStatusToken); virtual; abstract;
		procedure detach(status: PStatusToken); virtual; abstract;
		procedure dropDatabase(status: PStatusToken); virtual; abstract;
		function getIdleTimeout(status: PStatusToken): Cardinal; virtual; abstract;
		procedure setIdleTimeout(status: PStatusToken; timeOut: Cardinal); virtual; abstract;
		function getStatementTimeout(status: PStatusToken): Cardinal; virtual; abstract;
		procedure setStatementTimeout(status: PStatusToken; timeOut: Cardinal); virtual; abstract;
		function createBatch(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken; virtual; abstract;
		function createReplicator(status: PStatusToken): PReplicatorToken; virtual; abstract;
	end;

	PServiceVTable = ^ServiceVTable;
	ServiceVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  detach: IService_detachPtr;
	  query: IService_queryPtr;
	  start: IService_startPtr;
	end;

	IServiceImpl = class;

	IService = record
	private
	  token: PServiceToken;
	public
	  const VERSION = 5;

	  function vTable: PServiceVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure detach(status: PStatusToken);
	  procedure query(status: PStatusToken; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure start(status: PStatusToken; spbLength: Cardinal; spb: BytePtr);
	  class operator := (aToken:  PServiceToken): IService;
	  class operator := (intf: IService): PServiceToken;
	  class operator := (impl: IServiceImpl): IService;
	  class operator = (a: IService; b: pointer): boolean;
class operator = (a,b: IService): boolean;
	end;

	IServiceImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: ServiceVTable; 
	  class var FInitialized: boolean;
	  intf: IService;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PServiceToken inline;
	  function getInterface: IService inline;
		procedure detach(status: PStatusToken); virtual; abstract;
		procedure query(status: PStatusToken; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
		procedure start(status: PStatusToken; spbLength: Cardinal; spb: BytePtr); virtual; abstract;
	end;

	PProviderVTable = ^ProviderVTable;
	ProviderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  attachDatabase: IProvider_attachDatabasePtr;
	  createDatabase: IProvider_createDatabasePtr;
	  attachServiceManager: IProvider_attachServiceManagerPtr;
	  shutdown: IProvider_shutdownPtr;
	  setDbCryptCallback: IProvider_setDbCryptCallbackPtr;
	end;

	IProviderImpl = class;

	IProvider = record
	private
	  token: PProviderToken;
	public
	  const VERSION = 9;

	  function vTable: PProviderVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function attachDatabase(status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken;
	  function createDatabase(status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken;
	  function attachServiceManager(status: PStatusToken; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): PServiceToken;
	  procedure shutdown(status: PStatusToken; timeout: Cardinal; reason: Integer);
	  procedure setDbCryptCallback(status: PStatusToken; cryptCallback: PCryptKeyCallbackToken);
	  class operator := (aToken:  PProviderToken): IProvider;
	  class operator := (intf: IProvider): PProviderToken;
	  class operator := (impl: IProviderImpl): IProvider;
	  class operator = (a: IProvider; b: pointer): boolean;
class operator = (a,b: IProvider): boolean;
	end;

	IProviderImpl = class(IPluginBaseImpl)
	private
	  class var vTable: ProviderVTable; 
	  class var FInitialized: boolean;
	  intf: IProvider;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PProviderToken inline;
	  function getInterface: IProvider inline;
		function attachDatabase(status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken; virtual; abstract;
		function createDatabase(status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken; virtual; abstract;
		function attachServiceManager(status: PStatusToken; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): PServiceToken; virtual; abstract;
		procedure shutdown(status: PStatusToken; timeout: Cardinal; reason: Integer); virtual; abstract;
		procedure setDbCryptCallback(status: PStatusToken; cryptCallback: PCryptKeyCallbackToken); virtual; abstract;
	end;

	PDtcStartVTable = ^DtcStartVTable;
	DtcStartVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  addAttachment: IDtcStart_addAttachmentPtr;
	  addWithTpb: IDtcStart_addWithTpbPtr;
	  start: IDtcStart_startPtr;
	end;

	IDtcStartImpl = class;

	IDtcStart = record
	private
	  token: PDtcStartToken;
	public
	  const VERSION = 4;

	  function vTable: PDtcStartVTable inline;
	  procedure dispose();
	  procedure addAttachment(status: PStatusToken; att: PAttachmentToken);
	  procedure addWithTpb(status: PStatusToken; att: PAttachmentToken; length: Cardinal; tpb: BytePtr);
	  function start(status: PStatusToken): PTransactionToken;
	  class operator := (aToken:  PDtcStartToken): IDtcStart;
	  class operator := (intf: IDtcStart): PDtcStartToken;
	  class operator := (impl: IDtcStartImpl): IDtcStart;
	  class operator = (a: IDtcStart; b: pointer): boolean;
class operator = (a,b: IDtcStart): boolean;
	end;

	IDtcStartImpl = class(IDisposableImpl)
	private
	  class var vTable: DtcStartVTable; 
	  class var FInitialized: boolean;
	  intf: IDtcStart;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDtcStartToken inline;
	  function getInterface: IDtcStart inline;
		procedure addAttachment(status: PStatusToken; att: PAttachmentToken); virtual; abstract;
		procedure addWithTpb(status: PStatusToken; att: PAttachmentToken; length: Cardinal; tpb: BytePtr); virtual; abstract;
		function start(status: PStatusToken): PTransactionToken; virtual; abstract;
	end;

	PDtcVTable = ^DtcVTable;
	DtcVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  join: IDtc_joinPtr;
	  startBuilder: IDtc_startBuilderPtr;
	end;

	IDtcImpl = class;

	IDtc = record
	private
	  token: PDtcToken;
	public
	  const VERSION = 2;

	  function vTable: PDtcVTable inline;
	  function join(status: PStatusToken; one: PTransactionToken; two: PTransactionToken): PTransactionToken;
	  function startBuilder(status: PStatusToken): PDtcStartToken;
	  class operator := (aToken:  PDtcToken): IDtc;
	  class operator := (intf: IDtc): PDtcToken;
	  class operator := (impl: IDtcImpl): IDtc;
	  class operator = (a: IDtc; b: pointer): boolean;
class operator = (a,b: IDtc): boolean;
	end;

	IDtcImpl = class(IVersionedImpl)
	private
	  class var vTable: DtcVTable; 
	  class var FInitialized: boolean;
	  intf: IDtc;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDtcToken inline;
	  function getInterface: IDtc inline;
		function join(status: PStatusToken; one: PTransactionToken; two: PTransactionToken): PTransactionToken; virtual; abstract;
		function startBuilder(status: PStatusToken): PDtcStartToken; virtual; abstract;
	end;

	PAuthVTable = ^AuthVTable;
	AuthVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	end;

	IAuthImpl = class;

	IAuth = record
	private
	  token: PAuthToken;
	public
	  const VERSION = 4;
	  const AUTH_FAILED = Integer(-1);
	  const AUTH_SUCCESS = Integer(0);
	  const AUTH_MORE_DATA = Integer(1);
	  const AUTH_CONTINUE = Integer(2);

	  function vTable: PAuthVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  class operator := (aToken:  PAuthToken): IAuth;
	  class operator := (intf: IAuth): PAuthToken;
	  class operator := (impl: IAuthImpl): IAuth;
	  class operator = (a: IAuth; b: pointer): boolean;
class operator = (a,b: IAuth): boolean;
	end;

	IAuthImpl = class(IPluginBaseImpl)
	private
	  class var vTable: AuthVTable; 
	  class var FInitialized: boolean;
	  intf: IAuth;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PAuthToken inline;
	  function getInterface: IAuth inline;
	end;

	PWriterVTable = ^WriterVTable;
	WriterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  reset: IWriter_resetPtr;
	  add: IWriter_addPtr;
	  setType: IWriter_setTypePtr;
	  setDb: IWriter_setDbPtr;
	end;

	IWriterImpl = class;

	IWriter = record
	private
	  token: PWriterToken;
	public
	  const VERSION = 4;

	  function vTable: PWriterVTable inline;
	  procedure reset();
	  procedure add(status: PStatusToken; name: PAnsiChar);
	  procedure setType(status: PStatusToken; value: PAnsiChar);
	  procedure setDb(status: PStatusToken; value: PAnsiChar);
	  class operator := (aToken:  PWriterToken): IWriter;
	  class operator := (intf: IWriter): PWriterToken;
	  class operator := (impl: IWriterImpl): IWriter;
	  class operator = (a: IWriter; b: pointer): boolean;
class operator = (a,b: IWriter): boolean;
	end;

	IWriterImpl = class(IVersionedImpl)
	private
	  class var vTable: WriterVTable; 
	  class var FInitialized: boolean;
	  intf: IWriter;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PWriterToken inline;
	  function getInterface: IWriter inline;
		procedure reset(); virtual; abstract;
		procedure add(status: PStatusToken; name: PAnsiChar); virtual; abstract;
		procedure setType(status: PStatusToken; value: PAnsiChar); virtual; abstract;
		procedure setDb(status: PStatusToken; value: PAnsiChar); virtual; abstract;
	end;

	PServerBlockVTable = ^ServerBlockVTable;
	ServerBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getLogin: IServerBlock_getLoginPtr;
	  getData: IServerBlock_getDataPtr;
	  putData: IServerBlock_putDataPtr;
	  newKey: IServerBlock_newKeyPtr;
	end;

	IServerBlockImpl = class;

	IServerBlock = record
	private
	  token: PServerBlockToken;
	public
	  const VERSION = 4;

	  function vTable: PServerBlockVTable inline;
	  function getLogin(): PAnsiChar;
	  function getData(length: CardinalPtr): BytePtr;
	  procedure putData(status: PStatusToken; length: Cardinal; data: Pointer);
	  function newKey(status: PStatusToken): PCryptKeyToken;
	  class operator := (aToken:  PServerBlockToken): IServerBlock;
	  class operator := (intf: IServerBlock): PServerBlockToken;
	  class operator := (impl: IServerBlockImpl): IServerBlock;
	  class operator = (a: IServerBlock; b: pointer): boolean;
class operator = (a,b: IServerBlock): boolean;
	end;

	IServerBlockImpl = class(IVersionedImpl)
	private
	  class var vTable: ServerBlockVTable; 
	  class var FInitialized: boolean;
	  intf: IServerBlock;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PServerBlockToken inline;
	  function getInterface: IServerBlock inline;
		function getLogin(): PAnsiChar; virtual; abstract;
		function getData(length: CardinalPtr): BytePtr; virtual; abstract;
		procedure putData(status: PStatusToken; length: Cardinal; data: Pointer); virtual; abstract;
		function newKey(status: PStatusToken): PCryptKeyToken; virtual; abstract;
	end;

	PClientBlockVTable = ^ClientBlockVTable;
	ClientBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getLogin: IClientBlock_getLoginPtr;
	  getPassword: IClientBlock_getPasswordPtr;
	  getData: IClientBlock_getDataPtr;
	  putData: IClientBlock_putDataPtr;
	  newKey: IClientBlock_newKeyPtr;
	  getAuthBlock: IClientBlock_getAuthBlockPtr;
	end;

	IClientBlockImpl = class;

	IClientBlock = record
	private
	  token: PClientBlockToken;
	public
	  const VERSION = 8;

	  function vTable: PClientBlockVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getLogin(): PAnsiChar;
	  function getPassword(): PAnsiChar;
	  function getData(length: CardinalPtr): BytePtr;
	  procedure putData(status: PStatusToken; length: Cardinal; data: Pointer);
	  function newKey(status: PStatusToken): PCryptKeyToken;
	  function getAuthBlock(status: PStatusToken): PAuthBlockToken;
	  class operator := (aToken:  PClientBlockToken): IClientBlock;
	  class operator := (intf: IClientBlock): PClientBlockToken;
	  class operator := (impl: IClientBlockImpl): IClientBlock;
	  class operator = (a: IClientBlock; b: pointer): boolean;
class operator = (a,b: IClientBlock): boolean;
	end;

	IClientBlockImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: ClientBlockVTable; 
	  class var FInitialized: boolean;
	  intf: IClientBlock;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PClientBlockToken inline;
	  function getInterface: IClientBlock inline;
		function getLogin(): PAnsiChar; virtual; abstract;
		function getPassword(): PAnsiChar; virtual; abstract;
		function getData(length: CardinalPtr): BytePtr; virtual; abstract;
		procedure putData(status: PStatusToken; length: Cardinal; data: Pointer); virtual; abstract;
		function newKey(status: PStatusToken): PCryptKeyToken; virtual; abstract;
		function getAuthBlock(status: PStatusToken): PAuthBlockToken; virtual; abstract;
	end;

	PServerVTable = ^ServerVTable;
	ServerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  authenticate: IServer_authenticatePtr;
	  setDbCryptCallback: IServer_setDbCryptCallbackPtr;
	end;

	IServerImpl = class;

	IServer = record
	private
	  token: PServerToken;
	public
	  const VERSION = 6;
	  const AUTH_FAILED = Integer(-1);
	  const AUTH_SUCCESS = Integer(0);
	  const AUTH_MORE_DATA = Integer(1);
	  const AUTH_CONTINUE = Integer(2);

	  function vTable: PServerVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function authenticate(status: PStatusToken; sBlock: PServerBlockToken; writerInterface: PWriterToken): Integer;
	  procedure setDbCryptCallback(status: PStatusToken; cryptCallback: PCryptKeyCallbackToken);
	  class operator := (aToken:  PServerToken): IServer;
	  class operator := (intf: IServer): PServerToken;
	  class operator := (impl: IServerImpl): IServer;
	  class operator = (a: IServer; b: pointer): boolean;
class operator = (a,b: IServer): boolean;
	end;

	IServerImpl = class(IAuthImpl)
	private
	  class var vTable: ServerVTable; 
	  class var FInitialized: boolean;
	  intf: IServer;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PServerToken inline;
	  function getInterface: IServer inline;
		function authenticate(status: PStatusToken; sBlock: PServerBlockToken; writerInterface: PWriterToken): Integer; virtual; abstract;
		procedure setDbCryptCallback(status: PStatusToken; cryptCallback: PCryptKeyCallbackToken); virtual; abstract;
	end;

	PClientVTable = ^ClientVTable;
	ClientVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  authenticate: IClient_authenticatePtr;
	end;

	IClientImpl = class;

	IClient = record
	private
	  token: PClientToken;
	public
	  const VERSION = 5;
	  const AUTH_FAILED = Integer(-1);
	  const AUTH_SUCCESS = Integer(0);
	  const AUTH_MORE_DATA = Integer(1);
	  const AUTH_CONTINUE = Integer(2);

	  function vTable: PClientVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function authenticate(status: PStatusToken; cBlock: PClientBlockToken): Integer;
	  class operator := (aToken:  PClientToken): IClient;
	  class operator := (intf: IClient): PClientToken;
	  class operator := (impl: IClientImpl): IClient;
	  class operator = (a: IClient; b: pointer): boolean;
class operator = (a,b: IClient): boolean;
	end;

	IClientImpl = class(IAuthImpl)
	private
	  class var vTable: ClientVTable; 
	  class var FInitialized: boolean;
	  intf: IClient;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PClientToken inline;
	  function getInterface: IClient inline;
		function authenticate(status: PStatusToken; cBlock: PClientBlockToken): Integer; virtual; abstract;
	end;

	PUserFieldVTable = ^UserFieldVTable;
	UserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	end;

	IUserFieldImpl = class;

	IUserField = record
	private
	  token: PUserFieldToken;
	public
	  const VERSION = 3;

	  function vTable: PUserFieldVTable inline;
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: PStatusToken; newValue: Integer);
	  class operator := (aToken:  PUserFieldToken): IUserField;
	  class operator := (intf: IUserField): PUserFieldToken;
	  class operator := (impl: IUserFieldImpl): IUserField;
	  class operator = (a: IUserField; b: pointer): boolean;
class operator = (a,b: IUserField): boolean;
	end;

	IUserFieldImpl = class(IVersionedImpl)
	private
	  class var vTable: UserFieldVTable; 
	  class var FInitialized: boolean;
	  intf: IUserField;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUserFieldToken inline;
	  function getInterface: IUserField inline;
		function entered(): Integer; virtual; abstract;
		function specified(): Integer; virtual; abstract;
		procedure setEntered(status: PStatusToken; newValue: Integer); virtual; abstract;
	end;

	PCharUserFieldVTable = ^CharUserFieldVTable;
	CharUserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	  get: ICharUserField_getPtr;
	  set_: ICharUserField_set_Ptr;
	end;

	ICharUserFieldImpl = class;

	ICharUserField = record
	private
	  token: PCharUserFieldToken;
	public
	  const VERSION = 5;

	  function vTable: PCharUserFieldVTable inline;
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: PStatusToken; newValue: Integer);
	  function get(): PAnsiChar;
	  procedure set_(status: PStatusToken; newValue: PAnsiChar);
	  class operator := (aToken:  PCharUserFieldToken): ICharUserField;
	  class operator := (intf: ICharUserField): PCharUserFieldToken;
	  class operator := (impl: ICharUserFieldImpl): ICharUserField;
	  class operator = (a: ICharUserField; b: pointer): boolean;
class operator = (a,b: ICharUserField): boolean;
	end;

	ICharUserFieldImpl = class(IUserFieldImpl)
	private
	  class var vTable: CharUserFieldVTable; 
	  class var FInitialized: boolean;
	  intf: ICharUserField;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PCharUserFieldToken inline;
	  function getInterface: ICharUserField inline;
		function get(): PAnsiChar; virtual; abstract;
		procedure set_(status: PStatusToken; newValue: PAnsiChar); virtual; abstract;
	end;

	PIntUserFieldVTable = ^IntUserFieldVTable;
	IntUserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	  get: IIntUserField_getPtr;
	  set_: IIntUserField_set_Ptr;
	end;

	IIntUserFieldImpl = class;

	IIntUserField = record
	private
	  token: PIntUserFieldToken;
	public
	  const VERSION = 5;

	  function vTable: PIntUserFieldVTable inline;
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: PStatusToken; newValue: Integer);
	  function get(): Integer;
	  procedure set_(status: PStatusToken; newValue: Integer);
	  class operator := (aToken:  PIntUserFieldToken): IIntUserField;
	  class operator := (intf: IIntUserField): PIntUserFieldToken;
	  class operator := (impl: IIntUserFieldImpl): IIntUserField;
	  class operator = (a: IIntUserField; b: pointer): boolean;
class operator = (a,b: IIntUserField): boolean;
	end;

	IIntUserFieldImpl = class(IUserFieldImpl)
	private
	  class var vTable: IntUserFieldVTable; 
	  class var FInitialized: boolean;
	  intf: IIntUserField;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PIntUserFieldToken inline;
	  function getInterface: IIntUserField inline;
		function get(): Integer; virtual; abstract;
		procedure set_(status: PStatusToken; newValue: Integer); virtual; abstract;
	end;

	PUserVTable = ^UserVTable;
	UserVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  operation: IUser_operationPtr;
	  userName: IUser_userNamePtr;
	  password: IUser_passwordPtr;
	  firstName: IUser_firstNamePtr;
	  lastName: IUser_lastNamePtr;
	  middleName: IUser_middleNamePtr;
	  comment: IUser_commentPtr;
	  attributes: IUser_attributesPtr;
	  active: IUser_activePtr;
	  admin: IUser_adminPtr;
	  clear: IUser_clearPtr;
	end;

	IUserImpl = class;

	IUser = record
	private
	  token: PUserToken;
	public
	  const VERSION = 11;
	  const OP_USER_ADD = Cardinal(1);
	  const OP_USER_MODIFY = Cardinal(2);
	  const OP_USER_DELETE = Cardinal(3);
	  const OP_USER_DISPLAY = Cardinal(4);
	  const OP_USER_SET_MAP = Cardinal(5);
	  const OP_USER_DROP_MAP = Cardinal(6);

	  function vTable: PUserVTable inline;
	  function operation(): Cardinal;
	  function userName(): PCharUserFieldToken;
	  function password(): PCharUserFieldToken;
	  function firstName(): PCharUserFieldToken;
	  function lastName(): PCharUserFieldToken;
	  function middleName(): PCharUserFieldToken;
	  function comment(): PCharUserFieldToken;
	  function attributes(): PCharUserFieldToken;
	  function active(): PIntUserFieldToken;
	  function admin(): PIntUserFieldToken;
	  procedure clear(status: PStatusToken);
	  class operator := (aToken:  PUserToken): IUser;
	  class operator := (intf: IUser): PUserToken;
	  class operator := (impl: IUserImpl): IUser;
	  class operator = (a: IUser; b: pointer): boolean;
class operator = (a,b: IUser): boolean;
	end;

	IUserImpl = class(IVersionedImpl)
	private
	  class var vTable: UserVTable; 
	  class var FInitialized: boolean;
	  intf: IUser;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUserToken inline;
	  function getInterface: IUser inline;
		function operation(): Cardinal; virtual; abstract;
		function userName(): PCharUserFieldToken; virtual; abstract;
		function password(): PCharUserFieldToken; virtual; abstract;
		function firstName(): PCharUserFieldToken; virtual; abstract;
		function lastName(): PCharUserFieldToken; virtual; abstract;
		function middleName(): PCharUserFieldToken; virtual; abstract;
		function comment(): PCharUserFieldToken; virtual; abstract;
		function attributes(): PCharUserFieldToken; virtual; abstract;
		function active(): PIntUserFieldToken; virtual; abstract;
		function admin(): PIntUserFieldToken; virtual; abstract;
		procedure clear(status: PStatusToken); virtual; abstract;
	end;

	PListUsersVTable = ^ListUsersVTable;
	ListUsersVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  list: IListUsers_listPtr;
	end;

	IListUsersImpl = class;

	IListUsers = record
	private
	  token: PListUsersToken;
	public
	  const VERSION = 1;

	  function vTable: PListUsersVTable inline;
	  procedure list(status: PStatusToken; user: PUserToken);
	  class operator := (aToken:  PListUsersToken): IListUsers;
	  class operator := (intf: IListUsers): PListUsersToken;
	  class operator := (impl: IListUsersImpl): IListUsers;
	  class operator = (a: IListUsers; b: pointer): boolean;
class operator = (a,b: IListUsers): boolean;
	end;

	IListUsersImpl = class(IVersionedImpl)
	private
	  class var vTable: ListUsersVTable; 
	  class var FInitialized: boolean;
	  intf: IListUsers;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PListUsersToken inline;
	  function getInterface: IListUsers inline;
		procedure list(status: PStatusToken; user: PUserToken); virtual; abstract;
	end;

	PLogonInfoVTable = ^LogonInfoVTable;
	LogonInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  name: ILogonInfo_namePtr;
	  role: ILogonInfo_rolePtr;
	  networkProtocol: ILogonInfo_networkProtocolPtr;
	  remoteAddress: ILogonInfo_remoteAddressPtr;
	  authBlock: ILogonInfo_authBlockPtr;
	  attachment: ILogonInfo_attachmentPtr;
	  transaction: ILogonInfo_transactionPtr;
	end;

	ILogonInfoImpl = class;

	ILogonInfo = record
	private
	  token: PLogonInfoToken;
	public
	  const VERSION = 7;

	  function vTable: PLogonInfoVTable inline;
	  function name(): PAnsiChar;
	  function role(): PAnsiChar;
	  function networkProtocol(): PAnsiChar;
	  function remoteAddress(): PAnsiChar;
	  function authBlock(length: CardinalPtr): BytePtr;
	  function attachment(status: PStatusToken): PAttachmentToken;
	  function transaction(status: PStatusToken): PTransactionToken;
	  class operator := (aToken:  PLogonInfoToken): ILogonInfo;
	  class operator := (intf: ILogonInfo): PLogonInfoToken;
	  class operator := (impl: ILogonInfoImpl): ILogonInfo;
	  class operator = (a: ILogonInfo; b: pointer): boolean;
class operator = (a,b: ILogonInfo): boolean;
	end;

	ILogonInfoImpl = class(IVersionedImpl)
	private
	  class var vTable: LogonInfoVTable; 
	  class var FInitialized: boolean;
	  intf: ILogonInfo;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PLogonInfoToken inline;
	  function getInterface: ILogonInfo inline;
		function name(): PAnsiChar; virtual; abstract;
		function role(): PAnsiChar; virtual; abstract;
		function networkProtocol(): PAnsiChar; virtual; abstract;
		function remoteAddress(): PAnsiChar; virtual; abstract;
		function authBlock(length: CardinalPtr): BytePtr; virtual; abstract;
		function attachment(status: PStatusToken): PAttachmentToken; virtual; abstract;
		function transaction(status: PStatusToken): PTransactionToken; virtual; abstract;
	end;

	PManagementVTable = ^ManagementVTable;
	ManagementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  start: IManagement_startPtr;
	  execute: IManagement_executePtr;
	  commit: IManagement_commitPtr;
	  rollback: IManagement_rollbackPtr;
	end;

	IManagementImpl = class;

	IManagement = record
	private
	  token: PManagementToken;
	public
	  const VERSION = 8;

	  function vTable: PManagementVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  procedure start(status: PStatusToken; logonInfo: PLogonInfoToken);
	  function execute(status: PStatusToken; user: PUserToken; callback: PListUsersToken): Integer;
	  procedure commit(status: PStatusToken);
	  procedure rollback(status: PStatusToken);
	  class operator := (aToken:  PManagementToken): IManagement;
	  class operator := (intf: IManagement): PManagementToken;
	  class operator := (impl: IManagementImpl): IManagement;
	  class operator = (a: IManagement; b: pointer): boolean;
class operator = (a,b: IManagement): boolean;
	end;

	IManagementImpl = class(IPluginBaseImpl)
	private
	  class var vTable: ManagementVTable; 
	  class var FInitialized: boolean;
	  intf: IManagement;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PManagementToken inline;
	  function getInterface: IManagement inline;
		procedure start(status: PStatusToken; logonInfo: PLogonInfoToken); virtual; abstract;
		function execute(status: PStatusToken; user: PUserToken; callback: PListUsersToken): Integer; virtual; abstract;
		procedure commit(status: PStatusToken); virtual; abstract;
		procedure rollback(status: PStatusToken); virtual; abstract;
	end;

	PAuthBlockVTable = ^AuthBlockVTable;
	AuthBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getType: IAuthBlock_getTypePtr;
	  getName: IAuthBlock_getNamePtr;
	  getPlugin: IAuthBlock_getPluginPtr;
	  getSecurityDb: IAuthBlock_getSecurityDbPtr;
	  getOriginalPlugin: IAuthBlock_getOriginalPluginPtr;
	  next: IAuthBlock_nextPtr;
	  first: IAuthBlock_firstPtr;
	end;

	IAuthBlockImpl = class;

	IAuthBlock = record
	private
	  token: PAuthBlockToken;
	public
	  const VERSION = 7;

	  function vTable: PAuthBlockVTable inline;
	  function getType(): PAnsiChar;
	  function getName(): PAnsiChar;
	  function getPlugin(): PAnsiChar;
	  function getSecurityDb(): PAnsiChar;
	  function getOriginalPlugin(): PAnsiChar;
	  function next(status: PStatusToken): Boolean;
	  function first(status: PStatusToken): Boolean;
	  class operator := (aToken:  PAuthBlockToken): IAuthBlock;
	  class operator := (intf: IAuthBlock): PAuthBlockToken;
	  class operator := (impl: IAuthBlockImpl): IAuthBlock;
	  class operator = (a: IAuthBlock; b: pointer): boolean;
class operator = (a,b: IAuthBlock): boolean;
	end;

	IAuthBlockImpl = class(IVersionedImpl)
	private
	  class var vTable: AuthBlockVTable; 
	  class var FInitialized: boolean;
	  intf: IAuthBlock;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PAuthBlockToken inline;
	  function getInterface: IAuthBlock inline;
		function getType(): PAnsiChar; virtual; abstract;
		function getName(): PAnsiChar; virtual; abstract;
		function getPlugin(): PAnsiChar; virtual; abstract;
		function getSecurityDb(): PAnsiChar; virtual; abstract;
		function getOriginalPlugin(): PAnsiChar; virtual; abstract;
		function next(status: PStatusToken): Boolean; virtual; abstract;
		function first(status: PStatusToken): Boolean; virtual; abstract;
	end;

	PWireCryptPluginVTable = ^WireCryptPluginVTable;
	WireCryptPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  getKnownTypes: IWireCryptPlugin_getKnownTypesPtr;
	  setKey: IWireCryptPlugin_setKeyPtr;
	  encrypt: IWireCryptPlugin_encryptPtr;
	  decrypt: IWireCryptPlugin_decryptPtr;
	  getSpecificData: IWireCryptPlugin_getSpecificDataPtr;
	  setSpecificData: IWireCryptPlugin_setSpecificDataPtr;
	end;

	IWireCryptPluginImpl = class;

	IWireCryptPlugin = record
	private
	  token: PWireCryptPluginToken;
	public
	  const VERSION = 10;

	  function vTable: PWireCryptPluginVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function getKnownTypes(status: PStatusToken): PAnsiChar;
	  procedure setKey(status: PStatusToken; key: PCryptKeyToken);
	  procedure encrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure decrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
	  function getSpecificData(status: PStatusToken; keyType: PAnsiChar; length: CardinalPtr): BytePtr;
	  procedure setSpecificData(status: PStatusToken; keyType: PAnsiChar; length: Cardinal; data: BytePtr);
	  class operator := (aToken:  PWireCryptPluginToken): IWireCryptPlugin;
	  class operator := (intf: IWireCryptPlugin): PWireCryptPluginToken;
	  class operator := (impl: IWireCryptPluginImpl): IWireCryptPlugin;
	  class operator = (a: IWireCryptPlugin; b: pointer): boolean;
class operator = (a,b: IWireCryptPlugin): boolean;
	end;

	IWireCryptPluginImpl = class(IPluginBaseImpl)
	private
	  class var vTable: WireCryptPluginVTable; 
	  class var FInitialized: boolean;
	  intf: IWireCryptPlugin;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PWireCryptPluginToken inline;
	  function getInterface: IWireCryptPlugin inline;
		function getKnownTypes(status: PStatusToken): PAnsiChar; virtual; abstract;
		procedure setKey(status: PStatusToken; key: PCryptKeyToken); virtual; abstract;
		procedure encrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
		procedure decrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
		function getSpecificData(status: PStatusToken; keyType: PAnsiChar; length: CardinalPtr): BytePtr; virtual; abstract;
		procedure setSpecificData(status: PStatusToken; keyType: PAnsiChar; length: Cardinal; data: BytePtr); virtual; abstract;
	end;

	PCryptKeyCallbackVTable = ^CryptKeyCallbackVTable;
	CryptKeyCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  callback: ICryptKeyCallback_callbackPtr;
	end;

	ICryptKeyCallbackImpl = class;

	ICryptKeyCallback = record
	private
	  token: PCryptKeyCallbackToken;
	public
	  const VERSION = 1;

	  function vTable: PCryptKeyCallbackVTable inline;
	  function callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal;
	  class operator := (aToken:  PCryptKeyCallbackToken): ICryptKeyCallback;
	  class operator := (intf: ICryptKeyCallback): PCryptKeyCallbackToken;
	  class operator := (impl: ICryptKeyCallbackImpl): ICryptKeyCallback;
	  class operator = (a: ICryptKeyCallback; b: pointer): boolean;
class operator = (a,b: ICryptKeyCallback): boolean;
	end;

	ICryptKeyCallbackImpl = class(IVersionedImpl)
	private
	  class var vTable: CryptKeyCallbackVTable; 
	  class var FInitialized: boolean;
	  intf: ICryptKeyCallback;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PCryptKeyCallbackToken inline;
	  function getInterface: ICryptKeyCallback inline;
		function callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; virtual; abstract;
	end;

	PKeyHolderPluginVTable = ^KeyHolderPluginVTable;
	KeyHolderPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  keyCallback: IKeyHolderPlugin_keyCallbackPtr;
	  keyHandle: IKeyHolderPlugin_keyHandlePtr;
	  useOnlyOwnKeys: IKeyHolderPlugin_useOnlyOwnKeysPtr;
	  chainHandle: IKeyHolderPlugin_chainHandlePtr;
	end;

	IKeyHolderPluginImpl = class;

	IKeyHolderPlugin = record
	private
	  token: PKeyHolderPluginToken;
	public
	  const VERSION = 8;

	  function vTable: PKeyHolderPluginVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function keyCallback(status: PStatusToken; callback: PCryptKeyCallbackToken): Integer;
	  function keyHandle(status: PStatusToken; keyName: PAnsiChar): PCryptKeyCallbackToken;
	  function useOnlyOwnKeys(status: PStatusToken): Boolean;
	  function chainHandle(status: PStatusToken): PCryptKeyCallbackToken;
	  class operator := (aToken:  PKeyHolderPluginToken): IKeyHolderPlugin;
	  class operator := (intf: IKeyHolderPlugin): PKeyHolderPluginToken;
	  class operator := (impl: IKeyHolderPluginImpl): IKeyHolderPlugin;
	  class operator = (a: IKeyHolderPlugin; b: pointer): boolean;
class operator = (a,b: IKeyHolderPlugin): boolean;
	end;

	IKeyHolderPluginImpl = class(IPluginBaseImpl)
	private
	  class var vTable: KeyHolderPluginVTable; 
	  class var FInitialized: boolean;
	  intf: IKeyHolderPlugin;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PKeyHolderPluginToken inline;
	  function getInterface: IKeyHolderPlugin inline;
		function keyCallback(status: PStatusToken; callback: PCryptKeyCallbackToken): Integer; virtual; abstract;
		function keyHandle(status: PStatusToken; keyName: PAnsiChar): PCryptKeyCallbackToken; virtual; abstract;
		function useOnlyOwnKeys(status: PStatusToken): Boolean; virtual; abstract;
		function chainHandle(status: PStatusToken): PCryptKeyCallbackToken; virtual; abstract;
	end;

	PDbCryptInfoVTable = ^DbCryptInfoVTable;
	DbCryptInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getDatabaseFullPath: IDbCryptInfo_getDatabaseFullPathPtr;
	end;

	IDbCryptInfoImpl = class;

	IDbCryptInfo = record
	private
	  token: PDbCryptInfoToken;
	public
	  const VERSION = 3;

	  function vTable: PDbCryptInfoVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function getDatabaseFullPath(status: PStatusToken): PAnsiChar;
	  class operator := (aToken:  PDbCryptInfoToken): IDbCryptInfo;
	  class operator := (intf: IDbCryptInfo): PDbCryptInfoToken;
	  class operator := (impl: IDbCryptInfoImpl): IDbCryptInfo;
	  class operator = (a: IDbCryptInfo; b: pointer): boolean;
class operator = (a,b: IDbCryptInfo): boolean;
	end;

	IDbCryptInfoImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: DbCryptInfoVTable; 
	  class var FInitialized: boolean;
	  intf: IDbCryptInfo;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDbCryptInfoToken inline;
	  function getInterface: IDbCryptInfo inline;
		function getDatabaseFullPath(status: PStatusToken): PAnsiChar; virtual; abstract;
	end;

	PDbCryptPluginVTable = ^DbCryptPluginVTable;
	DbCryptPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  setKey: IDbCryptPlugin_setKeyPtr;
	  encrypt: IDbCryptPlugin_encryptPtr;
	  decrypt: IDbCryptPlugin_decryptPtr;
	  setInfo: IDbCryptPlugin_setInfoPtr;
	end;

	IDbCryptPluginImpl = class;

	IDbCryptPlugin = record
	private
	  token: PDbCryptPluginToken;
	public
	  const VERSION = 8;

	  function vTable: PDbCryptPluginVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  procedure setKey(status: PStatusToken; length: Cardinal; sources: PKeyHolderPluginTokenPtr; keyName: PAnsiChar);
	  procedure encrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure decrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure setInfo(status: PStatusToken; info: PDbCryptInfoToken);
	  class operator := (aToken:  PDbCryptPluginToken): IDbCryptPlugin;
	  class operator := (intf: IDbCryptPlugin): PDbCryptPluginToken;
	  class operator := (impl: IDbCryptPluginImpl): IDbCryptPlugin;
	  class operator = (a: IDbCryptPlugin; b: pointer): boolean;
class operator = (a,b: IDbCryptPlugin): boolean;
	end;

	IDbCryptPluginImpl = class(IPluginBaseImpl)
	private
	  class var vTable: DbCryptPluginVTable; 
	  class var FInitialized: boolean;
	  intf: IDbCryptPlugin;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDbCryptPluginToken inline;
	  function getInterface: IDbCryptPlugin inline;
		procedure setKey(status: PStatusToken; length: Cardinal; sources: PKeyHolderPluginTokenPtr; keyName: PAnsiChar); virtual; abstract;
		procedure encrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
		procedure decrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
		procedure setInfo(status: PStatusToken; info: PDbCryptInfoToken); virtual; abstract;
	end;

	PExternalContextVTable = ^ExternalContextVTable;
	ExternalContextVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getMaster: IExternalContext_getMasterPtr;
	  getEngine: IExternalContext_getEnginePtr;
	  getAttachment: IExternalContext_getAttachmentPtr;
	  getTransaction: IExternalContext_getTransactionPtr;
	  getUserName: IExternalContext_getUserNamePtr;
	  getDatabaseName: IExternalContext_getDatabaseNamePtr;
	  getClientCharSet: IExternalContext_getClientCharSetPtr;
	  obtainInfoCode: IExternalContext_obtainInfoCodePtr;
	  getInfo: IExternalContext_getInfoPtr;
	  setInfo: IExternalContext_setInfoPtr;
	end;

	IExternalContextImpl = class;

	IExternalContext = record
	private
	  token: PExternalContextToken;
	public
	  const VERSION = 10;

	  function vTable: PExternalContextVTable inline;
	  function getMaster(): PMasterToken;
	  function getEngine(status: PStatusToken): PExternalEngineToken;
	  function getAttachment(status: PStatusToken): PAttachmentToken;
	  function getTransaction(status: PStatusToken): PTransactionToken;
	  function getUserName(): PAnsiChar;
	  function getDatabaseName(): PAnsiChar;
	  function getClientCharSet(): PAnsiChar;
	  function obtainInfoCode(): Integer;
	  function getInfo(code: Integer): Pointer;
	  function setInfo(code: Integer; value: Pointer): Pointer;
	  class operator := (aToken:  PExternalContextToken): IExternalContext;
	  class operator := (intf: IExternalContext): PExternalContextToken;
	  class operator := (impl: IExternalContextImpl): IExternalContext;
	  class operator = (a: IExternalContext; b: pointer): boolean;
class operator = (a,b: IExternalContext): boolean;
	end;

	IExternalContextImpl = class(IVersionedImpl)
	private
	  class var vTable: ExternalContextVTable; 
	  class var FInitialized: boolean;
	  intf: IExternalContext;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PExternalContextToken inline;
	  function getInterface: IExternalContext inline;
		function getMaster(): PMasterToken; virtual; abstract;
		function getEngine(status: PStatusToken): PExternalEngineToken; virtual; abstract;
		function getAttachment(status: PStatusToken): PAttachmentToken; virtual; abstract;
		function getTransaction(status: PStatusToken): PTransactionToken; virtual; abstract;
		function getUserName(): PAnsiChar; virtual; abstract;
		function getDatabaseName(): PAnsiChar; virtual; abstract;
		function getClientCharSet(): PAnsiChar; virtual; abstract;
		function obtainInfoCode(): Integer; virtual; abstract;
		function getInfo(code: Integer): Pointer; virtual; abstract;
		function setInfo(code: Integer; value: Pointer): Pointer; virtual; abstract;
	end;

	PExternalResultSetVTable = ^ExternalResultSetVTable;
	ExternalResultSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  fetch: IExternalResultSet_fetchPtr;
	end;

	IExternalResultSetImpl = class;

	IExternalResultSet = record
	private
	  token: PExternalResultSetToken;
	public
	  const VERSION = 2;

	  function vTable: PExternalResultSetVTable inline;
	  procedure dispose();
	  function fetch(status: PStatusToken): Boolean;
	  class operator := (aToken:  PExternalResultSetToken): IExternalResultSet;
	  class operator := (intf: IExternalResultSet): PExternalResultSetToken;
	  class operator := (impl: IExternalResultSetImpl): IExternalResultSet;
	  class operator = (a: IExternalResultSet; b: pointer): boolean;
class operator = (a,b: IExternalResultSet): boolean;
	end;

	IExternalResultSetImpl = class(IDisposableImpl)
	private
	  class var vTable: ExternalResultSetVTable; 
	  class var FInitialized: boolean;
	  intf: IExternalResultSet;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PExternalResultSetToken inline;
	  function getInterface: IExternalResultSet inline;
		function fetch(status: PStatusToken): Boolean; virtual; abstract;
	end;

	PExternalFunctionVTable = ^ExternalFunctionVTable;
	ExternalFunctionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalFunction_getCharSetPtr;
	  execute: IExternalFunction_executePtr;
	end;

	IExternalFunctionImpl = class;

	IExternalFunction = record
	private
	  token: PExternalFunctionToken;
	public
	  const VERSION = 3;

	  function vTable: PExternalFunctionVTable inline;
	  procedure dispose();
	  procedure getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal);
	  procedure execute(status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer);
	  class operator := (aToken:  PExternalFunctionToken): IExternalFunction;
	  class operator := (intf: IExternalFunction): PExternalFunctionToken;
	  class operator := (impl: IExternalFunctionImpl): IExternalFunction;
	  class operator = (a: IExternalFunction; b: pointer): boolean;
class operator = (a,b: IExternalFunction): boolean;
	end;

	IExternalFunctionImpl = class(IDisposableImpl)
	private
	  class var vTable: ExternalFunctionVTable; 
	  class var FInitialized: boolean;
	  intf: IExternalFunction;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PExternalFunctionToken inline;
	  function getInterface: IExternalFunction inline;
		procedure getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
		procedure execute(status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer); virtual; abstract;
	end;

	PExternalProcedureVTable = ^ExternalProcedureVTable;
	ExternalProcedureVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalProcedure_getCharSetPtr;
	  open: IExternalProcedure_openPtr;
	end;

	IExternalProcedureImpl = class;

	IExternalProcedure = record
	private
	  token: PExternalProcedureToken;
	public
	  const VERSION = 3;

	  function vTable: PExternalProcedureVTable inline;
	  procedure dispose();
	  procedure getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal);
	  function open(status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer): PExternalResultSetToken;
	  class operator := (aToken:  PExternalProcedureToken): IExternalProcedure;
	  class operator := (intf: IExternalProcedure): PExternalProcedureToken;
	  class operator := (impl: IExternalProcedureImpl): IExternalProcedure;
	  class operator = (a: IExternalProcedure; b: pointer): boolean;
class operator = (a,b: IExternalProcedure): boolean;
	end;

	IExternalProcedureImpl = class(IDisposableImpl)
	private
	  class var vTable: ExternalProcedureVTable; 
	  class var FInitialized: boolean;
	  intf: IExternalProcedure;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PExternalProcedureToken inline;
	  function getInterface: IExternalProcedure inline;
		procedure getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
		function open(status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer): PExternalResultSetToken; virtual; abstract;
	end;

	PExternalTriggerVTable = ^ExternalTriggerVTable;
	ExternalTriggerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalTrigger_getCharSetPtr;
	  execute: IExternalTrigger_executePtr;
	end;

	IExternalTriggerImpl = class;

	IExternalTrigger = record
	private
	  token: PExternalTriggerToken;
	public
	  const VERSION = 3;
	  const TYPE_BEFORE = Cardinal(1);
	  const TYPE_AFTER = Cardinal(2);
	  const TYPE_DATABASE = Cardinal(3);
	  const ACTION_INSERT = Cardinal(1);
	  const ACTION_UPDATE = Cardinal(2);
	  const ACTION_DELETE = Cardinal(3);
	  const ACTION_CONNECT = Cardinal(4);
	  const ACTION_DISCONNECT = Cardinal(5);
	  const ACTION_TRANS_START = Cardinal(6);
	  const ACTION_TRANS_COMMIT = Cardinal(7);
	  const ACTION_TRANS_ROLLBACK = Cardinal(8);
	  const ACTION_DDL = Cardinal(9);

	  function vTable: PExternalTriggerVTable inline;
	  procedure dispose();
	  procedure getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal);
	  procedure execute(status: PStatusToken; context: PExternalContextToken; action: Cardinal; oldMsg: Pointer; newMsg: Pointer);
	  class operator := (aToken:  PExternalTriggerToken): IExternalTrigger;
	  class operator := (intf: IExternalTrigger): PExternalTriggerToken;
	  class operator := (impl: IExternalTriggerImpl): IExternalTrigger;
	  class operator = (a: IExternalTrigger; b: pointer): boolean;
class operator = (a,b: IExternalTrigger): boolean;
	end;

	IExternalTriggerImpl = class(IDisposableImpl)
	private
	  class var vTable: ExternalTriggerVTable; 
	  class var FInitialized: boolean;
	  intf: IExternalTrigger;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PExternalTriggerToken inline;
	  function getInterface: IExternalTrigger inline;
		procedure getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
		procedure execute(status: PStatusToken; context: PExternalContextToken; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); virtual; abstract;
	end;

	PRoutineMetadataVTable = ^RoutineMetadataVTable;
	RoutineMetadataVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getPackage: IRoutineMetadata_getPackagePtr;
	  getName: IRoutineMetadata_getNamePtr;
	  getEntryPoint: IRoutineMetadata_getEntryPointPtr;
	  getBody: IRoutineMetadata_getBodyPtr;
	  getInputMetadata: IRoutineMetadata_getInputMetadataPtr;
	  getOutputMetadata: IRoutineMetadata_getOutputMetadataPtr;
	  getTriggerMetadata: IRoutineMetadata_getTriggerMetadataPtr;
	  getTriggerTable: IRoutineMetadata_getTriggerTablePtr;
	  getTriggerType: IRoutineMetadata_getTriggerTypePtr;
	end;

	IRoutineMetadataImpl = class;

	IRoutineMetadata = record
	private
	  token: PRoutineMetadataToken;
	public
	  const VERSION = 9;

	  function vTable: PRoutineMetadataVTable inline;
	  function getPackage(status: PStatusToken): PAnsiChar;
	  function getName(status: PStatusToken): PAnsiChar;
	  function getEntryPoint(status: PStatusToken): PAnsiChar;
	  function getBody(status: PStatusToken): PAnsiChar;
	  function getInputMetadata(status: PStatusToken): PMessageMetadataToken;
	  function getOutputMetadata(status: PStatusToken): PMessageMetadataToken;
	  function getTriggerMetadata(status: PStatusToken): PMessageMetadataToken;
	  function getTriggerTable(status: PStatusToken): PAnsiChar;
	  function getTriggerType(status: PStatusToken): Cardinal;
	  class operator := (aToken:  PRoutineMetadataToken): IRoutineMetadata;
	  class operator := (intf: IRoutineMetadata): PRoutineMetadataToken;
	  class operator := (impl: IRoutineMetadataImpl): IRoutineMetadata;
	  class operator = (a: IRoutineMetadata; b: pointer): boolean;
class operator = (a,b: IRoutineMetadata): boolean;
	end;

	IRoutineMetadataImpl = class(IVersionedImpl)
	private
	  class var vTable: RoutineMetadataVTable; 
	  class var FInitialized: boolean;
	  intf: IRoutineMetadata;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PRoutineMetadataToken inline;
	  function getInterface: IRoutineMetadata inline;
		function getPackage(status: PStatusToken): PAnsiChar; virtual; abstract;
		function getName(status: PStatusToken): PAnsiChar; virtual; abstract;
		function getEntryPoint(status: PStatusToken): PAnsiChar; virtual; abstract;
		function getBody(status: PStatusToken): PAnsiChar; virtual; abstract;
		function getInputMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		function getOutputMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		function getTriggerMetadata(status: PStatusToken): PMessageMetadataToken; virtual; abstract;
		function getTriggerTable(status: PStatusToken): PAnsiChar; virtual; abstract;
		function getTriggerType(status: PStatusToken): Cardinal; virtual; abstract;
	end;

	PExternalEngineVTable = ^ExternalEngineVTable;
	ExternalEngineVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  open: IExternalEngine_openPtr;
	  openAttachment: IExternalEngine_openAttachmentPtr;
	  closeAttachment: IExternalEngine_closeAttachmentPtr;
	  makeFunction: IExternalEngine_makeFunctionPtr;
	  makeProcedure: IExternalEngine_makeProcedurePtr;
	  makeTrigger: IExternalEngine_makeTriggerPtr;
	end;

	IExternalEngineImpl = class;

	IExternalEngine = record
	private
	  token: PExternalEngineToken;
	public
	  const VERSION = 10;

	  function vTable: PExternalEngineVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  procedure open(status: PStatusToken; context: PExternalContextToken; charSet: PAnsiChar; charSetSize: Cardinal);
	  procedure openAttachment(status: PStatusToken; context: PExternalContextToken);
	  procedure closeAttachment(status: PStatusToken; context: PExternalContextToken);
	  function makeFunction(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalFunctionToken;
	  function makeProcedure(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalProcedureToken;
	  function makeTrigger(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken): PExternalTriggerToken;
	  class operator := (aToken:  PExternalEngineToken): IExternalEngine;
	  class operator := (intf: IExternalEngine): PExternalEngineToken;
	  class operator := (impl: IExternalEngineImpl): IExternalEngine;
	  class operator = (a: IExternalEngine; b: pointer): boolean;
class operator = (a,b: IExternalEngine): boolean;
	end;

	IExternalEngineImpl = class(IPluginBaseImpl)
	private
	  class var vTable: ExternalEngineVTable; 
	  class var FInitialized: boolean;
	  intf: IExternalEngine;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PExternalEngineToken inline;
	  function getInterface: IExternalEngine inline;
		procedure open(status: PStatusToken; context: PExternalContextToken; charSet: PAnsiChar; charSetSize: Cardinal); virtual; abstract;
		procedure openAttachment(status: PStatusToken; context: PExternalContextToken); virtual; abstract;
		procedure closeAttachment(status: PStatusToken; context: PExternalContextToken); virtual; abstract;
		function makeFunction(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalFunctionToken; virtual; abstract;
		function makeProcedure(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalProcedureToken; virtual; abstract;
		function makeTrigger(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken): PExternalTriggerToken; virtual; abstract;
	end;

	PTimerVTable = ^TimerVTable;
	TimerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  handler: ITimer_handlerPtr;
	end;

	ITimerImpl = class;

	ITimer = record
	private
	  token: PTimerToken;
	public
	  const VERSION = 3;

	  function vTable: PTimerVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure handler();
	  class operator := (aToken:  PTimerToken): ITimer;
	  class operator := (intf: ITimer): PTimerToken;
	  class operator := (impl: ITimerImpl): ITimer;
	  class operator = (a: ITimer; b: pointer): boolean;
class operator = (a,b: ITimer): boolean;
	end;

	ITimerImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: TimerVTable; 
	  class var FInitialized: boolean;
	  intf: ITimer;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTimerToken inline;
	  function getInterface: ITimer inline;
		procedure handler(); virtual; abstract;
	end;

	PTimerControlVTable = ^TimerControlVTable;
	TimerControlVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  start: ITimerControl_startPtr;
	  stop: ITimerControl_stopPtr;
	end;

	ITimerControlImpl = class;

	ITimerControl = record
	private
	  token: PTimerControlToken;
	public
	  const VERSION = 2;

	  function vTable: PTimerControlVTable inline;
	  procedure start(status: PStatusToken; timer: PTimerToken; microSeconds: QWord);
	  procedure stop(status: PStatusToken; timer: PTimerToken);
	  class operator := (aToken:  PTimerControlToken): ITimerControl;
	  class operator := (intf: ITimerControl): PTimerControlToken;
	  class operator := (impl: ITimerControlImpl): ITimerControl;
	  class operator = (a: ITimerControl; b: pointer): boolean;
class operator = (a,b: ITimerControl): boolean;
	end;

	ITimerControlImpl = class(IVersionedImpl)
	private
	  class var vTable: TimerControlVTable; 
	  class var FInitialized: boolean;
	  intf: ITimerControl;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTimerControlToken inline;
	  function getInterface: ITimerControl inline;
		procedure start(status: PStatusToken; timer: PTimerToken; microSeconds: QWord); virtual; abstract;
		procedure stop(status: PStatusToken; timer: PTimerToken); virtual; abstract;
	end;

	PVersionCallbackVTable = ^VersionCallbackVTable;
	VersionCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  callback: IVersionCallback_callbackPtr;
	end;

	IVersionCallbackImpl = class;

	IVersionCallback = record
	private
	  token: PVersionCallbackToken;
	public
	  const VERSION = 1;

	  function vTable: PVersionCallbackVTable inline;
	  procedure callback(status: PStatusToken; text: PAnsiChar);
	  class operator := (aToken:  PVersionCallbackToken): IVersionCallback;
	  class operator := (intf: IVersionCallback): PVersionCallbackToken;
	  class operator := (impl: IVersionCallbackImpl): IVersionCallback;
	  class operator = (a: IVersionCallback; b: pointer): boolean;
class operator = (a,b: IVersionCallback): boolean;
	end;

	IVersionCallbackImpl = class(IVersionedImpl)
	private
	  class var vTable: VersionCallbackVTable; 
	  class var FInitialized: boolean;
	  intf: IVersionCallback;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PVersionCallbackToken inline;
	  function getInterface: IVersionCallback inline;
		procedure callback(status: PStatusToken; text: PAnsiChar); virtual; abstract;
	end;

	PUtilVTable = ^UtilVTable;
	UtilVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getFbVersion: IUtil_getFbVersionPtr;
	  loadBlob: IUtil_loadBlobPtr;
	  dumpBlob: IUtil_dumpBlobPtr;
	  getPerfCounters: IUtil_getPerfCountersPtr;
	  executeCreateDatabase: IUtil_executeCreateDatabasePtr;
	  decodeDate: IUtil_decodeDatePtr;
	  decodeTime: IUtil_decodeTimePtr;
	  encodeDate: IUtil_encodeDatePtr;
	  encodeTime: IUtil_encodeTimePtr;
	  formatStatus: IUtil_formatStatusPtr;
	  getClientVersion: IUtil_getClientVersionPtr;
	  getXpbBuilder: IUtil_getXpbBuilderPtr;
	  setOffsets: IUtil_setOffsetsPtr;
	  getDecFloat16: IUtil_getDecFloat16Ptr;
	  getDecFloat34: IUtil_getDecFloat34Ptr;
	  decodeTimeTz: IUtil_decodeTimeTzPtr;
	  decodeTimeStampTz: IUtil_decodeTimeStampTzPtr;
	  encodeTimeTz: IUtil_encodeTimeTzPtr;
	  encodeTimeStampTz: IUtil_encodeTimeStampTzPtr;
	  getInt128: IUtil_getInt128Ptr;
	  decodeTimeTzEx: IUtil_decodeTimeTzExPtr;
	  decodeTimeStampTzEx: IUtil_decodeTimeStampTzExPtr;
	end;

	IUtilImpl = class;

	IUtil = record
	private
	  token: PUtilToken;
	public
	  const VERSION = 22;

	  function vTable: PUtilVTable inline;
	  procedure getFbVersion(status: PStatusToken; att: PAttachmentToken; callback: PVersionCallbackToken);
	  procedure loadBlob(status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean);
	  procedure dumpBlob(status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean);
	  procedure getPerfCounters(status: PStatusToken; att: PAttachmentToken; countersSet: PAnsiChar; counters: Int64Ptr);
	  function executeCreateDatabase(status: PStatusToken; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): PAttachmentToken;
	  procedure decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr);
	  procedure decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr);
	  function encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE;
	  function encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME;
	  function formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: PStatusToken): Cardinal;
	  function getClientVersion(): Cardinal;
	  function getXpbBuilder(status: PStatusToken; kind: Cardinal; buf: BytePtr; len: Cardinal): PXpbBuilderToken;
	  function setOffsets(status: PStatusToken; metadata: PMessageMetadataToken; callback: POffsetsCallbackToken): Cardinal;
	  function getDecFloat16(status: PStatusToken): PDecFloat16Token;
	  function getDecFloat34(status: PStatusToken): PDecFloat34Token;
	  procedure decodeTimeTz(status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure decodeTimeStampTz(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure encodeTimeTz(status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
	  procedure encodeTimeStampTz(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
	  function getInt128(status: PStatusToken): PInt128Token;
	  procedure decodeTimeTzEx(status: PStatusToken; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure decodeTimeStampTzEx(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  class operator := (aToken:  PUtilToken): IUtil;
	  class operator := (intf: IUtil): PUtilToken;
	  class operator := (impl: IUtilImpl): IUtil;
	  class operator = (a: IUtil; b: pointer): boolean;
class operator = (a,b: IUtil): boolean;
	end;

	IUtilImpl = class(IVersionedImpl)
	private
	  class var vTable: UtilVTable; 
	  class var FInitialized: boolean;
	  intf: IUtil;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUtilToken inline;
	  function getInterface: IUtil inline;
		procedure getFbVersion(status: PStatusToken; att: PAttachmentToken; callback: PVersionCallbackToken); virtual; abstract;
		procedure loadBlob(status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean); virtual; abstract;
		procedure dumpBlob(status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean); virtual; abstract;
		procedure getPerfCounters(status: PStatusToken; att: PAttachmentToken; countersSet: PAnsiChar; counters: Int64Ptr); virtual; abstract;
		function executeCreateDatabase(status: PStatusToken; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): PAttachmentToken; virtual; abstract;
		procedure decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); virtual; abstract;
		procedure decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); virtual; abstract;
		function encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; virtual; abstract;
		function encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; virtual; abstract;
		function formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: PStatusToken): Cardinal; virtual; abstract;
		function getClientVersion(): Cardinal; virtual; abstract;
		function getXpbBuilder(status: PStatusToken; kind: Cardinal; buf: BytePtr; len: Cardinal): PXpbBuilderToken; virtual; abstract;
		function setOffsets(status: PStatusToken; metadata: PMessageMetadataToken; callback: POffsetsCallbackToken): Cardinal; virtual; abstract;
		function getDecFloat16(status: PStatusToken): PDecFloat16Token; virtual; abstract;
		function getDecFloat34(status: PStatusToken): PDecFloat34Token; virtual; abstract;
		procedure decodeTimeTz(status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
		procedure decodeTimeStampTz(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
		procedure encodeTimeTz(status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); virtual; abstract;
		procedure encodeTimeStampTz(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); virtual; abstract;
		function getInt128(status: PStatusToken): PInt128Token; virtual; abstract;
		procedure decodeTimeTzEx(status: PStatusToken; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
		procedure decodeTimeStampTzEx(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	end;

	POffsetsCallbackVTable = ^OffsetsCallbackVTable;
	OffsetsCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  setOffset: IOffsetsCallback_setOffsetPtr;
	end;

	IOffsetsCallbackImpl = class;

	IOffsetsCallback = record
	private
	  token: POffsetsCallbackToken;
	public
	  const VERSION = 1;

	  function vTable: POffsetsCallbackVTable inline;
	  procedure setOffset(status: PStatusToken; index: Cardinal; offset: Cardinal; nullOffset: Cardinal);
	  class operator := (aToken:  POffsetsCallbackToken): IOffsetsCallback;
	  class operator := (intf: IOffsetsCallback): POffsetsCallbackToken;
	  class operator := (impl: IOffsetsCallbackImpl): IOffsetsCallback;
	  class operator = (a: IOffsetsCallback; b: pointer): boolean;
class operator = (a,b: IOffsetsCallback): boolean;
	end;

	IOffsetsCallbackImpl = class(IVersionedImpl)
	private
	  class var vTable: OffsetsCallbackVTable; 
	  class var FInitialized: boolean;
	  intf: IOffsetsCallback;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: POffsetsCallbackToken inline;
	  function getInterface: IOffsetsCallback inline;
		procedure setOffset(status: PStatusToken; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); virtual; abstract;
	end;

	PXpbBuilderVTable = ^XpbBuilderVTable;
	XpbBuilderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  clear: IXpbBuilder_clearPtr;
	  removeCurrent: IXpbBuilder_removeCurrentPtr;
	  insertInt: IXpbBuilder_insertIntPtr;
	  insertBigInt: IXpbBuilder_insertBigIntPtr;
	  insertBytes: IXpbBuilder_insertBytesPtr;
	  insertString: IXpbBuilder_insertStringPtr;
	  insertTag: IXpbBuilder_insertTagPtr;
	  isEof: IXpbBuilder_isEofPtr;
	  moveNext: IXpbBuilder_moveNextPtr;
	  rewind: IXpbBuilder_rewindPtr;
	  findFirst: IXpbBuilder_findFirstPtr;
	  findNext: IXpbBuilder_findNextPtr;
	  getTag: IXpbBuilder_getTagPtr;
	  getLength: IXpbBuilder_getLengthPtr;
	  getInt: IXpbBuilder_getIntPtr;
	  getBigInt: IXpbBuilder_getBigIntPtr;
	  getString: IXpbBuilder_getStringPtr;
	  getBytes: IXpbBuilder_getBytesPtr;
	  getBufferLength: IXpbBuilder_getBufferLengthPtr;
	  getBuffer: IXpbBuilder_getBufferPtr;
	end;

	IXpbBuilderImpl = class;

	IXpbBuilder = record
	private
	  token: PXpbBuilderToken;
	public
	  const VERSION = 21;
	  const DPB = Cardinal(1);
	  const SPB_ATTACH = Cardinal(2);
	  const SPB_START = Cardinal(3);
	  const TPB = Cardinal(4);
	  const BATCH = Cardinal(5);
	  const BPB = Cardinal(6);
	  const SPB_SEND = Cardinal(7);
	  const SPB_RECEIVE = Cardinal(8);
	  const SPB_RESPONSE = Cardinal(9);

	  function vTable: PXpbBuilderVTable inline;
	  procedure dispose();
	  procedure clear(status: PStatusToken);
	  procedure removeCurrent(status: PStatusToken);
	  procedure insertInt(status: PStatusToken; tag: Byte; value: Integer);
	  procedure insertBigInt(status: PStatusToken; tag: Byte; value: Int64);
	  procedure insertBytes(status: PStatusToken; tag: Byte; bytes: Pointer; length: Cardinal);
	  procedure insertString(status: PStatusToken; tag: Byte; str: PAnsiChar);
	  procedure insertTag(status: PStatusToken; tag: Byte);
	  function isEof(status: PStatusToken): Boolean;
	  procedure moveNext(status: PStatusToken);
	  procedure rewind(status: PStatusToken);
	  function findFirst(status: PStatusToken; tag: Byte): Boolean;
	  function findNext(status: PStatusToken): Boolean;
	  function getTag(status: PStatusToken): Byte;
	  function getLength(status: PStatusToken): Cardinal;
	  function getInt(status: PStatusToken): Integer;
	  function getBigInt(status: PStatusToken): Int64;
	  function getString(status: PStatusToken): PAnsiChar;
	  function getBytes(status: PStatusToken): BytePtr;
	  function getBufferLength(status: PStatusToken): Cardinal;
	  function getBuffer(status: PStatusToken): BytePtr;
	  class operator := (aToken:  PXpbBuilderToken): IXpbBuilder;
	  class operator := (intf: IXpbBuilder): PXpbBuilderToken;
	  class operator := (impl: IXpbBuilderImpl): IXpbBuilder;
	  class operator = (a: IXpbBuilder; b: pointer): boolean;
class operator = (a,b: IXpbBuilder): boolean;
	end;

	IXpbBuilderImpl = class(IDisposableImpl)
	private
	  class var vTable: XpbBuilderVTable; 
	  class var FInitialized: boolean;
	  intf: IXpbBuilder;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PXpbBuilderToken inline;
	  function getInterface: IXpbBuilder inline;
		procedure clear(status: PStatusToken); virtual; abstract;
		procedure removeCurrent(status: PStatusToken); virtual; abstract;
		procedure insertInt(status: PStatusToken; tag: Byte; value: Integer); virtual; abstract;
		procedure insertBigInt(status: PStatusToken; tag: Byte; value: Int64); virtual; abstract;
		procedure insertBytes(status: PStatusToken; tag: Byte; bytes: Pointer; length: Cardinal); virtual; abstract;
		procedure insertString(status: PStatusToken; tag: Byte; str: PAnsiChar); virtual; abstract;
		procedure insertTag(status: PStatusToken; tag: Byte); virtual; abstract;
		function isEof(status: PStatusToken): Boolean; virtual; abstract;
		procedure moveNext(status: PStatusToken); virtual; abstract;
		procedure rewind(status: PStatusToken); virtual; abstract;
		function findFirst(status: PStatusToken; tag: Byte): Boolean; virtual; abstract;
		function findNext(status: PStatusToken): Boolean; virtual; abstract;
		function getTag(status: PStatusToken): Byte; virtual; abstract;
		function getLength(status: PStatusToken): Cardinal; virtual; abstract;
		function getInt(status: PStatusToken): Integer; virtual; abstract;
		function getBigInt(status: PStatusToken): Int64; virtual; abstract;
		function getString(status: PStatusToken): PAnsiChar; virtual; abstract;
		function getBytes(status: PStatusToken): BytePtr; virtual; abstract;
		function getBufferLength(status: PStatusToken): Cardinal; virtual; abstract;
		function getBuffer(status: PStatusToken): BytePtr; virtual; abstract;
	end;

	PTraceConnectionVTable = ^TraceConnectionVTable;
	TraceConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	end;

	ITraceConnectionImpl = class;

	ITraceConnection = record
	private
	  token: PTraceConnectionToken;
	public
	  const VERSION = 9;
	  const KIND_DATABASE = Cardinal(1);
	  const KIND_SERVICE = Cardinal(2);

	  function vTable: PTraceConnectionVTable inline;
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  class operator := (aToken:  PTraceConnectionToken): ITraceConnection;
	  class operator := (intf: ITraceConnection): PTraceConnectionToken;
	  class operator := (impl: ITraceConnectionImpl): ITraceConnection;
	  class operator = (a: ITraceConnection; b: pointer): boolean;
class operator = (a,b: ITraceConnection): boolean;
	end;

	ITraceConnectionImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceConnectionVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceConnection;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceConnectionToken inline;
	  function getInterface: ITraceConnection inline;
		function getKind(): Cardinal; virtual; abstract;
		function getProcessID(): Integer; virtual; abstract;
		function getUserName(): PAnsiChar; virtual; abstract;
		function getRoleName(): PAnsiChar; virtual; abstract;
		function getCharSet(): PAnsiChar; virtual; abstract;
		function getRemoteProtocol(): PAnsiChar; virtual; abstract;
		function getRemoteAddress(): PAnsiChar; virtual; abstract;
		function getRemoteProcessID(): Integer; virtual; abstract;
		function getRemoteProcessName(): PAnsiChar; virtual; abstract;
	end;

	PTraceDatabaseConnectionVTable = ^TraceDatabaseConnectionVTable;
	TraceDatabaseConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	  getConnectionID: ITraceDatabaseConnection_getConnectionIDPtr;
	  getDatabaseName: ITraceDatabaseConnection_getDatabaseNamePtr;
	end;

	ITraceDatabaseConnectionImpl = class;

	ITraceDatabaseConnection = record
	private
	  token: PTraceDatabaseConnectionToken;
	public
	  const VERSION = 11;
	  const KIND_DATABASE = Cardinal(1);
	  const KIND_SERVICE = Cardinal(2);

	  function vTable: PTraceDatabaseConnectionVTable inline;
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  function getConnectionID(): Int64;
	  function getDatabaseName(): PAnsiChar;
	  class operator := (aToken:  PTraceDatabaseConnectionToken): ITraceDatabaseConnection;
	  class operator := (intf: ITraceDatabaseConnection): PTraceDatabaseConnectionToken;
	  class operator := (impl: ITraceDatabaseConnectionImpl): ITraceDatabaseConnection;
	  class operator = (a: ITraceDatabaseConnection; b: pointer): boolean;
class operator = (a,b: ITraceDatabaseConnection): boolean;
	end;

	ITraceDatabaseConnectionImpl = class(ITraceConnectionImpl)
	private
	  class var vTable: TraceDatabaseConnectionVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceDatabaseConnection;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceDatabaseConnectionToken inline;
	  function getInterface: ITraceDatabaseConnection inline;
		function getConnectionID(): Int64; virtual; abstract;
		function getDatabaseName(): PAnsiChar; virtual; abstract;
	end;

	PTraceTransactionVTable = ^TraceTransactionVTable;
	TraceTransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getTransactionID: ITraceTransaction_getTransactionIDPtr;
	  getReadOnly: ITraceTransaction_getReadOnlyPtr;
	  getWait: ITraceTransaction_getWaitPtr;
	  getIsolation: ITraceTransaction_getIsolationPtr;
	  getPerf: ITraceTransaction_getPerfPtr;
	  getInitialID: ITraceTransaction_getInitialIDPtr;
	  getPreviousID: ITraceTransaction_getPreviousIDPtr;
	end;

	ITraceTransactionImpl = class;

	ITraceTransaction = record
	private
	  token: PTraceTransactionToken;
	public
	  const VERSION = 7;
	  const ISOLATION_CONSISTENCY = Cardinal(1);
	  const ISOLATION_CONCURRENCY = Cardinal(2);
	  const ISOLATION_READ_COMMITTED_RECVER = Cardinal(3);
	  const ISOLATION_READ_COMMITTED_NORECVER = Cardinal(4);
	  const ISOLATION_READ_COMMITTED_READ_CONSISTENCY = Cardinal(5);

	  function vTable: PTraceTransactionVTable inline;
	  function getTransactionID(): Int64;
	  function getReadOnly(): Boolean;
	  function getWait(): Integer;
	  function getIsolation(): Cardinal;
	  function getPerf(): PerformanceInfoPtr;
	  function getInitialID(): Int64;
	  function getPreviousID(): Int64;
	  class operator := (aToken:  PTraceTransactionToken): ITraceTransaction;
	  class operator := (intf: ITraceTransaction): PTraceTransactionToken;
	  class operator := (impl: ITraceTransactionImpl): ITraceTransaction;
	  class operator = (a: ITraceTransaction; b: pointer): boolean;
class operator = (a,b: ITraceTransaction): boolean;
	end;

	ITraceTransactionImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceTransactionVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceTransaction;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceTransactionToken inline;
	  function getInterface: ITraceTransaction inline;
		function getTransactionID(): Int64; virtual; abstract;
		function getReadOnly(): Boolean; virtual; abstract;
		function getWait(): Integer; virtual; abstract;
		function getIsolation(): Cardinal; virtual; abstract;
		function getPerf(): PerformanceInfoPtr; virtual; abstract;
		function getInitialID(): Int64; virtual; abstract;
		function getPreviousID(): Int64; virtual; abstract;
	end;

	PTraceParamsVTable = ^TraceParamsVTable;
	TraceParamsVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getCount: ITraceParams_getCountPtr;
	  getParam: ITraceParams_getParamPtr;
	  getTextUTF8: ITraceParams_getTextUTF8Ptr;
	end;

	ITraceParamsImpl = class;

	ITraceParams = record
	private
	  token: PTraceParamsToken;
	public
	  const VERSION = 3;

	  function vTable: PTraceParamsVTable inline;
	  function getCount(): Cardinal;
	  function getParam(idx: Cardinal): dscPtr;
	  function getTextUTF8(status: PStatusToken; idx: Cardinal): PAnsiChar;
	  class operator := (aToken:  PTraceParamsToken): ITraceParams;
	  class operator := (intf: ITraceParams): PTraceParamsToken;
	  class operator := (impl: ITraceParamsImpl): ITraceParams;
	  class operator = (a: ITraceParams; b: pointer): boolean;
class operator = (a,b: ITraceParams): boolean;
	end;

	ITraceParamsImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceParamsVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceParams;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceParamsToken inline;
	  function getInterface: ITraceParams inline;
		function getCount(): Cardinal; virtual; abstract;
		function getParam(idx: Cardinal): dscPtr; virtual; abstract;
		function getTextUTF8(status: PStatusToken; idx: Cardinal): PAnsiChar; virtual; abstract;
	end;

	PTraceStatementVTable = ^TraceStatementVTable;
	TraceStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	end;

	ITraceStatementImpl = class;

	ITraceStatement = record
	private
	  token: PTraceStatementToken;
	public
	  const VERSION = 2;

	  function vTable: PTraceStatementVTable inline;
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  class operator := (aToken:  PTraceStatementToken): ITraceStatement;
	  class operator := (intf: ITraceStatement): PTraceStatementToken;
	  class operator := (impl: ITraceStatementImpl): ITraceStatement;
	  class operator = (a: ITraceStatement; b: pointer): boolean;
class operator = (a,b: ITraceStatement): boolean;
	end;

	ITraceStatementImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceStatementVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceStatement;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceStatementToken inline;
	  function getInterface: ITraceStatement inline;
		function getStmtID(): Int64; virtual; abstract;
		function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceSQLStatementVTable = ^TraceSQLStatementVTable;
	TraceSQLStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	  getText: ITraceSQLStatement_getTextPtr;
	  getPlan: ITraceSQLStatement_getPlanPtr;
	  getInputs: ITraceSQLStatement_getInputsPtr;
	  getTextUTF8: ITraceSQLStatement_getTextUTF8Ptr;
	  getExplainedPlan: ITraceSQLStatement_getExplainedPlanPtr;
	end;

	ITraceSQLStatementImpl = class;

	ITraceSQLStatement = record
	private
	  token: PTraceSQLStatementToken;
	public
	  const VERSION = 7;

	  function vTable: PTraceSQLStatementVTable inline;
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  function getText(): PAnsiChar;
	  function getPlan(): PAnsiChar;
	  function getInputs(): PTraceParamsToken;
	  function getTextUTF8(): PAnsiChar;
	  function getExplainedPlan(): PAnsiChar;
	  class operator := (aToken:  PTraceSQLStatementToken): ITraceSQLStatement;
	  class operator := (intf: ITraceSQLStatement): PTraceSQLStatementToken;
	  class operator := (impl: ITraceSQLStatementImpl): ITraceSQLStatement;
	  class operator = (a: ITraceSQLStatement; b: pointer): boolean;
class operator = (a,b: ITraceSQLStatement): boolean;
	end;

	ITraceSQLStatementImpl = class(ITraceStatementImpl)
	private
	  class var vTable: TraceSQLStatementVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceSQLStatement;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceSQLStatementToken inline;
	  function getInterface: ITraceSQLStatement inline;
		function getText(): PAnsiChar; virtual; abstract;
		function getPlan(): PAnsiChar; virtual; abstract;
		function getInputs(): PTraceParamsToken; virtual; abstract;
		function getTextUTF8(): PAnsiChar; virtual; abstract;
		function getExplainedPlan(): PAnsiChar; virtual; abstract;
	end;

	PTraceBLRStatementVTable = ^TraceBLRStatementVTable;
	TraceBLRStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	  getData: ITraceBLRStatement_getDataPtr;
	  getDataLength: ITraceBLRStatement_getDataLengthPtr;
	  getText: ITraceBLRStatement_getTextPtr;
	end;

	ITraceBLRStatementImpl = class;

	ITraceBLRStatement = record
	private
	  token: PTraceBLRStatementToken;
	public
	  const VERSION = 5;

	  function vTable: PTraceBLRStatementVTable inline;
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  function getData(): BytePtr;
	  function getDataLength(): Cardinal;
	  function getText(): PAnsiChar;
	  class operator := (aToken:  PTraceBLRStatementToken): ITraceBLRStatement;
	  class operator := (intf: ITraceBLRStatement): PTraceBLRStatementToken;
	  class operator := (impl: ITraceBLRStatementImpl): ITraceBLRStatement;
	  class operator = (a: ITraceBLRStatement; b: pointer): boolean;
class operator = (a,b: ITraceBLRStatement): boolean;
	end;

	ITraceBLRStatementImpl = class(ITraceStatementImpl)
	private
	  class var vTable: TraceBLRStatementVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceBLRStatement;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceBLRStatementToken inline;
	  function getInterface: ITraceBLRStatement inline;
		function getData(): BytePtr; virtual; abstract;
		function getDataLength(): Cardinal; virtual; abstract;
		function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceDYNRequestVTable = ^TraceDYNRequestVTable;
	TraceDYNRequestVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getData: ITraceDYNRequest_getDataPtr;
	  getDataLength: ITraceDYNRequest_getDataLengthPtr;
	  getText: ITraceDYNRequest_getTextPtr;
	end;

	ITraceDYNRequestImpl = class;

	ITraceDYNRequest = record
	private
	  token: PTraceDYNRequestToken;
	public
	  const VERSION = 3;

	  function vTable: PTraceDYNRequestVTable inline;
	  function getData(): BytePtr;
	  function getDataLength(): Cardinal;
	  function getText(): PAnsiChar;
	  class operator := (aToken:  PTraceDYNRequestToken): ITraceDYNRequest;
	  class operator := (intf: ITraceDYNRequest): PTraceDYNRequestToken;
	  class operator := (impl: ITraceDYNRequestImpl): ITraceDYNRequest;
	  class operator = (a: ITraceDYNRequest; b: pointer): boolean;
class operator = (a,b: ITraceDYNRequest): boolean;
	end;

	ITraceDYNRequestImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceDYNRequestVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceDYNRequest;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceDYNRequestToken inline;
	  function getInterface: ITraceDYNRequest inline;
		function getData(): BytePtr; virtual; abstract;
		function getDataLength(): Cardinal; virtual; abstract;
		function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceContextVariableVTable = ^TraceContextVariableVTable;
	TraceContextVariableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getNameSpace: ITraceContextVariable_getNameSpacePtr;
	  getVarName: ITraceContextVariable_getVarNamePtr;
	  getVarValue: ITraceContextVariable_getVarValuePtr;
	end;

	ITraceContextVariableImpl = class;

	ITraceContextVariable = record
	private
	  token: PTraceContextVariableToken;
	public
	  const VERSION = 3;

	  function vTable: PTraceContextVariableVTable inline;
	  function getNameSpace(): PAnsiChar;
	  function getVarName(): PAnsiChar;
	  function getVarValue(): PAnsiChar;
	  class operator := (aToken:  PTraceContextVariableToken): ITraceContextVariable;
	  class operator := (intf: ITraceContextVariable): PTraceContextVariableToken;
	  class operator := (impl: ITraceContextVariableImpl): ITraceContextVariable;
	  class operator = (a: ITraceContextVariable; b: pointer): boolean;
class operator = (a,b: ITraceContextVariable): boolean;
	end;

	ITraceContextVariableImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceContextVariableVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceContextVariable;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceContextVariableToken inline;
	  function getInterface: ITraceContextVariable inline;
		function getNameSpace(): PAnsiChar; virtual; abstract;
		function getVarName(): PAnsiChar; virtual; abstract;
		function getVarValue(): PAnsiChar; virtual; abstract;
	end;

	PTraceProcedureVTable = ^TraceProcedureVTable;
	TraceProcedureVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getProcName: ITraceProcedure_getProcNamePtr;
	  getInputs: ITraceProcedure_getInputsPtr;
	  getPerf: ITraceProcedure_getPerfPtr;
	end;

	ITraceProcedureImpl = class;

	ITraceProcedure = record
	private
	  token: PTraceProcedureToken;
	public
	  const VERSION = 3;

	  function vTable: PTraceProcedureVTable inline;
	  function getProcName(): PAnsiChar;
	  function getInputs(): PTraceParamsToken;
	  function getPerf(): PerformanceInfoPtr;
	  class operator := (aToken:  PTraceProcedureToken): ITraceProcedure;
	  class operator := (intf: ITraceProcedure): PTraceProcedureToken;
	  class operator := (impl: ITraceProcedureImpl): ITraceProcedure;
	  class operator = (a: ITraceProcedure; b: pointer): boolean;
class operator = (a,b: ITraceProcedure): boolean;
	end;

	ITraceProcedureImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceProcedureVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceProcedure;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceProcedureToken inline;
	  function getInterface: ITraceProcedure inline;
		function getProcName(): PAnsiChar; virtual; abstract;
		function getInputs(): PTraceParamsToken; virtual; abstract;
		function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceFunctionVTable = ^TraceFunctionVTable;
	TraceFunctionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getFuncName: ITraceFunction_getFuncNamePtr;
	  getInputs: ITraceFunction_getInputsPtr;
	  getResult: ITraceFunction_getResultPtr;
	  getPerf: ITraceFunction_getPerfPtr;
	end;

	ITraceFunctionImpl = class;

	ITraceFunction = record
	private
	  token: PTraceFunctionToken;
	public
	  const VERSION = 4;

	  function vTable: PTraceFunctionVTable inline;
	  function getFuncName(): PAnsiChar;
	  function getInputs(): PTraceParamsToken;
	  function getResult(): PTraceParamsToken;
	  function getPerf(): PerformanceInfoPtr;
	  class operator := (aToken:  PTraceFunctionToken): ITraceFunction;
	  class operator := (intf: ITraceFunction): PTraceFunctionToken;
	  class operator := (impl: ITraceFunctionImpl): ITraceFunction;
	  class operator = (a: ITraceFunction; b: pointer): boolean;
class operator = (a,b: ITraceFunction): boolean;
	end;

	ITraceFunctionImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceFunctionVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceFunction;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceFunctionToken inline;
	  function getInterface: ITraceFunction inline;
		function getFuncName(): PAnsiChar; virtual; abstract;
		function getInputs(): PTraceParamsToken; virtual; abstract;
		function getResult(): PTraceParamsToken; virtual; abstract;
		function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceTriggerVTable = ^TraceTriggerVTable;
	TraceTriggerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getTriggerName: ITraceTrigger_getTriggerNamePtr;
	  getRelationName: ITraceTrigger_getRelationNamePtr;
	  getAction: ITraceTrigger_getActionPtr;
	  getWhich: ITraceTrigger_getWhichPtr;
	  getPerf: ITraceTrigger_getPerfPtr;
	end;

	ITraceTriggerImpl = class;

	ITraceTrigger = record
	private
	  token: PTraceTriggerToken;
	public
	  const VERSION = 5;
	  const TYPE_ALL = Cardinal(0);
	  const TYPE_BEFORE = Cardinal(1);
	  const TYPE_AFTER = Cardinal(2);

	  function vTable: PTraceTriggerVTable inline;
	  function getTriggerName(): PAnsiChar;
	  function getRelationName(): PAnsiChar;
	  function getAction(): Integer;
	  function getWhich(): Integer;
	  function getPerf(): PerformanceInfoPtr;
	  class operator := (aToken:  PTraceTriggerToken): ITraceTrigger;
	  class operator := (intf: ITraceTrigger): PTraceTriggerToken;
	  class operator := (impl: ITraceTriggerImpl): ITraceTrigger;
	  class operator = (a: ITraceTrigger; b: pointer): boolean;
class operator = (a,b: ITraceTrigger): boolean;
	end;

	ITraceTriggerImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceTriggerVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceTrigger;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceTriggerToken inline;
	  function getInterface: ITraceTrigger inline;
		function getTriggerName(): PAnsiChar; virtual; abstract;
		function getRelationName(): PAnsiChar; virtual; abstract;
		function getAction(): Integer; virtual; abstract;
		function getWhich(): Integer; virtual; abstract;
		function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceServiceConnectionVTable = ^TraceServiceConnectionVTable;
	TraceServiceConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	  getServiceID: ITraceServiceConnection_getServiceIDPtr;
	  getServiceMgr: ITraceServiceConnection_getServiceMgrPtr;
	  getServiceName: ITraceServiceConnection_getServiceNamePtr;
	end;

	ITraceServiceConnectionImpl = class;

	ITraceServiceConnection = record
	private
	  token: PTraceServiceConnectionToken;
	public
	  const VERSION = 12;
	  const KIND_DATABASE = Cardinal(1);
	  const KIND_SERVICE = Cardinal(2);

	  function vTable: PTraceServiceConnectionVTable inline;
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  function getServiceID(): Pointer;
	  function getServiceMgr(): PAnsiChar;
	  function getServiceName(): PAnsiChar;
	  class operator := (aToken:  PTraceServiceConnectionToken): ITraceServiceConnection;
	  class operator := (intf: ITraceServiceConnection): PTraceServiceConnectionToken;
	  class operator := (impl: ITraceServiceConnectionImpl): ITraceServiceConnection;
	  class operator = (a: ITraceServiceConnection; b: pointer): boolean;
class operator = (a,b: ITraceServiceConnection): boolean;
	end;

	ITraceServiceConnectionImpl = class(ITraceConnectionImpl)
	private
	  class var vTable: TraceServiceConnectionVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceServiceConnection;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceServiceConnectionToken inline;
	  function getInterface: ITraceServiceConnection inline;
		function getServiceID(): Pointer; virtual; abstract;
		function getServiceMgr(): PAnsiChar; virtual; abstract;
		function getServiceName(): PAnsiChar; virtual; abstract;
	end;

	PTraceStatusVectorVTable = ^TraceStatusVectorVTable;
	TraceStatusVectorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  hasError: ITraceStatusVector_hasErrorPtr;
	  hasWarning: ITraceStatusVector_hasWarningPtr;
	  getStatus: ITraceStatusVector_getStatusPtr;
	  getText: ITraceStatusVector_getTextPtr;
	end;

	ITraceStatusVectorImpl = class;

	ITraceStatusVector = record
	private
	  token: PTraceStatusVectorToken;
	public
	  const VERSION = 4;

	  function vTable: PTraceStatusVectorVTable inline;
	  function hasError(): Boolean;
	  function hasWarning(): Boolean;
	  function getStatus(): PStatusToken;
	  function getText(): PAnsiChar;
	  class operator := (aToken:  PTraceStatusVectorToken): ITraceStatusVector;
	  class operator := (intf: ITraceStatusVector): PTraceStatusVectorToken;
	  class operator := (impl: ITraceStatusVectorImpl): ITraceStatusVector;
	  class operator = (a: ITraceStatusVector; b: pointer): boolean;
class operator = (a,b: ITraceStatusVector): boolean;
	end;

	ITraceStatusVectorImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceStatusVectorVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceStatusVector;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceStatusVectorToken inline;
	  function getInterface: ITraceStatusVector inline;
		function hasError(): Boolean; virtual; abstract;
		function hasWarning(): Boolean; virtual; abstract;
		function getStatus(): PStatusToken; virtual; abstract;
		function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceSweepInfoVTable = ^TraceSweepInfoVTable;
	TraceSweepInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getOIT: ITraceSweepInfo_getOITPtr;
	  getOST: ITraceSweepInfo_getOSTPtr;
	  getOAT: ITraceSweepInfo_getOATPtr;
	  getNext: ITraceSweepInfo_getNextPtr;
	  getPerf: ITraceSweepInfo_getPerfPtr;
	end;

	ITraceSweepInfoImpl = class;

	ITraceSweepInfo = record
	private
	  token: PTraceSweepInfoToken;
	public
	  const VERSION = 5;

	  function vTable: PTraceSweepInfoVTable inline;
	  function getOIT(): Int64;
	  function getOST(): Int64;
	  function getOAT(): Int64;
	  function getNext(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  class operator := (aToken:  PTraceSweepInfoToken): ITraceSweepInfo;
	  class operator := (intf: ITraceSweepInfo): PTraceSweepInfoToken;
	  class operator := (impl: ITraceSweepInfoImpl): ITraceSweepInfo;
	  class operator = (a: ITraceSweepInfo; b: pointer): boolean;
class operator = (a,b: ITraceSweepInfo): boolean;
	end;

	ITraceSweepInfoImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceSweepInfoVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceSweepInfo;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceSweepInfoToken inline;
	  function getInterface: ITraceSweepInfo inline;
		function getOIT(): Int64; virtual; abstract;
		function getOST(): Int64; virtual; abstract;
		function getOAT(): Int64; virtual; abstract;
		function getNext(): Int64; virtual; abstract;
		function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceLogWriterVTable = ^TraceLogWriterVTable;
	TraceLogWriterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  write: ITraceLogWriter_writePtr;
	  write_s: ITraceLogWriter_write_sPtr;
	end;

	ITraceLogWriterImpl = class;

	ITraceLogWriter = record
	private
	  token: PTraceLogWriterToken;
	public
	  const VERSION = 4;

	  function vTable: PTraceLogWriterVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function write(buf: Pointer; size: Cardinal): Cardinal;
	  function write_s(status: PStatusToken; buf: Pointer; size: Cardinal): Cardinal;
	  class operator := (aToken:  PTraceLogWriterToken): ITraceLogWriter;
	  class operator := (intf: ITraceLogWriter): PTraceLogWriterToken;
	  class operator := (impl: ITraceLogWriterImpl): ITraceLogWriter;
	  class operator = (a: ITraceLogWriter; b: pointer): boolean;
class operator = (a,b: ITraceLogWriter): boolean;
	end;

	ITraceLogWriterImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: TraceLogWriterVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceLogWriter;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceLogWriterToken inline;
	  function getInterface: ITraceLogWriter inline;
		function write(buf: Pointer; size: Cardinal): Cardinal; virtual; abstract;
		function write_s(status: PStatusToken; buf: Pointer; size: Cardinal): Cardinal; virtual; abstract;
	end;

	PTraceInitInfoVTable = ^TraceInitInfoVTable;
	TraceInitInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getConfigText: ITraceInitInfo_getConfigTextPtr;
	  getTraceSessionID: ITraceInitInfo_getTraceSessionIDPtr;
	  getTraceSessionName: ITraceInitInfo_getTraceSessionNamePtr;
	  getFirebirdRootDirectory: ITraceInitInfo_getFirebirdRootDirectoryPtr;
	  getDatabaseName: ITraceInitInfo_getDatabaseNamePtr;
	  getConnection: ITraceInitInfo_getConnectionPtr;
	  getLogWriter: ITraceInitInfo_getLogWriterPtr;
	end;

	ITraceInitInfoImpl = class;

	ITraceInitInfo = record
	private
	  token: PTraceInitInfoToken;
	public
	  const VERSION = 7;

	  function vTable: PTraceInitInfoVTable inline;
	  function getConfigText(): PAnsiChar;
	  function getTraceSessionID(): Integer;
	  function getTraceSessionName(): PAnsiChar;
	  function getFirebirdRootDirectory(): PAnsiChar;
	  function getDatabaseName(): PAnsiChar;
	  function getConnection(): PTraceDatabaseConnectionToken;
	  function getLogWriter(): PTraceLogWriterToken;
	  class operator := (aToken:  PTraceInitInfoToken): ITraceInitInfo;
	  class operator := (intf: ITraceInitInfo): PTraceInitInfoToken;
	  class operator := (impl: ITraceInitInfoImpl): ITraceInitInfo;
	  class operator = (a: ITraceInitInfo; b: pointer): boolean;
class operator = (a,b: ITraceInitInfo): boolean;
	end;

	ITraceInitInfoImpl = class(IVersionedImpl)
	private
	  class var vTable: TraceInitInfoVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceInitInfo;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceInitInfoToken inline;
	  function getInterface: ITraceInitInfo inline;
		function getConfigText(): PAnsiChar; virtual; abstract;
		function getTraceSessionID(): Integer; virtual; abstract;
		function getTraceSessionName(): PAnsiChar; virtual; abstract;
		function getFirebirdRootDirectory(): PAnsiChar; virtual; abstract;
		function getDatabaseName(): PAnsiChar; virtual; abstract;
		function getConnection(): PTraceDatabaseConnectionToken; virtual; abstract;
		function getLogWriter(): PTraceLogWriterToken; virtual; abstract;
	end;

	PTracePluginVTable = ^TracePluginVTable;
	TracePluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  trace_get_error: ITracePlugin_trace_get_errorPtr;
	  trace_attach: ITracePlugin_trace_attachPtr;
	  trace_detach: ITracePlugin_trace_detachPtr;
	  trace_transaction_start: ITracePlugin_trace_transaction_startPtr;
	  trace_transaction_end: ITracePlugin_trace_transaction_endPtr;
	  trace_proc_execute: ITracePlugin_trace_proc_executePtr;
	  trace_trigger_execute: ITracePlugin_trace_trigger_executePtr;
	  trace_set_context: ITracePlugin_trace_set_contextPtr;
	  trace_dsql_prepare: ITracePlugin_trace_dsql_preparePtr;
	  trace_dsql_free: ITracePlugin_trace_dsql_freePtr;
	  trace_dsql_execute: ITracePlugin_trace_dsql_executePtr;
	  trace_blr_compile: ITracePlugin_trace_blr_compilePtr;
	  trace_blr_execute: ITracePlugin_trace_blr_executePtr;
	  trace_dyn_execute: ITracePlugin_trace_dyn_executePtr;
	  trace_service_attach: ITracePlugin_trace_service_attachPtr;
	  trace_service_start: ITracePlugin_trace_service_startPtr;
	  trace_service_query: ITracePlugin_trace_service_queryPtr;
	  trace_service_detach: ITracePlugin_trace_service_detachPtr;
	  trace_event_error: ITracePlugin_trace_event_errorPtr;
	  trace_event_sweep: ITracePlugin_trace_event_sweepPtr;
	  trace_func_execute: ITracePlugin_trace_func_executePtr;
	end;

	ITracePluginImpl = class;

	ITracePlugin = record
	private
	  token: PTracePluginToken;
	public
	  const VERSION = 23;
	  const RESULT_SUCCESS = Cardinal(0);
	  const RESULT_FAILED = Cardinal(1);
	  const RESULT_UNAUTHORIZED = Cardinal(2);
	  const SWEEP_STATE_STARTED = Cardinal(1);
	  const SWEEP_STATE_FINISHED = Cardinal(2);
	  const SWEEP_STATE_FAILED = Cardinal(3);
	  const SWEEP_STATE_PROGRESS = Cardinal(4);

	  function vTable: PTracePluginVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  function trace_get_error(): PAnsiChar;
	  function trace_attach(connection: PTraceDatabaseConnectionToken; create_db: Boolean; att_result: Cardinal): Boolean;
	  function trace_detach(connection: PTraceDatabaseConnectionToken; drop_db: Boolean): Boolean;
	  function trace_transaction_start(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean;
	  function trace_transaction_end(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean;
	  function trace_proc_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; procedure_: PTraceProcedureToken; started: Boolean; proc_result: Cardinal): Boolean;
	  function trace_trigger_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; trigger: PTraceTriggerToken; started: Boolean; trig_result: Cardinal): Boolean;
	  function trace_set_context(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; variable: PTraceContextVariableToken): Boolean;
	  function trace_dsql_prepare(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_dsql_free(connection: PTraceDatabaseConnectionToken; statement: PTraceSQLStatementToken; option: Cardinal): Boolean;
	  function trace_dsql_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; started: Boolean; req_result: Cardinal): Boolean;
	  function trace_blr_compile(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_blr_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; req_result: Cardinal): Boolean;
	  function trace_dyn_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; request: PTraceDYNRequestToken; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_service_attach(service: PTraceServiceConnectionToken; att_result: Cardinal): Boolean;
	  function trace_service_start(service: PTraceServiceConnectionToken; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean;
	  function trace_service_query(service: PTraceServiceConnectionToken; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean;
	  function trace_service_detach(service: PTraceServiceConnectionToken; detach_result: Cardinal): Boolean;
	  function trace_event_error(connection: PTraceConnectionToken; status: PTraceStatusVectorToken; function_: PAnsiChar): Boolean;
	  function trace_event_sweep(connection: PTraceDatabaseConnectionToken; sweep: PTraceSweepInfoToken; sweep_state: Cardinal): Boolean;
	  function trace_func_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; function_: PTraceFunctionToken; started: Boolean; func_result: Cardinal): Boolean;
	  class operator := (aToken:  PTracePluginToken): ITracePlugin;
	  class operator := (intf: ITracePlugin): PTracePluginToken;
	  class operator := (impl: ITracePluginImpl): ITracePlugin;
	  class operator = (a: ITracePlugin; b: pointer): boolean;
class operator = (a,b: ITracePlugin): boolean;
	end;

	ITracePluginImpl = class(IReferenceCountedImpl)
	private
	  class var vTable: TracePluginVTable; 
	  class var FInitialized: boolean;
	  intf: ITracePlugin;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTracePluginToken inline;
	  function getInterface: ITracePlugin inline;
		function trace_get_error(): PAnsiChar; virtual; abstract;
		function trace_attach(connection: PTraceDatabaseConnectionToken; create_db: Boolean; att_result: Cardinal): Boolean; virtual; abstract;
		function trace_detach(connection: PTraceDatabaseConnectionToken; drop_db: Boolean): Boolean; virtual; abstract;
		function trace_transaction_start(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; virtual; abstract;
		function trace_transaction_end(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; virtual; abstract;
		function trace_proc_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; procedure_: PTraceProcedureToken; started: Boolean; proc_result: Cardinal): Boolean; virtual; abstract;
		function trace_trigger_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; trigger: PTraceTriggerToken; started: Boolean; trig_result: Cardinal): Boolean; virtual; abstract;
		function trace_set_context(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; variable: PTraceContextVariableToken): Boolean; virtual; abstract;
		function trace_dsql_prepare(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
		function trace_dsql_free(connection: PTraceDatabaseConnectionToken; statement: PTraceSQLStatementToken; option: Cardinal): Boolean; virtual; abstract;
		function trace_dsql_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; started: Boolean; req_result: Cardinal): Boolean; virtual; abstract;
		function trace_blr_compile(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
		function trace_blr_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; req_result: Cardinal): Boolean; virtual; abstract;
		function trace_dyn_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; request: PTraceDYNRequestToken; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
		function trace_service_attach(service: PTraceServiceConnectionToken; att_result: Cardinal): Boolean; virtual; abstract;
		function trace_service_start(service: PTraceServiceConnectionToken; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; virtual; abstract;
		function trace_service_query(service: PTraceServiceConnectionToken; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; virtual; abstract;
		function trace_service_detach(service: PTraceServiceConnectionToken; detach_result: Cardinal): Boolean; virtual; abstract;
		function trace_event_error(connection: PTraceConnectionToken; status: PTraceStatusVectorToken; function_: PAnsiChar): Boolean; virtual; abstract;
		function trace_event_sweep(connection: PTraceDatabaseConnectionToken; sweep: PTraceSweepInfoToken; sweep_state: Cardinal): Boolean; virtual; abstract;
		function trace_func_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; function_: PTraceFunctionToken; started: Boolean; func_result: Cardinal): Boolean; virtual; abstract;
	end;

	PTraceFactoryVTable = ^TraceFactoryVTable;
	TraceFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  trace_needs: ITraceFactory_trace_needsPtr;
	  trace_create: ITraceFactory_trace_createPtr;
	end;

	ITraceFactoryImpl = class;

	ITraceFactory = record
	private
	  token: PTraceFactoryToken;
	public
	  const VERSION = 6;
	  const TRACE_EVENT_ATTACH = Cardinal(0);
	  const TRACE_EVENT_DETACH = Cardinal(1);
	  const TRACE_EVENT_TRANSACTION_START = Cardinal(2);
	  const TRACE_EVENT_TRANSACTION_END = Cardinal(3);
	  const TRACE_EVENT_SET_CONTEXT = Cardinal(4);
	  const TRACE_EVENT_PROC_EXECUTE = Cardinal(5);
	  const TRACE_EVENT_TRIGGER_EXECUTE = Cardinal(6);
	  const TRACE_EVENT_DSQL_PREPARE = Cardinal(7);
	  const TRACE_EVENT_DSQL_FREE = Cardinal(8);
	  const TRACE_EVENT_DSQL_EXECUTE = Cardinal(9);
	  const TRACE_EVENT_BLR_COMPILE = Cardinal(10);
	  const TRACE_EVENT_BLR_EXECUTE = Cardinal(11);
	  const TRACE_EVENT_DYN_EXECUTE = Cardinal(12);
	  const TRACE_EVENT_SERVICE_ATTACH = Cardinal(13);
	  const TRACE_EVENT_SERVICE_START = Cardinal(14);
	  const TRACE_EVENT_SERVICE_QUERY = Cardinal(15);
	  const TRACE_EVENT_SERVICE_DETACH = Cardinal(16);
	  const TRACE_EVENT_ERROR = Cardinal(17);
	  const TRACE_EVENT_SWEEP = Cardinal(18);
	  const TRACE_EVENT_FUNC_EXECUTE = Cardinal(19);
	  const TRACE_EVENT_MAX = Cardinal(20);

	  function vTable: PTraceFactoryVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function trace_needs(): QWord;
	  function trace_create(status: PStatusToken; init_info: PTraceInitInfoToken): PTracePluginToken;
	  class operator := (aToken:  PTraceFactoryToken): ITraceFactory;
	  class operator := (intf: ITraceFactory): PTraceFactoryToken;
	  class operator := (impl: ITraceFactoryImpl): ITraceFactory;
	  class operator = (a: ITraceFactory; b: pointer): boolean;
class operator = (a,b: ITraceFactory): boolean;
	end;

	ITraceFactoryImpl = class(IPluginBaseImpl)
	private
	  class var vTable: TraceFactoryVTable; 
	  class var FInitialized: boolean;
	  intf: ITraceFactory;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PTraceFactoryToken inline;
	  function getInterface: ITraceFactory inline;
		function trace_needs(): QWord; virtual; abstract;
		function trace_create(status: PStatusToken; init_info: PTraceInitInfoToken): PTracePluginToken; virtual; abstract;
	end;

	PUdrFunctionFactoryVTable = ^UdrFunctionFactoryVTable;
	UdrFunctionFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrFunctionFactory_setupPtr;
	  newItem: IUdrFunctionFactory_newItemPtr;
	end;

	IUdrFunctionFactoryImpl = class;

	IUdrFunctionFactory = record
	private
	  token: PUdrFunctionFactoryToken;
	public
	  const VERSION = 3;

	  function vTable: PUdrFunctionFactoryVTable inline;
	  procedure dispose();
	  procedure setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken);
	  function newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalFunctionToken;
	  class operator := (aToken:  PUdrFunctionFactoryToken): IUdrFunctionFactory;
	  class operator := (intf: IUdrFunctionFactory): PUdrFunctionFactoryToken;
	  class operator := (impl: IUdrFunctionFactoryImpl): IUdrFunctionFactory;
	  class operator = (a: IUdrFunctionFactory; b: pointer): boolean;
class operator = (a,b: IUdrFunctionFactory): boolean;
	end;

	IUdrFunctionFactoryImpl = class(IDisposableImpl)
	private
	  class var vTable: UdrFunctionFactoryVTable; 
	  class var FInitialized: boolean;
	  intf: IUdrFunctionFactory;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUdrFunctionFactoryToken inline;
	  function getInterface: IUdrFunctionFactory inline;
		procedure setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken); virtual; abstract;
		function newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalFunctionToken; virtual; abstract;
	end;

	PUdrProcedureFactoryVTable = ^UdrProcedureFactoryVTable;
	UdrProcedureFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrProcedureFactory_setupPtr;
	  newItem: IUdrProcedureFactory_newItemPtr;
	end;

	IUdrProcedureFactoryImpl = class;

	IUdrProcedureFactory = record
	private
	  token: PUdrProcedureFactoryToken;
	public
	  const VERSION = 3;

	  function vTable: PUdrProcedureFactoryVTable inline;
	  procedure dispose();
	  procedure setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken);
	  function newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalProcedureToken;
	  class operator := (aToken:  PUdrProcedureFactoryToken): IUdrProcedureFactory;
	  class operator := (intf: IUdrProcedureFactory): PUdrProcedureFactoryToken;
	  class operator := (impl: IUdrProcedureFactoryImpl): IUdrProcedureFactory;
	  class operator = (a: IUdrProcedureFactory; b: pointer): boolean;
class operator = (a,b: IUdrProcedureFactory): boolean;
	end;

	IUdrProcedureFactoryImpl = class(IDisposableImpl)
	private
	  class var vTable: UdrProcedureFactoryVTable; 
	  class var FInitialized: boolean;
	  intf: IUdrProcedureFactory;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUdrProcedureFactoryToken inline;
	  function getInterface: IUdrProcedureFactory inline;
		procedure setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken); virtual; abstract;
		function newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalProcedureToken; virtual; abstract;
	end;

	PUdrTriggerFactoryVTable = ^UdrTriggerFactoryVTable;
	UdrTriggerFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrTriggerFactory_setupPtr;
	  newItem: IUdrTriggerFactory_newItemPtr;
	end;

	IUdrTriggerFactoryImpl = class;

	IUdrTriggerFactory = record
	private
	  token: PUdrTriggerFactoryToken;
	public
	  const VERSION = 3;

	  function vTable: PUdrTriggerFactoryVTable inline;
	  procedure dispose();
	  procedure setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken);
	  function newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalTriggerToken;
	  class operator := (aToken:  PUdrTriggerFactoryToken): IUdrTriggerFactory;
	  class operator := (intf: IUdrTriggerFactory): PUdrTriggerFactoryToken;
	  class operator := (impl: IUdrTriggerFactoryImpl): IUdrTriggerFactory;
	  class operator = (a: IUdrTriggerFactory; b: pointer): boolean;
class operator = (a,b: IUdrTriggerFactory): boolean;
	end;

	IUdrTriggerFactoryImpl = class(IDisposableImpl)
	private
	  class var vTable: UdrTriggerFactoryVTable; 
	  class var FInitialized: boolean;
	  intf: IUdrTriggerFactory;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUdrTriggerFactoryToken inline;
	  function getInterface: IUdrTriggerFactory inline;
		procedure setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken); virtual; abstract;
		function newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalTriggerToken; virtual; abstract;
	end;

	PUdrPluginVTable = ^UdrPluginVTable;
	UdrPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getMaster: IUdrPlugin_getMasterPtr;
	  registerFunction: IUdrPlugin_registerFunctionPtr;
	  registerProcedure: IUdrPlugin_registerProcedurePtr;
	  registerTrigger: IUdrPlugin_registerTriggerPtr;
	end;

	IUdrPluginImpl = class;

	IUdrPlugin = record
	private
	  token: PUdrPluginToken;
	public
	  const VERSION = 4;

	  function vTable: PUdrPluginVTable inline;
	  function getMaster(): PMasterToken;
	  procedure registerFunction(status: PStatusToken; name: PAnsiChar; factory: PUdrFunctionFactoryToken);
	  procedure registerProcedure(status: PStatusToken; name: PAnsiChar; factory: PUdrProcedureFactoryToken);
	  procedure registerTrigger(status: PStatusToken; name: PAnsiChar; factory: PUdrTriggerFactoryToken);
	  class operator := (aToken:  PUdrPluginToken): IUdrPlugin;
	  class operator := (intf: IUdrPlugin): PUdrPluginToken;
	  class operator := (impl: IUdrPluginImpl): IUdrPlugin;
	  class operator = (a: IUdrPlugin; b: pointer): boolean;
class operator = (a,b: IUdrPlugin): boolean;
	end;

	IUdrPluginImpl = class(IVersionedImpl)
	private
	  class var vTable: UdrPluginVTable; 
	  class var FInitialized: boolean;
	  intf: IUdrPlugin;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PUdrPluginToken inline;
	  function getInterface: IUdrPlugin inline;
		function getMaster(): PMasterToken; virtual; abstract;
		procedure registerFunction(status: PStatusToken; name: PAnsiChar; factory: PUdrFunctionFactoryToken); virtual; abstract;
		procedure registerProcedure(status: PStatusToken; name: PAnsiChar; factory: PUdrProcedureFactoryToken); virtual; abstract;
		procedure registerTrigger(status: PStatusToken; name: PAnsiChar; factory: PUdrTriggerFactoryToken); virtual; abstract;
	end;

	PDecFloat16VTable = ^DecFloat16VTable;
	DecFloat16VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toBcd: IDecFloat16_toBcdPtr;
	  toString: IDecFloat16_toStringPtr;
	  fromBcd: IDecFloat16_fromBcdPtr;
	  fromString: IDecFloat16_fromStringPtr;
	end;

	IDecFloat16Impl = class;

	IDecFloat16 = record
	private
	  token: PDecFloat16Token;
	public
	  const VERSION = 4;
	  const BCD_SIZE = Cardinal(16);
	  const STRING_SIZE = Cardinal(24);

	  function vTable: PDecFloat16VTable inline;
	  procedure toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
	  procedure toString(status: PStatusToken; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr);
	  procedure fromString(status: PStatusToken; from: PAnsiChar; to_: FB_DEC16Ptr);
	  class operator := (aToken:  PDecFloat16Token): IDecFloat16;
	  class operator := (intf: IDecFloat16): PDecFloat16Token;
	  class operator := (impl: IDecFloat16Impl): IDecFloat16;
	  class operator = (a: IDecFloat16; b: pointer): boolean;
class operator = (a,b: IDecFloat16): boolean;
	end;

	IDecFloat16Impl = class(IVersionedImpl)
	private
	  class var vTable: DecFloat16VTable; 
	  class var FInitialized: boolean;
	  intf: IDecFloat16;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDecFloat16Token inline;
	  function getInterface: IDecFloat16 inline;
		procedure toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); virtual; abstract;
		procedure toString(status: PStatusToken; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
		procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); virtual; abstract;
		procedure fromString(status: PStatusToken; from: PAnsiChar; to_: FB_DEC16Ptr); virtual; abstract;
	end;

	PDecFloat34VTable = ^DecFloat34VTable;
	DecFloat34VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toBcd: IDecFloat34_toBcdPtr;
	  toString: IDecFloat34_toStringPtr;
	  fromBcd: IDecFloat34_fromBcdPtr;
	  fromString: IDecFloat34_fromStringPtr;
	end;

	IDecFloat34Impl = class;

	IDecFloat34 = record
	private
	  token: PDecFloat34Token;
	public
	  const VERSION = 4;
	  const BCD_SIZE = Cardinal(34);
	  const STRING_SIZE = Cardinal(43);

	  function vTable: PDecFloat34VTable inline;
	  procedure toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
	  procedure toString(status: PStatusToken; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr);
	  procedure fromString(status: PStatusToken; from: PAnsiChar; to_: FB_DEC34Ptr);
	  class operator := (aToken:  PDecFloat34Token): IDecFloat34;
	  class operator := (intf: IDecFloat34): PDecFloat34Token;
	  class operator := (impl: IDecFloat34Impl): IDecFloat34;
	  class operator = (a: IDecFloat34; b: pointer): boolean;
class operator = (a,b: IDecFloat34): boolean;
	end;

	IDecFloat34Impl = class(IVersionedImpl)
	private
	  class var vTable: DecFloat34VTable; 
	  class var FInitialized: boolean;
	  intf: IDecFloat34;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PDecFloat34Token inline;
	  function getInterface: IDecFloat34 inline;
		procedure toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); virtual; abstract;
		procedure toString(status: PStatusToken; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
		procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); virtual; abstract;
		procedure fromString(status: PStatusToken; from: PAnsiChar; to_: FB_DEC34Ptr); virtual; abstract;
	end;

	PInt128VTable = ^Int128VTable;
	Int128VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toString: IInt128_toStringPtr;
	  fromString: IInt128_fromStringPtr;
	end;

	IInt128Impl = class;

	IInt128 = record
	private
	  token: PInt128Token;
	public
	  const VERSION = 2;
	  const STRING_SIZE = Cardinal(46);

	  function vTable: PInt128VTable inline;
	  procedure toString(status: PStatusToken; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromString(status: PStatusToken; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr);
	  class operator := (aToken:  PInt128Token): IInt128;
	  class operator := (intf: IInt128): PInt128Token;
	  class operator := (impl: IInt128Impl): IInt128;
	  class operator = (a: IInt128; b: pointer): boolean;
class operator = (a,b: IInt128): boolean;
	end;

	IInt128Impl = class(IVersionedImpl)
	private
	  class var vTable: Int128VTable; 
	  class var FInitialized: boolean;
	  intf: IInt128;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PInt128Token inline;
	  function getInterface: IInt128 inline;
		procedure toString(status: PStatusToken; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
		procedure fromString(status: PStatusToken; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); virtual; abstract;
	end;

	PReplicatedFieldVTable = ^ReplicatedFieldVTable;
	ReplicatedFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getName: IReplicatedField_getNamePtr;
	  getType: IReplicatedField_getTypePtr;
	  getSubType: IReplicatedField_getSubTypePtr;
	  getScale: IReplicatedField_getScalePtr;
	  getLength: IReplicatedField_getLengthPtr;
	  getCharSet: IReplicatedField_getCharSetPtr;
	  getData: IReplicatedField_getDataPtr;
	end;

	IReplicatedFieldImpl = class;

	IReplicatedField = record
	private
	  token: PReplicatedFieldToken;
	public
	  const VERSION = 7;

	  function vTable: PReplicatedFieldVTable inline;
	  function getName(): PAnsiChar;
	  function getType(): Cardinal;
	  function getSubType(): Integer;
	  function getScale(): Integer;
	  function getLength(): Cardinal;
	  function getCharSet(): Cardinal;
	  function getData(): Pointer;
	  class operator := (aToken:  PReplicatedFieldToken): IReplicatedField;
	  class operator := (intf: IReplicatedField): PReplicatedFieldToken;
	  class operator := (impl: IReplicatedFieldImpl): IReplicatedField;
	  class operator = (a: IReplicatedField; b: pointer): boolean;
class operator = (a,b: IReplicatedField): boolean;
	end;

	IReplicatedFieldImpl = class(IVersionedImpl)
	private
	  class var vTable: ReplicatedFieldVTable; 
	  class var FInitialized: boolean;
	  intf: IReplicatedField;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PReplicatedFieldToken inline;
	  function getInterface: IReplicatedField inline;
		function getName(): PAnsiChar; virtual; abstract;
		function getType(): Cardinal; virtual; abstract;
		function getSubType(): Integer; virtual; abstract;
		function getScale(): Integer; virtual; abstract;
		function getLength(): Cardinal; virtual; abstract;
		function getCharSet(): Cardinal; virtual; abstract;
		function getData(): Pointer; virtual; abstract;
	end;

	PReplicatedRecordVTable = ^ReplicatedRecordVTable;
	ReplicatedRecordVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getCount: IReplicatedRecord_getCountPtr;
	  getField: IReplicatedRecord_getFieldPtr;
	  getRawLength: IReplicatedRecord_getRawLengthPtr;
	  getRawData: IReplicatedRecord_getRawDataPtr;
	end;

	IReplicatedRecordImpl = class;

	IReplicatedRecord = record
	private
	  token: PReplicatedRecordToken;
	public
	  const VERSION = 4;

	  function vTable: PReplicatedRecordVTable inline;
	  function getCount(): Cardinal;
	  function getField(index: Cardinal): PReplicatedFieldToken;
	  function getRawLength(): Cardinal;
	  function getRawData(): BytePtr;
	  class operator := (aToken:  PReplicatedRecordToken): IReplicatedRecord;
	  class operator := (intf: IReplicatedRecord): PReplicatedRecordToken;
	  class operator := (impl: IReplicatedRecordImpl): IReplicatedRecord;
	  class operator = (a: IReplicatedRecord; b: pointer): boolean;
class operator = (a,b: IReplicatedRecord): boolean;
	end;

	IReplicatedRecordImpl = class(IVersionedImpl)
	private
	  class var vTable: ReplicatedRecordVTable; 
	  class var FInitialized: boolean;
	  intf: IReplicatedRecord;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PReplicatedRecordToken inline;
	  function getInterface: IReplicatedRecord inline;
		function getCount(): Cardinal; virtual; abstract;
		function getField(index: Cardinal): PReplicatedFieldToken; virtual; abstract;
		function getRawLength(): Cardinal; virtual; abstract;
		function getRawData(): BytePtr; virtual; abstract;
	end;

	PReplicatedTransactionVTable = ^ReplicatedTransactionVTable;
	ReplicatedTransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  prepare: IReplicatedTransaction_preparePtr;
	  commit: IReplicatedTransaction_commitPtr;
	  rollback: IReplicatedTransaction_rollbackPtr;
	  startSavepoint: IReplicatedTransaction_startSavepointPtr;
	  releaseSavepoint: IReplicatedTransaction_releaseSavepointPtr;
	  rollbackSavepoint: IReplicatedTransaction_rollbackSavepointPtr;
	  insertRecord: IReplicatedTransaction_insertRecordPtr;
	  updateRecord: IReplicatedTransaction_updateRecordPtr;
	  deleteRecord: IReplicatedTransaction_deleteRecordPtr;
	  executeSql: IReplicatedTransaction_executeSqlPtr;
	  executeSqlIntl: IReplicatedTransaction_executeSqlIntlPtr;
	end;

	IReplicatedTransactionImpl = class;

	IReplicatedTransaction = record
	private
	  token: PReplicatedTransactionToken;
	public
	  const VERSION = 12;

	  function vTable: PReplicatedTransactionVTable inline;
	  procedure dispose();
	  procedure prepare(status: PStatusToken);
	  procedure commit(status: PStatusToken);
	  procedure rollback(status: PStatusToken);
	  procedure startSavepoint(status: PStatusToken);
	  procedure releaseSavepoint(status: PStatusToken);
	  procedure rollbackSavepoint(status: PStatusToken);
	  procedure insertRecord(status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken);
	  procedure updateRecord(status: PStatusToken; name: PAnsiChar; orgRecord: PReplicatedRecordToken; newRecord: PReplicatedRecordToken);
	  procedure deleteRecord(status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken);
	  procedure executeSql(status: PStatusToken; sql: PAnsiChar);
	  procedure executeSqlIntl(status: PStatusToken; charset: Cardinal; sql: PAnsiChar);
	  class operator := (aToken:  PReplicatedTransactionToken): IReplicatedTransaction;
	  class operator := (intf: IReplicatedTransaction): PReplicatedTransactionToken;
	  class operator := (impl: IReplicatedTransactionImpl): IReplicatedTransaction;
	  class operator = (a: IReplicatedTransaction; b: pointer): boolean;
class operator = (a,b: IReplicatedTransaction): boolean;
	end;

	IReplicatedTransactionImpl = class(IDisposableImpl)
	private
	  class var vTable: ReplicatedTransactionVTable; 
	  class var FInitialized: boolean;
	  intf: IReplicatedTransaction;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PReplicatedTransactionToken inline;
	  function getInterface: IReplicatedTransaction inline;
		procedure prepare(status: PStatusToken); virtual; abstract;
		procedure commit(status: PStatusToken); virtual; abstract;
		procedure rollback(status: PStatusToken); virtual; abstract;
		procedure startSavepoint(status: PStatusToken); virtual; abstract;
		procedure releaseSavepoint(status: PStatusToken); virtual; abstract;
		procedure rollbackSavepoint(status: PStatusToken); virtual; abstract;
		procedure insertRecord(status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken); virtual; abstract;
		procedure updateRecord(status: PStatusToken; name: PAnsiChar; orgRecord: PReplicatedRecordToken; newRecord: PReplicatedRecordToken); virtual; abstract;
		procedure deleteRecord(status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken); virtual; abstract;
		procedure executeSql(status: PStatusToken; sql: PAnsiChar); virtual; abstract;
		procedure executeSqlIntl(status: PStatusToken; charset: Cardinal; sql: PAnsiChar); virtual; abstract;
	end;

	PReplicatedSessionVTable = ^ReplicatedSessionVTable;
	ReplicatedSessionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  init: IReplicatedSession_initPtr;
	  startTransaction: IReplicatedSession_startTransactionPtr;
	  cleanupTransaction: IReplicatedSession_cleanupTransactionPtr;
	  setSequence: IReplicatedSession_setSequencePtr;
	end;

	IReplicatedSessionImpl = class;

	IReplicatedSession = record
	private
	  token: PReplicatedSessionToken;
	public
	  const VERSION = 8;

	  function vTable: PReplicatedSessionVTable inline;
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: PReferenceCountedToken);
	  function getOwner(): PReferenceCountedToken;
	  function init(status: PStatusToken; attachment: PAttachmentToken): Boolean;
	  function startTransaction(status: PStatusToken; transaction: PTransactionToken; number: Int64): PReplicatedTransactionToken;
	  procedure cleanupTransaction(status: PStatusToken; number: Int64);
	  procedure setSequence(status: PStatusToken; name: PAnsiChar; value: Int64);
	  class operator := (aToken:  PReplicatedSessionToken): IReplicatedSession;
	  class operator := (intf: IReplicatedSession): PReplicatedSessionToken;
	  class operator := (impl: IReplicatedSessionImpl): IReplicatedSession;
	  class operator = (a: IReplicatedSession; b: pointer): boolean;
class operator = (a,b: IReplicatedSession): boolean;
	end;

	IReplicatedSessionImpl = class(IPluginBaseImpl)
	private
	  class var vTable: ReplicatedSessionVTable; 
	  class var FInitialized: boolean;
	  intf: IReplicatedSession;
	  class procedure Initialize;
	public
	  constructor create;
	  function getInterfaceToken: PReplicatedSessionToken inline;
	  function getInterface: IReplicatedSession inline;
		function init(status: PStatusToken; attachment: PAttachmentToken): Boolean; virtual; abstract;
		function startTransaction(status: PStatusToken; transaction: PTransactionToken; number: Int64): PReplicatedTransactionToken; virtual; abstract;
		procedure cleanupTransaction(status: PStatusToken; number: Int64); virtual; abstract;
		procedure setSequence(status: PStatusToken; name: PAnsiChar; value: Int64); virtual; abstract;
	end;

	FbException = class(Exception)
	public
		constructor create(status: IStatus); virtual;
		destructor Destroy(); override;

		function getStatus: IStatus;

		class procedure checkException(status: IStatus);
		class procedure catchException(status: IStatus; e: Exception);

	private
		status: IStatus;
	end;


implementation

function IVersioned.vtable: PVersionedVTable;
begin
  Result := PVersionedVTable(token^.vTable);
end;

class operator IVersioned.:= (aToken:  PVersionedToken): IVersioned;
begin
  Result.token := aToken;
end;

class operator IVersioned.:= (intf: IVersioned): PVersionedToken;
begin
  Result := intf.token;
end;

class operator IVersioned.:= (impl: IVersionedImpl): IVersioned;
begin
  Result := impl.intf;
end;

class operator IVersioned.= (a: IVersioned; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IVersioned.= (a,b: IVersioned): boolean;
begin
  Result := a.token = b.token;
end;

function IReferenceCounted.vtable: PReferenceCountedVTable;
begin
  Result := PReferenceCountedVTable(token^.vTable);
end;

class operator IReferenceCounted.:= (aToken:  PReferenceCountedToken): IReferenceCounted;
begin
  Result.token := aToken;
end;

class operator IReferenceCounted.:= (intf: IReferenceCounted): PReferenceCountedToken;
begin
  Result := intf.token;
end;

class operator IReferenceCounted.:= (impl: IReferenceCountedImpl): IReferenceCounted;
begin
  Result := impl.intf;
end;

class operator IReferenceCounted.= (a: IReferenceCounted; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IReferenceCounted.= (a,b: IReferenceCounted): boolean;
begin
  Result := a.token = b.token;
end;

procedure IReferenceCounted.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IReferenceCounted.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IDisposable.vtable: PDisposableVTable;
begin
  Result := PDisposableVTable(token^.vTable);
end;

class operator IDisposable.:= (aToken:  PDisposableToken): IDisposable;
begin
  Result.token := aToken;
end;

class operator IDisposable.:= (intf: IDisposable): PDisposableToken;
begin
  Result := intf.token;
end;

class operator IDisposable.:= (impl: IDisposableImpl): IDisposable;
begin
  Result := impl.intf;
end;

class operator IDisposable.= (a: IDisposable; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDisposable.= (a,b: IDisposable): boolean;
begin
  Result := a.token = b.token;
end;

procedure IDisposable.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

function IStatus.vtable: PStatusVTable;
begin
  Result := PStatusVTable(token^.vTable);
end;

class operator IStatus.:= (aToken:  PStatusToken): IStatus;
begin
  Result.token := aToken;
end;

class operator IStatus.:= (intf: IStatus): PStatusToken;
begin
  Result := intf.token;
end;

class operator IStatus.:= (impl: IStatusImpl): IStatus;
begin
  Result := impl.intf;
end;

class operator IStatus.= (a: IStatus; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IStatus.= (a,b: IStatus): boolean;
begin
  Result := a.token = b.token;
end;

procedure IStatus.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IStatus.init();
begin
	vTable^.init(PStatusToken(token));
end;

function IStatus.getState(): Cardinal;
begin
	Result := vTable^.getState(PStatusToken(token));
end;

procedure IStatus.setErrors2(length: Cardinal; value: NativeIntPtr);
begin
	vTable^.setErrors2(PStatusToken(token), length, value);
end;

procedure IStatus.setWarnings2(length: Cardinal; value: NativeIntPtr);
begin
	vTable^.setWarnings2(PStatusToken(token), length, value);
end;

procedure IStatus.setErrors(value: NativeIntPtr);
begin
	vTable^.setErrors(PStatusToken(token), value);
end;

procedure IStatus.setWarnings(value: NativeIntPtr);
begin
	vTable^.setWarnings(PStatusToken(token), value);
end;

function IStatus.getErrors(): NativeIntPtr;
begin
	Result := vTable^.getErrors(PStatusToken(token));
end;

function IStatus.getWarnings(): NativeIntPtr;
begin
	Result := vTable^.getWarnings(PStatusToken(token));
end;

function IStatus.clone(): PStatusToken;
begin
	Result := vTable^.clone(PStatusToken(token));
end;

function IMaster.vtable: PMasterVTable;
begin
  Result := PMasterVTable(token^.vTable);
end;

class operator IMaster.:= (aToken:  PMasterToken): IMaster;
begin
  Result.token := aToken;
end;

class operator IMaster.:= (intf: IMaster): PMasterToken;
begin
  Result := intf.token;
end;

class operator IMaster.:= (impl: IMasterImpl): IMaster;
begin
  Result := impl.intf;
end;

class operator IMaster.= (a: IMaster; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IMaster.= (a,b: IMaster): boolean;
begin
  Result := a.token = b.token;
end;

function IMaster.getStatus(): PStatusToken;
begin
	Result := vTable^.getStatus(PMasterToken(token));
end;

function IMaster.getDispatcher(): PProviderToken;
begin
	Result := vTable^.getDispatcher(PMasterToken(token));
end;

function IMaster.getPluginManager(): PPluginManagerToken;
begin
	Result := vTable^.getPluginManager(PMasterToken(token));
end;

function IMaster.getTimerControl(): PTimerControlToken;
begin
	Result := vTable^.getTimerControl(PMasterToken(token));
end;

function IMaster.getDtc(): PDtcToken;
begin
	Result := vTable^.getDtc(PMasterToken(token));
end;

function IMaster.registerAttachment(provider: PProviderToken; attachment: PAttachmentToken): PAttachmentToken;
begin
	Result := vTable^.registerAttachment(PMasterToken(token), provider, attachment);
end;

function IMaster.registerTransaction(attachment: PAttachmentToken; transaction: PTransactionToken): PTransactionToken;
begin
	Result := vTable^.registerTransaction(PMasterToken(token), attachment, transaction);
end;

function IMaster.getMetadataBuilder(status: PStatusToken; fieldCount: Cardinal): PMetadataBuilderToken;
begin
	Result := vTable^.getMetadataBuilder(PMasterToken(token), status, fieldCount);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMaster.serverMode(mode: Integer): Integer;
begin
	Result := vTable^.serverMode(PMasterToken(token), mode);
end;

function IMaster.getUtilInterface(): PUtilToken;
begin
	Result := vTable^.getUtilInterface(PMasterToken(token));
end;

function IMaster.getConfigManager(): PConfigManagerToken;
begin
	Result := vTable^.getConfigManager(PMasterToken(token));
end;

function IMaster.getProcessExiting(): Boolean;
begin
	Result := vTable^.getProcessExiting(PMasterToken(token));
end;

function IPluginBase.vtable: PPluginBaseVTable;
begin
  Result := PPluginBaseVTable(token^.vTable);
end;

class operator IPluginBase.:= (aToken:  PPluginBaseToken): IPluginBase;
begin
  Result.token := aToken;
end;

class operator IPluginBase.:= (intf: IPluginBase): PPluginBaseToken;
begin
  Result := intf.token;
end;

class operator IPluginBase.:= (impl: IPluginBaseImpl): IPluginBase;
begin
  Result := impl.intf;
end;

class operator IPluginBase.= (a: IPluginBase; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IPluginBase.= (a,b: IPluginBase): boolean;
begin
  Result := a.token = b.token;
end;

procedure IPluginBase.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IPluginBase.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IPluginBase.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IPluginBase.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IPluginSet.vtable: PPluginSetVTable;
begin
  Result := PPluginSetVTable(token^.vTable);
end;

class operator IPluginSet.:= (aToken:  PPluginSetToken): IPluginSet;
begin
  Result.token := aToken;
end;

class operator IPluginSet.:= (intf: IPluginSet): PPluginSetToken;
begin
  Result := intf.token;
end;

class operator IPluginSet.:= (impl: IPluginSetImpl): IPluginSet;
begin
  Result := impl.intf;
end;

class operator IPluginSet.= (a: IPluginSet; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IPluginSet.= (a,b: IPluginSet): boolean;
begin
  Result := a.token = b.token;
end;

procedure IPluginSet.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IPluginSet.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IPluginSet.getName(): PAnsiChar;
begin
	Result := vTable^.getName(PPluginSetToken(token));
end;

function IPluginSet.getModuleName(): PAnsiChar;
begin
	Result := vTable^.getModuleName(PPluginSetToken(token));
end;

function IPluginSet.getPlugin(status: PStatusToken): PPluginBaseToken;
begin
	Result := vTable^.getPlugin(PPluginSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IPluginSet.next(status: PStatusToken);
begin
	vTable^.next(PPluginSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IPluginSet.set_(status: PStatusToken; s: PAnsiChar);
begin
	vTable^.set_(PPluginSetToken(token), status, s);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IConfigEntry.vtable: PConfigEntryVTable;
begin
  Result := PConfigEntryVTable(token^.vTable);
end;

class operator IConfigEntry.:= (aToken:  PConfigEntryToken): IConfigEntry;
begin
  Result.token := aToken;
end;

class operator IConfigEntry.:= (intf: IConfigEntry): PConfigEntryToken;
begin
  Result := intf.token;
end;

class operator IConfigEntry.:= (impl: IConfigEntryImpl): IConfigEntry;
begin
  Result := impl.intf;
end;

class operator IConfigEntry.= (a: IConfigEntry; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IConfigEntry.= (a,b: IConfigEntry): boolean;
begin
  Result := a.token = b.token;
end;

procedure IConfigEntry.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IConfigEntry.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IConfigEntry.getName(): PAnsiChar;
begin
	Result := vTable^.getName(PConfigEntryToken(token));
end;

function IConfigEntry.getValue(): PAnsiChar;
begin
	Result := vTable^.getValue(PConfigEntryToken(token));
end;

function IConfigEntry.getIntValue(): Int64;
begin
	Result := vTable^.getIntValue(PConfigEntryToken(token));
end;

function IConfigEntry.getBoolValue(): Boolean;
begin
	Result := vTable^.getBoolValue(PConfigEntryToken(token));
end;

function IConfigEntry.getSubConfig(status: PStatusToken): PConfigToken;
begin
	Result := vTable^.getSubConfig(PConfigEntryToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IConfig.vtable: PConfigVTable;
begin
  Result := PConfigVTable(token^.vTable);
end;

class operator IConfig.:= (aToken:  PConfigToken): IConfig;
begin
  Result.token := aToken;
end;

class operator IConfig.:= (intf: IConfig): PConfigToken;
begin
  Result := intf.token;
end;

class operator IConfig.:= (impl: IConfigImpl): IConfig;
begin
  Result := impl.intf;
end;

class operator IConfig.= (a: IConfig; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IConfig.= (a,b: IConfig): boolean;
begin
  Result := a.token = b.token;
end;

procedure IConfig.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IConfig.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IConfig.find(status: PStatusToken; name: PAnsiChar): PConfigEntryToken;
begin
	Result := vTable^.find(PConfigToken(token), status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IConfig.findValue(status: PStatusToken; name: PAnsiChar; value: PAnsiChar): PConfigEntryToken;
begin
	Result := vTable^.findValue(PConfigToken(token), status, name, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IConfig.findPos(status: PStatusToken; name: PAnsiChar; pos: Cardinal): PConfigEntryToken;
begin
	Result := vTable^.findPos(PConfigToken(token), status, name, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IFirebirdConf.vtable: PFirebirdConfVTable;
begin
  Result := PFirebirdConfVTable(token^.vTable);
end;

class operator IFirebirdConf.:= (aToken:  PFirebirdConfToken): IFirebirdConf;
begin
  Result.token := aToken;
end;

class operator IFirebirdConf.:= (intf: IFirebirdConf): PFirebirdConfToken;
begin
  Result := intf.token;
end;

class operator IFirebirdConf.:= (impl: IFirebirdConfImpl): IFirebirdConf;
begin
  Result := impl.intf;
end;

class operator IFirebirdConf.= (a: IFirebirdConf; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IFirebirdConf.= (a,b: IFirebirdConf): boolean;
begin
  Result := a.token = b.token;
end;

procedure IFirebirdConf.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IFirebirdConf.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IFirebirdConf.getKey(name: PAnsiChar): Cardinal;
begin
	Result := vTable^.getKey(PFirebirdConfToken(token), name);
end;

function IFirebirdConf.asInteger(key: Cardinal): Int64;
begin
	Result := vTable^.asInteger(PFirebirdConfToken(token), key);
end;

function IFirebirdConf.asString(key: Cardinal): PAnsiChar;
begin
	Result := vTable^.asString(PFirebirdConfToken(token), key);
end;

function IFirebirdConf.asBoolean(key: Cardinal): Boolean;
begin
	Result := vTable^.asBoolean(PFirebirdConfToken(token), key);
end;

function IFirebirdConf.getVersion(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getVersion(PFirebirdConfToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IPluginConfig.vtable: PPluginConfigVTable;
begin
  Result := PPluginConfigVTable(token^.vTable);
end;

class operator IPluginConfig.:= (aToken:  PPluginConfigToken): IPluginConfig;
begin
  Result.token := aToken;
end;

class operator IPluginConfig.:= (intf: IPluginConfig): PPluginConfigToken;
begin
  Result := intf.token;
end;

class operator IPluginConfig.:= (impl: IPluginConfigImpl): IPluginConfig;
begin
  Result := impl.intf;
end;

class operator IPluginConfig.= (a: IPluginConfig; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IPluginConfig.= (a,b: IPluginConfig): boolean;
begin
  Result := a.token = b.token;
end;

procedure IPluginConfig.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IPluginConfig.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IPluginConfig.getConfigFileName(): PAnsiChar;
begin
	Result := vTable^.getConfigFileName(PPluginConfigToken(token));
end;

function IPluginConfig.getDefaultConfig(status: PStatusToken): PConfigToken;
begin
	Result := vTable^.getDefaultConfig(PPluginConfigToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IPluginConfig.getFirebirdConf(status: PStatusToken): PFirebirdConfToken;
begin
	Result := vTable^.getFirebirdConf(PPluginConfigToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IPluginConfig.setReleaseDelay(status: PStatusToken; microSeconds: QWord);
begin
	vTable^.setReleaseDelay(PPluginConfigToken(token), status, microSeconds);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IPluginFactory.vtable: PPluginFactoryVTable;
begin
  Result := PPluginFactoryVTable(token^.vTable);
end;

class operator IPluginFactory.:= (aToken:  PPluginFactoryToken): IPluginFactory;
begin
  Result.token := aToken;
end;

class operator IPluginFactory.:= (intf: IPluginFactory): PPluginFactoryToken;
begin
  Result := intf.token;
end;

class operator IPluginFactory.:= (impl: IPluginFactoryImpl): IPluginFactory;
begin
  Result := impl.intf;
end;

class operator IPluginFactory.= (a: IPluginFactory; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IPluginFactory.= (a,b: IPluginFactory): boolean;
begin
  Result := a.token = b.token;
end;

function IPluginFactory.createPlugin(status: PStatusToken; factoryParameter: PPluginConfigToken): PPluginBaseToken;
begin
	Result := vTable^.createPlugin(PPluginFactoryToken(token), status, factoryParameter);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IPluginModule.vtable: PPluginModuleVTable;
begin
  Result := PPluginModuleVTable(token^.vTable);
end;

class operator IPluginModule.:= (aToken:  PPluginModuleToken): IPluginModule;
begin
  Result.token := aToken;
end;

class operator IPluginModule.:= (intf: IPluginModule): PPluginModuleToken;
begin
  Result := intf.token;
end;

class operator IPluginModule.:= (impl: IPluginModuleImpl): IPluginModule;
begin
  Result := impl.intf;
end;

class operator IPluginModule.= (a: IPluginModule; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IPluginModule.= (a,b: IPluginModule): boolean;
begin
  Result := a.token = b.token;
end;

procedure IPluginModule.doClean();
begin
	vTable^.doClean(PPluginModuleToken(token));
end;

procedure IPluginModule.threadDetach();
begin
	vTable^.threadDetach(PPluginModuleToken(token));
end;

function IPluginManager.vtable: PPluginManagerVTable;
begin
  Result := PPluginManagerVTable(token^.vTable);
end;

class operator IPluginManager.:= (aToken:  PPluginManagerToken): IPluginManager;
begin
  Result.token := aToken;
end;

class operator IPluginManager.:= (intf: IPluginManager): PPluginManagerToken;
begin
  Result := intf.token;
end;

class operator IPluginManager.:= (impl: IPluginManagerImpl): IPluginManager;
begin
  Result := impl.intf;
end;

class operator IPluginManager.= (a: IPluginManager; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IPluginManager.= (a,b: IPluginManager): boolean;
begin
  Result := a.token = b.token;
end;

procedure IPluginManager.registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: PPluginFactoryToken);
begin
	vTable^.registerPluginFactory(PPluginManagerToken(token), pluginType, defaultName, factory);
end;

procedure IPluginManager.registerModule(cleanup: PPluginModuleToken);
begin
	vTable^.registerModule(PPluginManagerToken(token), cleanup);
end;

procedure IPluginManager.unregisterModule(cleanup: PPluginModuleToken);
begin
	vTable^.unregisterModule(PPluginManagerToken(token), cleanup);
end;

function IPluginManager.getPlugins(status: PStatusToken; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: PFirebirdConfToken): PPluginSetToken;
begin
	Result := vTable^.getPlugins(PPluginManagerToken(token), status, pluginType, namesList, firebirdConf);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IPluginManager.getConfig(status: PStatusToken; filename: PAnsiChar): PConfigToken;
begin
	Result := vTable^.getConfig(PPluginManagerToken(token), status, filename);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IPluginManager.releasePlugin(plugin: PPluginBaseToken);
begin
	vTable^.releasePlugin(PPluginManagerToken(token), plugin);
end;

function ICryptKey.vtable: PCryptKeyVTable;
begin
  Result := PCryptKeyVTable(token^.vTable);
end;

class operator ICryptKey.:= (aToken:  PCryptKeyToken): ICryptKey;
begin
  Result.token := aToken;
end;

class operator ICryptKey.:= (intf: ICryptKey): PCryptKeyToken;
begin
  Result := intf.token;
end;

class operator ICryptKey.:= (impl: ICryptKeyImpl): ICryptKey;
begin
  Result := impl.intf;
end;

class operator ICryptKey.= (a: ICryptKey; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ICryptKey.= (a,b: ICryptKey): boolean;
begin
  Result := a.token = b.token;
end;

procedure ICryptKey.setSymmetric(status: PStatusToken; type_: PAnsiChar; keyLength: Cardinal; key: Pointer);
begin
	vTable^.setSymmetric(PCryptKeyToken(token), status, type_, keyLength, key);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ICryptKey.setAsymmetric(status: PStatusToken; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer);
begin
	vTable^.setAsymmetric(PCryptKeyToken(token), status, type_, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ICryptKey.getEncryptKey(length: CardinalPtr): Pointer;
begin
	Result := vTable^.getEncryptKey(PCryptKeyToken(token), length);
end;

function ICryptKey.getDecryptKey(length: CardinalPtr): Pointer;
begin
	Result := vTable^.getDecryptKey(PCryptKeyToken(token), length);
end;

function IConfigManager.vtable: PConfigManagerVTable;
begin
  Result := PConfigManagerVTable(token^.vTable);
end;

class operator IConfigManager.:= (aToken:  PConfigManagerToken): IConfigManager;
begin
  Result.token := aToken;
end;

class operator IConfigManager.:= (intf: IConfigManager): PConfigManagerToken;
begin
  Result := intf.token;
end;

class operator IConfigManager.:= (impl: IConfigManagerImpl): IConfigManager;
begin
  Result := impl.intf;
end;

class operator IConfigManager.= (a: IConfigManager; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IConfigManager.= (a,b: IConfigManager): boolean;
begin
  Result := a.token = b.token;
end;

function IConfigManager.getDirectory(code: Cardinal): PAnsiChar;
begin
	Result := vTable^.getDirectory(PConfigManagerToken(token), code);
end;

function IConfigManager.getFirebirdConf(): PFirebirdConfToken;
begin
	Result := vTable^.getFirebirdConf(PConfigManagerToken(token));
end;

function IConfigManager.getDatabaseConf(dbName: PAnsiChar): PFirebirdConfToken;
begin
	Result := vTable^.getDatabaseConf(PConfigManagerToken(token), dbName);
end;

function IConfigManager.getPluginConfig(configuredPlugin: PAnsiChar): PConfigToken;
begin
	Result := vTable^.getPluginConfig(PConfigManagerToken(token), configuredPlugin);
end;

function IConfigManager.getInstallDirectory(): PAnsiChar;
begin
	Result := vTable^.getInstallDirectory(PConfigManagerToken(token));
end;

function IConfigManager.getRootDirectory(): PAnsiChar;
begin
	Result := vTable^.getRootDirectory(PConfigManagerToken(token));
end;

function IConfigManager.getDefaultSecurityDb(): PAnsiChar;
begin
	Result := vTable^.getDefaultSecurityDb(PConfigManagerToken(token));
end;

function IEventCallback.vtable: PEventCallbackVTable;
begin
  Result := PEventCallbackVTable(token^.vTable);
end;

class operator IEventCallback.:= (aToken:  PEventCallbackToken): IEventCallback;
begin
  Result.token := aToken;
end;

class operator IEventCallback.:= (intf: IEventCallback): PEventCallbackToken;
begin
  Result := intf.token;
end;

class operator IEventCallback.:= (impl: IEventCallbackImpl): IEventCallback;
begin
  Result := impl.intf;
end;

class operator IEventCallback.= (a: IEventCallback; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IEventCallback.= (a,b: IEventCallback): boolean;
begin
  Result := a.token = b.token;
end;

procedure IEventCallback.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IEventCallback.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IEventCallback.eventCallbackFunction(length: Cardinal; events: BytePtr);
begin
	vTable^.eventCallbackFunction(PEventCallbackToken(token), length, events);
end;

function IBlob.vtable: PBlobVTable;
begin
  Result := PBlobVTable(token^.vTable);
end;

class operator IBlob.:= (aToken:  PBlobToken): IBlob;
begin
  Result.token := aToken;
end;

class operator IBlob.:= (intf: IBlob): PBlobToken;
begin
  Result := intf.token;
end;

class operator IBlob.:= (impl: IBlobImpl): IBlob;
begin
  Result := impl.intf;
end;

class operator IBlob.= (a: IBlob; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IBlob.= (a,b: IBlob): boolean;
begin
  Result := a.token = b.token;
end;

procedure IBlob.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IBlob.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IBlob.getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(PBlobToken(token), status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBlob.getSegment(status: PStatusToken; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer;
begin
	Result := vTable^.getSegment(PBlobToken(token), status, bufferLength, buffer, segmentLength);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBlob.putSegment(status: PStatusToken; length: Cardinal; buffer: Pointer);
begin
	vTable^.putSegment(PBlobToken(token), status, length, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBlob.cancel(status: PStatusToken);
begin
	vTable^.cancel(PBlobToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBlob.close(status: PStatusToken);
begin
	vTable^.close(PBlobToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBlob.seek(status: PStatusToken; mode: Integer; offset: Integer): Integer;
begin
	Result := vTable^.seek(PBlobToken(token), status, mode, offset);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITransaction.vtable: PTransactionVTable;
begin
  Result := PTransactionVTable(token^.vTable);
end;

class operator ITransaction.:= (aToken:  PTransactionToken): ITransaction;
begin
  Result.token := aToken;
end;

class operator ITransaction.:= (intf: ITransaction): PTransactionToken;
begin
  Result := intf.token;
end;

class operator ITransaction.:= (impl: ITransactionImpl): ITransaction;
begin
  Result := impl.intf;
end;

class operator ITransaction.= (a: ITransaction; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITransaction.= (a,b: ITransaction): boolean;
begin
  Result := a.token = b.token;
end;

procedure ITransaction.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function ITransaction.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure ITransaction.getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(PTransactionToken(token), status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITransaction.prepare(status: PStatusToken; msgLength: Cardinal; message: BytePtr);
begin
	vTable^.prepare(PTransactionToken(token), status, msgLength, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITransaction.commit(status: PStatusToken);
begin
	vTable^.commit(PTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITransaction.commitRetaining(status: PStatusToken);
begin
	vTable^.commitRetaining(PTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITransaction.rollback(status: PStatusToken);
begin
	vTable^.rollback(PTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITransaction.rollbackRetaining(status: PStatusToken);
begin
	vTable^.rollbackRetaining(PTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITransaction.disconnect(status: PStatusToken);
begin
	vTable^.disconnect(PTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITransaction.join(status: PStatusToken; transaction: PTransactionToken): PTransactionToken;
begin
	Result := vTable^.join(PTransactionToken(token), status, transaction);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITransaction.validate(status: PStatusToken; attachment: PAttachmentToken): PTransactionToken;
begin
	Result := vTable^.validate(PTransactionToken(token), status, attachment);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITransaction.enterDtc(status: PStatusToken): PTransactionToken;
begin
	Result := vTable^.enterDtc(PTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.vtable: PMessageMetadataVTable;
begin
  Result := PMessageMetadataVTable(token^.vTable);
end;

class operator IMessageMetadata.:= (aToken:  PMessageMetadataToken): IMessageMetadata;
begin
  Result.token := aToken;
end;

class operator IMessageMetadata.:= (intf: IMessageMetadata): PMessageMetadataToken;
begin
  Result := intf.token;
end;

class operator IMessageMetadata.:= (impl: IMessageMetadataImpl): IMessageMetadata;
begin
  Result := impl.intf;
end;

class operator IMessageMetadata.= (a: IMessageMetadata; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IMessageMetadata.= (a,b: IMessageMetadata): boolean;
begin
  Result := a.token = b.token;
end;

procedure IMessageMetadata.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IMessageMetadata.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IMessageMetadata.getCount(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getCount(PMessageMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getField(status: PStatusToken; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getField(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getRelation(status: PStatusToken; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getRelation(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getOwner(status: PStatusToken; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getOwner(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getAlias(status: PStatusToken; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getAlias(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getType(status: PStatusToken; index: Cardinal): Cardinal;
begin
	Result := vTable^.getType(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.isNullable(status: PStatusToken; index: Cardinal): Boolean;
begin
	Result := vTable^.isNullable(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getSubType(status: PStatusToken; index: Cardinal): Integer;
begin
	Result := vTable^.getSubType(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getLength(status: PStatusToken; index: Cardinal): Cardinal;
begin
	Result := vTable^.getLength(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getScale(status: PStatusToken; index: Cardinal): Integer;
begin
	Result := vTable^.getScale(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getCharSet(status: PStatusToken; index: Cardinal): Cardinal;
begin
	Result := vTable^.getCharSet(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getOffset(status: PStatusToken; index: Cardinal): Cardinal;
begin
	Result := vTable^.getOffset(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getNullOffset(status: PStatusToken; index: Cardinal): Cardinal;
begin
	Result := vTable^.getNullOffset(PMessageMetadataToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getBuilder(status: PStatusToken): PMetadataBuilderToken;
begin
	Result := vTable^.getBuilder(PMessageMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getMessageLength(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getMessageLength(PMessageMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getAlignment(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getAlignment(PMessageMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMessageMetadata.getAlignedLength(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getAlignedLength(PMessageMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMetadataBuilder.vtable: PMetadataBuilderVTable;
begin
  Result := PMetadataBuilderVTable(token^.vTable);
end;

class operator IMetadataBuilder.:= (aToken:  PMetadataBuilderToken): IMetadataBuilder;
begin
  Result.token := aToken;
end;

class operator IMetadataBuilder.:= (intf: IMetadataBuilder): PMetadataBuilderToken;
begin
  Result := intf.token;
end;

class operator IMetadataBuilder.:= (impl: IMetadataBuilderImpl): IMetadataBuilder;
begin
  Result := impl.intf;
end;

class operator IMetadataBuilder.= (a: IMetadataBuilder; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IMetadataBuilder.= (a,b: IMetadataBuilder): boolean;
begin
  Result := a.token = b.token;
end;

procedure IMetadataBuilder.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IMetadataBuilder.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IMetadataBuilder.setType(status: PStatusToken; index: Cardinal; type_: Cardinal);
begin
	vTable^.setType(PMetadataBuilderToken(token), status, index, type_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setSubType(status: PStatusToken; index: Cardinal; subType: Integer);
begin
	vTable^.setSubType(PMetadataBuilderToken(token), status, index, subType);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setLength(status: PStatusToken; index: Cardinal; length: Cardinal);
begin
	vTable^.setLength(PMetadataBuilderToken(token), status, index, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setCharSet(status: PStatusToken; index: Cardinal; charSet: Cardinal);
begin
	vTable^.setCharSet(PMetadataBuilderToken(token), status, index, charSet);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setScale(status: PStatusToken; index: Cardinal; scale: Integer);
begin
	vTable^.setScale(PMetadataBuilderToken(token), status, index, scale);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.truncate(status: PStatusToken; count: Cardinal);
begin
	vTable^.truncate(PMetadataBuilderToken(token), status, count);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.moveNameToIndex(status: PStatusToken; name: PAnsiChar; index: Cardinal);
begin
	vTable^.moveNameToIndex(PMetadataBuilderToken(token), status, name, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.remove(status: PStatusToken; index: Cardinal);
begin
	vTable^.remove(PMetadataBuilderToken(token), status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMetadataBuilder.addField(status: PStatusToken): Cardinal;
begin
	Result := vTable^.addField(PMetadataBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IMetadataBuilder.getMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getMetadata(PMetadataBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setField(status: PStatusToken; index: Cardinal; field: PAnsiChar);
begin
	vTable^.setField(PMetadataBuilderToken(token), status, index, field);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setRelation(status: PStatusToken; index: Cardinal; relation: PAnsiChar);
begin
	vTable^.setRelation(PMetadataBuilderToken(token), status, index, relation);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setOwner(status: PStatusToken; index: Cardinal; owner: PAnsiChar);
begin
	vTable^.setOwner(PMetadataBuilderToken(token), status, index, owner);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IMetadataBuilder.setAlias(status: PStatusToken; index: Cardinal; alias: PAnsiChar);
begin
	vTable^.setAlias(PMetadataBuilderToken(token), status, index, alias);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.vtable: PResultSetVTable;
begin
  Result := PResultSetVTable(token^.vTable);
end;

class operator IResultSet.:= (aToken:  PResultSetToken): IResultSet;
begin
  Result.token := aToken;
end;

class operator IResultSet.:= (intf: IResultSet): PResultSetToken;
begin
  Result := intf.token;
end;

class operator IResultSet.:= (impl: IResultSetImpl): IResultSet;
begin
  Result := impl.intf;
end;

class operator IResultSet.= (a: IResultSet; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IResultSet.= (a,b: IResultSet): boolean;
begin
  Result := a.token = b.token;
end;

procedure IResultSet.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IResultSet.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IResultSet.fetchNext(status: PStatusToken; message: Pointer): Integer;
begin
	Result := vTable^.fetchNext(PResultSetToken(token), status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.fetchPrior(status: PStatusToken; message: Pointer): Integer;
begin
	Result := vTable^.fetchPrior(PResultSetToken(token), status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.fetchFirst(status: PStatusToken; message: Pointer): Integer;
begin
	Result := vTable^.fetchFirst(PResultSetToken(token), status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.fetchLast(status: PStatusToken; message: Pointer): Integer;
begin
	Result := vTable^.fetchLast(PResultSetToken(token), status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.fetchAbsolute(status: PStatusToken; position: Integer; message: Pointer): Integer;
begin
	Result := vTable^.fetchAbsolute(PResultSetToken(token), status, position, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.fetchRelative(status: PStatusToken; offset: Integer; message: Pointer): Integer;
begin
	Result := vTable^.fetchRelative(PResultSetToken(token), status, offset, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.isEof(status: PStatusToken): Boolean;
begin
	Result := vTable^.isEof(PResultSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.isBof(status: PStatusToken): Boolean;
begin
	Result := vTable^.isBof(PResultSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IResultSet.getMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getMetadata(PResultSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IResultSet.close(status: PStatusToken);
begin
	vTable^.close(PResultSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IResultSet.setDelayedOutputFormat(status: PStatusToken; format: PMessageMetadataToken);
begin
	vTable^.setDelayedOutputFormat(PResultSetToken(token), status, format);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.vtable: PStatementVTable;
begin
  Result := PStatementVTable(token^.vTable);
end;

class operator IStatement.:= (aToken:  PStatementToken): IStatement;
begin
  Result.token := aToken;
end;

class operator IStatement.:= (intf: IStatement): PStatementToken;
begin
  Result := intf.token;
end;

class operator IStatement.:= (impl: IStatementImpl): IStatement;
begin
  Result := impl.intf;
end;

class operator IStatement.= (a: IStatement; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IStatement.= (a,b: IStatement): boolean;
begin
  Result := a.token = b.token;
end;

procedure IStatement.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IStatement.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IStatement.getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(PStatementToken(token), status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getType(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getType(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getPlan(status: PStatusToken; detailed: Boolean): PAnsiChar;
begin
	Result := vTable^.getPlan(PStatementToken(token), status, detailed);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getAffectedRecords(status: PStatusToken): QWord;
begin
	Result := vTable^.getAffectedRecords(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getInputMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getInputMetadata(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getOutputMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getOutputMetadata(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.execute(status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken;
begin
	Result := vTable^.execute(PStatementToken(token), status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.openCursor(status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; flags: Cardinal): PResultSetToken;
begin
	Result := vTable^.openCursor(PStatementToken(token), status, transaction, inMetadata, inBuffer, outMetadata, flags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IStatement.setCursorName(status: PStatusToken; name: PAnsiChar);
begin
	vTable^.setCursorName(PStatementToken(token), status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IStatement.free(status: PStatusToken);
begin
	vTable^.free(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getFlags(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getFlags(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.getTimeout(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getTimeout(PStatementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IStatement.setTimeout(status: PStatusToken; timeOut: Cardinal);
begin
	vTable^.setTimeout(PStatementToken(token), status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IStatement.createBatch(status: PStatusToken; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken;
begin
	Result := vTable^.createBatch(PStatementToken(token), status, inMetadata, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatch.vtable: PBatchVTable;
begin
  Result := PBatchVTable(token^.vTable);
end;

class operator IBatch.:= (aToken:  PBatchToken): IBatch;
begin
  Result.token := aToken;
end;

class operator IBatch.:= (intf: IBatch): PBatchToken;
begin
  Result := intf.token;
end;

class operator IBatch.:= (impl: IBatchImpl): IBatch;
begin
  Result := impl.intf;
end;

class operator IBatch.= (a: IBatch; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IBatch.= (a,b: IBatch): boolean;
begin
  Result := a.token = b.token;
end;

procedure IBatch.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IBatch.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IBatch.add(status: PStatusToken; count: Cardinal; inBuffer: Pointer);
begin
	vTable^.add(PBatchToken(token), status, count, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.addBlob(status: PStatusToken; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr);
begin
	vTable^.addBlob(PBatchToken(token), status, length, inBuffer, blobId, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.appendBlobData(status: PStatusToken; length: Cardinal; inBuffer: Pointer);
begin
	vTable^.appendBlobData(PBatchToken(token), status, length, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.addBlobStream(status: PStatusToken; length: Cardinal; inBuffer: Pointer);
begin
	vTable^.addBlobStream(PBatchToken(token), status, length, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.registerBlob(status: PStatusToken; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr);
begin
	vTable^.registerBlob(PBatchToken(token), status, existingBlob, blobId);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatch.execute(status: PStatusToken; transaction: PTransactionToken): PBatchCompletionStateToken;
begin
	Result := vTable^.execute(PBatchToken(token), status, transaction);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.cancel(status: PStatusToken);
begin
	vTable^.cancel(PBatchToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatch.getBlobAlignment(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getBlobAlignment(PBatchToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatch.getMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getMetadata(PBatchToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.setDefaultBpb(status: PStatusToken; parLength: Cardinal; par: BytePtr);
begin
	vTable^.setDefaultBpb(PBatchToken(token), status, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatch.close(status: PStatusToken);
begin
	vTable^.close(PBatchToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatchCompletionState.vtable: PBatchCompletionStateVTable;
begin
  Result := PBatchCompletionStateVTable(token^.vTable);
end;

class operator IBatchCompletionState.:= (aToken:  PBatchCompletionStateToken): IBatchCompletionState;
begin
  Result.token := aToken;
end;

class operator IBatchCompletionState.:= (intf: IBatchCompletionState): PBatchCompletionStateToken;
begin
  Result := intf.token;
end;

class operator IBatchCompletionState.:= (impl: IBatchCompletionStateImpl): IBatchCompletionState;
begin
  Result := impl.intf;
end;

class operator IBatchCompletionState.= (a: IBatchCompletionState; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IBatchCompletionState.= (a,b: IBatchCompletionState): boolean;
begin
  Result := a.token = b.token;
end;

procedure IBatchCompletionState.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

function IBatchCompletionState.getSize(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getSize(PBatchCompletionStateToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatchCompletionState.getState(status: PStatusToken; pos: Cardinal): Integer;
begin
	Result := vTable^.getState(PBatchCompletionStateToken(token), status, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IBatchCompletionState.findError(status: PStatusToken; pos: Cardinal): Cardinal;
begin
	Result := vTable^.findError(PBatchCompletionStateToken(token), status, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IBatchCompletionState.getStatus(status: PStatusToken; to_: PStatusToken; pos: Cardinal);
begin
	vTable^.getStatus(PBatchCompletionStateToken(token), status, to_, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IReplicator.vtable: PReplicatorVTable;
begin
  Result := PReplicatorVTable(token^.vTable);
end;

class operator IReplicator.:= (aToken:  PReplicatorToken): IReplicator;
begin
  Result.token := aToken;
end;

class operator IReplicator.:= (intf: IReplicator): PReplicatorToken;
begin
  Result := intf.token;
end;

class operator IReplicator.:= (impl: IReplicatorImpl): IReplicator;
begin
  Result := impl.intf;
end;

class operator IReplicator.= (a: IReplicator; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IReplicator.= (a,b: IReplicator): boolean;
begin
  Result := a.token = b.token;
end;

procedure IReplicator.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IReplicator.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IReplicator.process(status: PStatusToken; length: Cardinal; data: BytePtr);
begin
	vTable^.process(PReplicatorToken(token), status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicator.close(status: PStatusToken);
begin
	vTable^.close(PReplicatorToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRequest.vtable: PRequestVTable;
begin
  Result := PRequestVTable(token^.vTable);
end;

class operator IRequest.:= (aToken:  PRequestToken): IRequest;
begin
  Result.token := aToken;
end;

class operator IRequest.:= (intf: IRequest): PRequestToken;
begin
  Result := intf.token;
end;

class operator IRequest.:= (impl: IRequestImpl): IRequest;
begin
  Result := impl.intf;
end;

class operator IRequest.= (a: IRequest; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IRequest.= (a,b: IRequest): boolean;
begin
  Result := a.token = b.token;
end;

procedure IRequest.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IRequest.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IRequest.receive(status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.receive(PRequestToken(token), status, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IRequest.send(status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.send(PRequestToken(token), status, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IRequest.getInfo(status: PStatusToken; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(PRequestToken(token), status, level, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IRequest.start(status: PStatusToken; tra: PTransactionToken; level: Integer);
begin
	vTable^.start(PRequestToken(token), status, tra, level);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IRequest.startAndSend(status: PStatusToken; tra: PTransactionToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.startAndSend(PRequestToken(token), status, tra, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IRequest.unwind(status: PStatusToken; level: Integer);
begin
	vTable^.unwind(PRequestToken(token), status, level);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IRequest.free(status: PStatusToken);
begin
	vTable^.free(PRequestToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IEvents.vtable: PEventsVTable;
begin
  Result := PEventsVTable(token^.vTable);
end;

class operator IEvents.:= (aToken:  PEventsToken): IEvents;
begin
  Result.token := aToken;
end;

class operator IEvents.:= (intf: IEvents): PEventsToken;
begin
  Result := intf.token;
end;

class operator IEvents.:= (impl: IEventsImpl): IEvents;
begin
  Result := impl.intf;
end;

class operator IEvents.= (a: IEvents; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IEvents.= (a,b: IEvents): boolean;
begin
  Result := a.token = b.token;
end;

procedure IEvents.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IEvents.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IEvents.cancel(status: PStatusToken);
begin
	vTable^.cancel(PEventsToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.vtable: PAttachmentVTable;
begin
  Result := PAttachmentVTable(token^.vTable);
end;

class operator IAttachment.:= (aToken:  PAttachmentToken): IAttachment;
begin
  Result.token := aToken;
end;

class operator IAttachment.:= (intf: IAttachment): PAttachmentToken;
begin
  Result := intf.token;
end;

class operator IAttachment.:= (impl: IAttachmentImpl): IAttachment;
begin
  Result := impl.intf;
end;

class operator IAttachment.= (a: IAttachment; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IAttachment.= (a,b: IAttachment): boolean;
begin
  Result := a.token = b.token;
end;

procedure IAttachment.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IAttachment.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IAttachment.getInfo(status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(PAttachmentToken(token), status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.startTransaction(status: PStatusToken; tpbLength: Cardinal; tpb: BytePtr): PTransactionToken;
begin
	Result := vTable^.startTransaction(PAttachmentToken(token), status, tpbLength, tpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.reconnectTransaction(status: PStatusToken; length: Cardinal; id: BytePtr): PTransactionToken;
begin
	Result := vTable^.reconnectTransaction(PAttachmentToken(token), status, length, id);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.compileRequest(status: PStatusToken; blrLength: Cardinal; blr: BytePtr): PRequestToken;
begin
	Result := vTable^.compileRequest(PAttachmentToken(token), status, blrLength, blr);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.transactRequest(status: PStatusToken; transaction: PTransactionToken; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr);
begin
	vTable^.transactRequest(PAttachmentToken(token), status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.createBlob(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken;
begin
	Result := vTable^.createBlob(PAttachmentToken(token), status, transaction, id, bpbLength, bpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.openBlob(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken;
begin
	Result := vTable^.openBlob(PAttachmentToken(token), status, transaction, id, bpbLength, bpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.getSlice(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer;
begin
	Result := vTable^.getSlice(PAttachmentToken(token), status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.putSlice(status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr);
begin
	vTable^.putSlice(PAttachmentToken(token), status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.executeDyn(status: PStatusToken; transaction: PTransactionToken; length: Cardinal; dyn: BytePtr);
begin
	vTable^.executeDyn(PAttachmentToken(token), status, transaction, length, dyn);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.prepare(status: PStatusToken; tra: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): PStatementToken;
begin
	Result := vTable^.prepare(PAttachmentToken(token), status, tra, stmtLength, sqlStmt, dialect, flags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.execute(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken;
begin
	Result := vTable^.execute(PAttachmentToken(token), status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.openCursor(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; cursorName: PAnsiChar; cursorFlags: Cardinal): PResultSetToken;
begin
	Result := vTable^.openCursor(PAttachmentToken(token), status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.queEvents(status: PStatusToken; callback: PEventCallbackToken; length: Cardinal; events: BytePtr): PEventsToken;
begin
	Result := vTable^.queEvents(PAttachmentToken(token), status, callback, length, events);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.cancelOperation(status: PStatusToken; option: Integer);
begin
	vTable^.cancelOperation(PAttachmentToken(token), status, option);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.ping(status: PStatusToken);
begin
	vTable^.ping(PAttachmentToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.detach(status: PStatusToken);
begin
	vTable^.detach(PAttachmentToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.dropDatabase(status: PStatusToken);
begin
	vTable^.dropDatabase(PAttachmentToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.getIdleTimeout(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getIdleTimeout(PAttachmentToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.setIdleTimeout(status: PStatusToken; timeOut: Cardinal);
begin
	vTable^.setIdleTimeout(PAttachmentToken(token), status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.getStatementTimeout(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getStatementTimeout(PAttachmentToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IAttachment.setStatementTimeout(status: PStatusToken; timeOut: Cardinal);
begin
	vTable^.setStatementTimeout(PAttachmentToken(token), status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.createBatch(status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken;
begin
	Result := vTable^.createBatch(PAttachmentToken(token), status, transaction, stmtLength, sqlStmt, dialect, inMetadata, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAttachment.createReplicator(status: PStatusToken): PReplicatorToken;
begin
	Result := vTable^.createReplicator(PAttachmentToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IService.vtable: PServiceVTable;
begin
  Result := PServiceVTable(token^.vTable);
end;

class operator IService.:= (aToken:  PServiceToken): IService;
begin
  Result.token := aToken;
end;

class operator IService.:= (intf: IService): PServiceToken;
begin
  Result := intf.token;
end;

class operator IService.:= (impl: IServiceImpl): IService;
begin
  Result := impl.intf;
end;

class operator IService.= (a: IService; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IService.= (a,b: IService): boolean;
begin
  Result := a.token = b.token;
end;

procedure IService.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IService.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IService.detach(status: PStatusToken);
begin
	vTable^.detach(PServiceToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IService.query(status: PStatusToken; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.query(PServiceToken(token), status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IService.start(status: PStatusToken; spbLength: Cardinal; spb: BytePtr);
begin
	vTable^.start(PServiceToken(token), status, spbLength, spb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IProvider.vtable: PProviderVTable;
begin
  Result := PProviderVTable(token^.vTable);
end;

class operator IProvider.:= (aToken:  PProviderToken): IProvider;
begin
  Result.token := aToken;
end;

class operator IProvider.:= (intf: IProvider): PProviderToken;
begin
  Result := intf.token;
end;

class operator IProvider.:= (impl: IProviderImpl): IProvider;
begin
  Result := impl.intf;
end;

class operator IProvider.= (a: IProvider; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IProvider.= (a,b: IProvider): boolean;
begin
  Result := a.token = b.token;
end;

procedure IProvider.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IProvider.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IProvider.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IProvider.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IProvider.attachDatabase(status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken;
begin
	Result := vTable^.attachDatabase(PProviderToken(token), status, fileName, dpbLength, dpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IProvider.createDatabase(status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken;
begin
	Result := vTable^.createDatabase(PProviderToken(token), status, fileName, dpbLength, dpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IProvider.attachServiceManager(status: PStatusToken; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): PServiceToken;
begin
	Result := vTable^.attachServiceManager(PProviderToken(token), status, service, spbLength, spb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IProvider.shutdown(status: PStatusToken; timeout: Cardinal; reason: Integer);
begin
	vTable^.shutdown(PProviderToken(token), status, timeout, reason);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IProvider.setDbCryptCallback(status: PStatusToken; cryptCallback: PCryptKeyCallbackToken);
begin
	vTable^.setDbCryptCallback(PProviderToken(token), status, cryptCallback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDtcStart.vtable: PDtcStartVTable;
begin
  Result := PDtcStartVTable(token^.vTable);
end;

class operator IDtcStart.:= (aToken:  PDtcStartToken): IDtcStart;
begin
  Result.token := aToken;
end;

class operator IDtcStart.:= (intf: IDtcStart): PDtcStartToken;
begin
  Result := intf.token;
end;

class operator IDtcStart.:= (impl: IDtcStartImpl): IDtcStart;
begin
  Result := impl.intf;
end;

class operator IDtcStart.= (a: IDtcStart; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDtcStart.= (a,b: IDtcStart): boolean;
begin
  Result := a.token = b.token;
end;

procedure IDtcStart.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IDtcStart.addAttachment(status: PStatusToken; att: PAttachmentToken);
begin
	vTable^.addAttachment(PDtcStartToken(token), status, att);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IDtcStart.addWithTpb(status: PStatusToken; att: PAttachmentToken; length: Cardinal; tpb: BytePtr);
begin
	vTable^.addWithTpb(PDtcStartToken(token), status, att, length, tpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDtcStart.start(status: PStatusToken): PTransactionToken;
begin
	Result := vTable^.start(PDtcStartToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDtc.vtable: PDtcVTable;
begin
  Result := PDtcVTable(token^.vTable);
end;

class operator IDtc.:= (aToken:  PDtcToken): IDtc;
begin
  Result.token := aToken;
end;

class operator IDtc.:= (intf: IDtc): PDtcToken;
begin
  Result := intf.token;
end;

class operator IDtc.:= (impl: IDtcImpl): IDtc;
begin
  Result := impl.intf;
end;

class operator IDtc.= (a: IDtc; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDtc.= (a,b: IDtc): boolean;
begin
  Result := a.token = b.token;
end;

function IDtc.join(status: PStatusToken; one: PTransactionToken; two: PTransactionToken): PTransactionToken;
begin
	Result := vTable^.join(PDtcToken(token), status, one, two);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDtc.startBuilder(status: PStatusToken): PDtcStartToken;
begin
	Result := vTable^.startBuilder(PDtcToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAuth.vtable: PAuthVTable;
begin
  Result := PAuthVTable(token^.vTable);
end;

class operator IAuth.:= (aToken:  PAuthToken): IAuth;
begin
  Result.token := aToken;
end;

class operator IAuth.:= (intf: IAuth): PAuthToken;
begin
  Result := intf.token;
end;

class operator IAuth.:= (impl: IAuthImpl): IAuth;
begin
  Result := impl.intf;
end;

class operator IAuth.= (a: IAuth; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IAuth.= (a,b: IAuth): boolean;
begin
  Result := a.token = b.token;
end;

procedure IAuth.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IAuth.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IAuth.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IAuth.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IWriter.vtable: PWriterVTable;
begin
  Result := PWriterVTable(token^.vTable);
end;

class operator IWriter.:= (aToken:  PWriterToken): IWriter;
begin
  Result.token := aToken;
end;

class operator IWriter.:= (intf: IWriter): PWriterToken;
begin
  Result := intf.token;
end;

class operator IWriter.:= (impl: IWriterImpl): IWriter;
begin
  Result := impl.intf;
end;

class operator IWriter.= (a: IWriter; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IWriter.= (a,b: IWriter): boolean;
begin
  Result := a.token = b.token;
end;

procedure IWriter.reset();
begin
	vTable^.reset(PWriterToken(token));
end;

procedure IWriter.add(status: PStatusToken; name: PAnsiChar);
begin
	vTable^.add(PWriterToken(token), status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IWriter.setType(status: PStatusToken; value: PAnsiChar);
begin
	vTable^.setType(PWriterToken(token), status, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IWriter.setDb(status: PStatusToken; value: PAnsiChar);
begin
	vTable^.setDb(PWriterToken(token), status, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IServerBlock.vtable: PServerBlockVTable;
begin
  Result := PServerBlockVTable(token^.vTable);
end;

class operator IServerBlock.:= (aToken:  PServerBlockToken): IServerBlock;
begin
  Result.token := aToken;
end;

class operator IServerBlock.:= (intf: IServerBlock): PServerBlockToken;
begin
  Result := intf.token;
end;

class operator IServerBlock.:= (impl: IServerBlockImpl): IServerBlock;
begin
  Result := impl.intf;
end;

class operator IServerBlock.= (a: IServerBlock; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IServerBlock.= (a,b: IServerBlock): boolean;
begin
  Result := a.token = b.token;
end;

function IServerBlock.getLogin(): PAnsiChar;
begin
	Result := vTable^.getLogin(PServerBlockToken(token));
end;

function IServerBlock.getData(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getData(PServerBlockToken(token), length);
end;

procedure IServerBlock.putData(status: PStatusToken; length: Cardinal; data: Pointer);
begin
	vTable^.putData(PServerBlockToken(token), status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IServerBlock.newKey(status: PStatusToken): PCryptKeyToken;
begin
	Result := vTable^.newKey(PServerBlockToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IClientBlock.vtable: PClientBlockVTable;
begin
  Result := PClientBlockVTable(token^.vTable);
end;

class operator IClientBlock.:= (aToken:  PClientBlockToken): IClientBlock;
begin
  Result.token := aToken;
end;

class operator IClientBlock.:= (intf: IClientBlock): PClientBlockToken;
begin
  Result := intf.token;
end;

class operator IClientBlock.:= (impl: IClientBlockImpl): IClientBlock;
begin
  Result := impl.intf;
end;

class operator IClientBlock.= (a: IClientBlock; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IClientBlock.= (a,b: IClientBlock): boolean;
begin
  Result := a.token = b.token;
end;

procedure IClientBlock.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IClientBlock.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IClientBlock.getLogin(): PAnsiChar;
begin
	Result := vTable^.getLogin(PClientBlockToken(token));
end;

function IClientBlock.getPassword(): PAnsiChar;
begin
	Result := vTable^.getPassword(PClientBlockToken(token));
end;

function IClientBlock.getData(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getData(PClientBlockToken(token), length);
end;

procedure IClientBlock.putData(status: PStatusToken; length: Cardinal; data: Pointer);
begin
	vTable^.putData(PClientBlockToken(token), status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IClientBlock.newKey(status: PStatusToken): PCryptKeyToken;
begin
	Result := vTable^.newKey(PClientBlockToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IClientBlock.getAuthBlock(status: PStatusToken): PAuthBlockToken;
begin
	Result := vTable^.getAuthBlock(PClientBlockToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IServer.vtable: PServerVTable;
begin
  Result := PServerVTable(token^.vTable);
end;

class operator IServer.:= (aToken:  PServerToken): IServer;
begin
  Result.token := aToken;
end;

class operator IServer.:= (intf: IServer): PServerToken;
begin
  Result := intf.token;
end;

class operator IServer.:= (impl: IServerImpl): IServer;
begin
  Result := impl.intf;
end;

class operator IServer.= (a: IServer; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IServer.= (a,b: IServer): boolean;
begin
  Result := a.token = b.token;
end;

procedure IServer.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IServer.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IServer.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IServer.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IServer.authenticate(status: PStatusToken; sBlock: PServerBlockToken; writerInterface: PWriterToken): Integer;
begin
	Result := vTable^.authenticate(PServerToken(token), status, sBlock, writerInterface);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IServer.setDbCryptCallback(status: PStatusToken; cryptCallback: PCryptKeyCallbackToken);
begin
	vTable^.setDbCryptCallback(PServerToken(token), status, cryptCallback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IClient.vtable: PClientVTable;
begin
  Result := PClientVTable(token^.vTable);
end;

class operator IClient.:= (aToken:  PClientToken): IClient;
begin
  Result.token := aToken;
end;

class operator IClient.:= (intf: IClient): PClientToken;
begin
  Result := intf.token;
end;

class operator IClient.:= (impl: IClientImpl): IClient;
begin
  Result := impl.intf;
end;

class operator IClient.= (a: IClient; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IClient.= (a,b: IClient): boolean;
begin
  Result := a.token = b.token;
end;

procedure IClient.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IClient.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IClient.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IClient.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IClient.authenticate(status: PStatusToken; cBlock: PClientBlockToken): Integer;
begin
	Result := vTable^.authenticate(PClientToken(token), status, cBlock);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUserField.vtable: PUserFieldVTable;
begin
  Result := PUserFieldVTable(token^.vTable);
end;

class operator IUserField.:= (aToken:  PUserFieldToken): IUserField;
begin
  Result.token := aToken;
end;

class operator IUserField.:= (intf: IUserField): PUserFieldToken;
begin
  Result := intf.token;
end;

class operator IUserField.:= (impl: IUserFieldImpl): IUserField;
begin
  Result := impl.intf;
end;

class operator IUserField.= (a: IUserField; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUserField.= (a,b: IUserField): boolean;
begin
  Result := a.token = b.token;
end;

function IUserField.entered(): Integer;
begin
	Result := vTable^.entered(PUserFieldToken(token));
end;

function IUserField.specified(): Integer;
begin
	Result := vTable^.specified(PUserFieldToken(token));
end;

procedure IUserField.setEntered(status: PStatusToken; newValue: Integer);
begin
	vTable^.setEntered(PUserFieldToken(token), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ICharUserField.vtable: PCharUserFieldVTable;
begin
  Result := PCharUserFieldVTable(token^.vTable);
end;

class operator ICharUserField.:= (aToken:  PCharUserFieldToken): ICharUserField;
begin
  Result.token := aToken;
end;

class operator ICharUserField.:= (intf: ICharUserField): PCharUserFieldToken;
begin
  Result := intf.token;
end;

class operator ICharUserField.:= (impl: ICharUserFieldImpl): ICharUserField;
begin
  Result := impl.intf;
end;

class operator ICharUserField.= (a: ICharUserField; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ICharUserField.= (a,b: ICharUserField): boolean;
begin
  Result := a.token = b.token;
end;

function ICharUserField.entered(): Integer;
begin
	Result := vTable^.entered(PUserFieldToken(token));
end;

function ICharUserField.specified(): Integer;
begin
	Result := vTable^.specified(PUserFieldToken(token));
end;

procedure ICharUserField.setEntered(status: PStatusToken; newValue: Integer);
begin
	vTable^.setEntered(PUserFieldToken(token), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ICharUserField.get(): PAnsiChar;
begin
	Result := vTable^.get(PCharUserFieldToken(token));
end;

procedure ICharUserField.set_(status: PStatusToken; newValue: PAnsiChar);
begin
	vTable^.set_(PCharUserFieldToken(token), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IIntUserField.vtable: PIntUserFieldVTable;
begin
  Result := PIntUserFieldVTable(token^.vTable);
end;

class operator IIntUserField.:= (aToken:  PIntUserFieldToken): IIntUserField;
begin
  Result.token := aToken;
end;

class operator IIntUserField.:= (intf: IIntUserField): PIntUserFieldToken;
begin
  Result := intf.token;
end;

class operator IIntUserField.:= (impl: IIntUserFieldImpl): IIntUserField;
begin
  Result := impl.intf;
end;

class operator IIntUserField.= (a: IIntUserField; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IIntUserField.= (a,b: IIntUserField): boolean;
begin
  Result := a.token = b.token;
end;

function IIntUserField.entered(): Integer;
begin
	Result := vTable^.entered(PUserFieldToken(token));
end;

function IIntUserField.specified(): Integer;
begin
	Result := vTable^.specified(PUserFieldToken(token));
end;

procedure IIntUserField.setEntered(status: PStatusToken; newValue: Integer);
begin
	vTable^.setEntered(PUserFieldToken(token), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IIntUserField.get(): Integer;
begin
	Result := vTable^.get(PIntUserFieldToken(token));
end;

procedure IIntUserField.set_(status: PStatusToken; newValue: Integer);
begin
	vTable^.set_(PIntUserFieldToken(token), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUser.vtable: PUserVTable;
begin
  Result := PUserVTable(token^.vTable);
end;

class operator IUser.:= (aToken:  PUserToken): IUser;
begin
  Result.token := aToken;
end;

class operator IUser.:= (intf: IUser): PUserToken;
begin
  Result := intf.token;
end;

class operator IUser.:= (impl: IUserImpl): IUser;
begin
  Result := impl.intf;
end;

class operator IUser.= (a: IUser; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUser.= (a,b: IUser): boolean;
begin
  Result := a.token = b.token;
end;

function IUser.operation(): Cardinal;
begin
	Result := vTable^.operation(PUserToken(token));
end;

function IUser.userName(): PCharUserFieldToken;
begin
	Result := vTable^.userName(PUserToken(token));
end;

function IUser.password(): PCharUserFieldToken;
begin
	Result := vTable^.password(PUserToken(token));
end;

function IUser.firstName(): PCharUserFieldToken;
begin
	Result := vTable^.firstName(PUserToken(token));
end;

function IUser.lastName(): PCharUserFieldToken;
begin
	Result := vTable^.lastName(PUserToken(token));
end;

function IUser.middleName(): PCharUserFieldToken;
begin
	Result := vTable^.middleName(PUserToken(token));
end;

function IUser.comment(): PCharUserFieldToken;
begin
	Result := vTable^.comment(PUserToken(token));
end;

function IUser.attributes(): PCharUserFieldToken;
begin
	Result := vTable^.attributes(PUserToken(token));
end;

function IUser.active(): PIntUserFieldToken;
begin
	Result := vTable^.active(PUserToken(token));
end;

function IUser.admin(): PIntUserFieldToken;
begin
	Result := vTable^.admin(PUserToken(token));
end;

procedure IUser.clear(status: PStatusToken);
begin
	vTable^.clear(PUserToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IListUsers.vtable: PListUsersVTable;
begin
  Result := PListUsersVTable(token^.vTable);
end;

class operator IListUsers.:= (aToken:  PListUsersToken): IListUsers;
begin
  Result.token := aToken;
end;

class operator IListUsers.:= (intf: IListUsers): PListUsersToken;
begin
  Result := intf.token;
end;

class operator IListUsers.:= (impl: IListUsersImpl): IListUsers;
begin
  Result := impl.intf;
end;

class operator IListUsers.= (a: IListUsers; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IListUsers.= (a,b: IListUsers): boolean;
begin
  Result := a.token = b.token;
end;

procedure IListUsers.list(status: PStatusToken; user: PUserToken);
begin
	vTable^.list(PListUsersToken(token), status, user);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ILogonInfo.vtable: PLogonInfoVTable;
begin
  Result := PLogonInfoVTable(token^.vTable);
end;

class operator ILogonInfo.:= (aToken:  PLogonInfoToken): ILogonInfo;
begin
  Result.token := aToken;
end;

class operator ILogonInfo.:= (intf: ILogonInfo): PLogonInfoToken;
begin
  Result := intf.token;
end;

class operator ILogonInfo.:= (impl: ILogonInfoImpl): ILogonInfo;
begin
  Result := impl.intf;
end;

class operator ILogonInfo.= (a: ILogonInfo; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ILogonInfo.= (a,b: ILogonInfo): boolean;
begin
  Result := a.token = b.token;
end;

function ILogonInfo.name(): PAnsiChar;
begin
	Result := vTable^.name(PLogonInfoToken(token));
end;

function ILogonInfo.role(): PAnsiChar;
begin
	Result := vTable^.role(PLogonInfoToken(token));
end;

function ILogonInfo.networkProtocol(): PAnsiChar;
begin
	Result := vTable^.networkProtocol(PLogonInfoToken(token));
end;

function ILogonInfo.remoteAddress(): PAnsiChar;
begin
	Result := vTable^.remoteAddress(PLogonInfoToken(token));
end;

function ILogonInfo.authBlock(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.authBlock(PLogonInfoToken(token), length);
end;

function ILogonInfo.attachment(status: PStatusToken): PAttachmentToken;
begin
	Result := vTable^.attachment(PLogonInfoToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ILogonInfo.transaction(status: PStatusToken): PTransactionToken;
begin
	Result := vTable^.transaction(PLogonInfoToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IManagement.vtable: PManagementVTable;
begin
  Result := PManagementVTable(token^.vTable);
end;

class operator IManagement.:= (aToken:  PManagementToken): IManagement;
begin
  Result.token := aToken;
end;

class operator IManagement.:= (intf: IManagement): PManagementToken;
begin
  Result := intf.token;
end;

class operator IManagement.:= (impl: IManagementImpl): IManagement;
begin
  Result := impl.intf;
end;

class operator IManagement.= (a: IManagement; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IManagement.= (a,b: IManagement): boolean;
begin
  Result := a.token = b.token;
end;

procedure IManagement.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IManagement.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IManagement.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IManagement.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

procedure IManagement.start(status: PStatusToken; logonInfo: PLogonInfoToken);
begin
	vTable^.start(PManagementToken(token), status, logonInfo);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IManagement.execute(status: PStatusToken; user: PUserToken; callback: PListUsersToken): Integer;
begin
	Result := vTable^.execute(PManagementToken(token), status, user, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IManagement.commit(status: PStatusToken);
begin
	vTable^.commit(PManagementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IManagement.rollback(status: PStatusToken);
begin
	vTable^.rollback(PManagementToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAuthBlock.vtable: PAuthBlockVTable;
begin
  Result := PAuthBlockVTable(token^.vTable);
end;

class operator IAuthBlock.:= (aToken:  PAuthBlockToken): IAuthBlock;
begin
  Result.token := aToken;
end;

class operator IAuthBlock.:= (intf: IAuthBlock): PAuthBlockToken;
begin
  Result := intf.token;
end;

class operator IAuthBlock.:= (impl: IAuthBlockImpl): IAuthBlock;
begin
  Result := impl.intf;
end;

class operator IAuthBlock.= (a: IAuthBlock; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IAuthBlock.= (a,b: IAuthBlock): boolean;
begin
  Result := a.token = b.token;
end;

function IAuthBlock.getType(): PAnsiChar;
begin
	Result := vTable^.getType(PAuthBlockToken(token));
end;

function IAuthBlock.getName(): PAnsiChar;
begin
	Result := vTable^.getName(PAuthBlockToken(token));
end;

function IAuthBlock.getPlugin(): PAnsiChar;
begin
	Result := vTable^.getPlugin(PAuthBlockToken(token));
end;

function IAuthBlock.getSecurityDb(): PAnsiChar;
begin
	Result := vTable^.getSecurityDb(PAuthBlockToken(token));
end;

function IAuthBlock.getOriginalPlugin(): PAnsiChar;
begin
	Result := vTable^.getOriginalPlugin(PAuthBlockToken(token));
end;

function IAuthBlock.next(status: PStatusToken): Boolean;
begin
	Result := vTable^.next(PAuthBlockToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IAuthBlock.first(status: PStatusToken): Boolean;
begin
	Result := vTable^.first(PAuthBlockToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IWireCryptPlugin.vtable: PWireCryptPluginVTable;
begin
  Result := PWireCryptPluginVTable(token^.vTable);
end;

class operator IWireCryptPlugin.:= (aToken:  PWireCryptPluginToken): IWireCryptPlugin;
begin
  Result.token := aToken;
end;

class operator IWireCryptPlugin.:= (intf: IWireCryptPlugin): PWireCryptPluginToken;
begin
  Result := intf.token;
end;

class operator IWireCryptPlugin.:= (impl: IWireCryptPluginImpl): IWireCryptPlugin;
begin
  Result := impl.intf;
end;

class operator IWireCryptPlugin.= (a: IWireCryptPlugin; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IWireCryptPlugin.= (a,b: IWireCryptPlugin): boolean;
begin
  Result := a.token = b.token;
end;

procedure IWireCryptPlugin.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IWireCryptPlugin.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IWireCryptPlugin.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IWireCryptPlugin.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IWireCryptPlugin.getKnownTypes(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getKnownTypes(PWireCryptPluginToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IWireCryptPlugin.setKey(status: PStatusToken; key: PCryptKeyToken);
begin
	vTable^.setKey(PWireCryptPluginToken(token), status, key);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IWireCryptPlugin.encrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.encrypt(PWireCryptPluginToken(token), status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IWireCryptPlugin.decrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.decrypt(PWireCryptPluginToken(token), status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IWireCryptPlugin.getSpecificData(status: PStatusToken; keyType: PAnsiChar; length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getSpecificData(PWireCryptPluginToken(token), status, keyType, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IWireCryptPlugin.setSpecificData(status: PStatusToken; keyType: PAnsiChar; length: Cardinal; data: BytePtr);
begin
	vTable^.setSpecificData(PWireCryptPluginToken(token), status, keyType, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ICryptKeyCallback.vtable: PCryptKeyCallbackVTable;
begin
  Result := PCryptKeyCallbackVTable(token^.vTable);
end;

class operator ICryptKeyCallback.:= (aToken:  PCryptKeyCallbackToken): ICryptKeyCallback;
begin
  Result.token := aToken;
end;

class operator ICryptKeyCallback.:= (intf: ICryptKeyCallback): PCryptKeyCallbackToken;
begin
  Result := intf.token;
end;

class operator ICryptKeyCallback.:= (impl: ICryptKeyCallbackImpl): ICryptKeyCallback;
begin
  Result := impl.intf;
end;

class operator ICryptKeyCallback.= (a: ICryptKeyCallback; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ICryptKeyCallback.= (a,b: ICryptKeyCallback): boolean;
begin
  Result := a.token = b.token;
end;

function ICryptKeyCallback.callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal;
begin
	Result := vTable^.callback(PCryptKeyCallbackToken(token), dataLength, data, bufferLength, buffer);
end;

function IKeyHolderPlugin.vtable: PKeyHolderPluginVTable;
begin
  Result := PKeyHolderPluginVTable(token^.vTable);
end;

class operator IKeyHolderPlugin.:= (aToken:  PKeyHolderPluginToken): IKeyHolderPlugin;
begin
  Result.token := aToken;
end;

class operator IKeyHolderPlugin.:= (intf: IKeyHolderPlugin): PKeyHolderPluginToken;
begin
  Result := intf.token;
end;

class operator IKeyHolderPlugin.:= (impl: IKeyHolderPluginImpl): IKeyHolderPlugin;
begin
  Result := impl.intf;
end;

class operator IKeyHolderPlugin.= (a: IKeyHolderPlugin; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IKeyHolderPlugin.= (a,b: IKeyHolderPlugin): boolean;
begin
  Result := a.token = b.token;
end;

procedure IKeyHolderPlugin.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IKeyHolderPlugin.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IKeyHolderPlugin.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IKeyHolderPlugin.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IKeyHolderPlugin.keyCallback(status: PStatusToken; callback: PCryptKeyCallbackToken): Integer;
begin
	Result := vTable^.keyCallback(PKeyHolderPluginToken(token), status, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IKeyHolderPlugin.keyHandle(status: PStatusToken; keyName: PAnsiChar): PCryptKeyCallbackToken;
begin
	Result := vTable^.keyHandle(PKeyHolderPluginToken(token), status, keyName);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IKeyHolderPlugin.useOnlyOwnKeys(status: PStatusToken): Boolean;
begin
	Result := vTable^.useOnlyOwnKeys(PKeyHolderPluginToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IKeyHolderPlugin.chainHandle(status: PStatusToken): PCryptKeyCallbackToken;
begin
	Result := vTable^.chainHandle(PKeyHolderPluginToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDbCryptInfo.vtable: PDbCryptInfoVTable;
begin
  Result := PDbCryptInfoVTable(token^.vTable);
end;

class operator IDbCryptInfo.:= (aToken:  PDbCryptInfoToken): IDbCryptInfo;
begin
  Result.token := aToken;
end;

class operator IDbCryptInfo.:= (intf: IDbCryptInfo): PDbCryptInfoToken;
begin
  Result := intf.token;
end;

class operator IDbCryptInfo.:= (impl: IDbCryptInfoImpl): IDbCryptInfo;
begin
  Result := impl.intf;
end;

class operator IDbCryptInfo.= (a: IDbCryptInfo; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDbCryptInfo.= (a,b: IDbCryptInfo): boolean;
begin
  Result := a.token = b.token;
end;

procedure IDbCryptInfo.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IDbCryptInfo.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function IDbCryptInfo.getDatabaseFullPath(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getDatabaseFullPath(PDbCryptInfoToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDbCryptPlugin.vtable: PDbCryptPluginVTable;
begin
  Result := PDbCryptPluginVTable(token^.vTable);
end;

class operator IDbCryptPlugin.:= (aToken:  PDbCryptPluginToken): IDbCryptPlugin;
begin
  Result.token := aToken;
end;

class operator IDbCryptPlugin.:= (intf: IDbCryptPlugin): PDbCryptPluginToken;
begin
  Result := intf.token;
end;

class operator IDbCryptPlugin.:= (impl: IDbCryptPluginImpl): IDbCryptPlugin;
begin
  Result := impl.intf;
end;

class operator IDbCryptPlugin.= (a: IDbCryptPlugin; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDbCryptPlugin.= (a,b: IDbCryptPlugin): boolean;
begin
  Result := a.token = b.token;
end;

procedure IDbCryptPlugin.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IDbCryptPlugin.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IDbCryptPlugin.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IDbCryptPlugin.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

procedure IDbCryptPlugin.setKey(status: PStatusToken; length: Cardinal; sources: PKeyHolderPluginTokenPtr; keyName: PAnsiChar);
begin
	vTable^.setKey(PDbCryptPluginToken(token), status, length, sources, keyName);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IDbCryptPlugin.encrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.encrypt(PDbCryptPluginToken(token), status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IDbCryptPlugin.decrypt(status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.decrypt(PDbCryptPluginToken(token), status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IDbCryptPlugin.setInfo(status: PStatusToken; info: PDbCryptInfoToken);
begin
	vTable^.setInfo(PDbCryptPluginToken(token), status, info);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalContext.vtable: PExternalContextVTable;
begin
  Result := PExternalContextVTable(token^.vTable);
end;

class operator IExternalContext.:= (aToken:  PExternalContextToken): IExternalContext;
begin
  Result.token := aToken;
end;

class operator IExternalContext.:= (intf: IExternalContext): PExternalContextToken;
begin
  Result := intf.token;
end;

class operator IExternalContext.:= (impl: IExternalContextImpl): IExternalContext;
begin
  Result := impl.intf;
end;

class operator IExternalContext.= (a: IExternalContext; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IExternalContext.= (a,b: IExternalContext): boolean;
begin
  Result := a.token = b.token;
end;

function IExternalContext.getMaster(): PMasterToken;
begin
	Result := vTable^.getMaster(PExternalContextToken(token));
end;

function IExternalContext.getEngine(status: PStatusToken): PExternalEngineToken;
begin
	Result := vTable^.getEngine(PExternalContextToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalContext.getAttachment(status: PStatusToken): PAttachmentToken;
begin
	Result := vTable^.getAttachment(PExternalContextToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalContext.getTransaction(status: PStatusToken): PTransactionToken;
begin
	Result := vTable^.getTransaction(PExternalContextToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalContext.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(PExternalContextToken(token));
end;

function IExternalContext.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(PExternalContextToken(token));
end;

function IExternalContext.getClientCharSet(): PAnsiChar;
begin
	Result := vTable^.getClientCharSet(PExternalContextToken(token));
end;

function IExternalContext.obtainInfoCode(): Integer;
begin
	Result := vTable^.obtainInfoCode(PExternalContextToken(token));
end;

function IExternalContext.getInfo(code: Integer): Pointer;
begin
	Result := vTable^.getInfo(PExternalContextToken(token), code);
end;

function IExternalContext.setInfo(code: Integer; value: Pointer): Pointer;
begin
	Result := vTable^.setInfo(PExternalContextToken(token), code, value);
end;

function IExternalResultSet.vtable: PExternalResultSetVTable;
begin
  Result := PExternalResultSetVTable(token^.vTable);
end;

class operator IExternalResultSet.:= (aToken:  PExternalResultSetToken): IExternalResultSet;
begin
  Result.token := aToken;
end;

class operator IExternalResultSet.:= (intf: IExternalResultSet): PExternalResultSetToken;
begin
  Result := intf.token;
end;

class operator IExternalResultSet.:= (impl: IExternalResultSetImpl): IExternalResultSet;
begin
  Result := impl.intf;
end;

class operator IExternalResultSet.= (a: IExternalResultSet; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IExternalResultSet.= (a,b: IExternalResultSet): boolean;
begin
  Result := a.token = b.token;
end;

procedure IExternalResultSet.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

function IExternalResultSet.fetch(status: PStatusToken): Boolean;
begin
	Result := vTable^.fetch(PExternalResultSetToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalFunction.vtable: PExternalFunctionVTable;
begin
  Result := PExternalFunctionVTable(token^.vTable);
end;

class operator IExternalFunction.:= (aToken:  PExternalFunctionToken): IExternalFunction;
begin
  Result.token := aToken;
end;

class operator IExternalFunction.:= (intf: IExternalFunction): PExternalFunctionToken;
begin
  Result := intf.token;
end;

class operator IExternalFunction.:= (impl: IExternalFunctionImpl): IExternalFunction;
begin
  Result := impl.intf;
end;

class operator IExternalFunction.= (a: IExternalFunction; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IExternalFunction.= (a,b: IExternalFunction): boolean;
begin
  Result := a.token = b.token;
end;

procedure IExternalFunction.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IExternalFunction.getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(PExternalFunctionToken(token), status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IExternalFunction.execute(status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer);
begin
	vTable^.execute(PExternalFunctionToken(token), status, context, inMsg, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalProcedure.vtable: PExternalProcedureVTable;
begin
  Result := PExternalProcedureVTable(token^.vTable);
end;

class operator IExternalProcedure.:= (aToken:  PExternalProcedureToken): IExternalProcedure;
begin
  Result.token := aToken;
end;

class operator IExternalProcedure.:= (intf: IExternalProcedure): PExternalProcedureToken;
begin
  Result := intf.token;
end;

class operator IExternalProcedure.:= (impl: IExternalProcedureImpl): IExternalProcedure;
begin
  Result := impl.intf;
end;

class operator IExternalProcedure.= (a: IExternalProcedure; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IExternalProcedure.= (a,b: IExternalProcedure): boolean;
begin
  Result := a.token = b.token;
end;

procedure IExternalProcedure.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IExternalProcedure.getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(PExternalProcedureToken(token), status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalProcedure.open(status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer): PExternalResultSetToken;
begin
	Result := vTable^.open(PExternalProcedureToken(token), status, context, inMsg, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalTrigger.vtable: PExternalTriggerVTable;
begin
  Result := PExternalTriggerVTable(token^.vTable);
end;

class operator IExternalTrigger.:= (aToken:  PExternalTriggerToken): IExternalTrigger;
begin
  Result.token := aToken;
end;

class operator IExternalTrigger.:= (intf: IExternalTrigger): PExternalTriggerToken;
begin
  Result := intf.token;
end;

class operator IExternalTrigger.:= (impl: IExternalTriggerImpl): IExternalTrigger;
begin
  Result := impl.intf;
end;

class operator IExternalTrigger.= (a: IExternalTrigger; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IExternalTrigger.= (a,b: IExternalTrigger): boolean;
begin
  Result := a.token = b.token;
end;

procedure IExternalTrigger.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IExternalTrigger.getCharSet(status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(PExternalTriggerToken(token), status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IExternalTrigger.execute(status: PStatusToken; context: PExternalContextToken; action: Cardinal; oldMsg: Pointer; newMsg: Pointer);
begin
	vTable^.execute(PExternalTriggerToken(token), status, context, action, oldMsg, newMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.vtable: PRoutineMetadataVTable;
begin
  Result := PRoutineMetadataVTable(token^.vTable);
end;

class operator IRoutineMetadata.:= (aToken:  PRoutineMetadataToken): IRoutineMetadata;
begin
  Result.token := aToken;
end;

class operator IRoutineMetadata.:= (intf: IRoutineMetadata): PRoutineMetadataToken;
begin
  Result := intf.token;
end;

class operator IRoutineMetadata.:= (impl: IRoutineMetadataImpl): IRoutineMetadata;
begin
  Result := impl.intf;
end;

class operator IRoutineMetadata.= (a: IRoutineMetadata; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IRoutineMetadata.= (a,b: IRoutineMetadata): boolean;
begin
  Result := a.token = b.token;
end;

function IRoutineMetadata.getPackage(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getPackage(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getName(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getName(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getEntryPoint(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getEntryPoint(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getBody(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getBody(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getInputMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getInputMetadata(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getOutputMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getOutputMetadata(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getTriggerMetadata(status: PStatusToken): PMessageMetadataToken;
begin
	Result := vTable^.getTriggerMetadata(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getTriggerTable(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getTriggerTable(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IRoutineMetadata.getTriggerType(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getTriggerType(PRoutineMetadataToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalEngine.vtable: PExternalEngineVTable;
begin
  Result := PExternalEngineVTable(token^.vTable);
end;

class operator IExternalEngine.:= (aToken:  PExternalEngineToken): IExternalEngine;
begin
  Result.token := aToken;
end;

class operator IExternalEngine.:= (intf: IExternalEngine): PExternalEngineToken;
begin
  Result := intf.token;
end;

class operator IExternalEngine.:= (impl: IExternalEngineImpl): IExternalEngine;
begin
  Result := impl.intf;
end;

class operator IExternalEngine.= (a: IExternalEngine; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IExternalEngine.= (a,b: IExternalEngine): boolean;
begin
  Result := a.token = b.token;
end;

procedure IExternalEngine.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IExternalEngine.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IExternalEngine.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IExternalEngine.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

procedure IExternalEngine.open(status: PStatusToken; context: PExternalContextToken; charSet: PAnsiChar; charSetSize: Cardinal);
begin
	vTable^.open(PExternalEngineToken(token), status, context, charSet, charSetSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IExternalEngine.openAttachment(status: PStatusToken; context: PExternalContextToken);
begin
	vTable^.openAttachment(PExternalEngineToken(token), status, context);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IExternalEngine.closeAttachment(status: PStatusToken; context: PExternalContextToken);
begin
	vTable^.closeAttachment(PExternalEngineToken(token), status, context);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalEngine.makeFunction(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalFunctionToken;
begin
	Result := vTable^.makeFunction(PExternalEngineToken(token), status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalEngine.makeProcedure(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalProcedureToken;
begin
	Result := vTable^.makeProcedure(PExternalEngineToken(token), status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IExternalEngine.makeTrigger(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken): PExternalTriggerToken;
begin
	Result := vTable^.makeTrigger(PExternalEngineToken(token), status, context, metadata, fieldsBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITimer.vtable: PTimerVTable;
begin
  Result := PTimerVTable(token^.vTable);
end;

class operator ITimer.:= (aToken:  PTimerToken): ITimer;
begin
  Result.token := aToken;
end;

class operator ITimer.:= (intf: ITimer): PTimerToken;
begin
  Result := intf.token;
end;

class operator ITimer.:= (impl: ITimerImpl): ITimer;
begin
  Result := impl.intf;
end;

class operator ITimer.= (a: ITimer; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITimer.= (a,b: ITimer): boolean;
begin
  Result := a.token = b.token;
end;

procedure ITimer.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function ITimer.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure ITimer.handler();
begin
	vTable^.handler(PTimerToken(token));
end;

function ITimerControl.vtable: PTimerControlVTable;
begin
  Result := PTimerControlVTable(token^.vTable);
end;

class operator ITimerControl.:= (aToken:  PTimerControlToken): ITimerControl;
begin
  Result.token := aToken;
end;

class operator ITimerControl.:= (intf: ITimerControl): PTimerControlToken;
begin
  Result := intf.token;
end;

class operator ITimerControl.:= (impl: ITimerControlImpl): ITimerControl;
begin
  Result := impl.intf;
end;

class operator ITimerControl.= (a: ITimerControl; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITimerControl.= (a,b: ITimerControl): boolean;
begin
  Result := a.token = b.token;
end;

procedure ITimerControl.start(status: PStatusToken; timer: PTimerToken; microSeconds: QWord);
begin
	vTable^.start(PTimerControlToken(token), status, timer, microSeconds);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure ITimerControl.stop(status: PStatusToken; timer: PTimerToken);
begin
	vTable^.stop(PTimerControlToken(token), status, timer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IVersionCallback.vtable: PVersionCallbackVTable;
begin
  Result := PVersionCallbackVTable(token^.vTable);
end;

class operator IVersionCallback.:= (aToken:  PVersionCallbackToken): IVersionCallback;
begin
  Result.token := aToken;
end;

class operator IVersionCallback.:= (intf: IVersionCallback): PVersionCallbackToken;
begin
  Result := intf.token;
end;

class operator IVersionCallback.:= (impl: IVersionCallbackImpl): IVersionCallback;
begin
  Result := impl.intf;
end;

class operator IVersionCallback.= (a: IVersionCallback; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IVersionCallback.= (a,b: IVersionCallback): boolean;
begin
  Result := a.token = b.token;
end;

procedure IVersionCallback.callback(status: PStatusToken; text: PAnsiChar);
begin
	vTable^.callback(PVersionCallbackToken(token), status, text);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUtil.vtable: PUtilVTable;
begin
  Result := PUtilVTable(token^.vTable);
end;

class operator IUtil.:= (aToken:  PUtilToken): IUtil;
begin
  Result.token := aToken;
end;

class operator IUtil.:= (intf: IUtil): PUtilToken;
begin
  Result := intf.token;
end;

class operator IUtil.:= (impl: IUtilImpl): IUtil;
begin
  Result := impl.intf;
end;

class operator IUtil.= (a: IUtil; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUtil.= (a,b: IUtil): boolean;
begin
  Result := a.token = b.token;
end;

procedure IUtil.getFbVersion(status: PStatusToken; att: PAttachmentToken; callback: PVersionCallbackToken);
begin
	vTable^.getFbVersion(PUtilToken(token), status, att, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.loadBlob(status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean);
begin
	vTable^.loadBlob(PUtilToken(token), status, blobId, att, tra, file_, txt);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.dumpBlob(status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean);
begin
	vTable^.dumpBlob(PUtilToken(token), status, blobId, att, tra, file_, txt);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.getPerfCounters(status: PStatusToken; att: PAttachmentToken; countersSet: PAnsiChar; counters: Int64Ptr);
begin
	vTable^.getPerfCounters(PUtilToken(token), status, att, countersSet, counters);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUtil.executeCreateDatabase(status: PStatusToken; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): PAttachmentToken;
begin
	Result := vTable^.executeCreateDatabase(PUtilToken(token), status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr);
begin
	vTable^.decodeDate(PUtilToken(token), date, year, month, day);
end;

procedure IUtil.decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr);
begin
	vTable^.decodeTime(PUtilToken(token), time, hours, minutes, seconds, fractions);
end;

function IUtil.encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE;
begin
	Result := vTable^.encodeDate(PUtilToken(token), year, month, day);
end;

function IUtil.encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME;
begin
	Result := vTable^.encodeTime(PUtilToken(token), hours, minutes, seconds, fractions);
end;

function IUtil.formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: PStatusToken): Cardinal;
begin
	Result := vTable^.formatStatus(PUtilToken(token), buffer, bufferSize, status);
end;

function IUtil.getClientVersion(): Cardinal;
begin
	Result := vTable^.getClientVersion(PUtilToken(token));
end;

function IUtil.getXpbBuilder(status: PStatusToken; kind: Cardinal; buf: BytePtr; len: Cardinal): PXpbBuilderToken;
begin
	Result := vTable^.getXpbBuilder(PUtilToken(token), status, kind, buf, len);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUtil.setOffsets(status: PStatusToken; metadata: PMessageMetadataToken; callback: POffsetsCallbackToken): Cardinal;
begin
	Result := vTable^.setOffsets(PUtilToken(token), status, metadata, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUtil.getDecFloat16(status: PStatusToken): PDecFloat16Token;
begin
	Result := vTable^.getDecFloat16(PUtilToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUtil.getDecFloat34(status: PStatusToken): PDecFloat34Token;
begin
	Result := vTable^.getDecFloat34(PUtilToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.decodeTimeTz(status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeTz(PUtilToken(token), status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.decodeTimeStampTz(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeStampTz(PUtilToken(token), status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.encodeTimeTz(status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
begin
	vTable^.encodeTimeTz(PUtilToken(token), status, timeTz, hours, minutes, seconds, fractions, timeZone);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.encodeTimeStampTz(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
begin
	vTable^.encodeTimeStampTz(PUtilToken(token), status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZone);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUtil.getInt128(status: PStatusToken): PInt128Token;
begin
	Result := vTable^.getInt128(PUtilToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.decodeTimeTzEx(status: PStatusToken; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeTzEx(PUtilToken(token), status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUtil.decodeTimeStampTzEx(status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeStampTzEx(PUtilToken(token), status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IOffsetsCallback.vtable: POffsetsCallbackVTable;
begin
  Result := POffsetsCallbackVTable(token^.vTable);
end;

class operator IOffsetsCallback.:= (aToken:  POffsetsCallbackToken): IOffsetsCallback;
begin
  Result.token := aToken;
end;

class operator IOffsetsCallback.:= (intf: IOffsetsCallback): POffsetsCallbackToken;
begin
  Result := intf.token;
end;

class operator IOffsetsCallback.:= (impl: IOffsetsCallbackImpl): IOffsetsCallback;
begin
  Result := impl.intf;
end;

class operator IOffsetsCallback.= (a: IOffsetsCallback; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IOffsetsCallback.= (a,b: IOffsetsCallback): boolean;
begin
  Result := a.token = b.token;
end;

procedure IOffsetsCallback.setOffset(status: PStatusToken; index: Cardinal; offset: Cardinal; nullOffset: Cardinal);
begin
	vTable^.setOffset(POffsetsCallbackToken(token), status, index, offset, nullOffset);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.vtable: PXpbBuilderVTable;
begin
  Result := PXpbBuilderVTable(token^.vTable);
end;

class operator IXpbBuilder.:= (aToken:  PXpbBuilderToken): IXpbBuilder;
begin
  Result.token := aToken;
end;

class operator IXpbBuilder.:= (intf: IXpbBuilder): PXpbBuilderToken;
begin
  Result := intf.token;
end;

class operator IXpbBuilder.:= (impl: IXpbBuilderImpl): IXpbBuilder;
begin
  Result := impl.intf;
end;

class operator IXpbBuilder.= (a: IXpbBuilder; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IXpbBuilder.= (a,b: IXpbBuilder): boolean;
begin
  Result := a.token = b.token;
end;

procedure IXpbBuilder.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IXpbBuilder.clear(status: PStatusToken);
begin
	vTable^.clear(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.removeCurrent(status: PStatusToken);
begin
	vTable^.removeCurrent(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.insertInt(status: PStatusToken; tag: Byte; value: Integer);
begin
	vTable^.insertInt(PXpbBuilderToken(token), status, tag, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.insertBigInt(status: PStatusToken; tag: Byte; value: Int64);
begin
	vTable^.insertBigInt(PXpbBuilderToken(token), status, tag, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.insertBytes(status: PStatusToken; tag: Byte; bytes: Pointer; length: Cardinal);
begin
	vTable^.insertBytes(PXpbBuilderToken(token), status, tag, bytes, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.insertString(status: PStatusToken; tag: Byte; str: PAnsiChar);
begin
	vTable^.insertString(PXpbBuilderToken(token), status, tag, str);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.insertTag(status: PStatusToken; tag: Byte);
begin
	vTable^.insertTag(PXpbBuilderToken(token), status, tag);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.isEof(status: PStatusToken): Boolean;
begin
	Result := vTable^.isEof(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.moveNext(status: PStatusToken);
begin
	vTable^.moveNext(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IXpbBuilder.rewind(status: PStatusToken);
begin
	vTable^.rewind(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.findFirst(status: PStatusToken; tag: Byte): Boolean;
begin
	Result := vTable^.findFirst(PXpbBuilderToken(token), status, tag);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.findNext(status: PStatusToken): Boolean;
begin
	Result := vTable^.findNext(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getTag(status: PStatusToken): Byte;
begin
	Result := vTable^.getTag(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getLength(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getLength(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getInt(status: PStatusToken): Integer;
begin
	Result := vTable^.getInt(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getBigInt(status: PStatusToken): Int64;
begin
	Result := vTable^.getBigInt(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getString(status: PStatusToken): PAnsiChar;
begin
	Result := vTable^.getString(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getBytes(status: PStatusToken): BytePtr;
begin
	Result := vTable^.getBytes(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getBufferLength(status: PStatusToken): Cardinal;
begin
	Result := vTable^.getBufferLength(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IXpbBuilder.getBuffer(status: PStatusToken): BytePtr;
begin
	Result := vTable^.getBuffer(PXpbBuilderToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITraceConnection.vtable: PTraceConnectionVTable;
begin
  Result := PTraceConnectionVTable(token^.vTable);
end;

class operator ITraceConnection.:= (aToken:  PTraceConnectionToken): ITraceConnection;
begin
  Result.token := aToken;
end;

class operator ITraceConnection.:= (intf: ITraceConnection): PTraceConnectionToken;
begin
  Result := intf.token;
end;

class operator ITraceConnection.:= (impl: ITraceConnectionImpl): ITraceConnection;
begin
  Result := impl.intf;
end;

class operator ITraceConnection.= (a: ITraceConnection; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceConnection.= (a,b: ITraceConnection): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(PTraceConnectionToken(token));
end;

function ITraceConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(PTraceConnectionToken(token));
end;

function ITraceConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(PTraceConnectionToken(token));
end;

function ITraceConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(PTraceConnectionToken(token));
end;

function ITraceConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(PTraceConnectionToken(token));
end;

function ITraceConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(PTraceConnectionToken(token));
end;

function ITraceConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(PTraceConnectionToken(token));
end;

function ITraceConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(PTraceConnectionToken(token));
end;

function ITraceConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.vtable: PTraceDatabaseConnectionVTable;
begin
  Result := PTraceDatabaseConnectionVTable(token^.vTable);
end;

class operator ITraceDatabaseConnection.:= (aToken:  PTraceDatabaseConnectionToken): ITraceDatabaseConnection;
begin
  Result.token := aToken;
end;

class operator ITraceDatabaseConnection.:= (intf: ITraceDatabaseConnection): PTraceDatabaseConnectionToken;
begin
  Result := intf.token;
end;

class operator ITraceDatabaseConnection.:= (impl: ITraceDatabaseConnectionImpl): ITraceDatabaseConnection;
begin
  Result := impl.intf;
end;

class operator ITraceDatabaseConnection.= (a: ITraceDatabaseConnection; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceDatabaseConnection.= (a,b: ITraceDatabaseConnection): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceDatabaseConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(PTraceConnectionToken(token));
end;

function ITraceDatabaseConnection.getConnectionID(): Int64;
begin
	Result := vTable^.getConnectionID(PTraceDatabaseConnectionToken(token));
end;

function ITraceDatabaseConnection.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(PTraceDatabaseConnectionToken(token));
end;

function ITraceTransaction.vtable: PTraceTransactionVTable;
begin
  Result := PTraceTransactionVTable(token^.vTable);
end;

class operator ITraceTransaction.:= (aToken:  PTraceTransactionToken): ITraceTransaction;
begin
  Result.token := aToken;
end;

class operator ITraceTransaction.:= (intf: ITraceTransaction): PTraceTransactionToken;
begin
  Result := intf.token;
end;

class operator ITraceTransaction.:= (impl: ITraceTransactionImpl): ITraceTransaction;
begin
  Result := impl.intf;
end;

class operator ITraceTransaction.= (a: ITraceTransaction; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceTransaction.= (a,b: ITraceTransaction): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceTransaction.getTransactionID(): Int64;
begin
	Result := vTable^.getTransactionID(PTraceTransactionToken(token));
end;

function ITraceTransaction.getReadOnly(): Boolean;
begin
	Result := vTable^.getReadOnly(PTraceTransactionToken(token));
end;

function ITraceTransaction.getWait(): Integer;
begin
	Result := vTable^.getWait(PTraceTransactionToken(token));
end;

function ITraceTransaction.getIsolation(): Cardinal;
begin
	Result := vTable^.getIsolation(PTraceTransactionToken(token));
end;

function ITraceTransaction.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceTransactionToken(token));
end;

function ITraceTransaction.getInitialID(): Int64;
begin
	Result := vTable^.getInitialID(PTraceTransactionToken(token));
end;

function ITraceTransaction.getPreviousID(): Int64;
begin
	Result := vTable^.getPreviousID(PTraceTransactionToken(token));
end;

function ITraceParams.vtable: PTraceParamsVTable;
begin
  Result := PTraceParamsVTable(token^.vTable);
end;

class operator ITraceParams.:= (aToken:  PTraceParamsToken): ITraceParams;
begin
  Result.token := aToken;
end;

class operator ITraceParams.:= (intf: ITraceParams): PTraceParamsToken;
begin
  Result := intf.token;
end;

class operator ITraceParams.:= (impl: ITraceParamsImpl): ITraceParams;
begin
  Result := impl.intf;
end;

class operator ITraceParams.= (a: ITraceParams; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceParams.= (a,b: ITraceParams): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceParams.getCount(): Cardinal;
begin
	Result := vTable^.getCount(PTraceParamsToken(token));
end;

function ITraceParams.getParam(idx: Cardinal): dscPtr;
begin
	Result := vTable^.getParam(PTraceParamsToken(token), idx);
end;

function ITraceParams.getTextUTF8(status: PStatusToken; idx: Cardinal): PAnsiChar;
begin
	Result := vTable^.getTextUTF8(PTraceParamsToken(token), status, idx);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITraceStatement.vtable: PTraceStatementVTable;
begin
  Result := PTraceStatementVTable(token^.vTable);
end;

class operator ITraceStatement.:= (aToken:  PTraceStatementToken): ITraceStatement;
begin
  Result.token := aToken;
end;

class operator ITraceStatement.:= (intf: ITraceStatement): PTraceStatementToken;
begin
  Result := intf.token;
end;

class operator ITraceStatement.:= (impl: ITraceStatementImpl): ITraceStatement;
begin
  Result := impl.intf;
end;

class operator ITraceStatement.= (a: ITraceStatement; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceStatement.= (a,b: ITraceStatement): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(PTraceStatementToken(token));
end;

function ITraceStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceStatementToken(token));
end;

function ITraceSQLStatement.vtable: PTraceSQLStatementVTable;
begin
  Result := PTraceSQLStatementVTable(token^.vTable);
end;

class operator ITraceSQLStatement.:= (aToken:  PTraceSQLStatementToken): ITraceSQLStatement;
begin
  Result.token := aToken;
end;

class operator ITraceSQLStatement.:= (intf: ITraceSQLStatement): PTraceSQLStatementToken;
begin
  Result := intf.token;
end;

class operator ITraceSQLStatement.:= (impl: ITraceSQLStatementImpl): ITraceSQLStatement;
begin
  Result := impl.intf;
end;

class operator ITraceSQLStatement.= (a: ITraceSQLStatement; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceSQLStatement.= (a,b: ITraceSQLStatement): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceSQLStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(PTraceStatementToken(token));
end;

function ITraceSQLStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceStatementToken(token));
end;

function ITraceSQLStatement.getText(): PAnsiChar;
begin
	Result := vTable^.getText(PTraceSQLStatementToken(token));
end;

function ITraceSQLStatement.getPlan(): PAnsiChar;
begin
	Result := vTable^.getPlan(PTraceSQLStatementToken(token));
end;

function ITraceSQLStatement.getInputs(): PTraceParamsToken;
begin
	Result := vTable^.getInputs(PTraceSQLStatementToken(token));
end;

function ITraceSQLStatement.getTextUTF8(): PAnsiChar;
begin
	Result := vTable^.getTextUTF8(PTraceSQLStatementToken(token));
end;

function ITraceSQLStatement.getExplainedPlan(): PAnsiChar;
begin
	Result := vTable^.getExplainedPlan(PTraceSQLStatementToken(token));
end;

function ITraceBLRStatement.vtable: PTraceBLRStatementVTable;
begin
  Result := PTraceBLRStatementVTable(token^.vTable);
end;

class operator ITraceBLRStatement.:= (aToken:  PTraceBLRStatementToken): ITraceBLRStatement;
begin
  Result.token := aToken;
end;

class operator ITraceBLRStatement.:= (intf: ITraceBLRStatement): PTraceBLRStatementToken;
begin
  Result := intf.token;
end;

class operator ITraceBLRStatement.:= (impl: ITraceBLRStatementImpl): ITraceBLRStatement;
begin
  Result := impl.intf;
end;

class operator ITraceBLRStatement.= (a: ITraceBLRStatement; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceBLRStatement.= (a,b: ITraceBLRStatement): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceBLRStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(PTraceStatementToken(token));
end;

function ITraceBLRStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceStatementToken(token));
end;

function ITraceBLRStatement.getData(): BytePtr;
begin
	Result := vTable^.getData(PTraceBLRStatementToken(token));
end;

function ITraceBLRStatement.getDataLength(): Cardinal;
begin
	Result := vTable^.getDataLength(PTraceBLRStatementToken(token));
end;

function ITraceBLRStatement.getText(): PAnsiChar;
begin
	Result := vTable^.getText(PTraceBLRStatementToken(token));
end;

function ITraceDYNRequest.vtable: PTraceDYNRequestVTable;
begin
  Result := PTraceDYNRequestVTable(token^.vTable);
end;

class operator ITraceDYNRequest.:= (aToken:  PTraceDYNRequestToken): ITraceDYNRequest;
begin
  Result.token := aToken;
end;

class operator ITraceDYNRequest.:= (intf: ITraceDYNRequest): PTraceDYNRequestToken;
begin
  Result := intf.token;
end;

class operator ITraceDYNRequest.:= (impl: ITraceDYNRequestImpl): ITraceDYNRequest;
begin
  Result := impl.intf;
end;

class operator ITraceDYNRequest.= (a: ITraceDYNRequest; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceDYNRequest.= (a,b: ITraceDYNRequest): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceDYNRequest.getData(): BytePtr;
begin
	Result := vTable^.getData(PTraceDYNRequestToken(token));
end;

function ITraceDYNRequest.getDataLength(): Cardinal;
begin
	Result := vTable^.getDataLength(PTraceDYNRequestToken(token));
end;

function ITraceDYNRequest.getText(): PAnsiChar;
begin
	Result := vTable^.getText(PTraceDYNRequestToken(token));
end;

function ITraceContextVariable.vtable: PTraceContextVariableVTable;
begin
  Result := PTraceContextVariableVTable(token^.vTable);
end;

class operator ITraceContextVariable.:= (aToken:  PTraceContextVariableToken): ITraceContextVariable;
begin
  Result.token := aToken;
end;

class operator ITraceContextVariable.:= (intf: ITraceContextVariable): PTraceContextVariableToken;
begin
  Result := intf.token;
end;

class operator ITraceContextVariable.:= (impl: ITraceContextVariableImpl): ITraceContextVariable;
begin
  Result := impl.intf;
end;

class operator ITraceContextVariable.= (a: ITraceContextVariable; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceContextVariable.= (a,b: ITraceContextVariable): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceContextVariable.getNameSpace(): PAnsiChar;
begin
	Result := vTable^.getNameSpace(PTraceContextVariableToken(token));
end;

function ITraceContextVariable.getVarName(): PAnsiChar;
begin
	Result := vTable^.getVarName(PTraceContextVariableToken(token));
end;

function ITraceContextVariable.getVarValue(): PAnsiChar;
begin
	Result := vTable^.getVarValue(PTraceContextVariableToken(token));
end;

function ITraceProcedure.vtable: PTraceProcedureVTable;
begin
  Result := PTraceProcedureVTable(token^.vTable);
end;

class operator ITraceProcedure.:= (aToken:  PTraceProcedureToken): ITraceProcedure;
begin
  Result.token := aToken;
end;

class operator ITraceProcedure.:= (intf: ITraceProcedure): PTraceProcedureToken;
begin
  Result := intf.token;
end;

class operator ITraceProcedure.:= (impl: ITraceProcedureImpl): ITraceProcedure;
begin
  Result := impl.intf;
end;

class operator ITraceProcedure.= (a: ITraceProcedure; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceProcedure.= (a,b: ITraceProcedure): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceProcedure.getProcName(): PAnsiChar;
begin
	Result := vTable^.getProcName(PTraceProcedureToken(token));
end;

function ITraceProcedure.getInputs(): PTraceParamsToken;
begin
	Result := vTable^.getInputs(PTraceProcedureToken(token));
end;

function ITraceProcedure.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceProcedureToken(token));
end;

function ITraceFunction.vtable: PTraceFunctionVTable;
begin
  Result := PTraceFunctionVTable(token^.vTable);
end;

class operator ITraceFunction.:= (aToken:  PTraceFunctionToken): ITraceFunction;
begin
  Result.token := aToken;
end;

class operator ITraceFunction.:= (intf: ITraceFunction): PTraceFunctionToken;
begin
  Result := intf.token;
end;

class operator ITraceFunction.:= (impl: ITraceFunctionImpl): ITraceFunction;
begin
  Result := impl.intf;
end;

class operator ITraceFunction.= (a: ITraceFunction; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceFunction.= (a,b: ITraceFunction): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceFunction.getFuncName(): PAnsiChar;
begin
	Result := vTable^.getFuncName(PTraceFunctionToken(token));
end;

function ITraceFunction.getInputs(): PTraceParamsToken;
begin
	Result := vTable^.getInputs(PTraceFunctionToken(token));
end;

function ITraceFunction.getResult(): PTraceParamsToken;
begin
	Result := vTable^.getResult(PTraceFunctionToken(token));
end;

function ITraceFunction.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceFunctionToken(token));
end;

function ITraceTrigger.vtable: PTraceTriggerVTable;
begin
  Result := PTraceTriggerVTable(token^.vTable);
end;

class operator ITraceTrigger.:= (aToken:  PTraceTriggerToken): ITraceTrigger;
begin
  Result.token := aToken;
end;

class operator ITraceTrigger.:= (intf: ITraceTrigger): PTraceTriggerToken;
begin
  Result := intf.token;
end;

class operator ITraceTrigger.:= (impl: ITraceTriggerImpl): ITraceTrigger;
begin
  Result := impl.intf;
end;

class operator ITraceTrigger.= (a: ITraceTrigger; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceTrigger.= (a,b: ITraceTrigger): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceTrigger.getTriggerName(): PAnsiChar;
begin
	Result := vTable^.getTriggerName(PTraceTriggerToken(token));
end;

function ITraceTrigger.getRelationName(): PAnsiChar;
begin
	Result := vTable^.getRelationName(PTraceTriggerToken(token));
end;

function ITraceTrigger.getAction(): Integer;
begin
	Result := vTable^.getAction(PTraceTriggerToken(token));
end;

function ITraceTrigger.getWhich(): Integer;
begin
	Result := vTable^.getWhich(PTraceTriggerToken(token));
end;

function ITraceTrigger.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceTriggerToken(token));
end;

function ITraceServiceConnection.vtable: PTraceServiceConnectionVTable;
begin
  Result := PTraceServiceConnectionVTable(token^.vTable);
end;

class operator ITraceServiceConnection.:= (aToken:  PTraceServiceConnectionToken): ITraceServiceConnection;
begin
  Result.token := aToken;
end;

class operator ITraceServiceConnection.:= (intf: ITraceServiceConnection): PTraceServiceConnectionToken;
begin
  Result := intf.token;
end;

class operator ITraceServiceConnection.:= (impl: ITraceServiceConnectionImpl): ITraceServiceConnection;
begin
  Result := impl.intf;
end;

class operator ITraceServiceConnection.= (a: ITraceServiceConnection; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceServiceConnection.= (a,b: ITraceServiceConnection): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceServiceConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(PTraceConnectionToken(token));
end;

function ITraceServiceConnection.getServiceID(): Pointer;
begin
	Result := vTable^.getServiceID(PTraceServiceConnectionToken(token));
end;

function ITraceServiceConnection.getServiceMgr(): PAnsiChar;
begin
	Result := vTable^.getServiceMgr(PTraceServiceConnectionToken(token));
end;

function ITraceServiceConnection.getServiceName(): PAnsiChar;
begin
	Result := vTable^.getServiceName(PTraceServiceConnectionToken(token));
end;

function ITraceStatusVector.vtable: PTraceStatusVectorVTable;
begin
  Result := PTraceStatusVectorVTable(token^.vTable);
end;

class operator ITraceStatusVector.:= (aToken:  PTraceStatusVectorToken): ITraceStatusVector;
begin
  Result.token := aToken;
end;

class operator ITraceStatusVector.:= (intf: ITraceStatusVector): PTraceStatusVectorToken;
begin
  Result := intf.token;
end;

class operator ITraceStatusVector.:= (impl: ITraceStatusVectorImpl): ITraceStatusVector;
begin
  Result := impl.intf;
end;

class operator ITraceStatusVector.= (a: ITraceStatusVector; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceStatusVector.= (a,b: ITraceStatusVector): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceStatusVector.hasError(): Boolean;
begin
	Result := vTable^.hasError(PTraceStatusVectorToken(token));
end;

function ITraceStatusVector.hasWarning(): Boolean;
begin
	Result := vTable^.hasWarning(PTraceStatusVectorToken(token));
end;

function ITraceStatusVector.getStatus(): PStatusToken;
begin
	Result := vTable^.getStatus(PTraceStatusVectorToken(token));
end;

function ITraceStatusVector.getText(): PAnsiChar;
begin
	Result := vTable^.getText(PTraceStatusVectorToken(token));
end;

function ITraceSweepInfo.vtable: PTraceSweepInfoVTable;
begin
  Result := PTraceSweepInfoVTable(token^.vTable);
end;

class operator ITraceSweepInfo.:= (aToken:  PTraceSweepInfoToken): ITraceSweepInfo;
begin
  Result.token := aToken;
end;

class operator ITraceSweepInfo.:= (intf: ITraceSweepInfo): PTraceSweepInfoToken;
begin
  Result := intf.token;
end;

class operator ITraceSweepInfo.:= (impl: ITraceSweepInfoImpl): ITraceSweepInfo;
begin
  Result := impl.intf;
end;

class operator ITraceSweepInfo.= (a: ITraceSweepInfo; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceSweepInfo.= (a,b: ITraceSweepInfo): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceSweepInfo.getOIT(): Int64;
begin
	Result := vTable^.getOIT(PTraceSweepInfoToken(token));
end;

function ITraceSweepInfo.getOST(): Int64;
begin
	Result := vTable^.getOST(PTraceSweepInfoToken(token));
end;

function ITraceSweepInfo.getOAT(): Int64;
begin
	Result := vTable^.getOAT(PTraceSweepInfoToken(token));
end;

function ITraceSweepInfo.getNext(): Int64;
begin
	Result := vTable^.getNext(PTraceSweepInfoToken(token));
end;

function ITraceSweepInfo.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(PTraceSweepInfoToken(token));
end;

function ITraceLogWriter.vtable: PTraceLogWriterVTable;
begin
  Result := PTraceLogWriterVTable(token^.vTable);
end;

class operator ITraceLogWriter.:= (aToken:  PTraceLogWriterToken): ITraceLogWriter;
begin
  Result.token := aToken;
end;

class operator ITraceLogWriter.:= (intf: ITraceLogWriter): PTraceLogWriterToken;
begin
  Result := intf.token;
end;

class operator ITraceLogWriter.:= (impl: ITraceLogWriterImpl): ITraceLogWriter;
begin
  Result := impl.intf;
end;

class operator ITraceLogWriter.= (a: ITraceLogWriter; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceLogWriter.= (a,b: ITraceLogWriter): boolean;
begin
  Result := a.token = b.token;
end;

procedure ITraceLogWriter.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function ITraceLogWriter.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function ITraceLogWriter.write(buf: Pointer; size: Cardinal): Cardinal;
begin
	Result := vTable^.write(PTraceLogWriterToken(token), buf, size);
end;

function ITraceLogWriter.write_s(status: PStatusToken; buf: Pointer; size: Cardinal): Cardinal;
begin
	Result := vTable^.write_s(PTraceLogWriterToken(token), status, buf, size);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function ITraceInitInfo.vtable: PTraceInitInfoVTable;
begin
  Result := PTraceInitInfoVTable(token^.vTable);
end;

class operator ITraceInitInfo.:= (aToken:  PTraceInitInfoToken): ITraceInitInfo;
begin
  Result.token := aToken;
end;

class operator ITraceInitInfo.:= (intf: ITraceInitInfo): PTraceInitInfoToken;
begin
  Result := intf.token;
end;

class operator ITraceInitInfo.:= (impl: ITraceInitInfoImpl): ITraceInitInfo;
begin
  Result := impl.intf;
end;

class operator ITraceInitInfo.= (a: ITraceInitInfo; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceInitInfo.= (a,b: ITraceInitInfo): boolean;
begin
  Result := a.token = b.token;
end;

function ITraceInitInfo.getConfigText(): PAnsiChar;
begin
	Result := vTable^.getConfigText(PTraceInitInfoToken(token));
end;

function ITraceInitInfo.getTraceSessionID(): Integer;
begin
	Result := vTable^.getTraceSessionID(PTraceInitInfoToken(token));
end;

function ITraceInitInfo.getTraceSessionName(): PAnsiChar;
begin
	Result := vTable^.getTraceSessionName(PTraceInitInfoToken(token));
end;

function ITraceInitInfo.getFirebirdRootDirectory(): PAnsiChar;
begin
	Result := vTable^.getFirebirdRootDirectory(PTraceInitInfoToken(token));
end;

function ITraceInitInfo.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(PTraceInitInfoToken(token));
end;

function ITraceInitInfo.getConnection(): PTraceDatabaseConnectionToken;
begin
	Result := vTable^.getConnection(PTraceInitInfoToken(token));
end;

function ITraceInitInfo.getLogWriter(): PTraceLogWriterToken;
begin
	Result := vTable^.getLogWriter(PTraceInitInfoToken(token));
end;

function ITracePlugin.vtable: PTracePluginVTable;
begin
  Result := PTracePluginVTable(token^.vTable);
end;

class operator ITracePlugin.:= (aToken:  PTracePluginToken): ITracePlugin;
begin
  Result.token := aToken;
end;

class operator ITracePlugin.:= (intf: ITracePlugin): PTracePluginToken;
begin
  Result := intf.token;
end;

class operator ITracePlugin.:= (impl: ITracePluginImpl): ITracePlugin;
begin
  Result := impl.intf;
end;

class operator ITracePlugin.= (a: ITracePlugin; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITracePlugin.= (a,b: ITracePlugin): boolean;
begin
  Result := a.token = b.token;
end;

procedure ITracePlugin.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function ITracePlugin.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

function ITracePlugin.trace_get_error(): PAnsiChar;
begin
	Result := vTable^.trace_get_error(PTracePluginToken(token));
end;

function ITracePlugin.trace_attach(connection: PTraceDatabaseConnectionToken; create_db: Boolean; att_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_attach(PTracePluginToken(token), connection, create_db, att_result);
end;

function ITracePlugin.trace_detach(connection: PTraceDatabaseConnectionToken; drop_db: Boolean): Boolean;
begin
	Result := vTable^.trace_detach(PTracePluginToken(token), connection, drop_db);
end;

function ITracePlugin.trace_transaction_start(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_transaction_start(PTracePluginToken(token), connection, transaction, tpb_length, tpb, tra_result);
end;

function ITracePlugin.trace_transaction_end(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_transaction_end(PTracePluginToken(token), connection, transaction, commit, retain_context, tra_result);
end;

function ITracePlugin.trace_proc_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; procedure_: PTraceProcedureToken; started: Boolean; proc_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_proc_execute(PTracePluginToken(token), connection, transaction, procedure_, started, proc_result);
end;

function ITracePlugin.trace_trigger_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; trigger: PTraceTriggerToken; started: Boolean; trig_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_trigger_execute(PTracePluginToken(token), connection, transaction, trigger, started, trig_result);
end;

function ITracePlugin.trace_set_context(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; variable: PTraceContextVariableToken): Boolean;
begin
	Result := vTable^.trace_set_context(PTracePluginToken(token), connection, transaction, variable);
end;

function ITracePlugin.trace_dsql_prepare(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_prepare(PTracePluginToken(token), connection, transaction, statement, time_millis, req_result);
end;

function ITracePlugin.trace_dsql_free(connection: PTraceDatabaseConnectionToken; statement: PTraceSQLStatementToken; option: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_free(PTracePluginToken(token), connection, statement, option);
end;

function ITracePlugin.trace_dsql_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; started: Boolean; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_execute(PTracePluginToken(token), connection, transaction, statement, started, req_result);
end;

function ITracePlugin.trace_blr_compile(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_blr_compile(PTracePluginToken(token), connection, transaction, statement, time_millis, req_result);
end;

function ITracePlugin.trace_blr_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_blr_execute(PTracePluginToken(token), connection, transaction, statement, req_result);
end;

function ITracePlugin.trace_dyn_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; request: PTraceDYNRequestToken; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dyn_execute(PTracePluginToken(token), connection, transaction, request, time_millis, req_result);
end;

function ITracePlugin.trace_service_attach(service: PTraceServiceConnectionToken; att_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_attach(PTracePluginToken(token), service, att_result);
end;

function ITracePlugin.trace_service_start(service: PTraceServiceConnectionToken; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_start(PTracePluginToken(token), service, switches_length, switches, start_result);
end;

function ITracePlugin.trace_service_query(service: PTraceServiceConnectionToken; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_query(PTracePluginToken(token), service, send_item_length, send_items, recv_item_length, recv_items, query_result);
end;

function ITracePlugin.trace_service_detach(service: PTraceServiceConnectionToken; detach_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_detach(PTracePluginToken(token), service, detach_result);
end;

function ITracePlugin.trace_event_error(connection: PTraceConnectionToken; status: PTraceStatusVectorToken; function_: PAnsiChar): Boolean;
begin
	Result := vTable^.trace_event_error(PTracePluginToken(token), connection, status, function_);
end;

function ITracePlugin.trace_event_sweep(connection: PTraceDatabaseConnectionToken; sweep: PTraceSweepInfoToken; sweep_state: Cardinal): Boolean;
begin
	Result := vTable^.trace_event_sweep(PTracePluginToken(token), connection, sweep, sweep_state);
end;

function ITracePlugin.trace_func_execute(connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; function_: PTraceFunctionToken; started: Boolean; func_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_func_execute(PTracePluginToken(token), connection, transaction, function_, started, func_result);
end;

function ITraceFactory.vtable: PTraceFactoryVTable;
begin
  Result := PTraceFactoryVTable(token^.vTable);
end;

class operator ITraceFactory.:= (aToken:  PTraceFactoryToken): ITraceFactory;
begin
  Result.token := aToken;
end;

class operator ITraceFactory.:= (intf: ITraceFactory): PTraceFactoryToken;
begin
  Result := intf.token;
end;

class operator ITraceFactory.:= (impl: ITraceFactoryImpl): ITraceFactory;
begin
  Result := impl.intf;
end;

class operator ITraceFactory.= (a: ITraceFactory; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator ITraceFactory.= (a,b: ITraceFactory): boolean;
begin
  Result := a.token = b.token;
end;

procedure ITraceFactory.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function ITraceFactory.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure ITraceFactory.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function ITraceFactory.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function ITraceFactory.trace_needs(): QWord;
begin
	Result := vTable^.trace_needs(PTraceFactoryToken(token));
end;

function ITraceFactory.trace_create(status: PStatusToken; init_info: PTraceInitInfoToken): PTracePluginToken;
begin
	Result := vTable^.trace_create(PTraceFactoryToken(token), status, init_info);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrFunctionFactory.vtable: PUdrFunctionFactoryVTable;
begin
  Result := PUdrFunctionFactoryVTable(token^.vTable);
end;

class operator IUdrFunctionFactory.:= (aToken:  PUdrFunctionFactoryToken): IUdrFunctionFactory;
begin
  Result.token := aToken;
end;

class operator IUdrFunctionFactory.:= (intf: IUdrFunctionFactory): PUdrFunctionFactoryToken;
begin
  Result := intf.token;
end;

class operator IUdrFunctionFactory.:= (impl: IUdrFunctionFactoryImpl): IUdrFunctionFactory;
begin
  Result := impl.intf;
end;

class operator IUdrFunctionFactory.= (a: IUdrFunctionFactory; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUdrFunctionFactory.= (a,b: IUdrFunctionFactory): boolean;
begin
  Result := a.token = b.token;
end;

procedure IUdrFunctionFactory.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IUdrFunctionFactory.setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken);
begin
	vTable^.setup(PUdrFunctionFactoryToken(token), status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrFunctionFactory.newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalFunctionToken;
begin
	Result := vTable^.newItem(PUdrFunctionFactoryToken(token), status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrProcedureFactory.vtable: PUdrProcedureFactoryVTable;
begin
  Result := PUdrProcedureFactoryVTable(token^.vTable);
end;

class operator IUdrProcedureFactory.:= (aToken:  PUdrProcedureFactoryToken): IUdrProcedureFactory;
begin
  Result.token := aToken;
end;

class operator IUdrProcedureFactory.:= (intf: IUdrProcedureFactory): PUdrProcedureFactoryToken;
begin
  Result := intf.token;
end;

class operator IUdrProcedureFactory.:= (impl: IUdrProcedureFactoryImpl): IUdrProcedureFactory;
begin
  Result := impl.intf;
end;

class operator IUdrProcedureFactory.= (a: IUdrProcedureFactory; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUdrProcedureFactory.= (a,b: IUdrProcedureFactory): boolean;
begin
  Result := a.token = b.token;
end;

procedure IUdrProcedureFactory.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IUdrProcedureFactory.setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken);
begin
	vTable^.setup(PUdrProcedureFactoryToken(token), status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrProcedureFactory.newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalProcedureToken;
begin
	Result := vTable^.newItem(PUdrProcedureFactoryToken(token), status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrTriggerFactory.vtable: PUdrTriggerFactoryVTable;
begin
  Result := PUdrTriggerFactoryVTable(token^.vTable);
end;

class operator IUdrTriggerFactory.:= (aToken:  PUdrTriggerFactoryToken): IUdrTriggerFactory;
begin
  Result.token := aToken;
end;

class operator IUdrTriggerFactory.:= (intf: IUdrTriggerFactory): PUdrTriggerFactoryToken;
begin
  Result := intf.token;
end;

class operator IUdrTriggerFactory.:= (impl: IUdrTriggerFactoryImpl): IUdrTriggerFactory;
begin
  Result := impl.intf;
end;

class operator IUdrTriggerFactory.= (a: IUdrTriggerFactory; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUdrTriggerFactory.= (a,b: IUdrTriggerFactory): boolean;
begin
  Result := a.token = b.token;
end;

procedure IUdrTriggerFactory.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IUdrTriggerFactory.setup(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken);
begin
	vTable^.setup(PUdrTriggerFactoryToken(token), status, context, metadata, fieldsBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrTriggerFactory.newItem(status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalTriggerToken;
begin
	Result := vTable^.newItem(PUdrTriggerFactoryToken(token), status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IUdrPlugin.vtable: PUdrPluginVTable;
begin
  Result := PUdrPluginVTable(token^.vTable);
end;

class operator IUdrPlugin.:= (aToken:  PUdrPluginToken): IUdrPlugin;
begin
  Result.token := aToken;
end;

class operator IUdrPlugin.:= (intf: IUdrPlugin): PUdrPluginToken;
begin
  Result := intf.token;
end;

class operator IUdrPlugin.:= (impl: IUdrPluginImpl): IUdrPlugin;
begin
  Result := impl.intf;
end;

class operator IUdrPlugin.= (a: IUdrPlugin; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IUdrPlugin.= (a,b: IUdrPlugin): boolean;
begin
  Result := a.token = b.token;
end;

function IUdrPlugin.getMaster(): PMasterToken;
begin
	Result := vTable^.getMaster(PUdrPluginToken(token));
end;

procedure IUdrPlugin.registerFunction(status: PStatusToken; name: PAnsiChar; factory: PUdrFunctionFactoryToken);
begin
	vTable^.registerFunction(PUdrPluginToken(token), status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUdrPlugin.registerProcedure(status: PStatusToken; name: PAnsiChar; factory: PUdrProcedureFactoryToken);
begin
	vTable^.registerProcedure(PUdrPluginToken(token), status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IUdrPlugin.registerTrigger(status: PStatusToken; name: PAnsiChar; factory: PUdrTriggerFactoryToken);
begin
	vTable^.registerTrigger(PUdrPluginToken(token), status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDecFloat16.vtable: PDecFloat16VTable;
begin
  Result := PDecFloat16VTable(token^.vTable);
end;

class operator IDecFloat16.:= (aToken:  PDecFloat16Token): IDecFloat16;
begin
  Result.token := aToken;
end;

class operator IDecFloat16.:= (intf: IDecFloat16): PDecFloat16Token;
begin
  Result := intf.token;
end;

class operator IDecFloat16.:= (impl: IDecFloat16Impl): IDecFloat16;
begin
  Result := impl.intf;
end;

class operator IDecFloat16.= (a: IDecFloat16; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDecFloat16.= (a,b: IDecFloat16): boolean;
begin
  Result := a.token = b.token;
end;

procedure IDecFloat16.toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
begin
	vTable^.toBcd(PDecFloat16Token(token), from, sign, bcd, exp);
end;

procedure IDecFloat16.toString(status: PStatusToken; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(PDecFloat16Token(token), status, from, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IDecFloat16.fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr);
begin
	vTable^.fromBcd(PDecFloat16Token(token), sign, bcd, exp, to_);
end;

procedure IDecFloat16.fromString(status: PStatusToken; from: PAnsiChar; to_: FB_DEC16Ptr);
begin
	vTable^.fromString(PDecFloat16Token(token), status, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IDecFloat34.vtable: PDecFloat34VTable;
begin
  Result := PDecFloat34VTable(token^.vTable);
end;

class operator IDecFloat34.:= (aToken:  PDecFloat34Token): IDecFloat34;
begin
  Result.token := aToken;
end;

class operator IDecFloat34.:= (intf: IDecFloat34): PDecFloat34Token;
begin
  Result := intf.token;
end;

class operator IDecFloat34.:= (impl: IDecFloat34Impl): IDecFloat34;
begin
  Result := impl.intf;
end;

class operator IDecFloat34.= (a: IDecFloat34; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IDecFloat34.= (a,b: IDecFloat34): boolean;
begin
  Result := a.token = b.token;
end;

procedure IDecFloat34.toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
begin
	vTable^.toBcd(PDecFloat34Token(token), from, sign, bcd, exp);
end;

procedure IDecFloat34.toString(status: PStatusToken; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(PDecFloat34Token(token), status, from, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IDecFloat34.fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr);
begin
	vTable^.fromBcd(PDecFloat34Token(token), sign, bcd, exp, to_);
end;

procedure IDecFloat34.fromString(status: PStatusToken; from: PAnsiChar; to_: FB_DEC34Ptr);
begin
	vTable^.fromString(PDecFloat34Token(token), status, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IInt128.vtable: PInt128VTable;
begin
  Result := PInt128VTable(token^.vTable);
end;

class operator IInt128.:= (aToken:  PInt128Token): IInt128;
begin
  Result.token := aToken;
end;

class operator IInt128.:= (intf: IInt128): PInt128Token;
begin
  Result := intf.token;
end;

class operator IInt128.:= (impl: IInt128Impl): IInt128;
begin
  Result := impl.intf;
end;

class operator IInt128.= (a: IInt128; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IInt128.= (a,b: IInt128): boolean;
begin
  Result := a.token = b.token;
end;

procedure IInt128.toString(status: PStatusToken; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(PInt128Token(token), status, from, scale, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IInt128.fromString(status: PStatusToken; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr);
begin
	vTable^.fromString(PInt128Token(token), status, scale, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IReplicatedField.vtable: PReplicatedFieldVTable;
begin
  Result := PReplicatedFieldVTable(token^.vTable);
end;

class operator IReplicatedField.:= (aToken:  PReplicatedFieldToken): IReplicatedField;
begin
  Result.token := aToken;
end;

class operator IReplicatedField.:= (intf: IReplicatedField): PReplicatedFieldToken;
begin
  Result := intf.token;
end;

class operator IReplicatedField.:= (impl: IReplicatedFieldImpl): IReplicatedField;
begin
  Result := impl.intf;
end;

class operator IReplicatedField.= (a: IReplicatedField; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IReplicatedField.= (a,b: IReplicatedField): boolean;
begin
  Result := a.token = b.token;
end;

function IReplicatedField.getName(): PAnsiChar;
begin
	Result := vTable^.getName(PReplicatedFieldToken(token));
end;

function IReplicatedField.getType(): Cardinal;
begin
	Result := vTable^.getType(PReplicatedFieldToken(token));
end;

function IReplicatedField.getSubType(): Integer;
begin
	Result := vTable^.getSubType(PReplicatedFieldToken(token));
end;

function IReplicatedField.getScale(): Integer;
begin
	Result := vTable^.getScale(PReplicatedFieldToken(token));
end;

function IReplicatedField.getLength(): Cardinal;
begin
	Result := vTable^.getLength(PReplicatedFieldToken(token));
end;

function IReplicatedField.getCharSet(): Cardinal;
begin
	Result := vTable^.getCharSet(PReplicatedFieldToken(token));
end;

function IReplicatedField.getData(): Pointer;
begin
	Result := vTable^.getData(PReplicatedFieldToken(token));
end;

function IReplicatedRecord.vtable: PReplicatedRecordVTable;
begin
  Result := PReplicatedRecordVTable(token^.vTable);
end;

class operator IReplicatedRecord.:= (aToken:  PReplicatedRecordToken): IReplicatedRecord;
begin
  Result.token := aToken;
end;

class operator IReplicatedRecord.:= (intf: IReplicatedRecord): PReplicatedRecordToken;
begin
  Result := intf.token;
end;

class operator IReplicatedRecord.:= (impl: IReplicatedRecordImpl): IReplicatedRecord;
begin
  Result := impl.intf;
end;

class operator IReplicatedRecord.= (a: IReplicatedRecord; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IReplicatedRecord.= (a,b: IReplicatedRecord): boolean;
begin
  Result := a.token = b.token;
end;

function IReplicatedRecord.getCount(): Cardinal;
begin
	Result := vTable^.getCount(PReplicatedRecordToken(token));
end;

function IReplicatedRecord.getField(index: Cardinal): PReplicatedFieldToken;
begin
	Result := vTable^.getField(PReplicatedRecordToken(token), index);
end;

function IReplicatedRecord.getRawLength(): Cardinal;
begin
	Result := vTable^.getRawLength(PReplicatedRecordToken(token));
end;

function IReplicatedRecord.getRawData(): BytePtr;
begin
	Result := vTable^.getRawData(PReplicatedRecordToken(token));
end;

function IReplicatedTransaction.vtable: PReplicatedTransactionVTable;
begin
  Result := PReplicatedTransactionVTable(token^.vTable);
end;

class operator IReplicatedTransaction.:= (aToken:  PReplicatedTransactionToken): IReplicatedTransaction;
begin
  Result.token := aToken;
end;

class operator IReplicatedTransaction.:= (intf: IReplicatedTransaction): PReplicatedTransactionToken;
begin
  Result := intf.token;
end;

class operator IReplicatedTransaction.:= (impl: IReplicatedTransactionImpl): IReplicatedTransaction;
begin
  Result := impl.intf;
end;

class operator IReplicatedTransaction.= (a: IReplicatedTransaction; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IReplicatedTransaction.= (a,b: IReplicatedTransaction): boolean;
begin
  Result := a.token = b.token;
end;

procedure IReplicatedTransaction.dispose();
begin
	vTable^.dispose(PDisposableToken(token));
end;

procedure IReplicatedTransaction.prepare(status: PStatusToken);
begin
	vTable^.prepare(PReplicatedTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.commit(status: PStatusToken);
begin
	vTable^.commit(PReplicatedTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.rollback(status: PStatusToken);
begin
	vTable^.rollback(PReplicatedTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.startSavepoint(status: PStatusToken);
begin
	vTable^.startSavepoint(PReplicatedTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.releaseSavepoint(status: PStatusToken);
begin
	vTable^.releaseSavepoint(PReplicatedTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.rollbackSavepoint(status: PStatusToken);
begin
	vTable^.rollbackSavepoint(PReplicatedTransactionToken(token), status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.insertRecord(status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken);
begin
	vTable^.insertRecord(PReplicatedTransactionToken(token), status, name, record_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.updateRecord(status: PStatusToken; name: PAnsiChar; orgRecord: PReplicatedRecordToken; newRecord: PReplicatedRecordToken);
begin
	vTable^.updateRecord(PReplicatedTransactionToken(token), status, name, orgRecord, newRecord);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.deleteRecord(status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken);
begin
	vTable^.deleteRecord(PReplicatedTransactionToken(token), status, name, record_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.executeSql(status: PStatusToken; sql: PAnsiChar);
begin
	vTable^.executeSql(PReplicatedTransactionToken(token), status, sql);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedTransaction.executeSqlIntl(status: PStatusToken; charset: Cardinal; sql: PAnsiChar);
begin
	vTable^.executeSqlIntl(PReplicatedTransactionToken(token), status, charset, sql);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IReplicatedSession.vtable: PReplicatedSessionVTable;
begin
  Result := PReplicatedSessionVTable(token^.vTable);
end;

class operator IReplicatedSession.:= (aToken:  PReplicatedSessionToken): IReplicatedSession;
begin
  Result.token := aToken;
end;

class operator IReplicatedSession.:= (intf: IReplicatedSession): PReplicatedSessionToken;
begin
  Result := intf.token;
end;

class operator IReplicatedSession.:= (impl: IReplicatedSessionImpl): IReplicatedSession;
begin
  Result := impl.intf;
end;

class operator IReplicatedSession.= (a: IReplicatedSession; b: pointer): boolean;
begin
  Result := a.token = b;
end;

class operator IReplicatedSession.= (a,b: IReplicatedSession): boolean;
begin
  Result := a.token = b.token;
end;

procedure IReplicatedSession.addRef();
begin
	vTable^.addRef(PReferenceCountedToken(token));
end;

function IReplicatedSession.release(): Integer;
begin
	Result := vTable^.release(PReferenceCountedToken(token));
end;

procedure IReplicatedSession.setOwner(r: PReferenceCountedToken);
begin
	vTable^.setOwner(PPluginBaseToken(token), r);
end;

function IReplicatedSession.getOwner(): PReferenceCountedToken;
begin
	Result := vTable^.getOwner(PPluginBaseToken(token));
end;

function IReplicatedSession.init(status: PStatusToken; attachment: PAttachmentToken): Boolean;
begin
	Result := vTable^.init(PReplicatedSessionToken(token), status, attachment);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IReplicatedSession.startTransaction(status: PStatusToken; transaction: PTransactionToken; number: Int64): PReplicatedTransactionToken;
begin
	Result := vTable^.startTransaction(PReplicatedSessionToken(token), status, transaction, number);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedSession.cleanupTransaction(status: PStatusToken; number: Int64);
begin
	vTable^.cleanupTransaction(PReplicatedSessionToken(token), status, number);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure IReplicatedSession.setSequence(status: PStatusToken; name: PAnsiChar; value: Int64);
begin
	vTable^.setSequence(PReplicatedSessionToken(token), status, name, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

constructor IVersionedImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IVersionedImpl.getInterfaceToken: PVersionedToken;
begin
  Result := PVersionedToken(@token);
end;

function IVersionedImpl.getInterface: IVersioned;
begin
  Result := intf;
end;

class procedure IVersionedImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 0;
  end;

  FInitialized := true;
end;

constructor IReferenceCountedImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IReferenceCountedImpl.getInterfaceToken: PReferenceCountedToken;
begin
  Result := PReferenceCountedToken(@token);
end;

function IReferenceCountedImpl.getInterface: IReferenceCounted;
begin
  Result := intf;
end;

procedure IReferenceCountedImpl_addRefDispatcher(this: PReferenceCountedToken); cdecl;
begin
	try
		IReferenceCountedImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReferenceCountedImpl_releaseDispatcher(this: PReferenceCountedToken): Integer; cdecl;
begin
	try
		Result := IReferenceCountedImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IReferenceCountedImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
  end;

  FInitialized := true;
end;

constructor IDisposableImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDisposableImpl.getInterfaceToken: PDisposableToken;
begin
  Result := PDisposableToken(@token);
end;

function IDisposableImpl.getInterface: IDisposable;
begin
  Result := intf;
end;

procedure IDisposableImpl_disposeDispatcher(this: PDisposableToken); cdecl;
begin
	try
		IDisposableImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IDisposableImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 1;
     dispose := @IDisposableImpl_disposeDispatcher;
  end;

  FInitialized := true;
end;

constructor IStatusImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IStatusImpl.getInterfaceToken: PStatusToken;
begin
  Result := PStatusToken(@token);
end;

function IStatusImpl.getInterface: IStatus;
begin
  Result := intf;
end;

procedure IStatusImpl_disposeDispatcher(this: PStatusToken); cdecl;
begin
	try
		IStatusImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_initDispatcher(this: PStatusToken); cdecl;
begin
	try
		IStatusImpl(PFBImplementationToken(this).Owner).init();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getStateDispatcher(this: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IStatusImpl(PFBImplementationToken(this).Owner).getState();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setErrors2Dispatcher(this: PStatusToken; length: Cardinal; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(PFBImplementationToken(this).Owner).setErrors2(length, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setWarnings2Dispatcher(this: PStatusToken; length: Cardinal; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(PFBImplementationToken(this).Owner).setWarnings2(length, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setErrorsDispatcher(this: PStatusToken; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(PFBImplementationToken(this).Owner).setErrors(value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setWarningsDispatcher(this: PStatusToken; value: NativeIntPtr); cdecl;
begin
	try
		IStatusImpl(PFBImplementationToken(this).Owner).setWarnings(value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getErrorsDispatcher(this: PStatusToken): NativeIntPtr; cdecl;
begin
	try
		Result := IStatusImpl(PFBImplementationToken(this).Owner).getErrors();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getWarningsDispatcher(this: PStatusToken): NativeIntPtr; cdecl;
begin
	try
		Result := IStatusImpl(PFBImplementationToken(this).Owner).getWarnings();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_cloneDispatcher(this: PStatusToken): PStatusToken; cdecl;
begin
	try
		Result := IStatusImpl(PFBImplementationToken(this).Owner).clone();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IStatusImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 10;
     dispose := @IDisposableImpl_disposeDispatcher;
     init := @IStatusImpl_initDispatcher;
     getState := @IStatusImpl_getStateDispatcher;
     setErrors2 := @IStatusImpl_setErrors2Dispatcher;
     setWarnings2 := @IStatusImpl_setWarnings2Dispatcher;
     setErrors := @IStatusImpl_setErrorsDispatcher;
     setWarnings := @IStatusImpl_setWarningsDispatcher;
     getErrors := @IStatusImpl_getErrorsDispatcher;
     getWarnings := @IStatusImpl_getWarningsDispatcher;
     clone := @IStatusImpl_cloneDispatcher;
  end;

  FInitialized := true;
end;

constructor IMasterImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IMasterImpl.getInterfaceToken: PMasterToken;
begin
  Result := PMasterToken(@token);
end;

function IMasterImpl.getInterface: IMaster;
begin
  Result := intf;
end;

function IMasterImpl_getStatusDispatcher(this: PMasterToken): PStatusToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getStatus();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getDispatcherDispatcher(this: PMasterToken): PProviderToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getDispatcher();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getPluginManagerDispatcher(this: PMasterToken): PPluginManagerToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getPluginManager();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getTimerControlDispatcher(this: PMasterToken): PTimerControlToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getTimerControl();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getDtcDispatcher(this: PMasterToken): PDtcToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getDtc();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_registerAttachmentDispatcher(this: PMasterToken; provider: PProviderToken; attachment: PAttachmentToken): PAttachmentToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).registerAttachment(provider, attachment);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_registerTransactionDispatcher(this: PMasterToken; attachment: PAttachmentToken; transaction: PTransactionToken): PTransactionToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).registerTransaction(attachment, transaction);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getMetadataBuilderDispatcher(this: PMasterToken; status: PStatusToken; fieldCount: Cardinal): PMetadataBuilderToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getMetadataBuilder(status, fieldCount);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMasterImpl_serverModeDispatcher(this: PMasterToken; mode: Integer): Integer; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).serverMode(mode);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getUtilInterfaceDispatcher(this: PMasterToken): PUtilToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getUtilInterface();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getConfigManagerDispatcher(this: PMasterToken): PConfigManagerToken; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getConfigManager();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getProcessExitingDispatcher(this: PMasterToken): Boolean; cdecl;
begin
	try
		Result := IMasterImpl(PFBImplementationToken(this).Owner).getProcessExiting();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IMasterImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 12;
     getStatus := @IMasterImpl_getStatusDispatcher;
     getDispatcher := @IMasterImpl_getDispatcherDispatcher;
     getPluginManager := @IMasterImpl_getPluginManagerDispatcher;
     getTimerControl := @IMasterImpl_getTimerControlDispatcher;
     getDtc := @IMasterImpl_getDtcDispatcher;
     registerAttachment := @IMasterImpl_registerAttachmentDispatcher;
     registerTransaction := @IMasterImpl_registerTransactionDispatcher;
     getMetadataBuilder := @IMasterImpl_getMetadataBuilderDispatcher;
     serverMode := @IMasterImpl_serverModeDispatcher;
     getUtilInterface := @IMasterImpl_getUtilInterfaceDispatcher;
     getConfigManager := @IMasterImpl_getConfigManagerDispatcher;
     getProcessExiting := @IMasterImpl_getProcessExitingDispatcher;
  end;

  FInitialized := true;
end;

constructor IPluginBaseImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IPluginBaseImpl.getInterfaceToken: PPluginBaseToken;
begin
  Result := PPluginBaseToken(@token);
end;

function IPluginBaseImpl.getInterface: IPluginBase;
begin
  Result := intf;
end;

procedure IPluginBaseImpl_addRefDispatcher(this: PPluginBaseToken); cdecl;
begin
	try
		IPluginBaseImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginBaseImpl_releaseDispatcher(this: PPluginBaseToken): Integer; cdecl;
begin
	try
		Result := IPluginBaseImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginBaseImpl_setOwnerDispatcher(this: PPluginBaseToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IPluginBaseImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginBaseImpl_getOwnerDispatcher(this: PPluginBaseToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IPluginBaseImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IPluginBaseImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
  end;

  FInitialized := true;
end;

constructor IPluginSetImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IPluginSetImpl.getInterfaceToken: PPluginSetToken;
begin
  Result := PPluginSetToken(@token);
end;

function IPluginSetImpl.getInterface: IPluginSet;
begin
  Result := intf;
end;

procedure IPluginSetImpl_addRefDispatcher(this: PPluginSetToken); cdecl;
begin
	try
		IPluginSetImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_releaseDispatcher(this: PPluginSetToken): Integer; cdecl;
begin
	try
		Result := IPluginSetImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getNameDispatcher(this: PPluginSetToken): PAnsiChar; cdecl;
begin
	try
		Result := IPluginSetImpl(PFBImplementationToken(this).Owner).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getModuleNameDispatcher(this: PPluginSetToken): PAnsiChar; cdecl;
begin
	try
		Result := IPluginSetImpl(PFBImplementationToken(this).Owner).getModuleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getPluginDispatcher(this: PPluginSetToken; status: PStatusToken): PPluginBaseToken; cdecl;
begin
	try
		Result := IPluginSetImpl(PFBImplementationToken(this).Owner).getPlugin(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginSetImpl_nextDispatcher(this: PPluginSetToken; status: PStatusToken); cdecl;
begin
	try
		IPluginSetImpl(PFBImplementationToken(this).Owner).next(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginSetImpl_set_Dispatcher(this: PPluginSetToken; status: PStatusToken; s: PAnsiChar); cdecl;
begin
	try
		IPluginSetImpl(PFBImplementationToken(this).Owner).set_(status, s);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IPluginSetImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getName := @IPluginSetImpl_getNameDispatcher;
     getModuleName := @IPluginSetImpl_getModuleNameDispatcher;
     getPlugin := @IPluginSetImpl_getPluginDispatcher;
     next := @IPluginSetImpl_nextDispatcher;
     set_ := @IPluginSetImpl_set_Dispatcher;
  end;

  FInitialized := true;
end;

constructor IConfigEntryImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IConfigEntryImpl.getInterfaceToken: PConfigEntryToken;
begin
  Result := PConfigEntryToken(@token);
end;

function IConfigEntryImpl.getInterface: IConfigEntry;
begin
  Result := intf;
end;

procedure IConfigEntryImpl_addRefDispatcher(this: PConfigEntryToken); cdecl;
begin
	try
		IConfigEntryImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_releaseDispatcher(this: PConfigEntryToken): Integer; cdecl;
begin
	try
		Result := IConfigEntryImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getNameDispatcher(this: PConfigEntryToken): PAnsiChar; cdecl;
begin
	try
		Result := IConfigEntryImpl(PFBImplementationToken(this).Owner).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getValueDispatcher(this: PConfigEntryToken): PAnsiChar; cdecl;
begin
	try
		Result := IConfigEntryImpl(PFBImplementationToken(this).Owner).getValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getIntValueDispatcher(this: PConfigEntryToken): Int64; cdecl;
begin
	try
		Result := IConfigEntryImpl(PFBImplementationToken(this).Owner).getIntValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getBoolValueDispatcher(this: PConfigEntryToken): Boolean; cdecl;
begin
	try
		Result := IConfigEntryImpl(PFBImplementationToken(this).Owner).getBoolValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getSubConfigDispatcher(this: PConfigEntryToken; status: PStatusToken): PConfigToken; cdecl;
begin
	try
		Result := IConfigEntryImpl(PFBImplementationToken(this).Owner).getSubConfig(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IConfigEntryImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getName := @IConfigEntryImpl_getNameDispatcher;
     getValue := @IConfigEntryImpl_getValueDispatcher;
     getIntValue := @IConfigEntryImpl_getIntValueDispatcher;
     getBoolValue := @IConfigEntryImpl_getBoolValueDispatcher;
     getSubConfig := @IConfigEntryImpl_getSubConfigDispatcher;
  end;

  FInitialized := true;
end;

constructor IConfigImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IConfigImpl.getInterfaceToken: PConfigToken;
begin
  Result := PConfigToken(@token);
end;

function IConfigImpl.getInterface: IConfig;
begin
  Result := intf;
end;

procedure IConfigImpl_addRefDispatcher(this: PConfigToken); cdecl;
begin
	try
		IConfigImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigImpl_releaseDispatcher(this: PConfigToken): Integer; cdecl;
begin
	try
		Result := IConfigImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigImpl_findDispatcher(this: PConfigToken; status: PStatusToken; name: PAnsiChar): PConfigEntryToken; cdecl;
begin
	try
		Result := IConfigImpl(PFBImplementationToken(this).Owner).find(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IConfigImpl_findValueDispatcher(this: PConfigToken; status: PStatusToken; name: PAnsiChar; value: PAnsiChar): PConfigEntryToken; cdecl;
begin
	try
		Result := IConfigImpl(PFBImplementationToken(this).Owner).findValue(status, name, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IConfigImpl_findPosDispatcher(this: PConfigToken; status: PStatusToken; name: PAnsiChar; pos: Cardinal): PConfigEntryToken; cdecl;
begin
	try
		Result := IConfigImpl(PFBImplementationToken(this).Owner).findPos(status, name, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IConfigImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     find := @IConfigImpl_findDispatcher;
     findValue := @IConfigImpl_findValueDispatcher;
     findPos := @IConfigImpl_findPosDispatcher;
  end;

  FInitialized := true;
end;

constructor IFirebirdConfImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IFirebirdConfImpl.getInterfaceToken: PFirebirdConfToken;
begin
  Result := PFirebirdConfToken(@token);
end;

function IFirebirdConfImpl.getInterface: IFirebirdConf;
begin
  Result := intf;
end;

procedure IFirebirdConfImpl_addRefDispatcher(this: PFirebirdConfToken); cdecl;
begin
	try
		IFirebirdConfImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_releaseDispatcher(this: PFirebirdConfToken): Integer; cdecl;
begin
	try
		Result := IFirebirdConfImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_getKeyDispatcher(this: PFirebirdConfToken; name: PAnsiChar): Cardinal; cdecl;
begin
	try
		Result := IFirebirdConfImpl(PFBImplementationToken(this).Owner).getKey(name);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asIntegerDispatcher(this: PFirebirdConfToken; key: Cardinal): Int64; cdecl;
begin
	try
		Result := IFirebirdConfImpl(PFBImplementationToken(this).Owner).asInteger(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asStringDispatcher(this: PFirebirdConfToken; key: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IFirebirdConfImpl(PFBImplementationToken(this).Owner).asString(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asBooleanDispatcher(this: PFirebirdConfToken; key: Cardinal): Boolean; cdecl;
begin
	try
		Result := IFirebirdConfImpl(PFBImplementationToken(this).Owner).asBoolean(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_getVersionDispatcher(this: PFirebirdConfToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IFirebirdConfImpl(PFBImplementationToken(this).Owner).getVersion(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IFirebirdConfImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getKey := @IFirebirdConfImpl_getKeyDispatcher;
     asInteger := @IFirebirdConfImpl_asIntegerDispatcher;
     asString := @IFirebirdConfImpl_asStringDispatcher;
     asBoolean := @IFirebirdConfImpl_asBooleanDispatcher;
     getVersion := @IFirebirdConfImpl_getVersionDispatcher;
  end;

  FInitialized := true;
end;

constructor IPluginConfigImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IPluginConfigImpl.getInterfaceToken: PPluginConfigToken;
begin
  Result := PPluginConfigToken(@token);
end;

function IPluginConfigImpl.getInterface: IPluginConfig;
begin
  Result := intf;
end;

procedure IPluginConfigImpl_addRefDispatcher(this: PPluginConfigToken); cdecl;
begin
	try
		IPluginConfigImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_releaseDispatcher(this: PPluginConfigToken): Integer; cdecl;
begin
	try
		Result := IPluginConfigImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_getConfigFileNameDispatcher(this: PPluginConfigToken): PAnsiChar; cdecl;
begin
	try
		Result := IPluginConfigImpl(PFBImplementationToken(this).Owner).getConfigFileName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_getDefaultConfigDispatcher(this: PPluginConfigToken; status: PStatusToken): PConfigToken; cdecl;
begin
	try
		Result := IPluginConfigImpl(PFBImplementationToken(this).Owner).getDefaultConfig(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IPluginConfigImpl_getFirebirdConfDispatcher(this: PPluginConfigToken; status: PStatusToken): PFirebirdConfToken; cdecl;
begin
	try
		Result := IPluginConfigImpl(PFBImplementationToken(this).Owner).getFirebirdConf(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginConfigImpl_setReleaseDelayDispatcher(this: PPluginConfigToken; status: PStatusToken; microSeconds: QWord); cdecl;
begin
	try
		IPluginConfigImpl(PFBImplementationToken(this).Owner).setReleaseDelay(status, microSeconds);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IPluginConfigImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 6;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getConfigFileName := @IPluginConfigImpl_getConfigFileNameDispatcher;
     getDefaultConfig := @IPluginConfigImpl_getDefaultConfigDispatcher;
     getFirebirdConf := @IPluginConfigImpl_getFirebirdConfDispatcher;
     setReleaseDelay := @IPluginConfigImpl_setReleaseDelayDispatcher;
  end;

  FInitialized := true;
end;

constructor IPluginFactoryImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IPluginFactoryImpl.getInterfaceToken: PPluginFactoryToken;
begin
  Result := PPluginFactoryToken(@token);
end;

function IPluginFactoryImpl.getInterface: IPluginFactory;
begin
  Result := intf;
end;

function IPluginFactoryImpl_createPluginDispatcher(this: PPluginFactoryToken; status: PStatusToken; factoryParameter: PPluginConfigToken): PPluginBaseToken; cdecl;
begin
	try
		Result := IPluginFactoryImpl(PFBImplementationToken(this).Owner).createPlugin(status, factoryParameter);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IPluginFactoryImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 1;
     createPlugin := @IPluginFactoryImpl_createPluginDispatcher;
  end;

  FInitialized := true;
end;

constructor IPluginModuleImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IPluginModuleImpl.getInterfaceToken: PPluginModuleToken;
begin
  Result := PPluginModuleToken(@token);
end;

function IPluginModuleImpl.getInterface: IPluginModule;
begin
  Result := intf;
end;

procedure IPluginModuleImpl_doCleanDispatcher(this: PPluginModuleToken); cdecl;
begin
	try
		IPluginModuleImpl(PFBImplementationToken(this).Owner).doClean();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginModuleImpl_threadDetachDispatcher(this: PPluginModuleToken); cdecl;
begin
	try
		IPluginModuleImpl(PFBImplementationToken(this).Owner).threadDetach();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IPluginModuleImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     doClean := @IPluginModuleImpl_doCleanDispatcher;
     threadDetach := @IPluginModuleImpl_threadDetachDispatcher;
  end;

  FInitialized := true;
end;

constructor IPluginManagerImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IPluginManagerImpl.getInterfaceToken: PPluginManagerToken;
begin
  Result := PPluginManagerToken(@token);
end;

function IPluginManagerImpl.getInterface: IPluginManager;
begin
  Result := intf;
end;

procedure IPluginManagerImpl_registerPluginFactoryDispatcher(this: PPluginManagerToken; pluginType: Cardinal; defaultName: PAnsiChar; factory: PPluginFactoryToken); cdecl;
begin
	try
		IPluginManagerImpl(PFBImplementationToken(this).Owner).registerPluginFactory(pluginType, defaultName, factory);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginManagerImpl_registerModuleDispatcher(this: PPluginManagerToken; cleanup: PPluginModuleToken); cdecl;
begin
	try
		IPluginManagerImpl(PFBImplementationToken(this).Owner).registerModule(cleanup);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginManagerImpl_unregisterModuleDispatcher(this: PPluginManagerToken; cleanup: PPluginModuleToken); cdecl;
begin
	try
		IPluginManagerImpl(PFBImplementationToken(this).Owner).unregisterModule(cleanup);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginManagerImpl_getPluginsDispatcher(this: PPluginManagerToken; status: PStatusToken; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: PFirebirdConfToken): PPluginSetToken; cdecl;
begin
	try
		Result := IPluginManagerImpl(PFBImplementationToken(this).Owner).getPlugins(status, pluginType, namesList, firebirdConf);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IPluginManagerImpl_getConfigDispatcher(this: PPluginManagerToken; status: PStatusToken; filename: PAnsiChar): PConfigToken; cdecl;
begin
	try
		Result := IPluginManagerImpl(PFBImplementationToken(this).Owner).getConfig(status, filename);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginManagerImpl_releasePluginDispatcher(this: PPluginManagerToken; plugin: PPluginBaseToken); cdecl;
begin
	try
		IPluginManagerImpl(PFBImplementationToken(this).Owner).releasePlugin(plugin);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IPluginManagerImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 6;
     registerPluginFactory := @IPluginManagerImpl_registerPluginFactoryDispatcher;
     registerModule := @IPluginManagerImpl_registerModuleDispatcher;
     unregisterModule := @IPluginManagerImpl_unregisterModuleDispatcher;
     getPlugins := @IPluginManagerImpl_getPluginsDispatcher;
     getConfig := @IPluginManagerImpl_getConfigDispatcher;
     releasePlugin := @IPluginManagerImpl_releasePluginDispatcher;
  end;

  FInitialized := true;
end;

constructor ICryptKeyImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ICryptKeyImpl.getInterfaceToken: PCryptKeyToken;
begin
  Result := PCryptKeyToken(@token);
end;

function ICryptKeyImpl.getInterface: ICryptKey;
begin
  Result := intf;
end;

procedure ICryptKeyImpl_setSymmetricDispatcher(this: PCryptKeyToken; status: PStatusToken; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); cdecl;
begin
	try
		ICryptKeyImpl(PFBImplementationToken(this).Owner).setSymmetric(status, type_, keyLength, key);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ICryptKeyImpl_setAsymmetricDispatcher(this: PCryptKeyToken; status: PStatusToken; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); cdecl;
begin
	try
		ICryptKeyImpl(PFBImplementationToken(this).Owner).setAsymmetric(status, type_, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ICryptKeyImpl_getEncryptKeyDispatcher(this: PCryptKeyToken; length: CardinalPtr): Pointer; cdecl;
begin
	try
		Result := ICryptKeyImpl(PFBImplementationToken(this).Owner).getEncryptKey(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ICryptKeyImpl_getDecryptKeyDispatcher(this: PCryptKeyToken; length: CardinalPtr): Pointer; cdecl;
begin
	try
		Result := ICryptKeyImpl(PFBImplementationToken(this).Owner).getDecryptKey(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ICryptKeyImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     setSymmetric := @ICryptKeyImpl_setSymmetricDispatcher;
     setAsymmetric := @ICryptKeyImpl_setAsymmetricDispatcher;
     getEncryptKey := @ICryptKeyImpl_getEncryptKeyDispatcher;
     getDecryptKey := @ICryptKeyImpl_getDecryptKeyDispatcher;
  end;

  FInitialized := true;
end;

constructor IConfigManagerImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IConfigManagerImpl.getInterfaceToken: PConfigManagerToken;
begin
  Result := PConfigManagerToken(@token);
end;

function IConfigManagerImpl.getInterface: IConfigManager;
begin
  Result := intf;
end;

function IConfigManagerImpl_getDirectoryDispatcher(this: PConfigManagerToken; code: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getDirectory(code);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getFirebirdConfDispatcher(this: PConfigManagerToken): PFirebirdConfToken; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getFirebirdConf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getDatabaseConfDispatcher(this: PConfigManagerToken; dbName: PAnsiChar): PFirebirdConfToken; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getDatabaseConf(dbName);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getPluginConfigDispatcher(this: PConfigManagerToken; configuredPlugin: PAnsiChar): PConfigToken; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getPluginConfig(configuredPlugin);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getInstallDirectoryDispatcher(this: PConfigManagerToken): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getInstallDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getRootDirectoryDispatcher(this: PConfigManagerToken): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getRootDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getDefaultSecurityDbDispatcher(this: PConfigManagerToken): PAnsiChar; cdecl;
begin
	try
		Result := IConfigManagerImpl(PFBImplementationToken(this).Owner).getDefaultSecurityDb();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IConfigManagerImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     getDirectory := @IConfigManagerImpl_getDirectoryDispatcher;
     getFirebirdConf := @IConfigManagerImpl_getFirebirdConfDispatcher;
     getDatabaseConf := @IConfigManagerImpl_getDatabaseConfDispatcher;
     getPluginConfig := @IConfigManagerImpl_getPluginConfigDispatcher;
     getInstallDirectory := @IConfigManagerImpl_getInstallDirectoryDispatcher;
     getRootDirectory := @IConfigManagerImpl_getRootDirectoryDispatcher;
     getDefaultSecurityDb := @IConfigManagerImpl_getDefaultSecurityDbDispatcher;
  end;

  FInitialized := true;
end;

constructor IEventCallbackImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IEventCallbackImpl.getInterfaceToken: PEventCallbackToken;
begin
  Result := PEventCallbackToken(@token);
end;

function IEventCallbackImpl.getInterface: IEventCallback;
begin
  Result := intf;
end;

procedure IEventCallbackImpl_addRefDispatcher(this: PEventCallbackToken); cdecl;
begin
	try
		IEventCallbackImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IEventCallbackImpl_releaseDispatcher(this: PEventCallbackToken): Integer; cdecl;
begin
	try
		Result := IEventCallbackImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IEventCallbackImpl_eventCallbackFunctionDispatcher(this: PEventCallbackToken; length: Cardinal; events: BytePtr); cdecl;
begin
	try
		IEventCallbackImpl(PFBImplementationToken(this).Owner).eventCallbackFunction(length, events);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IEventCallbackImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     eventCallbackFunction := @IEventCallbackImpl_eventCallbackFunctionDispatcher;
  end;

  FInitialized := true;
end;

constructor IBlobImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IBlobImpl.getInterfaceToken: PBlobToken;
begin
  Result := PBlobToken(@token);
end;

function IBlobImpl.getInterface: IBlob;
begin
  Result := intf;
end;

procedure IBlobImpl_addRefDispatcher(this: PBlobToken); cdecl;
begin
	try
		IBlobImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBlobImpl_releaseDispatcher(this: PBlobToken): Integer; cdecl;
begin
	try
		Result := IBlobImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IBlobImpl_getInfoDispatcher(this: PBlobToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IBlobImpl(PFBImplementationToken(this).Owner).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBlobImpl_getSegmentDispatcher(this: PBlobToken; status: PStatusToken; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; cdecl;
begin
	try
		Result := IBlobImpl(PFBImplementationToken(this).Owner).getSegment(status, bufferLength, buffer, segmentLength);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_putSegmentDispatcher(this: PBlobToken; status: PStatusToken; length: Cardinal; buffer: Pointer); cdecl;
begin
	try
		IBlobImpl(PFBImplementationToken(this).Owner).putSegment(status, length, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_cancelDispatcher(this: PBlobToken; status: PStatusToken); cdecl;
begin
	try
		IBlobImpl(PFBImplementationToken(this).Owner).cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_closeDispatcher(this: PBlobToken; status: PStatusToken); cdecl;
begin
	try
		IBlobImpl(PFBImplementationToken(this).Owner).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBlobImpl_seekDispatcher(this: PBlobToken; status: PStatusToken; mode: Integer; offset: Integer): Integer; cdecl;
begin
	try
		Result := IBlobImpl(PFBImplementationToken(this).Owner).seek(status, mode, offset);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IBlobImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 8;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getInfo := @IBlobImpl_getInfoDispatcher;
     getSegment := @IBlobImpl_getSegmentDispatcher;
     putSegment := @IBlobImpl_putSegmentDispatcher;
     cancel := @IBlobImpl_cancelDispatcher;
     close := @IBlobImpl_closeDispatcher;
     seek := @IBlobImpl_seekDispatcher;
  end;

  FInitialized := true;
end;

constructor ITransactionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITransactionImpl.getInterfaceToken: PTransactionToken;
begin
  Result := PTransactionToken(@token);
end;

function ITransactionImpl.getInterface: ITransaction;
begin
  Result := intf;
end;

procedure ITransactionImpl_addRefDispatcher(this: PTransactionToken); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITransactionImpl_releaseDispatcher(this: PTransactionToken): Integer; cdecl;
begin
	try
		Result := ITransactionImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITransactionImpl_getInfoDispatcher(this: PTransactionToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_prepareDispatcher(this: PTransactionToken; status: PStatusToken; msgLength: Cardinal; message: BytePtr); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).prepare(status, msgLength, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_commitDispatcher(this: PTransactionToken; status: PStatusToken); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_commitRetainingDispatcher(this: PTransactionToken; status: PStatusToken); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).commitRetaining(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_rollbackDispatcher(this: PTransactionToken; status: PStatusToken); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_rollbackRetainingDispatcher(this: PTransactionToken; status: PStatusToken); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).rollbackRetaining(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_disconnectDispatcher(this: PTransactionToken; status: PStatusToken); cdecl;
begin
	try
		ITransactionImpl(PFBImplementationToken(this).Owner).disconnect(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_joinDispatcher(this: PTransactionToken; status: PStatusToken; transaction: PTransactionToken): PTransactionToken; cdecl;
begin
	try
		Result := ITransactionImpl(PFBImplementationToken(this).Owner).join(status, transaction);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_validateDispatcher(this: PTransactionToken; status: PStatusToken; attachment: PAttachmentToken): PTransactionToken; cdecl;
begin
	try
		Result := ITransactionImpl(PFBImplementationToken(this).Owner).validate(status, attachment);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_enterDtcDispatcher(this: PTransactionToken; status: PStatusToken): PTransactionToken; cdecl;
begin
	try
		Result := ITransactionImpl(PFBImplementationToken(this).Owner).enterDtc(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ITransactionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 12;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getInfo := @ITransactionImpl_getInfoDispatcher;
     prepare := @ITransactionImpl_prepareDispatcher;
     commit := @ITransactionImpl_commitDispatcher;
     commitRetaining := @ITransactionImpl_commitRetainingDispatcher;
     rollback := @ITransactionImpl_rollbackDispatcher;
     rollbackRetaining := @ITransactionImpl_rollbackRetainingDispatcher;
     disconnect := @ITransactionImpl_disconnectDispatcher;
     join := @ITransactionImpl_joinDispatcher;
     validate := @ITransactionImpl_validateDispatcher;
     enterDtc := @ITransactionImpl_enterDtcDispatcher;
  end;

  FInitialized := true;
end;

constructor IMessageMetadataImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IMessageMetadataImpl.getInterfaceToken: PMessageMetadataToken;
begin
  Result := PMessageMetadataToken(@token);
end;

function IMessageMetadataImpl.getInterface: IMessageMetadata;
begin
  Result := intf;
end;

procedure IMessageMetadataImpl_addRefDispatcher(this: PMessageMetadataToken); cdecl;
begin
	try
		IMessageMetadataImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMessageMetadataImpl_releaseDispatcher(this: PMessageMetadataToken): Integer; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMessageMetadataImpl_getCountDispatcher(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getCount(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getFieldDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getField(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getRelationDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getRelation(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getOwnerDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getOwner(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAliasDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getAlias(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getTypeDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getType(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_isNullableDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Boolean; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).isNullable(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getSubTypeDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Integer; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getSubType(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getLengthDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getLength(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getScaleDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Integer; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getScale(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getCharSetDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getCharSet(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getOffsetDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getOffset(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getNullOffsetDispatcher(this: PMessageMetadataToken; status: PStatusToken; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getNullOffset(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getBuilderDispatcher(this: PMessageMetadataToken; status: PStatusToken): PMetadataBuilderToken; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getBuilder(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getMessageLengthDispatcher(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getMessageLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAlignmentDispatcher(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getAlignment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAlignedLengthDispatcher(this: PMessageMetadataToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IMessageMetadataImpl(PFBImplementationToken(this).Owner).getAlignedLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IMessageMetadataImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 19;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getCount := @IMessageMetadataImpl_getCountDispatcher;
     getField := @IMessageMetadataImpl_getFieldDispatcher;
     getRelation := @IMessageMetadataImpl_getRelationDispatcher;
     getOwner := @IMessageMetadataImpl_getOwnerDispatcher;
     getAlias := @IMessageMetadataImpl_getAliasDispatcher;
     getType := @IMessageMetadataImpl_getTypeDispatcher;
     isNullable := @IMessageMetadataImpl_isNullableDispatcher;
     getSubType := @IMessageMetadataImpl_getSubTypeDispatcher;
     getLength := @IMessageMetadataImpl_getLengthDispatcher;
     getScale := @IMessageMetadataImpl_getScaleDispatcher;
     getCharSet := @IMessageMetadataImpl_getCharSetDispatcher;
     getOffset := @IMessageMetadataImpl_getOffsetDispatcher;
     getNullOffset := @IMessageMetadataImpl_getNullOffsetDispatcher;
     getBuilder := @IMessageMetadataImpl_getBuilderDispatcher;
     getMessageLength := @IMessageMetadataImpl_getMessageLengthDispatcher;
     getAlignment := @IMessageMetadataImpl_getAlignmentDispatcher;
     getAlignedLength := @IMessageMetadataImpl_getAlignedLengthDispatcher;
  end;

  FInitialized := true;
end;

constructor IMetadataBuilderImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IMetadataBuilderImpl.getInterfaceToken: PMetadataBuilderToken;
begin
  Result := PMetadataBuilderToken(@token);
end;

function IMetadataBuilderImpl.getInterface: IMetadataBuilder;
begin
  Result := intf;
end;

procedure IMetadataBuilderImpl_addRefDispatcher(this: PMetadataBuilderToken); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMetadataBuilderImpl_releaseDispatcher(this: PMetadataBuilderToken): Integer; cdecl;
begin
	try
		Result := IMetadataBuilderImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IMetadataBuilderImpl_setTypeDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; type_: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setType(status, index, type_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setSubTypeDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; subType: Integer); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setSubType(status, index, subType);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setLengthDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; length: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setLength(status, index, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setCharSetDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; charSet: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setCharSet(status, index, charSet);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setScaleDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; scale: Integer); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setScale(status, index, scale);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_truncateDispatcher(this: PMetadataBuilderToken; status: PStatusToken; count: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).truncate(status, count);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_moveNameToIndexDispatcher(this: PMetadataBuilderToken; status: PStatusToken; name: PAnsiChar; index: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).moveNameToIndex(status, name, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_removeDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).remove(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMetadataBuilderImpl_addFieldDispatcher(this: PMetadataBuilderToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IMetadataBuilderImpl(PFBImplementationToken(this).Owner).addField(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMetadataBuilderImpl_getMetadataDispatcher(this: PMetadataBuilderToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IMetadataBuilderImpl(PFBImplementationToken(this).Owner).getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setFieldDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; field: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setField(status, index, field);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setRelationDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; relation: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setRelation(status, index, relation);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setOwnerDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; owner: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setOwner(status, index, owner);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setAliasDispatcher(this: PMetadataBuilderToken; status: PStatusToken; index: Cardinal; alias: PAnsiChar); cdecl;
begin
	try
		IMetadataBuilderImpl(PFBImplementationToken(this).Owner).setAlias(status, index, alias);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IMetadataBuilderImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 16;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setType := @IMetadataBuilderImpl_setTypeDispatcher;
     setSubType := @IMetadataBuilderImpl_setSubTypeDispatcher;
     setLength := @IMetadataBuilderImpl_setLengthDispatcher;
     setCharSet := @IMetadataBuilderImpl_setCharSetDispatcher;
     setScale := @IMetadataBuilderImpl_setScaleDispatcher;
     truncate := @IMetadataBuilderImpl_truncateDispatcher;
     moveNameToIndex := @IMetadataBuilderImpl_moveNameToIndexDispatcher;
     remove := @IMetadataBuilderImpl_removeDispatcher;
     addField := @IMetadataBuilderImpl_addFieldDispatcher;
     getMetadata := @IMetadataBuilderImpl_getMetadataDispatcher;
     setField := @IMetadataBuilderImpl_setFieldDispatcher;
     setRelation := @IMetadataBuilderImpl_setRelationDispatcher;
     setOwner := @IMetadataBuilderImpl_setOwnerDispatcher;
     setAlias := @IMetadataBuilderImpl_setAliasDispatcher;
  end;

  FInitialized := true;
end;

constructor IResultSetImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IResultSetImpl.getInterfaceToken: PResultSetToken;
begin
  Result := PResultSetToken(@token);
end;

function IResultSetImpl.getInterface: IResultSet;
begin
  Result := intf;
end;

procedure IResultSetImpl_addRefDispatcher(this: PResultSetToken); cdecl;
begin
	try
		IResultSetImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IResultSetImpl_releaseDispatcher(this: PResultSetToken): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IResultSetImpl_fetchNextDispatcher(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).fetchNext(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchPriorDispatcher(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).fetchPrior(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchFirstDispatcher(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).fetchFirst(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchLastDispatcher(this: PResultSetToken; status: PStatusToken; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).fetchLast(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchAbsoluteDispatcher(this: PResultSetToken; status: PStatusToken; position: Integer; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).fetchAbsolute(status, position, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchRelativeDispatcher(this: PResultSetToken; status: PStatusToken; offset: Integer; message: Pointer): Integer; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).fetchRelative(status, offset, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_isEofDispatcher(this: PResultSetToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).isEof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_isBofDispatcher(this: PResultSetToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).isBof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_getMetadataDispatcher(this: PResultSetToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IResultSetImpl(PFBImplementationToken(this).Owner).getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IResultSetImpl_closeDispatcher(this: PResultSetToken; status: PStatusToken); cdecl;
begin
	try
		IResultSetImpl(PFBImplementationToken(this).Owner).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IResultSetImpl_setDelayedOutputFormatDispatcher(this: PResultSetToken; status: PStatusToken; format: PMessageMetadataToken); cdecl;
begin
	try
		IResultSetImpl(PFBImplementationToken(this).Owner).setDelayedOutputFormat(status, format);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IResultSetImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 13;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     fetchNext := @IResultSetImpl_fetchNextDispatcher;
     fetchPrior := @IResultSetImpl_fetchPriorDispatcher;
     fetchFirst := @IResultSetImpl_fetchFirstDispatcher;
     fetchLast := @IResultSetImpl_fetchLastDispatcher;
     fetchAbsolute := @IResultSetImpl_fetchAbsoluteDispatcher;
     fetchRelative := @IResultSetImpl_fetchRelativeDispatcher;
     isEof := @IResultSetImpl_isEofDispatcher;
     isBof := @IResultSetImpl_isBofDispatcher;
     getMetadata := @IResultSetImpl_getMetadataDispatcher;
     close := @IResultSetImpl_closeDispatcher;
     setDelayedOutputFormat := @IResultSetImpl_setDelayedOutputFormatDispatcher;
  end;

  FInitialized := true;
end;

constructor IStatementImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IStatementImpl.getInterfaceToken: PStatementToken;
begin
  Result := PStatementToken(@token);
end;

function IStatementImpl.getInterface: IStatement;
begin
  Result := intf;
end;

procedure IStatementImpl_addRefDispatcher(this: PStatementToken); cdecl;
begin
	try
		IStatementImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatementImpl_releaseDispatcher(this: PStatementToken): Integer; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatementImpl_getInfoDispatcher(this: PStatementToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IStatementImpl(PFBImplementationToken(this).Owner).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getTypeDispatcher(this: PStatementToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getType(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getPlanDispatcher(this: PStatementToken; status: PStatusToken; detailed: Boolean): PAnsiChar; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getPlan(status, detailed);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getAffectedRecordsDispatcher(this: PStatementToken; status: PStatusToken): QWord; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getAffectedRecords(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getInputMetadataDispatcher(this: PStatementToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getInputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getOutputMetadataDispatcher(this: PStatementToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getOutputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_executeDispatcher(this: PStatementToken; status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).execute(status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_openCursorDispatcher(this: PStatementToken; status: PStatusToken; transaction: PTransactionToken; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; flags: Cardinal): PResultSetToken; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).openCursor(status, transaction, inMetadata, inBuffer, outMetadata, flags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_setCursorNameDispatcher(this: PStatementToken; status: PStatusToken; name: PAnsiChar); cdecl;
begin
	try
		IStatementImpl(PFBImplementationToken(this).Owner).setCursorName(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_freeDispatcher(this: PStatementToken; status: PStatusToken); cdecl;
begin
	try
		IStatementImpl(PFBImplementationToken(this).Owner).free(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getFlagsDispatcher(this: PStatementToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getFlags(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getTimeoutDispatcher(this: PStatementToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).getTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_setTimeoutDispatcher(this: PStatementToken; status: PStatusToken; timeOut: Cardinal); cdecl;
begin
	try
		IStatementImpl(PFBImplementationToken(this).Owner).setTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_createBatchDispatcher(this: PStatementToken; status: PStatusToken; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken; cdecl;
begin
	try
		Result := IStatementImpl(PFBImplementationToken(this).Owner).createBatch(status, inMetadata, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IStatementImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 16;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getInfo := @IStatementImpl_getInfoDispatcher;
     getType := @IStatementImpl_getTypeDispatcher;
     getPlan := @IStatementImpl_getPlanDispatcher;
     getAffectedRecords := @IStatementImpl_getAffectedRecordsDispatcher;
     getInputMetadata := @IStatementImpl_getInputMetadataDispatcher;
     getOutputMetadata := @IStatementImpl_getOutputMetadataDispatcher;
     execute := @IStatementImpl_executeDispatcher;
     openCursor := @IStatementImpl_openCursorDispatcher;
     setCursorName := @IStatementImpl_setCursorNameDispatcher;
     free := @IStatementImpl_freeDispatcher;
     getFlags := @IStatementImpl_getFlagsDispatcher;
     getTimeout := @IStatementImpl_getTimeoutDispatcher;
     setTimeout := @IStatementImpl_setTimeoutDispatcher;
     createBatch := @IStatementImpl_createBatchDispatcher;
  end;

  FInitialized := true;
end;

constructor IBatchImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IBatchImpl.getInterfaceToken: PBatchToken;
begin
  Result := PBatchToken(@token);
end;

function IBatchImpl.getInterface: IBatch;
begin
  Result := intf;
end;

procedure IBatchImpl_addRefDispatcher(this: PBatchToken); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBatchImpl_releaseDispatcher(this: PBatchToken): Integer; cdecl;
begin
	try
		Result := IBatchImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IBatchImpl_addDispatcher(this: PBatchToken; status: PStatusToken; count: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).add(status, count, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_addBlobDispatcher(this: PBatchToken; status: PStatusToken; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).addBlob(status, length, inBuffer, blobId, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_appendBlobDataDispatcher(this: PBatchToken; status: PStatusToken; length: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).appendBlobData(status, length, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_addBlobStreamDispatcher(this: PBatchToken; status: PStatusToken; length: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).addBlobStream(status, length, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_registerBlobDispatcher(this: PBatchToken; status: PStatusToken; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).registerBlob(status, existingBlob, blobId);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_executeDispatcher(this: PBatchToken; status: PStatusToken; transaction: PTransactionToken): PBatchCompletionStateToken; cdecl;
begin
	try
		Result := IBatchImpl(PFBImplementationToken(this).Owner).execute(status, transaction);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_cancelDispatcher(this: PBatchToken; status: PStatusToken); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_getBlobAlignmentDispatcher(this: PBatchToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IBatchImpl(PFBImplementationToken(this).Owner).getBlobAlignment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_getMetadataDispatcher(this: PBatchToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IBatchImpl(PFBImplementationToken(this).Owner).getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_setDefaultBpbDispatcher(this: PBatchToken; status: PStatusToken; parLength: Cardinal; par: BytePtr); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).setDefaultBpb(status, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_closeDispatcher(this: PBatchToken; status: PStatusToken); cdecl;
begin
	try
		IBatchImpl(PFBImplementationToken(this).Owner).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IBatchImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 13;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     add := @IBatchImpl_addDispatcher;
     addBlob := @IBatchImpl_addBlobDispatcher;
     appendBlobData := @IBatchImpl_appendBlobDataDispatcher;
     addBlobStream := @IBatchImpl_addBlobStreamDispatcher;
     registerBlob := @IBatchImpl_registerBlobDispatcher;
     execute := @IBatchImpl_executeDispatcher;
     cancel := @IBatchImpl_cancelDispatcher;
     getBlobAlignment := @IBatchImpl_getBlobAlignmentDispatcher;
     getMetadata := @IBatchImpl_getMetadataDispatcher;
     setDefaultBpb := @IBatchImpl_setDefaultBpbDispatcher;
     close := @IBatchImpl_closeDispatcher;
  end;

  FInitialized := true;
end;

constructor IBatchCompletionStateImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IBatchCompletionStateImpl.getInterfaceToken: PBatchCompletionStateToken;
begin
  Result := PBatchCompletionStateToken(@token);
end;

function IBatchCompletionStateImpl.getInterface: IBatchCompletionState;
begin
  Result := intf;
end;

procedure IBatchCompletionStateImpl_disposeDispatcher(this: PBatchCompletionStateToken); cdecl;
begin
	try
		IBatchCompletionStateImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBatchCompletionStateImpl_getSizeDispatcher(this: PBatchCompletionStateToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IBatchCompletionStateImpl(PFBImplementationToken(this).Owner).getSize(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchCompletionStateImpl_getStateDispatcher(this: PBatchCompletionStateToken; status: PStatusToken; pos: Cardinal): Integer; cdecl;
begin
	try
		Result := IBatchCompletionStateImpl(PFBImplementationToken(this).Owner).getState(status, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchCompletionStateImpl_findErrorDispatcher(this: PBatchCompletionStateToken; status: PStatusToken; pos: Cardinal): Cardinal; cdecl;
begin
	try
		Result := IBatchCompletionStateImpl(PFBImplementationToken(this).Owner).findError(status, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchCompletionStateImpl_getStatusDispatcher(this: PBatchCompletionStateToken; status: PStatusToken; to_: PStatusToken; pos: Cardinal); cdecl;
begin
	try
		IBatchCompletionStateImpl(PFBImplementationToken(this).Owner).getStatus(status, to_, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IBatchCompletionStateImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     dispose := @IDisposableImpl_disposeDispatcher;
     getSize := @IBatchCompletionStateImpl_getSizeDispatcher;
     getState := @IBatchCompletionStateImpl_getStateDispatcher;
     findError := @IBatchCompletionStateImpl_findErrorDispatcher;
     getStatus := @IBatchCompletionStateImpl_getStatusDispatcher;
  end;

  FInitialized := true;
end;

constructor IReplicatorImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IReplicatorImpl.getInterfaceToken: PReplicatorToken;
begin
  Result := PReplicatorToken(@token);
end;

function IReplicatorImpl.getInterface: IReplicator;
begin
  Result := intf;
end;

procedure IReplicatorImpl_addRefDispatcher(this: PReplicatorToken); cdecl;
begin
	try
		IReplicatorImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatorImpl_releaseDispatcher(this: PReplicatorToken): Integer; cdecl;
begin
	try
		Result := IReplicatorImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatorImpl_processDispatcher(this: PReplicatorToken; status: PStatusToken; length: Cardinal; data: BytePtr); cdecl;
begin
	try
		IReplicatorImpl(PFBImplementationToken(this).Owner).process(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatorImpl_closeDispatcher(this: PReplicatorToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatorImpl(PFBImplementationToken(this).Owner).close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IReplicatorImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     process := @IReplicatorImpl_processDispatcher;
     close := @IReplicatorImpl_closeDispatcher;
  end;

  FInitialized := true;
end;

constructor IRequestImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IRequestImpl.getInterfaceToken: PRequestToken;
begin
  Result := PRequestToken(@token);
end;

function IRequestImpl.getInterface: IRequest;
begin
  Result := intf;
end;

procedure IRequestImpl_addRefDispatcher(this: PRequestToken); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IRequestImpl_releaseDispatcher(this: PRequestToken): Integer; cdecl;
begin
	try
		Result := IRequestImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IRequestImpl_receiveDispatcher(this: PRequestToken; status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).receive(status, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_sendDispatcher(this: PRequestToken; status: PStatusToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).send(status, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_getInfoDispatcher(this: PRequestToken; status: PStatusToken; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).getInfo(status, level, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_startDispatcher(this: PRequestToken; status: PStatusToken; tra: PTransactionToken; level: Integer); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).start(status, tra, level);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_startAndSendDispatcher(this: PRequestToken; status: PStatusToken; tra: PTransactionToken; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).startAndSend(status, tra, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_unwindDispatcher(this: PRequestToken; status: PStatusToken; level: Integer); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).unwind(status, level);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_freeDispatcher(this: PRequestToken; status: PStatusToken); cdecl;
begin
	try
		IRequestImpl(PFBImplementationToken(this).Owner).free(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IRequestImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 9;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     receive := @IRequestImpl_receiveDispatcher;
     send := @IRequestImpl_sendDispatcher;
     getInfo := @IRequestImpl_getInfoDispatcher;
     start := @IRequestImpl_startDispatcher;
     startAndSend := @IRequestImpl_startAndSendDispatcher;
     unwind := @IRequestImpl_unwindDispatcher;
     free := @IRequestImpl_freeDispatcher;
  end;

  FInitialized := true;
end;

constructor IEventsImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IEventsImpl.getInterfaceToken: PEventsToken;
begin
  Result := PEventsToken(@token);
end;

function IEventsImpl.getInterface: IEvents;
begin
  Result := intf;
end;

procedure IEventsImpl_addRefDispatcher(this: PEventsToken); cdecl;
begin
	try
		IEventsImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IEventsImpl_releaseDispatcher(this: PEventsToken): Integer; cdecl;
begin
	try
		Result := IEventsImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IEventsImpl_cancelDispatcher(this: PEventsToken; status: PStatusToken); cdecl;
begin
	try
		IEventsImpl(PFBImplementationToken(this).Owner).cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IEventsImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     cancel := @IEventsImpl_cancelDispatcher;
  end;

  FInitialized := true;
end;

constructor IAttachmentImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IAttachmentImpl.getInterfaceToken: PAttachmentToken;
begin
  Result := PAttachmentToken(@token);
end;

function IAttachmentImpl.getInterface: IAttachment;
begin
  Result := intf;
end;

procedure IAttachmentImpl_addRefDispatcher(this: PAttachmentToken); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAttachmentImpl_releaseDispatcher(this: PAttachmentToken): Integer; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IAttachmentImpl_getInfoDispatcher(this: PAttachmentToken; status: PStatusToken; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_startTransactionDispatcher(this: PAttachmentToken; status: PStatusToken; tpbLength: Cardinal; tpb: BytePtr): PTransactionToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).startTransaction(status, tpbLength, tpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_reconnectTransactionDispatcher(this: PAttachmentToken; status: PStatusToken; length: Cardinal; id: BytePtr): PTransactionToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).reconnectTransaction(status, length, id);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_compileRequestDispatcher(this: PAttachmentToken; status: PStatusToken; blrLength: Cardinal; blr: BytePtr): PRequestToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).compileRequest(status, blrLength, blr);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_transactRequestDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).transactRequest(status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createBlobDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).createBlob(status, transaction, id, bpbLength, bpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_openBlobDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): PBlobToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).openBlob(status, transaction, id, bpbLength, bpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getSliceDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).getSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_putSliceDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).putSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_executeDynDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; length: Cardinal; dyn: BytePtr); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).executeDyn(status, transaction, length, dyn);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_prepareDispatcher(this: PAttachmentToken; status: PStatusToken; tra: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): PStatementToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).prepare(status, tra, stmtLength, sqlStmt, dialect, flags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_executeDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; outBuffer: Pointer): PTransactionToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).execute(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_openCursorDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; inBuffer: Pointer; outMetadata: PMessageMetadataToken; cursorName: PAnsiChar; cursorFlags: Cardinal): PResultSetToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).openCursor(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_queEventsDispatcher(this: PAttachmentToken; status: PStatusToken; callback: PEventCallbackToken; length: Cardinal; events: BytePtr): PEventsToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).queEvents(status, callback, length, events);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_cancelOperationDispatcher(this: PAttachmentToken; status: PStatusToken; option: Integer); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).cancelOperation(status, option);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_pingDispatcher(this: PAttachmentToken; status: PStatusToken); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).ping(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_detachDispatcher(this: PAttachmentToken; status: PStatusToken); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).detach(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_dropDatabaseDispatcher(this: PAttachmentToken; status: PStatusToken); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).dropDatabase(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getIdleTimeoutDispatcher(this: PAttachmentToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).getIdleTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_setIdleTimeoutDispatcher(this: PAttachmentToken; status: PStatusToken; timeOut: Cardinal); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).setIdleTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getStatementTimeoutDispatcher(this: PAttachmentToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).getStatementTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_setStatementTimeoutDispatcher(this: PAttachmentToken; status: PStatusToken; timeOut: Cardinal); cdecl;
begin
	try
		IAttachmentImpl(PFBImplementationToken(this).Owner).setStatementTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createBatchDispatcher(this: PAttachmentToken; status: PStatusToken; transaction: PTransactionToken; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: PMessageMetadataToken; parLength: Cardinal; par: BytePtr): PBatchToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).createBatch(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createReplicatorDispatcher(this: PAttachmentToken; status: PStatusToken): PReplicatorToken; cdecl;
begin
	try
		Result := IAttachmentImpl(PFBImplementationToken(this).Owner).createReplicator(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IAttachmentImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 26;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getInfo := @IAttachmentImpl_getInfoDispatcher;
     startTransaction := @IAttachmentImpl_startTransactionDispatcher;
     reconnectTransaction := @IAttachmentImpl_reconnectTransactionDispatcher;
     compileRequest := @IAttachmentImpl_compileRequestDispatcher;
     transactRequest := @IAttachmentImpl_transactRequestDispatcher;
     createBlob := @IAttachmentImpl_createBlobDispatcher;
     openBlob := @IAttachmentImpl_openBlobDispatcher;
     getSlice := @IAttachmentImpl_getSliceDispatcher;
     putSlice := @IAttachmentImpl_putSliceDispatcher;
     executeDyn := @IAttachmentImpl_executeDynDispatcher;
     prepare := @IAttachmentImpl_prepareDispatcher;
     execute := @IAttachmentImpl_executeDispatcher;
     openCursor := @IAttachmentImpl_openCursorDispatcher;
     queEvents := @IAttachmentImpl_queEventsDispatcher;
     cancelOperation := @IAttachmentImpl_cancelOperationDispatcher;
     ping := @IAttachmentImpl_pingDispatcher;
     detach := @IAttachmentImpl_detachDispatcher;
     dropDatabase := @IAttachmentImpl_dropDatabaseDispatcher;
     getIdleTimeout := @IAttachmentImpl_getIdleTimeoutDispatcher;
     setIdleTimeout := @IAttachmentImpl_setIdleTimeoutDispatcher;
     getStatementTimeout := @IAttachmentImpl_getStatementTimeoutDispatcher;
     setStatementTimeout := @IAttachmentImpl_setStatementTimeoutDispatcher;
     createBatch := @IAttachmentImpl_createBatchDispatcher;
     createReplicator := @IAttachmentImpl_createReplicatorDispatcher;
  end;

  FInitialized := true;
end;

constructor IServiceImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IServiceImpl.getInterfaceToken: PServiceToken;
begin
  Result := PServiceToken(@token);
end;

function IServiceImpl.getInterface: IService;
begin
  Result := intf;
end;

procedure IServiceImpl_addRefDispatcher(this: PServiceToken); cdecl;
begin
	try
		IServiceImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServiceImpl_releaseDispatcher(this: PServiceToken): Integer; cdecl;
begin
	try
		Result := IServiceImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServiceImpl_detachDispatcher(this: PServiceToken; status: PStatusToken); cdecl;
begin
	try
		IServiceImpl(PFBImplementationToken(this).Owner).detach(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServiceImpl_queryDispatcher(this: PServiceToken; status: PStatusToken; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		IServiceImpl(PFBImplementationToken(this).Owner).query(status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServiceImpl_startDispatcher(this: PServiceToken; status: PStatusToken; spbLength: Cardinal; spb: BytePtr); cdecl;
begin
	try
		IServiceImpl(PFBImplementationToken(this).Owner).start(status, spbLength, spb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IServiceImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     detach := @IServiceImpl_detachDispatcher;
     query := @IServiceImpl_queryDispatcher;
     start := @IServiceImpl_startDispatcher;
  end;

  FInitialized := true;
end;

constructor IProviderImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IProviderImpl.getInterfaceToken: PProviderToken;
begin
  Result := PProviderToken(@token);
end;

function IProviderImpl.getInterface: IProvider;
begin
  Result := intf;
end;

procedure IProviderImpl_addRefDispatcher(this: PProviderToken); cdecl;
begin
	try
		IProviderImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_releaseDispatcher(this: PProviderToken): Integer; cdecl;
begin
	try
		Result := IProviderImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IProviderImpl_setOwnerDispatcher(this: PProviderToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IProviderImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_getOwnerDispatcher(this: PProviderToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IProviderImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_attachDatabaseDispatcher(this: PProviderToken; status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken; cdecl;
begin
	try
		Result := IProviderImpl(PFBImplementationToken(this).Owner).attachDatabase(status, fileName, dpbLength, dpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IProviderImpl_createDatabaseDispatcher(this: PProviderToken; status: PStatusToken; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): PAttachmentToken; cdecl;
begin
	try
		Result := IProviderImpl(PFBImplementationToken(this).Owner).createDatabase(status, fileName, dpbLength, dpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IProviderImpl_attachServiceManagerDispatcher(this: PProviderToken; status: PStatusToken; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): PServiceToken; cdecl;
begin
	try
		Result := IProviderImpl(PFBImplementationToken(this).Owner).attachServiceManager(status, service, spbLength, spb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IProviderImpl_shutdownDispatcher(this: PProviderToken; status: PStatusToken; timeout: Cardinal; reason: Integer); cdecl;
begin
	try
		IProviderImpl(PFBImplementationToken(this).Owner).shutdown(status, timeout, reason);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IProviderImpl_setDbCryptCallbackDispatcher(this: PProviderToken; status: PStatusToken; cryptCallback: PCryptKeyCallbackToken); cdecl;
begin
	try
		IProviderImpl(PFBImplementationToken(this).Owner).setDbCryptCallback(status, cryptCallback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IProviderImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 9;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     attachDatabase := @IProviderImpl_attachDatabaseDispatcher;
     createDatabase := @IProviderImpl_createDatabaseDispatcher;
     attachServiceManager := @IProviderImpl_attachServiceManagerDispatcher;
     shutdown := @IProviderImpl_shutdownDispatcher;
     setDbCryptCallback := @IProviderImpl_setDbCryptCallbackDispatcher;
  end;

  FInitialized := true;
end;

constructor IDtcStartImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDtcStartImpl.getInterfaceToken: PDtcStartToken;
begin
  Result := PDtcStartToken(@token);
end;

function IDtcStartImpl.getInterface: IDtcStart;
begin
  Result := intf;
end;

procedure IDtcStartImpl_disposeDispatcher(this: PDtcStartToken); cdecl;
begin
	try
		IDtcStartImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDtcStartImpl_addAttachmentDispatcher(this: PDtcStartToken; status: PStatusToken; att: PAttachmentToken); cdecl;
begin
	try
		IDtcStartImpl(PFBImplementationToken(this).Owner).addAttachment(status, att);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDtcStartImpl_addWithTpbDispatcher(this: PDtcStartToken; status: PStatusToken; att: PAttachmentToken; length: Cardinal; tpb: BytePtr); cdecl;
begin
	try
		IDtcStartImpl(PFBImplementationToken(this).Owner).addWithTpb(status, att, length, tpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IDtcStartImpl_startDispatcher(this: PDtcStartToken; status: PStatusToken): PTransactionToken; cdecl;
begin
	try
		Result := IDtcStartImpl(PFBImplementationToken(this).Owner).start(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IDtcStartImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     dispose := @IDisposableImpl_disposeDispatcher;
     addAttachment := @IDtcStartImpl_addAttachmentDispatcher;
     addWithTpb := @IDtcStartImpl_addWithTpbDispatcher;
     start := @IDtcStartImpl_startDispatcher;
  end;

  FInitialized := true;
end;

constructor IDtcImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDtcImpl.getInterfaceToken: PDtcToken;
begin
  Result := PDtcToken(@token);
end;

function IDtcImpl.getInterface: IDtc;
begin
  Result := intf;
end;

function IDtcImpl_joinDispatcher(this: PDtcToken; status: PStatusToken; one: PTransactionToken; two: PTransactionToken): PTransactionToken; cdecl;
begin
	try
		Result := IDtcImpl(PFBImplementationToken(this).Owner).join(status, one, two);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IDtcImpl_startBuilderDispatcher(this: PDtcToken; status: PStatusToken): PDtcStartToken; cdecl;
begin
	try
		Result := IDtcImpl(PFBImplementationToken(this).Owner).startBuilder(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IDtcImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     join := @IDtcImpl_joinDispatcher;
     startBuilder := @IDtcImpl_startBuilderDispatcher;
  end;

  FInitialized := true;
end;

constructor IAuthImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IAuthImpl.getInterfaceToken: PAuthToken;
begin
  Result := PAuthToken(@token);
end;

function IAuthImpl.getInterface: IAuth;
begin
  Result := intf;
end;

procedure IAuthImpl_addRefDispatcher(this: PAuthToken); cdecl;
begin
	try
		IAuthImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthImpl_releaseDispatcher(this: PAuthToken): Integer; cdecl;
begin
	try
		Result := IAuthImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IAuthImpl_setOwnerDispatcher(this: PAuthToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IAuthImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthImpl_getOwnerDispatcher(this: PAuthToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IAuthImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IAuthImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
  end;

  FInitialized := true;
end;

constructor IWriterImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IWriterImpl.getInterfaceToken: PWriterToken;
begin
  Result := PWriterToken(@token);
end;

function IWriterImpl.getInterface: IWriter;
begin
  Result := intf;
end;

procedure IWriterImpl_resetDispatcher(this: PWriterToken); cdecl;
begin
	try
		IWriterImpl(PFBImplementationToken(this).Owner).reset();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IWriterImpl_addDispatcher(this: PWriterToken; status: PStatusToken; name: PAnsiChar); cdecl;
begin
	try
		IWriterImpl(PFBImplementationToken(this).Owner).add(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWriterImpl_setTypeDispatcher(this: PWriterToken; status: PStatusToken; value: PAnsiChar); cdecl;
begin
	try
		IWriterImpl(PFBImplementationToken(this).Owner).setType(status, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWriterImpl_setDbDispatcher(this: PWriterToken; status: PStatusToken; value: PAnsiChar); cdecl;
begin
	try
		IWriterImpl(PFBImplementationToken(this).Owner).setDb(status, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IWriterImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     reset := @IWriterImpl_resetDispatcher;
     add := @IWriterImpl_addDispatcher;
     setType := @IWriterImpl_setTypeDispatcher;
     setDb := @IWriterImpl_setDbDispatcher;
  end;

  FInitialized := true;
end;

constructor IServerBlockImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IServerBlockImpl.getInterfaceToken: PServerBlockToken;
begin
  Result := PServerBlockToken(@token);
end;

function IServerBlockImpl.getInterface: IServerBlock;
begin
  Result := intf;
end;

function IServerBlockImpl_getLoginDispatcher(this: PServerBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IServerBlockImpl(PFBImplementationToken(this).Owner).getLogin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerBlockImpl_getDataDispatcher(this: PServerBlockToken; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := IServerBlockImpl(PFBImplementationToken(this).Owner).getData(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServerBlockImpl_putDataDispatcher(this: PServerBlockToken; status: PStatusToken; length: Cardinal; data: Pointer); cdecl;
begin
	try
		IServerBlockImpl(PFBImplementationToken(this).Owner).putData(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IServerBlockImpl_newKeyDispatcher(this: PServerBlockToken; status: PStatusToken): PCryptKeyToken; cdecl;
begin
	try
		Result := IServerBlockImpl(PFBImplementationToken(this).Owner).newKey(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IServerBlockImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     getLogin := @IServerBlockImpl_getLoginDispatcher;
     getData := @IServerBlockImpl_getDataDispatcher;
     putData := @IServerBlockImpl_putDataDispatcher;
     newKey := @IServerBlockImpl_newKeyDispatcher;
  end;

  FInitialized := true;
end;

constructor IClientBlockImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IClientBlockImpl.getInterfaceToken: PClientBlockToken;
begin
  Result := PClientBlockToken(@token);
end;

function IClientBlockImpl.getInterface: IClientBlock;
begin
  Result := intf;
end;

procedure IClientBlockImpl_addRefDispatcher(this: PClientBlockToken); cdecl;
begin
	try
		IClientBlockImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_releaseDispatcher(this: PClientBlockToken): Integer; cdecl;
begin
	try
		Result := IClientBlockImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getLoginDispatcher(this: PClientBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IClientBlockImpl(PFBImplementationToken(this).Owner).getLogin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getPasswordDispatcher(this: PClientBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IClientBlockImpl(PFBImplementationToken(this).Owner).getPassword();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getDataDispatcher(this: PClientBlockToken; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := IClientBlockImpl(PFBImplementationToken(this).Owner).getData(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IClientBlockImpl_putDataDispatcher(this: PClientBlockToken; status: PStatusToken; length: Cardinal; data: Pointer); cdecl;
begin
	try
		IClientBlockImpl(PFBImplementationToken(this).Owner).putData(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IClientBlockImpl_newKeyDispatcher(this: PClientBlockToken; status: PStatusToken): PCryptKeyToken; cdecl;
begin
	try
		Result := IClientBlockImpl(PFBImplementationToken(this).Owner).newKey(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IClientBlockImpl_getAuthBlockDispatcher(this: PClientBlockToken; status: PStatusToken): PAuthBlockToken; cdecl;
begin
	try
		Result := IClientBlockImpl(PFBImplementationToken(this).Owner).getAuthBlock(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IClientBlockImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 8;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getLogin := @IClientBlockImpl_getLoginDispatcher;
     getPassword := @IClientBlockImpl_getPasswordDispatcher;
     getData := @IClientBlockImpl_getDataDispatcher;
     putData := @IClientBlockImpl_putDataDispatcher;
     newKey := @IClientBlockImpl_newKeyDispatcher;
     getAuthBlock := @IClientBlockImpl_getAuthBlockDispatcher;
  end;

  FInitialized := true;
end;

constructor IServerImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IServerImpl.getInterfaceToken: PServerToken;
begin
  Result := PServerToken(@token);
end;

function IServerImpl.getInterface: IServer;
begin
  Result := intf;
end;

procedure IServerImpl_addRefDispatcher(this: PServerToken); cdecl;
begin
	try
		IServerImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_releaseDispatcher(this: PServerToken): Integer; cdecl;
begin
	try
		Result := IServerImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServerImpl_setOwnerDispatcher(this: PServerToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IServerImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_getOwnerDispatcher(this: PServerToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IServerImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_authenticateDispatcher(this: PServerToken; status: PStatusToken; sBlock: PServerBlockToken; writerInterface: PWriterToken): Integer; cdecl;
begin
	try
		Result := IServerImpl(PFBImplementationToken(this).Owner).authenticate(status, sBlock, writerInterface);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServerImpl_setDbCryptCallbackDispatcher(this: PServerToken; status: PStatusToken; cryptCallback: PCryptKeyCallbackToken); cdecl;
begin
	try
		IServerImpl(PFBImplementationToken(this).Owner).setDbCryptCallback(status, cryptCallback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IServerImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 6;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     authenticate := @IServerImpl_authenticateDispatcher;
     setDbCryptCallback := @IServerImpl_setDbCryptCallbackDispatcher;
  end;

  FInitialized := true;
end;

constructor IClientImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IClientImpl.getInterfaceToken: PClientToken;
begin
  Result := PClientToken(@token);
end;

function IClientImpl.getInterface: IClient;
begin
  Result := intf;
end;

procedure IClientImpl_addRefDispatcher(this: PClientToken); cdecl;
begin
	try
		IClientImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_releaseDispatcher(this: PClientToken): Integer; cdecl;
begin
	try
		Result := IClientImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IClientImpl_setOwnerDispatcher(this: PClientToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IClientImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_getOwnerDispatcher(this: PClientToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IClientImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_authenticateDispatcher(this: PClientToken; status: PStatusToken; cBlock: PClientBlockToken): Integer; cdecl;
begin
	try
		Result := IClientImpl(PFBImplementationToken(this).Owner).authenticate(status, cBlock);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IClientImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     authenticate := @IClientImpl_authenticateDispatcher;
  end;

  FInitialized := true;
end;

constructor IUserFieldImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUserFieldImpl.getInterfaceToken: PUserFieldToken;
begin
  Result := PUserFieldToken(@token);
end;

function IUserFieldImpl.getInterface: IUserField;
begin
  Result := intf;
end;

function IUserFieldImpl_enteredDispatcher(this: PUserFieldToken): Integer; cdecl;
begin
	try
		Result := IUserFieldImpl(PFBImplementationToken(this).Owner).entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserFieldImpl_specifiedDispatcher(this: PUserFieldToken): Integer; cdecl;
begin
	try
		Result := IUserFieldImpl(PFBImplementationToken(this).Owner).specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUserFieldImpl_setEnteredDispatcher(this: PUserFieldToken; status: PStatusToken; newValue: Integer); cdecl;
begin
	try
		IUserFieldImpl(PFBImplementationToken(this).Owner).setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUserFieldImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     entered := @IUserFieldImpl_enteredDispatcher;
     specified := @IUserFieldImpl_specifiedDispatcher;
     setEntered := @IUserFieldImpl_setEnteredDispatcher;
  end;

  FInitialized := true;
end;

constructor ICharUserFieldImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ICharUserFieldImpl.getInterfaceToken: PCharUserFieldToken;
begin
  Result := PCharUserFieldToken(@token);
end;

function ICharUserFieldImpl.getInterface: ICharUserField;
begin
  Result := intf;
end;

function ICharUserFieldImpl_enteredDispatcher(this: PCharUserFieldToken): Integer; cdecl;
begin
	try
		Result := ICharUserFieldImpl(PFBImplementationToken(this).Owner).entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ICharUserFieldImpl_specifiedDispatcher(this: PCharUserFieldToken): Integer; cdecl;
begin
	try
		Result := ICharUserFieldImpl(PFBImplementationToken(this).Owner).specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ICharUserFieldImpl_setEnteredDispatcher(this: PCharUserFieldToken; status: PStatusToken; newValue: Integer); cdecl;
begin
	try
		ICharUserFieldImpl(PFBImplementationToken(this).Owner).setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ICharUserFieldImpl_getDispatcher(this: PCharUserFieldToken): PAnsiChar; cdecl;
begin
	try
		Result := ICharUserFieldImpl(PFBImplementationToken(this).Owner).get();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ICharUserFieldImpl_set_Dispatcher(this: PCharUserFieldToken; status: PStatusToken; newValue: PAnsiChar); cdecl;
begin
	try
		ICharUserFieldImpl(PFBImplementationToken(this).Owner).set_(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ICharUserFieldImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     entered := @IUserFieldImpl_enteredDispatcher;
     specified := @IUserFieldImpl_specifiedDispatcher;
     setEntered := @IUserFieldImpl_setEnteredDispatcher;
     get := @ICharUserFieldImpl_getDispatcher;
     set_ := @ICharUserFieldImpl_set_Dispatcher;
  end;

  FInitialized := true;
end;

constructor IIntUserFieldImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IIntUserFieldImpl.getInterfaceToken: PIntUserFieldToken;
begin
  Result := PIntUserFieldToken(@token);
end;

function IIntUserFieldImpl.getInterface: IIntUserField;
begin
  Result := intf;
end;

function IIntUserFieldImpl_enteredDispatcher(this: PIntUserFieldToken): Integer; cdecl;
begin
	try
		Result := IIntUserFieldImpl(PFBImplementationToken(this).Owner).entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IIntUserFieldImpl_specifiedDispatcher(this: PIntUserFieldToken): Integer; cdecl;
begin
	try
		Result := IIntUserFieldImpl(PFBImplementationToken(this).Owner).specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IIntUserFieldImpl_setEnteredDispatcher(this: PIntUserFieldToken; status: PStatusToken; newValue: Integer); cdecl;
begin
	try
		IIntUserFieldImpl(PFBImplementationToken(this).Owner).setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IIntUserFieldImpl_getDispatcher(this: PIntUserFieldToken): Integer; cdecl;
begin
	try
		Result := IIntUserFieldImpl(PFBImplementationToken(this).Owner).get();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IIntUserFieldImpl_set_Dispatcher(this: PIntUserFieldToken; status: PStatusToken; newValue: Integer); cdecl;
begin
	try
		IIntUserFieldImpl(PFBImplementationToken(this).Owner).set_(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IIntUserFieldImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     entered := @IUserFieldImpl_enteredDispatcher;
     specified := @IUserFieldImpl_specifiedDispatcher;
     setEntered := @IUserFieldImpl_setEnteredDispatcher;
     get := @IIntUserFieldImpl_getDispatcher;
     set_ := @IIntUserFieldImpl_set_Dispatcher;
  end;

  FInitialized := true;
end;

constructor IUserImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUserImpl.getInterfaceToken: PUserToken;
begin
  Result := PUserToken(@token);
end;

function IUserImpl.getInterface: IUser;
begin
  Result := intf;
end;

function IUserImpl_operationDispatcher(this: PUserToken): Cardinal; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).operation();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_userNameDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).userName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_passwordDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).password();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_firstNameDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).firstName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_lastNameDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).lastName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_middleNameDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).middleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_commentDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).comment();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_attributesDispatcher(this: PUserToken): PCharUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).attributes();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_activeDispatcher(this: PUserToken): PIntUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).active();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_adminDispatcher(this: PUserToken): PIntUserFieldToken; cdecl;
begin
	try
		Result := IUserImpl(PFBImplementationToken(this).Owner).admin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUserImpl_clearDispatcher(this: PUserToken; status: PStatusToken); cdecl;
begin
	try
		IUserImpl(PFBImplementationToken(this).Owner).clear(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUserImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 11;
     operation := @IUserImpl_operationDispatcher;
     userName := @IUserImpl_userNameDispatcher;
     password := @IUserImpl_passwordDispatcher;
     firstName := @IUserImpl_firstNameDispatcher;
     lastName := @IUserImpl_lastNameDispatcher;
     middleName := @IUserImpl_middleNameDispatcher;
     comment := @IUserImpl_commentDispatcher;
     attributes := @IUserImpl_attributesDispatcher;
     active := @IUserImpl_activeDispatcher;
     admin := @IUserImpl_adminDispatcher;
     clear := @IUserImpl_clearDispatcher;
  end;

  FInitialized := true;
end;

constructor IListUsersImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IListUsersImpl.getInterfaceToken: PListUsersToken;
begin
  Result := PListUsersToken(@token);
end;

function IListUsersImpl.getInterface: IListUsers;
begin
  Result := intf;
end;

procedure IListUsersImpl_listDispatcher(this: PListUsersToken; status: PStatusToken; user: PUserToken); cdecl;
begin
	try
		IListUsersImpl(PFBImplementationToken(this).Owner).list(status, user);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IListUsersImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 1;
     list := @IListUsersImpl_listDispatcher;
  end;

  FInitialized := true;
end;

constructor ILogonInfoImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ILogonInfoImpl.getInterfaceToken: PLogonInfoToken;
begin
  Result := PLogonInfoToken(@token);
end;

function ILogonInfoImpl.getInterface: ILogonInfo;
begin
  Result := intf;
end;

function ILogonInfoImpl_nameDispatcher(this: PLogonInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).name();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_roleDispatcher(this: PLogonInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).role();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_networkProtocolDispatcher(this: PLogonInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).networkProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_remoteAddressDispatcher(this: PLogonInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).remoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_authBlockDispatcher(this: PLogonInfoToken; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).authBlock(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_attachmentDispatcher(this: PLogonInfoToken; status: PStatusToken): PAttachmentToken; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).attachment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ILogonInfoImpl_transactionDispatcher(this: PLogonInfoToken; status: PStatusToken): PTransactionToken; cdecl;
begin
	try
		Result := ILogonInfoImpl(PFBImplementationToken(this).Owner).transaction(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ILogonInfoImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     name := @ILogonInfoImpl_nameDispatcher;
     role := @ILogonInfoImpl_roleDispatcher;
     networkProtocol := @ILogonInfoImpl_networkProtocolDispatcher;
     remoteAddress := @ILogonInfoImpl_remoteAddressDispatcher;
     authBlock := @ILogonInfoImpl_authBlockDispatcher;
     attachment := @ILogonInfoImpl_attachmentDispatcher;
     transaction := @ILogonInfoImpl_transactionDispatcher;
  end;

  FInitialized := true;
end;

constructor IManagementImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IManagementImpl.getInterfaceToken: PManagementToken;
begin
  Result := PManagementToken(@token);
end;

function IManagementImpl.getInterface: IManagement;
begin
  Result := intf;
end;

procedure IManagementImpl_addRefDispatcher(this: PManagementToken); cdecl;
begin
	try
		IManagementImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IManagementImpl_releaseDispatcher(this: PManagementToken): Integer; cdecl;
begin
	try
		Result := IManagementImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IManagementImpl_setOwnerDispatcher(this: PManagementToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IManagementImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IManagementImpl_getOwnerDispatcher(this: PManagementToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IManagementImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IManagementImpl_startDispatcher(this: PManagementToken; status: PStatusToken; logonInfo: PLogonInfoToken); cdecl;
begin
	try
		IManagementImpl(PFBImplementationToken(this).Owner).start(status, logonInfo);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IManagementImpl_executeDispatcher(this: PManagementToken; status: PStatusToken; user: PUserToken; callback: PListUsersToken): Integer; cdecl;
begin
	try
		Result := IManagementImpl(PFBImplementationToken(this).Owner).execute(status, user, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IManagementImpl_commitDispatcher(this: PManagementToken; status: PStatusToken); cdecl;
begin
	try
		IManagementImpl(PFBImplementationToken(this).Owner).commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IManagementImpl_rollbackDispatcher(this: PManagementToken; status: PStatusToken); cdecl;
begin
	try
		IManagementImpl(PFBImplementationToken(this).Owner).rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IManagementImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 8;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     start := @IManagementImpl_startDispatcher;
     execute := @IManagementImpl_executeDispatcher;
     commit := @IManagementImpl_commitDispatcher;
     rollback := @IManagementImpl_rollbackDispatcher;
  end;

  FInitialized := true;
end;

constructor IAuthBlockImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IAuthBlockImpl.getInterfaceToken: PAuthBlockToken;
begin
  Result := PAuthBlockToken(@token);
end;

function IAuthBlockImpl.getInterface: IAuthBlock;
begin
  Result := intf;
end;

function IAuthBlockImpl_getTypeDispatcher(this: PAuthBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).getType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getNameDispatcher(this: PAuthBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getPluginDispatcher(this: PAuthBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).getPlugin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getSecurityDbDispatcher(this: PAuthBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).getSecurityDb();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getOriginalPluginDispatcher(this: PAuthBlockToken): PAnsiChar; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).getOriginalPlugin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_nextDispatcher(this: PAuthBlockToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).next(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAuthBlockImpl_firstDispatcher(this: PAuthBlockToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IAuthBlockImpl(PFBImplementationToken(this).Owner).first(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IAuthBlockImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     getType := @IAuthBlockImpl_getTypeDispatcher;
     getName := @IAuthBlockImpl_getNameDispatcher;
     getPlugin := @IAuthBlockImpl_getPluginDispatcher;
     getSecurityDb := @IAuthBlockImpl_getSecurityDbDispatcher;
     getOriginalPlugin := @IAuthBlockImpl_getOriginalPluginDispatcher;
     next := @IAuthBlockImpl_nextDispatcher;
     first := @IAuthBlockImpl_firstDispatcher;
  end;

  FInitialized := true;
end;

constructor IWireCryptPluginImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IWireCryptPluginImpl.getInterfaceToken: PWireCryptPluginToken;
begin
  Result := PWireCryptPluginToken(@token);
end;

function IWireCryptPluginImpl.getInterface: IWireCryptPlugin;
begin
  Result := intf;
end;

procedure IWireCryptPluginImpl_addRefDispatcher(this: PWireCryptPluginToken); cdecl;
begin
	try
		IWireCryptPluginImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_releaseDispatcher(this: PWireCryptPluginToken): Integer; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IWireCryptPluginImpl_setOwnerDispatcher(this: PWireCryptPluginToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IWireCryptPluginImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_getOwnerDispatcher(this: PWireCryptPluginToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_getKnownTypesDispatcher(this: PWireCryptPluginToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(PFBImplementationToken(this).Owner).getKnownTypes(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_setKeyDispatcher(this: PWireCryptPluginToken; status: PStatusToken; key: PCryptKeyToken); cdecl;
begin
	try
		IWireCryptPluginImpl(PFBImplementationToken(this).Owner).setKey(status, key);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_encryptDispatcher(this: PWireCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IWireCryptPluginImpl(PFBImplementationToken(this).Owner).encrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_decryptDispatcher(this: PWireCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IWireCryptPluginImpl(PFBImplementationToken(this).Owner).decrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IWireCryptPluginImpl_getSpecificDataDispatcher(this: PWireCryptPluginToken; status: PStatusToken; keyType: PAnsiChar; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := IWireCryptPluginImpl(PFBImplementationToken(this).Owner).getSpecificData(status, keyType, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_setSpecificDataDispatcher(this: PWireCryptPluginToken; status: PStatusToken; keyType: PAnsiChar; length: Cardinal; data: BytePtr); cdecl;
begin
	try
		IWireCryptPluginImpl(PFBImplementationToken(this).Owner).setSpecificData(status, keyType, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IWireCryptPluginImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 10;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     getKnownTypes := @IWireCryptPluginImpl_getKnownTypesDispatcher;
     setKey := @IWireCryptPluginImpl_setKeyDispatcher;
     encrypt := @IWireCryptPluginImpl_encryptDispatcher;
     decrypt := @IWireCryptPluginImpl_decryptDispatcher;
     getSpecificData := @IWireCryptPluginImpl_getSpecificDataDispatcher;
     setSpecificData := @IWireCryptPluginImpl_setSpecificDataDispatcher;
  end;

  FInitialized := true;
end;

constructor ICryptKeyCallbackImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ICryptKeyCallbackImpl.getInterfaceToken: PCryptKeyCallbackToken;
begin
  Result := PCryptKeyCallbackToken(@token);
end;

function ICryptKeyCallbackImpl.getInterface: ICryptKeyCallback;
begin
  Result := intf;
end;

function ICryptKeyCallbackImpl_callbackDispatcher(this: PCryptKeyCallbackToken; dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; cdecl;
begin
	try
		Result := ICryptKeyCallbackImpl(PFBImplementationToken(this).Owner).callback(dataLength, data, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ICryptKeyCallbackImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 1;
     callback := @ICryptKeyCallbackImpl_callbackDispatcher;
  end;

  FInitialized := true;
end;

constructor IKeyHolderPluginImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IKeyHolderPluginImpl.getInterfaceToken: PKeyHolderPluginToken;
begin
  Result := PKeyHolderPluginToken(@token);
end;

function IKeyHolderPluginImpl.getInterface: IKeyHolderPlugin;
begin
  Result := intf;
end;

procedure IKeyHolderPluginImpl_addRefDispatcher(this: PKeyHolderPluginToken); cdecl;
begin
	try
		IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_releaseDispatcher(this: PKeyHolderPluginToken): Integer; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IKeyHolderPluginImpl_setOwnerDispatcher(this: PKeyHolderPluginToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_getOwnerDispatcher(this: PKeyHolderPluginToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_keyCallbackDispatcher(this: PKeyHolderPluginToken; status: PStatusToken; callback: PCryptKeyCallbackToken): Integer; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).keyCallback(status, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_keyHandleDispatcher(this: PKeyHolderPluginToken; status: PStatusToken; keyName: PAnsiChar): PCryptKeyCallbackToken; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).keyHandle(status, keyName);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_useOnlyOwnKeysDispatcher(this: PKeyHolderPluginToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).useOnlyOwnKeys(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_chainHandleDispatcher(this: PKeyHolderPluginToken; status: PStatusToken): PCryptKeyCallbackToken; cdecl;
begin
	try
		Result := IKeyHolderPluginImpl(PFBImplementationToken(this).Owner).chainHandle(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IKeyHolderPluginImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 8;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     keyCallback := @IKeyHolderPluginImpl_keyCallbackDispatcher;
     keyHandle := @IKeyHolderPluginImpl_keyHandleDispatcher;
     useOnlyOwnKeys := @IKeyHolderPluginImpl_useOnlyOwnKeysDispatcher;
     chainHandle := @IKeyHolderPluginImpl_chainHandleDispatcher;
  end;

  FInitialized := true;
end;

constructor IDbCryptInfoImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDbCryptInfoImpl.getInterfaceToken: PDbCryptInfoToken;
begin
  Result := PDbCryptInfoToken(@token);
end;

function IDbCryptInfoImpl.getInterface: IDbCryptInfo;
begin
  Result := intf;
end;

procedure IDbCryptInfoImpl_addRefDispatcher(this: PDbCryptInfoToken); cdecl;
begin
	try
		IDbCryptInfoImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptInfoImpl_releaseDispatcher(this: PDbCryptInfoToken): Integer; cdecl;
begin
	try
		Result := IDbCryptInfoImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptInfoImpl_getDatabaseFullPathDispatcher(this: PDbCryptInfoToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IDbCryptInfoImpl(PFBImplementationToken(this).Owner).getDatabaseFullPath(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IDbCryptInfoImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     getDatabaseFullPath := @IDbCryptInfoImpl_getDatabaseFullPathDispatcher;
  end;

  FInitialized := true;
end;

constructor IDbCryptPluginImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDbCryptPluginImpl.getInterfaceToken: PDbCryptPluginToken;
begin
  Result := PDbCryptPluginToken(@token);
end;

function IDbCryptPluginImpl.getInterface: IDbCryptPlugin;
begin
  Result := intf;
end;

procedure IDbCryptPluginImpl_addRefDispatcher(this: PDbCryptPluginToken); cdecl;
begin
	try
		IDbCryptPluginImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptPluginImpl_releaseDispatcher(this: PDbCryptPluginToken): Integer; cdecl;
begin
	try
		Result := IDbCryptPluginImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDbCryptPluginImpl_setOwnerDispatcher(this: PDbCryptPluginToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IDbCryptPluginImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptPluginImpl_getOwnerDispatcher(this: PDbCryptPluginToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IDbCryptPluginImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDbCryptPluginImpl_setKeyDispatcher(this: PDbCryptPluginToken; status: PStatusToken; length: Cardinal; sources: PKeyHolderPluginTokenPtr; keyName: PAnsiChar); cdecl;
begin
	try
		IDbCryptPluginImpl(PFBImplementationToken(this).Owner).setKey(status, length, sources, keyName);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_encryptDispatcher(this: PDbCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IDbCryptPluginImpl(PFBImplementationToken(this).Owner).encrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_decryptDispatcher(this: PDbCryptPluginToken; status: PStatusToken; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		IDbCryptPluginImpl(PFBImplementationToken(this).Owner).decrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_setInfoDispatcher(this: PDbCryptPluginToken; status: PStatusToken; info: PDbCryptInfoToken); cdecl;
begin
	try
		IDbCryptPluginImpl(PFBImplementationToken(this).Owner).setInfo(status, info);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IDbCryptPluginImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 8;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     setKey := @IDbCryptPluginImpl_setKeyDispatcher;
     encrypt := @IDbCryptPluginImpl_encryptDispatcher;
     decrypt := @IDbCryptPluginImpl_decryptDispatcher;
     setInfo := @IDbCryptPluginImpl_setInfoDispatcher;
  end;

  FInitialized := true;
end;

constructor IExternalContextImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IExternalContextImpl.getInterfaceToken: PExternalContextToken;
begin
  Result := PExternalContextToken(@token);
end;

function IExternalContextImpl.getInterface: IExternalContext;
begin
  Result := intf;
end;

function IExternalContextImpl_getMasterDispatcher(this: PExternalContextToken): PMasterToken; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getMaster();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getEngineDispatcher(this: PExternalContextToken; status: PStatusToken): PExternalEngineToken; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getEngine(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getAttachmentDispatcher(this: PExternalContextToken; status: PStatusToken): PAttachmentToken; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getAttachment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getTransactionDispatcher(this: PExternalContextToken; status: PStatusToken): PTransactionToken; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getTransaction(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getUserNameDispatcher(this: PExternalContextToken): PAnsiChar; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getDatabaseNameDispatcher(this: PExternalContextToken): PAnsiChar; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getClientCharSetDispatcher(this: PExternalContextToken): PAnsiChar; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getClientCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_obtainInfoCodeDispatcher(this: PExternalContextToken): Integer; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).obtainInfoCode();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getInfoDispatcher(this: PExternalContextToken; code: Integer): Pointer; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).getInfo(code);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_setInfoDispatcher(this: PExternalContextToken; code: Integer; value: Pointer): Pointer; cdecl;
begin
	try
		Result := IExternalContextImpl(PFBImplementationToken(this).Owner).setInfo(code, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IExternalContextImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 10;
     getMaster := @IExternalContextImpl_getMasterDispatcher;
     getEngine := @IExternalContextImpl_getEngineDispatcher;
     getAttachment := @IExternalContextImpl_getAttachmentDispatcher;
     getTransaction := @IExternalContextImpl_getTransactionDispatcher;
     getUserName := @IExternalContextImpl_getUserNameDispatcher;
     getDatabaseName := @IExternalContextImpl_getDatabaseNameDispatcher;
     getClientCharSet := @IExternalContextImpl_getClientCharSetDispatcher;
     obtainInfoCode := @IExternalContextImpl_obtainInfoCodeDispatcher;
     getInfo := @IExternalContextImpl_getInfoDispatcher;
     setInfo := @IExternalContextImpl_setInfoDispatcher;
  end;

  FInitialized := true;
end;

constructor IExternalResultSetImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IExternalResultSetImpl.getInterfaceToken: PExternalResultSetToken;
begin
  Result := PExternalResultSetToken(@token);
end;

function IExternalResultSetImpl.getInterface: IExternalResultSet;
begin
  Result := intf;
end;

procedure IExternalResultSetImpl_disposeDispatcher(this: PExternalResultSetToken); cdecl;
begin
	try
		IExternalResultSetImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalResultSetImpl_fetchDispatcher(this: PExternalResultSetToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IExternalResultSetImpl(PFBImplementationToken(this).Owner).fetch(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IExternalResultSetImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     dispose := @IDisposableImpl_disposeDispatcher;
     fetch := @IExternalResultSetImpl_fetchDispatcher;
  end;

  FInitialized := true;
end;

constructor IExternalFunctionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IExternalFunctionImpl.getInterfaceToken: PExternalFunctionToken;
begin
  Result := PExternalFunctionToken(@token);
end;

function IExternalFunctionImpl.getInterface: IExternalFunction;
begin
  Result := intf;
end;

procedure IExternalFunctionImpl_disposeDispatcher(this: PExternalFunctionToken); cdecl;
begin
	try
		IExternalFunctionImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalFunctionImpl_getCharSetDispatcher(this: PExternalFunctionToken; status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		IExternalFunctionImpl(PFBImplementationToken(this).Owner).getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalFunctionImpl_executeDispatcher(this: PExternalFunctionToken; status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer); cdecl;
begin
	try
		IExternalFunctionImpl(PFBImplementationToken(this).Owner).execute(status, context, inMsg, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IExternalFunctionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     dispose := @IDisposableImpl_disposeDispatcher;
     getCharSet := @IExternalFunctionImpl_getCharSetDispatcher;
     execute := @IExternalFunctionImpl_executeDispatcher;
  end;

  FInitialized := true;
end;

constructor IExternalProcedureImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IExternalProcedureImpl.getInterfaceToken: PExternalProcedureToken;
begin
  Result := PExternalProcedureToken(@token);
end;

function IExternalProcedureImpl.getInterface: IExternalProcedure;
begin
  Result := intf;
end;

procedure IExternalProcedureImpl_disposeDispatcher(this: PExternalProcedureToken); cdecl;
begin
	try
		IExternalProcedureImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalProcedureImpl_getCharSetDispatcher(this: PExternalProcedureToken; status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		IExternalProcedureImpl(PFBImplementationToken(this).Owner).getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalProcedureImpl_openDispatcher(this: PExternalProcedureToken; status: PStatusToken; context: PExternalContextToken; inMsg: Pointer; outMsg: Pointer): PExternalResultSetToken; cdecl;
begin
	try
		Result := IExternalProcedureImpl(PFBImplementationToken(this).Owner).open(status, context, inMsg, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IExternalProcedureImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     dispose := @IDisposableImpl_disposeDispatcher;
     getCharSet := @IExternalProcedureImpl_getCharSetDispatcher;
     open := @IExternalProcedureImpl_openDispatcher;
  end;

  FInitialized := true;
end;

constructor IExternalTriggerImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IExternalTriggerImpl.getInterfaceToken: PExternalTriggerToken;
begin
  Result := PExternalTriggerToken(@token);
end;

function IExternalTriggerImpl.getInterface: IExternalTrigger;
begin
  Result := intf;
end;

procedure IExternalTriggerImpl_disposeDispatcher(this: PExternalTriggerToken); cdecl;
begin
	try
		IExternalTriggerImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalTriggerImpl_getCharSetDispatcher(this: PExternalTriggerToken; status: PStatusToken; context: PExternalContextToken; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		IExternalTriggerImpl(PFBImplementationToken(this).Owner).getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalTriggerImpl_executeDispatcher(this: PExternalTriggerToken; status: PStatusToken; context: PExternalContextToken; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); cdecl;
begin
	try
		IExternalTriggerImpl(PFBImplementationToken(this).Owner).execute(status, context, action, oldMsg, newMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IExternalTriggerImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     dispose := @IDisposableImpl_disposeDispatcher;
     getCharSet := @IExternalTriggerImpl_getCharSetDispatcher;
     execute := @IExternalTriggerImpl_executeDispatcher;
  end;

  FInitialized := true;
end;

constructor IRoutineMetadataImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IRoutineMetadataImpl.getInterfaceToken: PRoutineMetadataToken;
begin
  Result := PRoutineMetadataToken(@token);
end;

function IRoutineMetadataImpl.getInterface: IRoutineMetadata;
begin
  Result := intf;
end;

function IRoutineMetadataImpl_getPackageDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getPackage(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getNameDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getName(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getEntryPointDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getEntryPoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getBodyDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getBody(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getInputMetadataDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getInputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getOutputMetadataDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getOutputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerMetadataDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PMessageMetadataToken; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getTriggerMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerTableDispatcher(this: PRoutineMetadataToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getTriggerTable(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerTypeDispatcher(this: PRoutineMetadataToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IRoutineMetadataImpl(PFBImplementationToken(this).Owner).getTriggerType(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IRoutineMetadataImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 9;
     getPackage := @IRoutineMetadataImpl_getPackageDispatcher;
     getName := @IRoutineMetadataImpl_getNameDispatcher;
     getEntryPoint := @IRoutineMetadataImpl_getEntryPointDispatcher;
     getBody := @IRoutineMetadataImpl_getBodyDispatcher;
     getInputMetadata := @IRoutineMetadataImpl_getInputMetadataDispatcher;
     getOutputMetadata := @IRoutineMetadataImpl_getOutputMetadataDispatcher;
     getTriggerMetadata := @IRoutineMetadataImpl_getTriggerMetadataDispatcher;
     getTriggerTable := @IRoutineMetadataImpl_getTriggerTableDispatcher;
     getTriggerType := @IRoutineMetadataImpl_getTriggerTypeDispatcher;
  end;

  FInitialized := true;
end;

constructor IExternalEngineImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IExternalEngineImpl.getInterfaceToken: PExternalEngineToken;
begin
  Result := PExternalEngineToken(@token);
end;

function IExternalEngineImpl.getInterface: IExternalEngine;
begin
  Result := intf;
end;

procedure IExternalEngineImpl_addRefDispatcher(this: PExternalEngineToken); cdecl;
begin
	try
		IExternalEngineImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalEngineImpl_releaseDispatcher(this: PExternalEngineToken): Integer; cdecl;
begin
	try
		Result := IExternalEngineImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalEngineImpl_setOwnerDispatcher(this: PExternalEngineToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IExternalEngineImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalEngineImpl_getOwnerDispatcher(this: PExternalEngineToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IExternalEngineImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalEngineImpl_openDispatcher(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; charSet: PAnsiChar; charSetSize: Cardinal); cdecl;
begin
	try
		IExternalEngineImpl(PFBImplementationToken(this).Owner).open(status, context, charSet, charSetSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalEngineImpl_openAttachmentDispatcher(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken); cdecl;
begin
	try
		IExternalEngineImpl(PFBImplementationToken(this).Owner).openAttachment(status, context);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalEngineImpl_closeAttachmentDispatcher(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken); cdecl;
begin
	try
		IExternalEngineImpl(PFBImplementationToken(this).Owner).closeAttachment(status, context);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeFunctionDispatcher(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalFunctionToken; cdecl;
begin
	try
		Result := IExternalEngineImpl(PFBImplementationToken(this).Owner).makeFunction(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeProcedureDispatcher(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken): PExternalProcedureToken; cdecl;
begin
	try
		Result := IExternalEngineImpl(PFBImplementationToken(this).Owner).makeProcedure(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeTriggerDispatcher(this: PExternalEngineToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken): PExternalTriggerToken; cdecl;
begin
	try
		Result := IExternalEngineImpl(PFBImplementationToken(this).Owner).makeTrigger(status, context, metadata, fieldsBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IExternalEngineImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 10;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     open := @IExternalEngineImpl_openDispatcher;
     openAttachment := @IExternalEngineImpl_openAttachmentDispatcher;
     closeAttachment := @IExternalEngineImpl_closeAttachmentDispatcher;
     makeFunction := @IExternalEngineImpl_makeFunctionDispatcher;
     makeProcedure := @IExternalEngineImpl_makeProcedureDispatcher;
     makeTrigger := @IExternalEngineImpl_makeTriggerDispatcher;
  end;

  FInitialized := true;
end;

constructor ITimerImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITimerImpl.getInterfaceToken: PTimerToken;
begin
  Result := PTimerToken(@token);
end;

function ITimerImpl.getInterface: ITimer;
begin
  Result := intf;
end;

procedure ITimerImpl_addRefDispatcher(this: PTimerToken); cdecl;
begin
	try
		ITimerImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITimerImpl_releaseDispatcher(this: PTimerToken): Integer; cdecl;
begin
	try
		Result := ITimerImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITimerImpl_handlerDispatcher(this: PTimerToken); cdecl;
begin
	try
		ITimerImpl(PFBImplementationToken(this).Owner).handler();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITimerImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     handler := @ITimerImpl_handlerDispatcher;
  end;

  FInitialized := true;
end;

constructor ITimerControlImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITimerControlImpl.getInterfaceToken: PTimerControlToken;
begin
  Result := PTimerControlToken(@token);
end;

function ITimerControlImpl.getInterface: ITimerControl;
begin
  Result := intf;
end;

procedure ITimerControlImpl_startDispatcher(this: PTimerControlToken; status: PStatusToken; timer: PTimerToken; microSeconds: QWord); cdecl;
begin
	try
		ITimerControlImpl(PFBImplementationToken(this).Owner).start(status, timer, microSeconds);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITimerControlImpl_stopDispatcher(this: PTimerControlToken; status: PStatusToken; timer: PTimerToken); cdecl;
begin
	try
		ITimerControlImpl(PFBImplementationToken(this).Owner).stop(status, timer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ITimerControlImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     start := @ITimerControlImpl_startDispatcher;
     stop := @ITimerControlImpl_stopDispatcher;
  end;

  FInitialized := true;
end;

constructor IVersionCallbackImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IVersionCallbackImpl.getInterfaceToken: PVersionCallbackToken;
begin
  Result := PVersionCallbackToken(@token);
end;

function IVersionCallbackImpl.getInterface: IVersionCallback;
begin
  Result := intf;
end;

procedure IVersionCallbackImpl_callbackDispatcher(this: PVersionCallbackToken; status: PStatusToken; text: PAnsiChar); cdecl;
begin
	try
		IVersionCallbackImpl(PFBImplementationToken(this).Owner).callback(status, text);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IVersionCallbackImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 1;
     callback := @IVersionCallbackImpl_callbackDispatcher;
  end;

  FInitialized := true;
end;

constructor IUtilImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUtilImpl.getInterfaceToken: PUtilToken;
begin
  Result := PUtilToken(@token);
end;

function IUtilImpl.getInterface: IUtil;
begin
  Result := intf;
end;

procedure IUtilImpl_getFbVersionDispatcher(this: PUtilToken; status: PStatusToken; att: PAttachmentToken; callback: PVersionCallbackToken); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).getFbVersion(status, att, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_loadBlobDispatcher(this: PUtilToken; status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).loadBlob(status, blobId, att, tra, file_, txt);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_dumpBlobDispatcher(this: PUtilToken; status: PStatusToken; blobId: ISC_QUADPtr; att: PAttachmentToken; tra: PTransactionToken; file_: PAnsiChar; txt: Boolean); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).dumpBlob(status, blobId, att, tra, file_, txt);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_getPerfCountersDispatcher(this: PUtilToken; status: PStatusToken; att: PAttachmentToken; countersSet: PAnsiChar; counters: Int64Ptr); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).getPerfCounters(status, att, countersSet, counters);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_executeCreateDatabaseDispatcher(this: PUtilToken; status: PStatusToken; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): PAttachmentToken; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).executeCreateDatabase(status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeDateDispatcher(this: PUtilToken; date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).decodeDate(date, year, month, day);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUtilImpl_decodeTimeDispatcher(this: PUtilToken; time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).decodeTime(time, hours, minutes, seconds, fractions);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_encodeDateDispatcher(this: PUtilToken; year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).encodeDate(year, month, day);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_encodeTimeDispatcher(this: PUtilToken; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).encodeTime(hours, minutes, seconds, fractions);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_formatStatusDispatcher(this: PUtilToken; buffer: PAnsiChar; bufferSize: Cardinal; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).formatStatus(buffer, bufferSize, status);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_getClientVersionDispatcher(this: PUtilToken): Cardinal; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).getClientVersion();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_getXpbBuilderDispatcher(this: PUtilToken; status: PStatusToken; kind: Cardinal; buf: BytePtr; len: Cardinal): PXpbBuilderToken; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).getXpbBuilder(status, kind, buf, len);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_setOffsetsDispatcher(this: PUtilToken; status: PStatusToken; metadata: PMessageMetadataToken; callback: POffsetsCallbackToken): Cardinal; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).setOffsets(status, metadata, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getDecFloat16Dispatcher(this: PUtilToken; status: PStatusToken): PDecFloat16Token; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).getDecFloat16(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getDecFloat34Dispatcher(this: PUtilToken; status: PStatusToken): PDecFloat34Token; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).getDecFloat34(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeTzDispatcher(this: PUtilToken; status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).decodeTimeTz(status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeStampTzDispatcher(this: PUtilToken; status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).decodeTimeStampTz(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_encodeTimeTzDispatcher(this: PUtilToken; status: PStatusToken; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).encodeTimeTz(status, timeTz, hours, minutes, seconds, fractions, timeZone);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_encodeTimeStampTzDispatcher(this: PUtilToken; status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).encodeTimeStampTz(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZone);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getInt128Dispatcher(this: PUtilToken; status: PStatusToken): PInt128Token; cdecl;
begin
	try
		Result := IUtilImpl(PFBImplementationToken(this).Owner).getInt128(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeTzExDispatcher(this: PUtilToken; status: PStatusToken; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).decodeTimeTzEx(status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeStampTzExDispatcher(this: PUtilToken; status: PStatusToken; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		IUtilImpl(PFBImplementationToken(this).Owner).decodeTimeStampTzEx(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUtilImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 22;
     getFbVersion := @IUtilImpl_getFbVersionDispatcher;
     loadBlob := @IUtilImpl_loadBlobDispatcher;
     dumpBlob := @IUtilImpl_dumpBlobDispatcher;
     getPerfCounters := @IUtilImpl_getPerfCountersDispatcher;
     executeCreateDatabase := @IUtilImpl_executeCreateDatabaseDispatcher;
     decodeDate := @IUtilImpl_decodeDateDispatcher;
     decodeTime := @IUtilImpl_decodeTimeDispatcher;
     encodeDate := @IUtilImpl_encodeDateDispatcher;
     encodeTime := @IUtilImpl_encodeTimeDispatcher;
     formatStatus := @IUtilImpl_formatStatusDispatcher;
     getClientVersion := @IUtilImpl_getClientVersionDispatcher;
     getXpbBuilder := @IUtilImpl_getXpbBuilderDispatcher;
     setOffsets := @IUtilImpl_setOffsetsDispatcher;
     getDecFloat16 := @IUtilImpl_getDecFloat16Dispatcher;
     getDecFloat34 := @IUtilImpl_getDecFloat34Dispatcher;
     decodeTimeTz := @IUtilImpl_decodeTimeTzDispatcher;
     decodeTimeStampTz := @IUtilImpl_decodeTimeStampTzDispatcher;
     encodeTimeTz := @IUtilImpl_encodeTimeTzDispatcher;
     encodeTimeStampTz := @IUtilImpl_encodeTimeStampTzDispatcher;
     getInt128 := @IUtilImpl_getInt128Dispatcher;
     decodeTimeTzEx := @IUtilImpl_decodeTimeTzExDispatcher;
     decodeTimeStampTzEx := @IUtilImpl_decodeTimeStampTzExDispatcher;
  end;

  FInitialized := true;
end;

constructor IOffsetsCallbackImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IOffsetsCallbackImpl.getInterfaceToken: POffsetsCallbackToken;
begin
  Result := POffsetsCallbackToken(@token);
end;

function IOffsetsCallbackImpl.getInterface: IOffsetsCallback;
begin
  Result := intf;
end;

procedure IOffsetsCallbackImpl_setOffsetDispatcher(this: POffsetsCallbackToken; status: PStatusToken; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); cdecl;
begin
	try
		IOffsetsCallbackImpl(PFBImplementationToken(this).Owner).setOffset(status, index, offset, nullOffset);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IOffsetsCallbackImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 1;
     setOffset := @IOffsetsCallbackImpl_setOffsetDispatcher;
  end;

  FInitialized := true;
end;

constructor IXpbBuilderImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IXpbBuilderImpl.getInterfaceToken: PXpbBuilderToken;
begin
  Result := PXpbBuilderToken(@token);
end;

function IXpbBuilderImpl.getInterface: IXpbBuilder;
begin
  Result := intf;
end;

procedure IXpbBuilderImpl_disposeDispatcher(this: PXpbBuilderToken); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IXpbBuilderImpl_clearDispatcher(this: PXpbBuilderToken; status: PStatusToken); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).clear(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_removeCurrentDispatcher(this: PXpbBuilderToken; status: PStatusToken); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).removeCurrent(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertIntDispatcher(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; value: Integer); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).insertInt(status, tag, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertBigIntDispatcher(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; value: Int64); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).insertBigInt(status, tag, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertBytesDispatcher(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; bytes: Pointer; length: Cardinal); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).insertBytes(status, tag, bytes, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertStringDispatcher(this: PXpbBuilderToken; status: PStatusToken; tag: Byte; str: PAnsiChar); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).insertString(status, tag, str);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertTagDispatcher(this: PXpbBuilderToken; status: PStatusToken; tag: Byte); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).insertTag(status, tag);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_isEofDispatcher(this: PXpbBuilderToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).isEof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_moveNextDispatcher(this: PXpbBuilderToken; status: PStatusToken); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).moveNext(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_rewindDispatcher(this: PXpbBuilderToken; status: PStatusToken); cdecl;
begin
	try
		IXpbBuilderImpl(PFBImplementationToken(this).Owner).rewind(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_findFirstDispatcher(this: PXpbBuilderToken; status: PStatusToken; tag: Byte): Boolean; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).findFirst(status, tag);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_findNextDispatcher(this: PXpbBuilderToken; status: PStatusToken): Boolean; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).findNext(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getTagDispatcher(this: PXpbBuilderToken; status: PStatusToken): Byte; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getTag(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getLengthDispatcher(this: PXpbBuilderToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getIntDispatcher(this: PXpbBuilderToken; status: PStatusToken): Integer; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getInt(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBigIntDispatcher(this: PXpbBuilderToken; status: PStatusToken): Int64; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getBigInt(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getStringDispatcher(this: PXpbBuilderToken; status: PStatusToken): PAnsiChar; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getString(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBytesDispatcher(this: PXpbBuilderToken; status: PStatusToken): BytePtr; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getBytes(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBufferLengthDispatcher(this: PXpbBuilderToken; status: PStatusToken): Cardinal; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getBufferLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBufferDispatcher(this: PXpbBuilderToken; status: PStatusToken): BytePtr; cdecl;
begin
	try
		Result := IXpbBuilderImpl(PFBImplementationToken(this).Owner).getBuffer(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IXpbBuilderImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 21;
     dispose := @IDisposableImpl_disposeDispatcher;
     clear := @IXpbBuilderImpl_clearDispatcher;
     removeCurrent := @IXpbBuilderImpl_removeCurrentDispatcher;
     insertInt := @IXpbBuilderImpl_insertIntDispatcher;
     insertBigInt := @IXpbBuilderImpl_insertBigIntDispatcher;
     insertBytes := @IXpbBuilderImpl_insertBytesDispatcher;
     insertString := @IXpbBuilderImpl_insertStringDispatcher;
     insertTag := @IXpbBuilderImpl_insertTagDispatcher;
     isEof := @IXpbBuilderImpl_isEofDispatcher;
     moveNext := @IXpbBuilderImpl_moveNextDispatcher;
     rewind := @IXpbBuilderImpl_rewindDispatcher;
     findFirst := @IXpbBuilderImpl_findFirstDispatcher;
     findNext := @IXpbBuilderImpl_findNextDispatcher;
     getTag := @IXpbBuilderImpl_getTagDispatcher;
     getLength := @IXpbBuilderImpl_getLengthDispatcher;
     getInt := @IXpbBuilderImpl_getIntDispatcher;
     getBigInt := @IXpbBuilderImpl_getBigIntDispatcher;
     getString := @IXpbBuilderImpl_getStringDispatcher;
     getBytes := @IXpbBuilderImpl_getBytesDispatcher;
     getBufferLength := @IXpbBuilderImpl_getBufferLengthDispatcher;
     getBuffer := @IXpbBuilderImpl_getBufferDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceConnectionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceConnectionImpl.getInterfaceToken: PTraceConnectionToken;
begin
  Result := PTraceConnectionToken(@token);
end;

function ITraceConnectionImpl.getInterface: ITraceConnection;
begin
  Result := intf;
end;

function ITraceConnectionImpl_getKindDispatcher(this: PTraceConnectionToken): Cardinal; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getProcessIDDispatcher(this: PTraceConnectionToken): Integer; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getUserNameDispatcher(this: PTraceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRoleNameDispatcher(this: PTraceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getCharSetDispatcher(this: PTraceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProtocolDispatcher(this: PTraceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteAddressDispatcher(this: PTraceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProcessIDDispatcher(this: PTraceConnectionToken): Integer; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProcessNameDispatcher(this: PTraceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceConnectionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 9;
     getKind := @ITraceConnectionImpl_getKindDispatcher;
     getProcessID := @ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName := @ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName := @ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet := @ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol := @ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress := @ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID := @ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName := @ITraceConnectionImpl_getRemoteProcessNameDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceDatabaseConnectionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceDatabaseConnectionImpl.getInterfaceToken: PTraceDatabaseConnectionToken;
begin
  Result := PTraceDatabaseConnectionToken(@token);
end;

function ITraceDatabaseConnectionImpl.getInterface: ITraceDatabaseConnection;
begin
  Result := intf;
end;

function ITraceDatabaseConnectionImpl_getKindDispatcher(this: PTraceDatabaseConnectionToken): Cardinal; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getProcessIDDispatcher(this: PTraceDatabaseConnectionToken): Integer; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getUserNameDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRoleNameDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getCharSetDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProtocolDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteAddressDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProcessIDDispatcher(this: PTraceDatabaseConnectionToken): Integer; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProcessNameDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getConnectionIDDispatcher(this: PTraceDatabaseConnectionToken): Int64; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getConnectionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getDatabaseNameDispatcher(this: PTraceDatabaseConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDatabaseConnectionImpl(PFBImplementationToken(this).Owner).getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceDatabaseConnectionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 11;
     getKind := @ITraceConnectionImpl_getKindDispatcher;
     getProcessID := @ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName := @ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName := @ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet := @ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol := @ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress := @ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID := @ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName := @ITraceConnectionImpl_getRemoteProcessNameDispatcher;
     getConnectionID := @ITraceDatabaseConnectionImpl_getConnectionIDDispatcher;
     getDatabaseName := @ITraceDatabaseConnectionImpl_getDatabaseNameDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceTransactionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceTransactionImpl.getInterfaceToken: PTraceTransactionToken;
begin
  Result := PTraceTransactionToken(@token);
end;

function ITraceTransactionImpl.getInterface: ITraceTransaction;
begin
  Result := intf;
end;

function ITraceTransactionImpl_getTransactionIDDispatcher(this: PTraceTransactionToken): Int64; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getTransactionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getReadOnlyDispatcher(this: PTraceTransactionToken): Boolean; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getReadOnly();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getWaitDispatcher(this: PTraceTransactionToken): Integer; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getWait();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getIsolationDispatcher(this: PTraceTransactionToken): Cardinal; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getIsolation();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getPerfDispatcher(this: PTraceTransactionToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getInitialIDDispatcher(this: PTraceTransactionToken): Int64; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getInitialID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getPreviousIDDispatcher(this: PTraceTransactionToken): Int64; cdecl;
begin
	try
		Result := ITraceTransactionImpl(PFBImplementationToken(this).Owner).getPreviousID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceTransactionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     getTransactionID := @ITraceTransactionImpl_getTransactionIDDispatcher;
     getReadOnly := @ITraceTransactionImpl_getReadOnlyDispatcher;
     getWait := @ITraceTransactionImpl_getWaitDispatcher;
     getIsolation := @ITraceTransactionImpl_getIsolationDispatcher;
     getPerf := @ITraceTransactionImpl_getPerfDispatcher;
     getInitialID := @ITraceTransactionImpl_getInitialIDDispatcher;
     getPreviousID := @ITraceTransactionImpl_getPreviousIDDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceParamsImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceParamsImpl.getInterfaceToken: PTraceParamsToken;
begin
  Result := PTraceParamsToken(@token);
end;

function ITraceParamsImpl.getInterface: ITraceParams;
begin
  Result := intf;
end;

function ITraceParamsImpl_getCountDispatcher(this: PTraceParamsToken): Cardinal; cdecl;
begin
	try
		Result := ITraceParamsImpl(PFBImplementationToken(this).Owner).getCount();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceParamsImpl_getParamDispatcher(this: PTraceParamsToken; idx: Cardinal): dscPtr; cdecl;
begin
	try
		Result := ITraceParamsImpl(PFBImplementationToken(this).Owner).getParam(idx);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceParamsImpl_getTextUTF8Dispatcher(this: PTraceParamsToken; status: PStatusToken; idx: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := ITraceParamsImpl(PFBImplementationToken(this).Owner).getTextUTF8(status, idx);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ITraceParamsImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     getCount := @ITraceParamsImpl_getCountDispatcher;
     getParam := @ITraceParamsImpl_getParamDispatcher;
     getTextUTF8 := @ITraceParamsImpl_getTextUTF8Dispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceStatementImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceStatementImpl.getInterfaceToken: PTraceStatementToken;
begin
  Result := PTraceStatementToken(@token);
end;

function ITraceStatementImpl.getInterface: ITraceStatement;
begin
  Result := intf;
end;

function ITraceStatementImpl_getStmtIDDispatcher(this: PTraceStatementToken): Int64; cdecl;
begin
	try
		Result := ITraceStatementImpl(PFBImplementationToken(this).Owner).getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatementImpl_getPerfDispatcher(this: PTraceStatementToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceStatementImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceStatementImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     getStmtID := @ITraceStatementImpl_getStmtIDDispatcher;
     getPerf := @ITraceStatementImpl_getPerfDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceSQLStatementImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceSQLStatementImpl.getInterfaceToken: PTraceSQLStatementToken;
begin
  Result := PTraceSQLStatementToken(@token);
end;

function ITraceSQLStatementImpl.getInterface: ITraceSQLStatement;
begin
  Result := intf;
end;

function ITraceSQLStatementImpl_getStmtIDDispatcher(this: PTraceSQLStatementToken): Int64; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getPerfDispatcher(this: PTraceSQLStatementToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getTextDispatcher(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getPlanDispatcher(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getPlan();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getInputsDispatcher(this: PTraceSQLStatementToken): PTraceParamsToken; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getTextUTF8Dispatcher(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getTextUTF8();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getExplainedPlanDispatcher(this: PTraceSQLStatementToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceSQLStatementImpl(PFBImplementationToken(this).Owner).getExplainedPlan();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceSQLStatementImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     getStmtID := @ITraceStatementImpl_getStmtIDDispatcher;
     getPerf := @ITraceStatementImpl_getPerfDispatcher;
     getText := @ITraceSQLStatementImpl_getTextDispatcher;
     getPlan := @ITraceSQLStatementImpl_getPlanDispatcher;
     getInputs := @ITraceSQLStatementImpl_getInputsDispatcher;
     getTextUTF8 := @ITraceSQLStatementImpl_getTextUTF8Dispatcher;
     getExplainedPlan := @ITraceSQLStatementImpl_getExplainedPlanDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceBLRStatementImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceBLRStatementImpl.getInterfaceToken: PTraceBLRStatementToken;
begin
  Result := PTraceBLRStatementToken(@token);
end;

function ITraceBLRStatementImpl.getInterface: ITraceBLRStatement;
begin
  Result := intf;
end;

function ITraceBLRStatementImpl_getStmtIDDispatcher(this: PTraceBLRStatementToken): Int64; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(PFBImplementationToken(this).Owner).getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getPerfDispatcher(this: PTraceBLRStatementToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getDataDispatcher(this: PTraceBLRStatementToken): BytePtr; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(PFBImplementationToken(this).Owner).getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getDataLengthDispatcher(this: PTraceBLRStatementToken): Cardinal; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(PFBImplementationToken(this).Owner).getDataLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getTextDispatcher(this: PTraceBLRStatementToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceBLRStatementImpl(PFBImplementationToken(this).Owner).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceBLRStatementImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     getStmtID := @ITraceStatementImpl_getStmtIDDispatcher;
     getPerf := @ITraceStatementImpl_getPerfDispatcher;
     getData := @ITraceBLRStatementImpl_getDataDispatcher;
     getDataLength := @ITraceBLRStatementImpl_getDataLengthDispatcher;
     getText := @ITraceBLRStatementImpl_getTextDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceDYNRequestImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceDYNRequestImpl.getInterfaceToken: PTraceDYNRequestToken;
begin
  Result := PTraceDYNRequestToken(@token);
end;

function ITraceDYNRequestImpl.getInterface: ITraceDYNRequest;
begin
  Result := intf;
end;

function ITraceDYNRequestImpl_getDataDispatcher(this: PTraceDYNRequestToken): BytePtr; cdecl;
begin
	try
		Result := ITraceDYNRequestImpl(PFBImplementationToken(this).Owner).getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDYNRequestImpl_getDataLengthDispatcher(this: PTraceDYNRequestToken): Cardinal; cdecl;
begin
	try
		Result := ITraceDYNRequestImpl(PFBImplementationToken(this).Owner).getDataLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDYNRequestImpl_getTextDispatcher(this: PTraceDYNRequestToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceDYNRequestImpl(PFBImplementationToken(this).Owner).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceDYNRequestImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     getData := @ITraceDYNRequestImpl_getDataDispatcher;
     getDataLength := @ITraceDYNRequestImpl_getDataLengthDispatcher;
     getText := @ITraceDYNRequestImpl_getTextDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceContextVariableImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceContextVariableImpl.getInterfaceToken: PTraceContextVariableToken;
begin
  Result := PTraceContextVariableToken(@token);
end;

function ITraceContextVariableImpl.getInterface: ITraceContextVariable;
begin
  Result := intf;
end;

function ITraceContextVariableImpl_getNameSpaceDispatcher(this: PTraceContextVariableToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceContextVariableImpl(PFBImplementationToken(this).Owner).getNameSpace();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceContextVariableImpl_getVarNameDispatcher(this: PTraceContextVariableToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceContextVariableImpl(PFBImplementationToken(this).Owner).getVarName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceContextVariableImpl_getVarValueDispatcher(this: PTraceContextVariableToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceContextVariableImpl(PFBImplementationToken(this).Owner).getVarValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceContextVariableImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     getNameSpace := @ITraceContextVariableImpl_getNameSpaceDispatcher;
     getVarName := @ITraceContextVariableImpl_getVarNameDispatcher;
     getVarValue := @ITraceContextVariableImpl_getVarValueDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceProcedureImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceProcedureImpl.getInterfaceToken: PTraceProcedureToken;
begin
  Result := PTraceProcedureToken(@token);
end;

function ITraceProcedureImpl.getInterface: ITraceProcedure;
begin
  Result := intf;
end;

function ITraceProcedureImpl_getProcNameDispatcher(this: PTraceProcedureToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceProcedureImpl(PFBImplementationToken(this).Owner).getProcName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceProcedureImpl_getInputsDispatcher(this: PTraceProcedureToken): PTraceParamsToken; cdecl;
begin
	try
		Result := ITraceProcedureImpl(PFBImplementationToken(this).Owner).getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceProcedureImpl_getPerfDispatcher(this: PTraceProcedureToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceProcedureImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceProcedureImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     getProcName := @ITraceProcedureImpl_getProcNameDispatcher;
     getInputs := @ITraceProcedureImpl_getInputsDispatcher;
     getPerf := @ITraceProcedureImpl_getPerfDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceFunctionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceFunctionImpl.getInterfaceToken: PTraceFunctionToken;
begin
  Result := PTraceFunctionToken(@token);
end;

function ITraceFunctionImpl.getInterface: ITraceFunction;
begin
  Result := intf;
end;

function ITraceFunctionImpl_getFuncNameDispatcher(this: PTraceFunctionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceFunctionImpl(PFBImplementationToken(this).Owner).getFuncName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getInputsDispatcher(this: PTraceFunctionToken): PTraceParamsToken; cdecl;
begin
	try
		Result := ITraceFunctionImpl(PFBImplementationToken(this).Owner).getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getResultDispatcher(this: PTraceFunctionToken): PTraceParamsToken; cdecl;
begin
	try
		Result := ITraceFunctionImpl(PFBImplementationToken(this).Owner).getResult();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getPerfDispatcher(this: PTraceFunctionToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceFunctionImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceFunctionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     getFuncName := @ITraceFunctionImpl_getFuncNameDispatcher;
     getInputs := @ITraceFunctionImpl_getInputsDispatcher;
     getResult := @ITraceFunctionImpl_getResultDispatcher;
     getPerf := @ITraceFunctionImpl_getPerfDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceTriggerImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceTriggerImpl.getInterfaceToken: PTraceTriggerToken;
begin
  Result := PTraceTriggerToken(@token);
end;

function ITraceTriggerImpl.getInterface: ITraceTrigger;
begin
  Result := intf;
end;

function ITraceTriggerImpl_getTriggerNameDispatcher(this: PTraceTriggerToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceTriggerImpl(PFBImplementationToken(this).Owner).getTriggerName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getRelationNameDispatcher(this: PTraceTriggerToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceTriggerImpl(PFBImplementationToken(this).Owner).getRelationName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getActionDispatcher(this: PTraceTriggerToken): Integer; cdecl;
begin
	try
		Result := ITraceTriggerImpl(PFBImplementationToken(this).Owner).getAction();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getWhichDispatcher(this: PTraceTriggerToken): Integer; cdecl;
begin
	try
		Result := ITraceTriggerImpl(PFBImplementationToken(this).Owner).getWhich();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getPerfDispatcher(this: PTraceTriggerToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceTriggerImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceTriggerImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     getTriggerName := @ITraceTriggerImpl_getTriggerNameDispatcher;
     getRelationName := @ITraceTriggerImpl_getRelationNameDispatcher;
     getAction := @ITraceTriggerImpl_getActionDispatcher;
     getWhich := @ITraceTriggerImpl_getWhichDispatcher;
     getPerf := @ITraceTriggerImpl_getPerfDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceServiceConnectionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceServiceConnectionImpl.getInterfaceToken: PTraceServiceConnectionToken;
begin
  Result := PTraceServiceConnectionToken(@token);
end;

function ITraceServiceConnectionImpl.getInterface: ITraceServiceConnection;
begin
  Result := intf;
end;

function ITraceServiceConnectionImpl_getKindDispatcher(this: PTraceServiceConnectionToken): Cardinal; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getProcessIDDispatcher(this: PTraceServiceConnectionToken): Integer; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getUserNameDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRoleNameDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getCharSetDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProtocolDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteAddressDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProcessIDDispatcher(this: PTraceServiceConnectionToken): Integer; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProcessNameDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceIDDispatcher(this: PTraceServiceConnectionToken): Pointer; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getServiceID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceMgrDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getServiceMgr();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceNameDispatcher(this: PTraceServiceConnectionToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceServiceConnectionImpl(PFBImplementationToken(this).Owner).getServiceName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceServiceConnectionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 12;
     getKind := @ITraceConnectionImpl_getKindDispatcher;
     getProcessID := @ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName := @ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName := @ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet := @ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol := @ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress := @ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID := @ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName := @ITraceConnectionImpl_getRemoteProcessNameDispatcher;
     getServiceID := @ITraceServiceConnectionImpl_getServiceIDDispatcher;
     getServiceMgr := @ITraceServiceConnectionImpl_getServiceMgrDispatcher;
     getServiceName := @ITraceServiceConnectionImpl_getServiceNameDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceStatusVectorImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceStatusVectorImpl.getInterfaceToken: PTraceStatusVectorToken;
begin
  Result := PTraceStatusVectorToken(@token);
end;

function ITraceStatusVectorImpl.getInterface: ITraceStatusVector;
begin
  Result := intf;
end;

function ITraceStatusVectorImpl_hasErrorDispatcher(this: PTraceStatusVectorToken): Boolean; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(PFBImplementationToken(this).Owner).hasError();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_hasWarningDispatcher(this: PTraceStatusVectorToken): Boolean; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(PFBImplementationToken(this).Owner).hasWarning();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_getStatusDispatcher(this: PTraceStatusVectorToken): PStatusToken; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(PFBImplementationToken(this).Owner).getStatus();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_getTextDispatcher(this: PTraceStatusVectorToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceStatusVectorImpl(PFBImplementationToken(this).Owner).getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceStatusVectorImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     hasError := @ITraceStatusVectorImpl_hasErrorDispatcher;
     hasWarning := @ITraceStatusVectorImpl_hasWarningDispatcher;
     getStatus := @ITraceStatusVectorImpl_getStatusDispatcher;
     getText := @ITraceStatusVectorImpl_getTextDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceSweepInfoImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceSweepInfoImpl.getInterfaceToken: PTraceSweepInfoToken;
begin
  Result := PTraceSweepInfoToken(@token);
end;

function ITraceSweepInfoImpl.getInterface: ITraceSweepInfo;
begin
  Result := intf;
end;

function ITraceSweepInfoImpl_getOITDispatcher(this: PTraceSweepInfoToken): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(PFBImplementationToken(this).Owner).getOIT();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getOSTDispatcher(this: PTraceSweepInfoToken): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(PFBImplementationToken(this).Owner).getOST();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getOATDispatcher(this: PTraceSweepInfoToken): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(PFBImplementationToken(this).Owner).getOAT();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getNextDispatcher(this: PTraceSweepInfoToken): Int64; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(PFBImplementationToken(this).Owner).getNext();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getPerfDispatcher(this: PTraceSweepInfoToken): PerformanceInfoPtr; cdecl;
begin
	try
		Result := ITraceSweepInfoImpl(PFBImplementationToken(this).Owner).getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceSweepInfoImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 5;
     getOIT := @ITraceSweepInfoImpl_getOITDispatcher;
     getOST := @ITraceSweepInfoImpl_getOSTDispatcher;
     getOAT := @ITraceSweepInfoImpl_getOATDispatcher;
     getNext := @ITraceSweepInfoImpl_getNextDispatcher;
     getPerf := @ITraceSweepInfoImpl_getPerfDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceLogWriterImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceLogWriterImpl.getInterfaceToken: PTraceLogWriterToken;
begin
  Result := PTraceLogWriterToken(@token);
end;

function ITraceLogWriterImpl.getInterface: ITraceLogWriter;
begin
  Result := intf;
end;

procedure ITraceLogWriterImpl_addRefDispatcher(this: PTraceLogWriterToken); cdecl;
begin
	try
		ITraceLogWriterImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_releaseDispatcher(this: PTraceLogWriterToken): Integer; cdecl;
begin
	try
		Result := ITraceLogWriterImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_writeDispatcher(this: PTraceLogWriterToken; buf: Pointer; size: Cardinal): Cardinal; cdecl;
begin
	try
		Result := ITraceLogWriterImpl(PFBImplementationToken(this).Owner).write(buf, size);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_write_sDispatcher(this: PTraceLogWriterToken; status: PStatusToken; buf: Pointer; size: Cardinal): Cardinal; cdecl;
begin
	try
		Result := ITraceLogWriterImpl(PFBImplementationToken(this).Owner).write_s(status, buf, size);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ITraceLogWriterImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     write := @ITraceLogWriterImpl_writeDispatcher;
     write_s := @ITraceLogWriterImpl_write_sDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceInitInfoImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceInitInfoImpl.getInterfaceToken: PTraceInitInfoToken;
begin
  Result := PTraceInitInfoToken(@token);
end;

function ITraceInitInfoImpl.getInterface: ITraceInitInfo;
begin
  Result := intf;
end;

function ITraceInitInfoImpl_getConfigTextDispatcher(this: PTraceInitInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getConfigText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getTraceSessionIDDispatcher(this: PTraceInitInfoToken): Integer; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getTraceSessionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getTraceSessionNameDispatcher(this: PTraceInitInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getTraceSessionName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getFirebirdRootDirectoryDispatcher(this: PTraceInitInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getFirebirdRootDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getDatabaseNameDispatcher(this: PTraceInitInfoToken): PAnsiChar; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getConnectionDispatcher(this: PTraceInitInfoToken): PTraceDatabaseConnectionToken; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getConnection();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getLogWriterDispatcher(this: PTraceInitInfoToken): PTraceLogWriterToken; cdecl;
begin
	try
		Result := ITraceInitInfoImpl(PFBImplementationToken(this).Owner).getLogWriter();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITraceInitInfoImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     getConfigText := @ITraceInitInfoImpl_getConfigTextDispatcher;
     getTraceSessionID := @ITraceInitInfoImpl_getTraceSessionIDDispatcher;
     getTraceSessionName := @ITraceInitInfoImpl_getTraceSessionNameDispatcher;
     getFirebirdRootDirectory := @ITraceInitInfoImpl_getFirebirdRootDirectoryDispatcher;
     getDatabaseName := @ITraceInitInfoImpl_getDatabaseNameDispatcher;
     getConnection := @ITraceInitInfoImpl_getConnectionDispatcher;
     getLogWriter := @ITraceInitInfoImpl_getLogWriterDispatcher;
  end;

  FInitialized := true;
end;

constructor ITracePluginImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITracePluginImpl.getInterfaceToken: PTracePluginToken;
begin
  Result := PTracePluginToken(@token);
end;

function ITracePluginImpl.getInterface: ITracePlugin;
begin
  Result := intf;
end;

procedure ITracePluginImpl_addRefDispatcher(this: PTracePluginToken); cdecl;
begin
	try
		ITracePluginImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_releaseDispatcher(this: PTracePluginToken): Integer; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_get_errorDispatcher(this: PTracePluginToken): PAnsiChar; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_get_error();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_attachDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; create_db: Boolean; att_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_attach(connection, create_db, att_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_detachDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; drop_db: Boolean): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_detach(connection, drop_db);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_transaction_startDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_transaction_start(connection, transaction, tpb_length, tpb, tra_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_transaction_endDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_transaction_end(connection, transaction, commit, retain_context, tra_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_proc_executeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; procedure_: PTraceProcedureToken; started: Boolean; proc_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_proc_execute(connection, transaction, procedure_, started, proc_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_trigger_executeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; trigger: PTraceTriggerToken; started: Boolean; trig_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_trigger_execute(connection, transaction, trigger, started, trig_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_set_contextDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; variable: PTraceContextVariableToken): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_set_context(connection, transaction, variable);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_prepareDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_dsql_prepare(connection, transaction, statement, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_freeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; statement: PTraceSQLStatementToken; option: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_dsql_free(connection, statement, option);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_executeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceSQLStatementToken; started: Boolean; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_dsql_execute(connection, transaction, statement, started, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_blr_compileDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_blr_compile(connection, transaction, statement, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_blr_executeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; statement: PTraceBLRStatementToken; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_blr_execute(connection, transaction, statement, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dyn_executeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; request: PTraceDYNRequestToken; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_dyn_execute(connection, transaction, request, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_attachDispatcher(this: PTracePluginToken; service: PTraceServiceConnectionToken; att_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_service_attach(service, att_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_startDispatcher(this: PTracePluginToken; service: PTraceServiceConnectionToken; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_service_start(service, switches_length, switches, start_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_queryDispatcher(this: PTracePluginToken; service: PTraceServiceConnectionToken; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_service_query(service, send_item_length, send_items, recv_item_length, recv_items, query_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_detachDispatcher(this: PTracePluginToken; service: PTraceServiceConnectionToken; detach_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_service_detach(service, detach_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_event_errorDispatcher(this: PTracePluginToken; connection: PTraceConnectionToken; status: PTraceStatusVectorToken; function_: PAnsiChar): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_event_error(connection, status, function_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_event_sweepDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; sweep: PTraceSweepInfoToken; sweep_state: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_event_sweep(connection, sweep, sweep_state);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_func_executeDispatcher(this: PTracePluginToken; connection: PTraceDatabaseConnectionToken; transaction: PTraceTransactionToken; function_: PTraceFunctionToken; started: Boolean; func_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := ITracePluginImpl(PFBImplementationToken(this).Owner).trace_func_execute(connection, transaction, function_, started, func_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure ITracePluginImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 23;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     trace_get_error := @ITracePluginImpl_trace_get_errorDispatcher;
     trace_attach := @ITracePluginImpl_trace_attachDispatcher;
     trace_detach := @ITracePluginImpl_trace_detachDispatcher;
     trace_transaction_start := @ITracePluginImpl_trace_transaction_startDispatcher;
     trace_transaction_end := @ITracePluginImpl_trace_transaction_endDispatcher;
     trace_proc_execute := @ITracePluginImpl_trace_proc_executeDispatcher;
     trace_trigger_execute := @ITracePluginImpl_trace_trigger_executeDispatcher;
     trace_set_context := @ITracePluginImpl_trace_set_contextDispatcher;
     trace_dsql_prepare := @ITracePluginImpl_trace_dsql_prepareDispatcher;
     trace_dsql_free := @ITracePluginImpl_trace_dsql_freeDispatcher;
     trace_dsql_execute := @ITracePluginImpl_trace_dsql_executeDispatcher;
     trace_blr_compile := @ITracePluginImpl_trace_blr_compileDispatcher;
     trace_blr_execute := @ITracePluginImpl_trace_blr_executeDispatcher;
     trace_dyn_execute := @ITracePluginImpl_trace_dyn_executeDispatcher;
     trace_service_attach := @ITracePluginImpl_trace_service_attachDispatcher;
     trace_service_start := @ITracePluginImpl_trace_service_startDispatcher;
     trace_service_query := @ITracePluginImpl_trace_service_queryDispatcher;
     trace_service_detach := @ITracePluginImpl_trace_service_detachDispatcher;
     trace_event_error := @ITracePluginImpl_trace_event_errorDispatcher;
     trace_event_sweep := @ITracePluginImpl_trace_event_sweepDispatcher;
     trace_func_execute := @ITracePluginImpl_trace_func_executeDispatcher;
  end;

  FInitialized := true;
end;

constructor ITraceFactoryImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function ITraceFactoryImpl.getInterfaceToken: PTraceFactoryToken;
begin
  Result := PTraceFactoryToken(@token);
end;

function ITraceFactoryImpl.getInterface: ITraceFactory;
begin
  Result := intf;
end;

procedure ITraceFactoryImpl_addRefDispatcher(this: PTraceFactoryToken); cdecl;
begin
	try
		ITraceFactoryImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_releaseDispatcher(this: PTraceFactoryToken): Integer; cdecl;
begin
	try
		Result := ITraceFactoryImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITraceFactoryImpl_setOwnerDispatcher(this: PTraceFactoryToken; r: PReferenceCountedToken); cdecl;
begin
	try
		ITraceFactoryImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_getOwnerDispatcher(this: PTraceFactoryToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := ITraceFactoryImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_trace_needsDispatcher(this: PTraceFactoryToken): QWord; cdecl;
begin
	try
		Result := ITraceFactoryImpl(PFBImplementationToken(this).Owner).trace_needs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_trace_createDispatcher(this: PTraceFactoryToken; status: PStatusToken; init_info: PTraceInitInfoToken): PTracePluginToken; cdecl;
begin
	try
		Result := ITraceFactoryImpl(PFBImplementationToken(this).Owner).trace_create(status, init_info);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure ITraceFactoryImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 6;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     trace_needs := @ITraceFactoryImpl_trace_needsDispatcher;
     trace_create := @ITraceFactoryImpl_trace_createDispatcher;
  end;

  FInitialized := true;
end;

constructor IUdrFunctionFactoryImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUdrFunctionFactoryImpl.getInterfaceToken: PUdrFunctionFactoryToken;
begin
  Result := PUdrFunctionFactoryToken(@token);
end;

function IUdrFunctionFactoryImpl.getInterface: IUdrFunctionFactory;
begin
  Result := intf;
end;

procedure IUdrFunctionFactoryImpl_disposeDispatcher(this: PUdrFunctionFactoryToken); cdecl;
begin
	try
		IUdrFunctionFactoryImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrFunctionFactoryImpl_setupDispatcher(this: PUdrFunctionFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken); cdecl;
begin
	try
		IUdrFunctionFactoryImpl(PFBImplementationToken(this).Owner).setup(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrFunctionFactoryImpl_newItemDispatcher(this: PUdrFunctionFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalFunctionToken; cdecl;
begin
	try
		Result := IUdrFunctionFactoryImpl(PFBImplementationToken(this).Owner).newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUdrFunctionFactoryImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     dispose := @IDisposableImpl_disposeDispatcher;
     setup := @IUdrFunctionFactoryImpl_setupDispatcher;
     newItem := @IUdrFunctionFactoryImpl_newItemDispatcher;
  end;

  FInitialized := true;
end;

constructor IUdrProcedureFactoryImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUdrProcedureFactoryImpl.getInterfaceToken: PUdrProcedureFactoryToken;
begin
  Result := PUdrProcedureFactoryToken(@token);
end;

function IUdrProcedureFactoryImpl.getInterface: IUdrProcedureFactory;
begin
  Result := intf;
end;

procedure IUdrProcedureFactoryImpl_disposeDispatcher(this: PUdrProcedureFactoryToken); cdecl;
begin
	try
		IUdrProcedureFactoryImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrProcedureFactoryImpl_setupDispatcher(this: PUdrProcedureFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; inBuilder: PMetadataBuilderToken; outBuilder: PMetadataBuilderToken); cdecl;
begin
	try
		IUdrProcedureFactoryImpl(PFBImplementationToken(this).Owner).setup(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrProcedureFactoryImpl_newItemDispatcher(this: PUdrProcedureFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalProcedureToken; cdecl;
begin
	try
		Result := IUdrProcedureFactoryImpl(PFBImplementationToken(this).Owner).newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUdrProcedureFactoryImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     dispose := @IDisposableImpl_disposeDispatcher;
     setup := @IUdrProcedureFactoryImpl_setupDispatcher;
     newItem := @IUdrProcedureFactoryImpl_newItemDispatcher;
  end;

  FInitialized := true;
end;

constructor IUdrTriggerFactoryImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUdrTriggerFactoryImpl.getInterfaceToken: PUdrTriggerFactoryToken;
begin
  Result := PUdrTriggerFactoryToken(@token);
end;

function IUdrTriggerFactoryImpl.getInterface: IUdrTriggerFactory;
begin
  Result := intf;
end;

procedure IUdrTriggerFactoryImpl_disposeDispatcher(this: PUdrTriggerFactoryToken); cdecl;
begin
	try
		IUdrTriggerFactoryImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrTriggerFactoryImpl_setupDispatcher(this: PUdrTriggerFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken; fieldsBuilder: PMetadataBuilderToken); cdecl;
begin
	try
		IUdrTriggerFactoryImpl(PFBImplementationToken(this).Owner).setup(status, context, metadata, fieldsBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrTriggerFactoryImpl_newItemDispatcher(this: PUdrTriggerFactoryToken; status: PStatusToken; context: PExternalContextToken; metadata: PRoutineMetadataToken): PExternalTriggerToken; cdecl;
begin
	try
		Result := IUdrTriggerFactoryImpl(PFBImplementationToken(this).Owner).newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUdrTriggerFactoryImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 3;
     dispose := @IDisposableImpl_disposeDispatcher;
     setup := @IUdrTriggerFactoryImpl_setupDispatcher;
     newItem := @IUdrTriggerFactoryImpl_newItemDispatcher;
  end;

  FInitialized := true;
end;

constructor IUdrPluginImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IUdrPluginImpl.getInterfaceToken: PUdrPluginToken;
begin
  Result := PUdrPluginToken(@token);
end;

function IUdrPluginImpl.getInterface: IUdrPlugin;
begin
  Result := intf;
end;

function IUdrPluginImpl_getMasterDispatcher(this: PUdrPluginToken): PMasterToken; cdecl;
begin
	try
		Result := IUdrPluginImpl(PFBImplementationToken(this).Owner).getMaster();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrPluginImpl_registerFunctionDispatcher(this: PUdrPluginToken; status: PStatusToken; name: PAnsiChar; factory: PUdrFunctionFactoryToken); cdecl;
begin
	try
		IUdrPluginImpl(PFBImplementationToken(this).Owner).registerFunction(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUdrPluginImpl_registerProcedureDispatcher(this: PUdrPluginToken; status: PStatusToken; name: PAnsiChar; factory: PUdrProcedureFactoryToken); cdecl;
begin
	try
		IUdrPluginImpl(PFBImplementationToken(this).Owner).registerProcedure(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUdrPluginImpl_registerTriggerDispatcher(this: PUdrPluginToken; status: PStatusToken; name: PAnsiChar; factory: PUdrTriggerFactoryToken); cdecl;
begin
	try
		IUdrPluginImpl(PFBImplementationToken(this).Owner).registerTrigger(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IUdrPluginImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     getMaster := @IUdrPluginImpl_getMasterDispatcher;
     registerFunction := @IUdrPluginImpl_registerFunctionDispatcher;
     registerProcedure := @IUdrPluginImpl_registerProcedureDispatcher;
     registerTrigger := @IUdrPluginImpl_registerTriggerDispatcher;
  end;

  FInitialized := true;
end;

constructor IDecFloat16Impl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDecFloat16Impl.getInterfaceToken: PDecFloat16Token;
begin
  Result := PDecFloat16Token(@token);
end;

function IDecFloat16Impl.getInterface: IDecFloat16;
begin
  Result := intf;
end;

procedure IDecFloat16Impl_toBcdDispatcher(this: PDecFloat16Token; from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
begin
	try
		IDecFloat16Impl(PFBImplementationToken(this).Owner).toBcd(from, sign, bcd, exp);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat16Impl_toStringDispatcher(this: PDecFloat16Token; status: PStatusToken; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		IDecFloat16Impl(PFBImplementationToken(this).Owner).toString(status, from, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDecFloat16Impl_fromBcdDispatcher(this: PDecFloat16Token; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); cdecl;
begin
	try
		IDecFloat16Impl(PFBImplementationToken(this).Owner).fromBcd(sign, bcd, exp, to_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat16Impl_fromStringDispatcher(this: PDecFloat16Token; status: PStatusToken; from: PAnsiChar; to_: FB_DEC16Ptr); cdecl;
begin
	try
		IDecFloat16Impl(PFBImplementationToken(this).Owner).fromString(status, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IDecFloat16Impl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     toBcd := @IDecFloat16Impl_toBcdDispatcher;
     toString := @IDecFloat16Impl_toStringDispatcher;
     fromBcd := @IDecFloat16Impl_fromBcdDispatcher;
     fromString := @IDecFloat16Impl_fromStringDispatcher;
  end;

  FInitialized := true;
end;

constructor IDecFloat34Impl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IDecFloat34Impl.getInterfaceToken: PDecFloat34Token;
begin
  Result := PDecFloat34Token(@token);
end;

function IDecFloat34Impl.getInterface: IDecFloat34;
begin
  Result := intf;
end;

procedure IDecFloat34Impl_toBcdDispatcher(this: PDecFloat34Token; from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
begin
	try
		IDecFloat34Impl(PFBImplementationToken(this).Owner).toBcd(from, sign, bcd, exp);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat34Impl_toStringDispatcher(this: PDecFloat34Token; status: PStatusToken; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		IDecFloat34Impl(PFBImplementationToken(this).Owner).toString(status, from, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDecFloat34Impl_fromBcdDispatcher(this: PDecFloat34Token; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); cdecl;
begin
	try
		IDecFloat34Impl(PFBImplementationToken(this).Owner).fromBcd(sign, bcd, exp, to_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat34Impl_fromStringDispatcher(this: PDecFloat34Token; status: PStatusToken; from: PAnsiChar; to_: FB_DEC34Ptr); cdecl;
begin
	try
		IDecFloat34Impl(PFBImplementationToken(this).Owner).fromString(status, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IDecFloat34Impl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     toBcd := @IDecFloat34Impl_toBcdDispatcher;
     toString := @IDecFloat34Impl_toStringDispatcher;
     fromBcd := @IDecFloat34Impl_fromBcdDispatcher;
     fromString := @IDecFloat34Impl_fromStringDispatcher;
  end;

  FInitialized := true;
end;

constructor IInt128Impl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IInt128Impl.getInterfaceToken: PInt128Token;
begin
  Result := PInt128Token(@token);
end;

function IInt128Impl.getInterface: IInt128;
begin
  Result := intf;
end;

procedure IInt128Impl_toStringDispatcher(this: PInt128Token; status: PStatusToken; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		IInt128Impl(PFBImplementationToken(this).Owner).toString(status, from, scale, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IInt128Impl_fromStringDispatcher(this: PInt128Token; status: PStatusToken; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); cdecl;
begin
	try
		IInt128Impl(PFBImplementationToken(this).Owner).fromString(status, scale, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IInt128Impl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 2;
     toString := @IInt128Impl_toStringDispatcher;
     fromString := @IInt128Impl_fromStringDispatcher;
  end;

  FInitialized := true;
end;

constructor IReplicatedFieldImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IReplicatedFieldImpl.getInterfaceToken: PReplicatedFieldToken;
begin
  Result := PReplicatedFieldToken(@token);
end;

function IReplicatedFieldImpl.getInterface: IReplicatedField;
begin
  Result := intf;
end;

function IReplicatedFieldImpl_getNameDispatcher(this: PReplicatedFieldToken): PAnsiChar; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getTypeDispatcher(this: PReplicatedFieldToken): Cardinal; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getSubTypeDispatcher(this: PReplicatedFieldToken): Integer; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getSubType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getScaleDispatcher(this: PReplicatedFieldToken): Integer; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getScale();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getLengthDispatcher(this: PReplicatedFieldToken): Cardinal; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getCharSetDispatcher(this: PReplicatedFieldToken): Cardinal; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getDataDispatcher(this: PReplicatedFieldToken): Pointer; cdecl;
begin
	try
		Result := IReplicatedFieldImpl(PFBImplementationToken(this).Owner).getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IReplicatedFieldImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 7;
     getName := @IReplicatedFieldImpl_getNameDispatcher;
     getType := @IReplicatedFieldImpl_getTypeDispatcher;
     getSubType := @IReplicatedFieldImpl_getSubTypeDispatcher;
     getScale := @IReplicatedFieldImpl_getScaleDispatcher;
     getLength := @IReplicatedFieldImpl_getLengthDispatcher;
     getCharSet := @IReplicatedFieldImpl_getCharSetDispatcher;
     getData := @IReplicatedFieldImpl_getDataDispatcher;
  end;

  FInitialized := true;
end;

constructor IReplicatedRecordImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IReplicatedRecordImpl.getInterfaceToken: PReplicatedRecordToken;
begin
  Result := PReplicatedRecordToken(@token);
end;

function IReplicatedRecordImpl.getInterface: IReplicatedRecord;
begin
  Result := intf;
end;

function IReplicatedRecordImpl_getCountDispatcher(this: PReplicatedRecordToken): Cardinal; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(PFBImplementationToken(this).Owner).getCount();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getFieldDispatcher(this: PReplicatedRecordToken; index: Cardinal): PReplicatedFieldToken; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(PFBImplementationToken(this).Owner).getField(index);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getRawLengthDispatcher(this: PReplicatedRecordToken): Cardinal; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(PFBImplementationToken(this).Owner).getRawLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getRawDataDispatcher(this: PReplicatedRecordToken): BytePtr; cdecl;
begin
	try
		Result := IReplicatedRecordImpl(PFBImplementationToken(this).Owner).getRawData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

class procedure IReplicatedRecordImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 4;
     getCount := @IReplicatedRecordImpl_getCountDispatcher;
     getField := @IReplicatedRecordImpl_getFieldDispatcher;
     getRawLength := @IReplicatedRecordImpl_getRawLengthDispatcher;
     getRawData := @IReplicatedRecordImpl_getRawDataDispatcher;
  end;

  FInitialized := true;
end;

constructor IReplicatedTransactionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IReplicatedTransactionImpl.getInterfaceToken: PReplicatedTransactionToken;
begin
  Result := PReplicatedTransactionToken(@token);
end;

function IReplicatedTransactionImpl.getInterface: IReplicatedTransaction;
begin
  Result := intf;
end;

procedure IReplicatedTransactionImpl_disposeDispatcher(this: PReplicatedTransactionToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatedTransactionImpl_prepareDispatcher(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).prepare(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_commitDispatcher(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_rollbackDispatcher(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_startSavepointDispatcher(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).startSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_releaseSavepointDispatcher(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).releaseSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_rollbackSavepointDispatcher(this: PReplicatedTransactionToken; status: PStatusToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).rollbackSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_insertRecordDispatcher(this: PReplicatedTransactionToken; status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).insertRecord(status, name, record_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_updateRecordDispatcher(this: PReplicatedTransactionToken; status: PStatusToken; name: PAnsiChar; orgRecord: PReplicatedRecordToken; newRecord: PReplicatedRecordToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).updateRecord(status, name, orgRecord, newRecord);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_deleteRecordDispatcher(this: PReplicatedTransactionToken; status: PStatusToken; name: PAnsiChar; record_: PReplicatedRecordToken); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).deleteRecord(status, name, record_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_executeSqlDispatcher(this: PReplicatedTransactionToken; status: PStatusToken; sql: PAnsiChar); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).executeSql(status, sql);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_executeSqlIntlDispatcher(this: PReplicatedTransactionToken; status: PStatusToken; charset: Cardinal; sql: PAnsiChar); cdecl;
begin
	try
		IReplicatedTransactionImpl(PFBImplementationToken(this).Owner).executeSqlIntl(status, charset, sql);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IReplicatedTransactionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 12;
     dispose := @IDisposableImpl_disposeDispatcher;
     prepare := @IReplicatedTransactionImpl_prepareDispatcher;
     commit := @IReplicatedTransactionImpl_commitDispatcher;
     rollback := @IReplicatedTransactionImpl_rollbackDispatcher;
     startSavepoint := @IReplicatedTransactionImpl_startSavepointDispatcher;
     releaseSavepoint := @IReplicatedTransactionImpl_releaseSavepointDispatcher;
     rollbackSavepoint := @IReplicatedTransactionImpl_rollbackSavepointDispatcher;
     insertRecord := @IReplicatedTransactionImpl_insertRecordDispatcher;
     updateRecord := @IReplicatedTransactionImpl_updateRecordDispatcher;
     deleteRecord := @IReplicatedTransactionImpl_deleteRecordDispatcher;
     executeSql := @IReplicatedTransactionImpl_executeSqlDispatcher;
     executeSqlIntl := @IReplicatedTransactionImpl_executeSqlIntlDispatcher;
  end;

  FInitialized := true;
end;

constructor IReplicatedSessionImpl.create;
begin
	Initialize;
	token.vTable := @vTable;
	token.Owner := self;
end;

function IReplicatedSessionImpl.getInterfaceToken: PReplicatedSessionToken;
begin
  Result := PReplicatedSessionToken(@token);
end;

function IReplicatedSessionImpl.getInterface: IReplicatedSession;
begin
  Result := intf;
end;

procedure IReplicatedSessionImpl_addRefDispatcher(this: PReplicatedSessionToken); cdecl;
begin
	try
		IReplicatedSessionImpl(PFBImplementationToken(this).Owner).addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_releaseDispatcher(this: PReplicatedSessionToken): Integer; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(PFBImplementationToken(this).Owner).release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatedSessionImpl_setOwnerDispatcher(this: PReplicatedSessionToken; r: PReferenceCountedToken); cdecl;
begin
	try
		IReplicatedSessionImpl(PFBImplementationToken(this).Owner).setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_getOwnerDispatcher(this: PReplicatedSessionToken): PReferenceCountedToken; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(PFBImplementationToken(this).Owner).getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_initDispatcher(this: PReplicatedSessionToken; status: PStatusToken; attachment: PAttachmentToken): Boolean; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(PFBImplementationToken(this).Owner).init(status, attachment);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IReplicatedSessionImpl_startTransactionDispatcher(this: PReplicatedSessionToken; status: PStatusToken; transaction: PTransactionToken; number: Int64): PReplicatedTransactionToken; cdecl;
begin
	try
		Result := IReplicatedSessionImpl(PFBImplementationToken(this).Owner).startTransaction(status, transaction, number);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedSessionImpl_cleanupTransactionDispatcher(this: PReplicatedSessionToken; status: PStatusToken; number: Int64); cdecl;
begin
	try
		IReplicatedSessionImpl(PFBImplementationToken(this).Owner).cleanupTransaction(status, number);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedSessionImpl_setSequenceDispatcher(this: PReplicatedSessionToken; status: PStatusToken; name: PAnsiChar; value: Int64); cdecl;
begin
	try
		IReplicatedSessionImpl(PFBImplementationToken(this).Owner).setSequence(status, name, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

class procedure IReplicatedSessionImpl.Initialize;
begin
  if FInitialized then Exit;
  with vTable do
  begin
     NullPtr := nil;
     version := 8;
     addRef := @IReferenceCountedImpl_addRefDispatcher;
     release := @IReferenceCountedImpl_releaseDispatcher;
     setOwner := @IPluginBaseImpl_setOwnerDispatcher;
     getOwner := @IPluginBaseImpl_getOwnerDispatcher;
     init := @IReplicatedSessionImpl_initDispatcher;
     startTransaction := @IReplicatedSessionImpl_startTransactionDispatcher;
     cleanupTransaction := @IReplicatedSessionImpl_cleanupTransactionDispatcher;
     setSequence := @IReplicatedSessionImpl_setSequenceDispatcher;
  end;

  FInitialized := true;
end;

constructor FbException.create(status: IStatus);
begin
	inherited Create('FbException');
	self.status := status.clone;
end;

destructor FbException.Destroy();
begin
	status.dispose;
	inherited Destroy;
end;

function FbException.getStatus: IStatus;
begin
	Result := status;
end;

class procedure FbException.checkException(status: IStatus);
begin
	if ((status.getState and status.STATE_ERRORS) <> 0) then
		raise FbException.create(status);
end;

class procedure FbException.catchException(status: IStatus; e: Exception);
var
	statusVector: array[0..4] of NativeIntPtr;
	msg: AnsiString;
begin
	if (e.inheritsFrom(FbException)) then
		status.setErrors(FbException(e).getStatus.getErrors)
	else
	begin
		msg := e.message;

		statusVector[0] := NativeIntPtr(isc_arg_gds);
		statusVector[1] := NativeIntPtr(isc_random);
		statusVector[2] := NativeIntPtr(isc_arg_string);
		statusVector[3] := NativeIntPtr(PAnsiChar(msg));
		statusVector[4] := NativeIntPtr(isc_arg_end);

		status.setErrors(@statusVector);
	end
end;

Initialization

  IVersionedImpl.FInitialized := false;
  IReferenceCountedImpl.FInitialized := false;
  IDisposableImpl.FInitialized := false;
  IStatusImpl.FInitialized := false;
  IMasterImpl.FInitialized := false;
  IPluginBaseImpl.FInitialized := false;
  IPluginSetImpl.FInitialized := false;
  IConfigEntryImpl.FInitialized := false;
  IConfigImpl.FInitialized := false;
  IFirebirdConfImpl.FInitialized := false;
  IPluginConfigImpl.FInitialized := false;
  IPluginFactoryImpl.FInitialized := false;
  IPluginModuleImpl.FInitialized := false;
  IPluginManagerImpl.FInitialized := false;
  ICryptKeyImpl.FInitialized := false;
  IConfigManagerImpl.FInitialized := false;
  IEventCallbackImpl.FInitialized := false;
  IBlobImpl.FInitialized := false;
  ITransactionImpl.FInitialized := false;
  IMessageMetadataImpl.FInitialized := false;
  IMetadataBuilderImpl.FInitialized := false;
  IResultSetImpl.FInitialized := false;
  IStatementImpl.FInitialized := false;
  IBatchImpl.FInitialized := false;
  IBatchCompletionStateImpl.FInitialized := false;
  IReplicatorImpl.FInitialized := false;
  IRequestImpl.FInitialized := false;
  IEventsImpl.FInitialized := false;
  IAttachmentImpl.FInitialized := false;
  IServiceImpl.FInitialized := false;
  IProviderImpl.FInitialized := false;
  IDtcStartImpl.FInitialized := false;
  IDtcImpl.FInitialized := false;
  IAuthImpl.FInitialized := false;
  IWriterImpl.FInitialized := false;
  IServerBlockImpl.FInitialized := false;
  IClientBlockImpl.FInitialized := false;
  IServerImpl.FInitialized := false;
  IClientImpl.FInitialized := false;
  IUserFieldImpl.FInitialized := false;
  ICharUserFieldImpl.FInitialized := false;
  IIntUserFieldImpl.FInitialized := false;
  IUserImpl.FInitialized := false;
  IListUsersImpl.FInitialized := false;
  ILogonInfoImpl.FInitialized := false;
  IManagementImpl.FInitialized := false;
  IAuthBlockImpl.FInitialized := false;
  IWireCryptPluginImpl.FInitialized := false;
  ICryptKeyCallbackImpl.FInitialized := false;
  IKeyHolderPluginImpl.FInitialized := false;
  IDbCryptInfoImpl.FInitialized := false;
  IDbCryptPluginImpl.FInitialized := false;
  IExternalContextImpl.FInitialized := false;
  IExternalResultSetImpl.FInitialized := false;
  IExternalFunctionImpl.FInitialized := false;
  IExternalProcedureImpl.FInitialized := false;
  IExternalTriggerImpl.FInitialized := false;
  IRoutineMetadataImpl.FInitialized := false;
  IExternalEngineImpl.FInitialized := false;
  ITimerImpl.FInitialized := false;
  ITimerControlImpl.FInitialized := false;
  IVersionCallbackImpl.FInitialized := false;
  IUtilImpl.FInitialized := false;
  IOffsetsCallbackImpl.FInitialized := false;
  IXpbBuilderImpl.FInitialized := false;
  ITraceConnectionImpl.FInitialized := false;
  ITraceDatabaseConnectionImpl.FInitialized := false;
  ITraceTransactionImpl.FInitialized := false;
  ITraceParamsImpl.FInitialized := false;
  ITraceStatementImpl.FInitialized := false;
  ITraceSQLStatementImpl.FInitialized := false;
  ITraceBLRStatementImpl.FInitialized := false;
  ITraceDYNRequestImpl.FInitialized := false;
  ITraceContextVariableImpl.FInitialized := false;
  ITraceProcedureImpl.FInitialized := false;
  ITraceFunctionImpl.FInitialized := false;
  ITraceTriggerImpl.FInitialized := false;
  ITraceServiceConnectionImpl.FInitialized := false;
  ITraceStatusVectorImpl.FInitialized := false;
  ITraceSweepInfoImpl.FInitialized := false;
  ITraceLogWriterImpl.FInitialized := false;
  ITraceInitInfoImpl.FInitialized := false;
  ITracePluginImpl.FInitialized := false;
  ITraceFactoryImpl.FInitialized := false;
  IUdrFunctionFactoryImpl.FInitialized := false;
  IUdrProcedureFactoryImpl.FInitialized := false;
  IUdrTriggerFactoryImpl.FInitialized := false;
  IUdrPluginImpl.FInitialized := false;
  IDecFloat16Impl.FInitialized := false;
  IDecFloat34Impl.FInitialized := false;
  IInt128Impl.FInitialized := false;
  IReplicatedFieldImpl.FInitialized := false;
  IReplicatedRecordImpl.FInitialized := false;
  IReplicatedTransactionImpl.FInitialized := false;
  IReplicatedSessionImpl.FInitialized := false;

end.
