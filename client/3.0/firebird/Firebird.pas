{ This file was autogenerated by cloop - Cross Language Object Oriented Programming }

{ $DEFINE USEFBEXCEPTION}
{ $DEFINE STATIC_LINK_TO_FIREBIRD_LIBRARY}

{$WARNINGS OFF}
{$IFDEF FPC}
{$MODE DELPHI}
{$ENDIF}

unit Firebird;

interface

uses Classes, Sysutils, IBErrorCodes;

type
{$IFNDEF FPC}
	QWord = UInt64;
{$ENDIF}

	IVersioned = ^TVersioned;
	IReferenceCounted = ^TReferenceCounted;
	IDisposable = ^TDisposable;
	IStatus = ^TStatus;
	IMaster = ^TMaster;
	IPluginBase = ^TPluginBase;
	IPluginSet = ^TPluginSet;
	IConfigEntry = ^TConfigEntry;
	IConfig = ^TConfig;
	IFirebirdConf = ^TFirebirdConf;
	IPluginConfig = ^TPluginConfig;
	IPluginFactory = ^TPluginFactory;
	IPluginModule = ^TPluginModule;
	IPluginManager = ^TPluginManager;
	ICryptKey = ^TCryptKey;
	IConfigManager = ^TConfigManager;
	IEventCallback = ^TEventCallback;
	IBlob = ^TBlob;
	ITransaction = ^TTransaction;
	IMessageMetadata = ^TMessageMetadata;
	IMetadataBuilder = ^TMetadataBuilder;
	IResultSet = ^TResultSet;
	IStatement = ^TStatement;
	IBatch = ^TBatch;
	IBatchCompletionState = ^TBatchCompletionState;
	IReplicator = ^TReplicator;
	IRequest = ^TRequest;
	IEvents = ^TEvents;
	IAttachment = ^TAttachment;
	IService = ^TService;
	IProvider = ^TProvider;
	IDtcStart = ^TDtcStart;
	IDtc = ^TDtc;
	IAuth = ^TAuth;
	IWriter = ^TWriter;
	IServerBlock = ^TServerBlock;
	IClientBlock = ^TClientBlock;
	IServer = ^TServer;
	IClient = ^TClient;
	IUserField = ^TUserField;
	ICharUserField = ^TCharUserField;
	IIntUserField = ^TIntUserField;
	IUser = ^TUser;
	IListUsers = ^TListUsers;
	ILogonInfo = ^TLogonInfo;
	IManagement = ^TManagement;
	IAuthBlock = ^TAuthBlock;
	IWireCryptPlugin = ^TWireCryptPlugin;
	ICryptKeyCallback = ^TCryptKeyCallback;
	IKeyHolderPlugin = ^TKeyHolderPlugin;
	IDbCryptInfo = ^TDbCryptInfo;
	IDbCryptPlugin = ^TDbCryptPlugin;
	IExternalContext = ^TExternalContext;
	IExternalResultSet = ^TExternalResultSet;
	IExternalFunction = ^TExternalFunction;
	IExternalProcedure = ^TExternalProcedure;
	IExternalTrigger = ^TExternalTrigger;
	IRoutineMetadata = ^TRoutineMetadata;
	IExternalEngine = ^TExternalEngine;
	ITimer = ^TTimer;
	ITimerControl = ^TTimerControl;
	IVersionCallback = ^TVersionCallback;
	IUtil = ^TUtil;
	IOffsetsCallback = ^TOffsetsCallback;
	IXpbBuilder = ^TXpbBuilder;
	ITraceConnection = ^TTraceConnection;
	ITraceDatabaseConnection = ^TTraceDatabaseConnection;
	ITraceTransaction = ^TTraceTransaction;
	ITraceParams = ^TTraceParams;
	ITraceStatement = ^TTraceStatement;
	ITraceSQLStatement = ^TTraceSQLStatement;
	ITraceBLRStatement = ^TTraceBLRStatement;
	ITraceDYNRequest = ^TTraceDYNRequest;
	ITraceContextVariable = ^TTraceContextVariable;
	ITraceProcedure = ^TTraceProcedure;
	ITraceFunction = ^TTraceFunction;
	ITraceTrigger = ^TTraceTrigger;
	ITraceServiceConnection = ^TTraceServiceConnection;
	ITraceStatusVector = ^TTraceStatusVector;
	ITraceSweepInfo = ^TTraceSweepInfo;
	ITraceLogWriter = ^TTraceLogWriter;
	ITraceInitInfo = ^TTraceInitInfo;
	ITracePlugin = ^TTracePlugin;
	ITraceFactory = ^TTraceFactory;
	IUdrFunctionFactory = ^TUdrFunctionFactory;
	IUdrProcedureFactory = ^TUdrProcedureFactory;
	IUdrTriggerFactory = ^TUdrTriggerFactory;
	IUdrPlugin = ^TUdrPlugin;
	IDecFloat16 = ^TDecFloat16;
	IDecFloat34 = ^TDecFloat34;
	IInt128 = ^TInt128;
	IReplicatedField = ^TReplicatedField;
	IReplicatedRecord = ^TReplicatedRecord;
	IReplicatedTransaction = ^TReplicatedTransaction;
	IReplicatedSession = ^TReplicatedSession;

	ISC_DATE = Integer;
	ISC_TIME = Integer;
	ISC_QUAD = array [1..2] of Integer;
	FB_DEC16 = array [1..1] of Int64;
	FB_DEC34 = array [1..2] of Int64;
	FB_I128 = array [1..2] of Int64;

	isc_tr_handle = ^Integer;
	isc_stmt_handle = ^Integer;

	ISC_USHORT = word;		{ 16 bit unsigned }
	ISC_SHORT = smallint;	{ 16 bit signed }

	ISC_TIME_TZ = record
		utc_time: ISC_TIME;
		time_zone: ISC_USHORT;
	end;

	ISC_TIME_TZ_EX = record
		utc_time: ISC_TIME;
		time_zone: ISC_USHORT;
		ext_offset: ISC_SHORT;
	end;

	ISC_TIMESTAMP = record
		timestamp_date: ISC_DATE;
		timestamp_time: ISC_TIME;
	end;

	ISC_TIMESTAMP_TZ = record
		utc_timestamp: ISC_TIMESTAMP;
		time_zone: ISC_USHORT;
	end;

	ISC_TIMESTAMP_TZ_EX = record
		utc_timestamp: ISC_TIMESTAMP;
		time_zone: ISC_USHORT;
		ext_offset: ISC_SHORT;
	end;

	ntrace_relation_t = Integer;
	TraceCounts = Record
		trc_relation_id		: ntrace_relation_t;
		trc_relation_name	: PAnsiChar;
		trc_counters		: ^Int64;
	end;
	TraceCountsPtr = ^TraceCounts;
	PerformanceInfo = Record
		pin_time			: Int64;
		pin_counters		: ^Int64;
		pin_count			: NativeUInt;
		pin_tables			: TraceCountsPtr;
		pin_records_fetched	: Int64;
	end;

	Dsc = Record
		dsc_dtype, dsc_scale: Byte;
		dsc_length, dsc_sub_type, dsc_flags: Int16;
		dsc_address: ^Byte;
	end;

	FbException = class(Exception)
	public
		constructor create(status: IStatus); virtual;
		destructor Destroy(); override;

		function getStatus: IStatus;

		class procedure checkException(status: IStatus);
		class procedure catchException(status: IStatus; e: Exception);

	private
		status: IStatus;
	end;

	BooleanPtr = ^Boolean;
	BytePtr = ^Byte;
	CardinalPtr = ^Cardinal;
	FB_DEC16Ptr = ^FB_DEC16;
	FB_DEC34Ptr = ^FB_DEC34;
	FB_I128Ptr = ^FB_I128;
	ISC_QUADPtr = ^ISC_QUAD;
	ISC_TIMESTAMP_TZPtr = ^ISC_TIMESTAMP_TZ;
	ISC_TIMESTAMP_TZ_EXPtr = ^ISC_TIMESTAMP_TZ_EX;
	ISC_TIME_TZPtr = ^ISC_TIME_TZ;
	ISC_TIME_TZ_EXPtr = ^ISC_TIME_TZ_EX;
	Int64Ptr = ^Int64;
	IntegerPtr = ^Integer;
	NativeIntPtr = ^NativeInt;
	PerformanceInfoPtr = ^PerformanceInfo;
	dscPtr = ^dsc;

	IReferenceCounted_addRefPtr = procedure(this: IReferenceCounted); cdecl;
	IReferenceCounted_releasePtr = function(this: IReferenceCounted): Integer; cdecl;
	IDisposable_disposePtr = procedure(this: IDisposable); cdecl;
	IStatus_initPtr = procedure(this: IStatus); cdecl;
	IStatus_getStatePtr = function(this: IStatus): Cardinal; cdecl;
	IStatus_setErrors2Ptr = procedure(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
	IStatus_setWarnings2Ptr = procedure(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
	IStatus_setErrorsPtr = procedure(this: IStatus; value: NativeIntPtr); cdecl;
	IStatus_setWarningsPtr = procedure(this: IStatus; value: NativeIntPtr); cdecl;
	IStatus_getErrorsPtr = function(this: IStatus): NativeIntPtr; cdecl;
	IStatus_getWarningsPtr = function(this: IStatus): NativeIntPtr; cdecl;
	IStatus_clonePtr = function(this: IStatus): IStatus; cdecl;
	IMaster_getStatusPtr = function(this: IMaster): IStatus; cdecl;
	IMaster_getDispatcherPtr = function(this: IMaster): IProvider; cdecl;
	IMaster_getPluginManagerPtr = function(this: IMaster): IPluginManager; cdecl;
	IMaster_getTimerControlPtr = function(this: IMaster): ITimerControl; cdecl;
	IMaster_getDtcPtr = function(this: IMaster): IDtc; cdecl;
	IMaster_registerAttachmentPtr = function(this: IMaster; provider: IProvider; attachment: IAttachment): IAttachment; cdecl;
	IMaster_registerTransactionPtr = function(this: IMaster; attachment: IAttachment; transaction: ITransaction): ITransaction; cdecl;
	IMaster_getMetadataBuilderPtr = function(this: IMaster; status: IStatus; fieldCount: Cardinal): IMetadataBuilder; cdecl;
	IMaster_serverModePtr = function(this: IMaster; mode: Integer): Integer; cdecl;
	IMaster_getUtilInterfacePtr = function(this: IMaster): IUtil; cdecl;
	IMaster_getConfigManagerPtr = function(this: IMaster): IConfigManager; cdecl;
	IMaster_getProcessExitingPtr = function(this: IMaster): Boolean; cdecl;
	IPluginBase_setOwnerPtr = procedure(this: IPluginBase; r: IReferenceCounted); cdecl;
	IPluginBase_getOwnerPtr = function(this: IPluginBase): IReferenceCounted; cdecl;
	IPluginSet_getNamePtr = function(this: IPluginSet): PAnsiChar; cdecl;
	IPluginSet_getModuleNamePtr = function(this: IPluginSet): PAnsiChar; cdecl;
	IPluginSet_getPluginPtr = function(this: IPluginSet; status: IStatus): IPluginBase; cdecl;
	IPluginSet_nextPtr = procedure(this: IPluginSet; status: IStatus); cdecl;
	IPluginSet_set_Ptr = procedure(this: IPluginSet; status: IStatus; s: PAnsiChar); cdecl;
	IConfigEntry_getNamePtr = function(this: IConfigEntry): PAnsiChar; cdecl;
	IConfigEntry_getValuePtr = function(this: IConfigEntry): PAnsiChar; cdecl;
	IConfigEntry_getIntValuePtr = function(this: IConfigEntry): Int64; cdecl;
	IConfigEntry_getBoolValuePtr = function(this: IConfigEntry): Boolean; cdecl;
	IConfigEntry_getSubConfigPtr = function(this: IConfigEntry; status: IStatus): IConfig; cdecl;
	IConfig_findPtr = function(this: IConfig; status: IStatus; name: PAnsiChar): IConfigEntry; cdecl;
	IConfig_findValuePtr = function(this: IConfig; status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry; cdecl;
	IConfig_findPosPtr = function(this: IConfig; status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry; cdecl;
	IFirebirdConf_getKeyPtr = function(this: IFirebirdConf; name: PAnsiChar): Cardinal; cdecl;
	IFirebirdConf_asIntegerPtr = function(this: IFirebirdConf; key: Cardinal): Int64; cdecl;
	IFirebirdConf_asStringPtr = function(this: IFirebirdConf; key: Cardinal): PAnsiChar; cdecl;
	IFirebirdConf_asBooleanPtr = function(this: IFirebirdConf; key: Cardinal): Boolean; cdecl;
	IFirebirdConf_getVersionPtr = function(this: IFirebirdConf; status: IStatus): Cardinal; cdecl;
	IPluginConfig_getConfigFileNamePtr = function(this: IPluginConfig): PAnsiChar; cdecl;
	IPluginConfig_getDefaultConfigPtr = function(this: IPluginConfig; status: IStatus): IConfig; cdecl;
	IPluginConfig_getFirebirdConfPtr = function(this: IPluginConfig; status: IStatus): IFirebirdConf; cdecl;
	IPluginConfig_setReleaseDelayPtr = procedure(this: IPluginConfig; status: IStatus; microSeconds: QWord); cdecl;
	IPluginFactory_createPluginPtr = function(this: IPluginFactory; status: IStatus; factoryParameter: IPluginConfig): IPluginBase; cdecl;
	IPluginModule_doCleanPtr = procedure(this: IPluginModule); cdecl;
	IPluginModule_threadDetachPtr = procedure(this: IPluginModule); cdecl;
	IPluginManager_registerPluginFactoryPtr = procedure(this: IPluginManager; pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory); cdecl;
	IPluginManager_registerModulePtr = procedure(this: IPluginManager; cleanup: IPluginModule); cdecl;
	IPluginManager_unregisterModulePtr = procedure(this: IPluginManager; cleanup: IPluginModule); cdecl;
	IPluginManager_getPluginsPtr = function(this: IPluginManager; status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet; cdecl;
	IPluginManager_getConfigPtr = function(this: IPluginManager; status: IStatus; filename: PAnsiChar): IConfig; cdecl;
	IPluginManager_releasePluginPtr = procedure(this: IPluginManager; plugin: IPluginBase); cdecl;
	ICryptKey_setSymmetricPtr = procedure(this: ICryptKey; status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); cdecl;
	ICryptKey_setAsymmetricPtr = procedure(this: ICryptKey; status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); cdecl;
	ICryptKey_getEncryptKeyPtr = function(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
	ICryptKey_getDecryptKeyPtr = function(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
	IConfigManager_getDirectoryPtr = function(this: IConfigManager; code: Cardinal): PAnsiChar; cdecl;
	IConfigManager_getFirebirdConfPtr = function(this: IConfigManager): IFirebirdConf; cdecl;
	IConfigManager_getDatabaseConfPtr = function(this: IConfigManager; dbName: PAnsiChar): IFirebirdConf; cdecl;
	IConfigManager_getPluginConfigPtr = function(this: IConfigManager; configuredPlugin: PAnsiChar): IConfig; cdecl;
	IConfigManager_getInstallDirectoryPtr = function(this: IConfigManager): PAnsiChar; cdecl;
	IConfigManager_getRootDirectoryPtr = function(this: IConfigManager): PAnsiChar; cdecl;
	IConfigManager_getDefaultSecurityDbPtr = function(this: IConfigManager): PAnsiChar; cdecl;
	IEventCallback_eventCallbackFunctionPtr = procedure(this: IEventCallback; length: Cardinal; events: BytePtr); cdecl;
	IBlob_getInfoPtr = procedure(this: IBlob; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IBlob_getSegmentPtr = function(this: IBlob; status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; cdecl;
	IBlob_putSegmentPtr = procedure(this: IBlob; status: IStatus; length: Cardinal; buffer: Pointer); cdecl;
	IBlob_cancelPtr = procedure(this: IBlob; status: IStatus); cdecl;
	IBlob_closePtr = procedure(this: IBlob; status: IStatus); cdecl;
	IBlob_seekPtr = function(this: IBlob; status: IStatus; mode: Integer; offset: Integer): Integer; cdecl;
	ITransaction_getInfoPtr = procedure(this: ITransaction; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	ITransaction_preparePtr = procedure(this: ITransaction; status: IStatus; msgLength: Cardinal; message: BytePtr); cdecl;
	ITransaction_commitPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_commitRetainingPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_rollbackPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_rollbackRetainingPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_disconnectPtr = procedure(this: ITransaction; status: IStatus); cdecl;
	ITransaction_joinPtr = function(this: ITransaction; status: IStatus; transaction: ITransaction): ITransaction; cdecl;
	ITransaction_validatePtr = function(this: ITransaction; status: IStatus; attachment: IAttachment): ITransaction; cdecl;
	ITransaction_enterDtcPtr = function(this: ITransaction; status: IStatus): ITransaction; cdecl;
	IMessageMetadata_getCountPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMessageMetadata_getFieldPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getRelationPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getOwnerPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getAliasPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
	IMessageMetadata_getTypePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_isNullablePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Boolean; cdecl;
	IMessageMetadata_getSubTypePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
	IMessageMetadata_getLengthPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getScalePtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
	IMessageMetadata_getCharSetPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getOffsetPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getNullOffsetPtr = function(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
	IMessageMetadata_getBuilderPtr = function(this: IMessageMetadata; status: IStatus): IMetadataBuilder; cdecl;
	IMessageMetadata_getMessageLengthPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMessageMetadata_getAlignmentPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMessageMetadata_getAlignedLengthPtr = function(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
	IMetadataBuilder_setTypePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; type_: Cardinal); cdecl;
	IMetadataBuilder_setSubTypePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; subType: Integer); cdecl;
	IMetadataBuilder_setLengthPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; length: Cardinal); cdecl;
	IMetadataBuilder_setCharSetPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; charSet: Cardinal); cdecl;
	IMetadataBuilder_setScalePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; scale: Integer); cdecl;
	IMetadataBuilder_truncatePtr = procedure(this: IMetadataBuilder; status: IStatus; count: Cardinal); cdecl;
	IMetadataBuilder_moveNameToIndexPtr = procedure(this: IMetadataBuilder; status: IStatus; name: PAnsiChar; index: Cardinal); cdecl;
	IMetadataBuilder_removePtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal); cdecl;
	IMetadataBuilder_addFieldPtr = function(this: IMetadataBuilder; status: IStatus): Cardinal; cdecl;
	IMetadataBuilder_getMetadataPtr = function(this: IMetadataBuilder; status: IStatus): IMessageMetadata; cdecl;
	IMetadataBuilder_setFieldPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; field: PAnsiChar); cdecl;
	IMetadataBuilder_setRelationPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; relation: PAnsiChar); cdecl;
	IMetadataBuilder_setOwnerPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; owner: PAnsiChar); cdecl;
	IMetadataBuilder_setAliasPtr = procedure(this: IMetadataBuilder; status: IStatus; index: Cardinal; alias: PAnsiChar); cdecl;
	IResultSet_fetchNextPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchPriorPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchFirstPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchLastPtr = function(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
	IResultSet_fetchAbsolutePtr = function(this: IResultSet; status: IStatus; position: Integer; message: Pointer): Integer; cdecl;
	IResultSet_fetchRelativePtr = function(this: IResultSet; status: IStatus; offset: Integer; message: Pointer): Integer; cdecl;
	IResultSet_isEofPtr = function(this: IResultSet; status: IStatus): Boolean; cdecl;
	IResultSet_isBofPtr = function(this: IResultSet; status: IStatus): Boolean; cdecl;
	IResultSet_getMetadataPtr = function(this: IResultSet; status: IStatus): IMessageMetadata; cdecl;
	IResultSet_closePtr = procedure(this: IResultSet; status: IStatus); cdecl;
	IResultSet_setDelayedOutputFormatPtr = procedure(this: IResultSet; status: IStatus; format: IMessageMetadata); cdecl;
	IStatement_getInfoPtr = procedure(this: IStatement; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IStatement_getTypePtr = function(this: IStatement; status: IStatus): Cardinal; cdecl;
	IStatement_getPlanPtr = function(this: IStatement; status: IStatus; detailed: Boolean): PAnsiChar; cdecl;
	IStatement_getAffectedRecordsPtr = function(this: IStatement; status: IStatus): QWord; cdecl;
	IStatement_getInputMetadataPtr = function(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
	IStatement_getOutputMetadataPtr = function(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
	IStatement_executePtr = function(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
	IStatement_openCursorPtr = function(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet; cdecl;
	IStatement_setCursorNamePtr = procedure(this: IStatement; status: IStatus; name: PAnsiChar); cdecl;
	IStatement_freePtr = procedure(this: IStatement; status: IStatus); cdecl;
	IStatement_getFlagsPtr = function(this: IStatement; status: IStatus): Cardinal; cdecl;
	IStatement_getTimeoutPtr = function(this: IStatement; status: IStatus): Cardinal; cdecl;
	IStatement_setTimeoutPtr = procedure(this: IStatement; status: IStatus; timeOut: Cardinal); cdecl;
	IStatement_createBatchPtr = function(this: IStatement; status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
	IBatch_addPtr = procedure(this: IBatch; status: IStatus; count: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_addBlobPtr = procedure(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); cdecl;
	IBatch_appendBlobDataPtr = procedure(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_addBlobStreamPtr = procedure(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
	IBatch_registerBlobPtr = procedure(this: IBatch; status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); cdecl;
	IBatch_executePtr = function(this: IBatch; status: IStatus; transaction: ITransaction): IBatchCompletionState; cdecl;
	IBatch_cancelPtr = procedure(this: IBatch; status: IStatus); cdecl;
	IBatch_getBlobAlignmentPtr = function(this: IBatch; status: IStatus): Cardinal; cdecl;
	IBatch_getMetadataPtr = function(this: IBatch; status: IStatus): IMessageMetadata; cdecl;
	IBatch_setDefaultBpbPtr = procedure(this: IBatch; status: IStatus; parLength: Cardinal; par: BytePtr); cdecl;
	IBatch_closePtr = procedure(this: IBatch; status: IStatus); cdecl;
	IBatchCompletionState_getSizePtr = function(this: IBatchCompletionState; status: IStatus): Cardinal; cdecl;
	IBatchCompletionState_getStatePtr = function(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Integer; cdecl;
	IBatchCompletionState_findErrorPtr = function(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Cardinal; cdecl;
	IBatchCompletionState_getStatusPtr = procedure(this: IBatchCompletionState; status: IStatus; to_: IStatus; pos: Cardinal); cdecl;
	IReplicator_processPtr = procedure(this: IReplicator; status: IStatus; length: Cardinal; data: BytePtr); cdecl;
	IReplicator_closePtr = procedure(this: IReplicator; status: IStatus); cdecl;
	IRequest_receivePtr = procedure(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_sendPtr = procedure(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_getInfoPtr = procedure(this: IRequest; status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IRequest_startPtr = procedure(this: IRequest; status: IStatus; tra: ITransaction; level: Integer); cdecl;
	IRequest_startAndSendPtr = procedure(this: IRequest; status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
	IRequest_unwindPtr = procedure(this: IRequest; status: IStatus; level: Integer); cdecl;
	IRequest_freePtr = procedure(this: IRequest; status: IStatus); cdecl;
	IEvents_cancelPtr = procedure(this: IEvents; status: IStatus); cdecl;
	IAttachment_getInfoPtr = procedure(this: IAttachment; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IAttachment_startTransactionPtr = function(this: IAttachment; status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction; cdecl;
	IAttachment_reconnectTransactionPtr = function(this: IAttachment; status: IStatus; length: Cardinal; id: BytePtr): ITransaction; cdecl;
	IAttachment_compileRequestPtr = function(this: IAttachment; status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest; cdecl;
	IAttachment_transactRequestPtr = procedure(this: IAttachment; status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); cdecl;
	IAttachment_createBlobPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
	IAttachment_openBlobPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
	IAttachment_getSlicePtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; cdecl;
	IAttachment_putSlicePtr = procedure(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); cdecl;
	IAttachment_executeDynPtr = procedure(this: IAttachment; status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr); cdecl;
	IAttachment_preparePtr = function(this: IAttachment; status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement; cdecl;
	IAttachment_executePtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
	IAttachment_openCursorPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet; cdecl;
	IAttachment_queEventsPtr = function(this: IAttachment; status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents; cdecl;
	IAttachment_cancelOperationPtr = procedure(this: IAttachment; status: IStatus; option: Integer); cdecl;
	IAttachment_pingPtr = procedure(this: IAttachment; status: IStatus); cdecl;
	IAttachment_detachPtr = procedure(this: IAttachment; status: IStatus); cdecl;
	IAttachment_dropDatabasePtr = procedure(this: IAttachment; status: IStatus); cdecl;
	IAttachment_getIdleTimeoutPtr = function(this: IAttachment; status: IStatus): Cardinal; cdecl;
	IAttachment_setIdleTimeoutPtr = procedure(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
	IAttachment_getStatementTimeoutPtr = function(this: IAttachment; status: IStatus): Cardinal; cdecl;
	IAttachment_setStatementTimeoutPtr = procedure(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
	IAttachment_createBatchPtr = function(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
	IAttachment_createReplicatorPtr = function(this: IAttachment; status: IStatus): IReplicator; cdecl;
	IService_detachPtr = procedure(this: IService; status: IStatus); cdecl;
	IService_queryPtr = procedure(this: IService; status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
	IService_startPtr = procedure(this: IService; status: IStatus; spbLength: Cardinal; spb: BytePtr); cdecl;
	IProvider_attachDatabasePtr = function(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
	IProvider_createDatabasePtr = function(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
	IProvider_attachServiceManagerPtr = function(this: IProvider; status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService; cdecl;
	IProvider_shutdownPtr = procedure(this: IProvider; status: IStatus; timeout: Cardinal; reason: Integer); cdecl;
	IProvider_setDbCryptCallbackPtr = procedure(this: IProvider; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
	IDtcStart_addAttachmentPtr = procedure(this: IDtcStart; status: IStatus; att: IAttachment); cdecl;
	IDtcStart_addWithTpbPtr = procedure(this: IDtcStart; status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr); cdecl;
	IDtcStart_startPtr = function(this: IDtcStart; status: IStatus): ITransaction; cdecl;
	IDtc_joinPtr = function(this: IDtc; status: IStatus; one: ITransaction; two: ITransaction): ITransaction; cdecl;
	IDtc_startBuilderPtr = function(this: IDtc; status: IStatus): IDtcStart; cdecl;
	IWriter_resetPtr = procedure(this: IWriter); cdecl;
	IWriter_addPtr = procedure(this: IWriter; status: IStatus; name: PAnsiChar); cdecl;
	IWriter_setTypePtr = procedure(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
	IWriter_setDbPtr = procedure(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
	IServerBlock_getLoginPtr = function(this: IServerBlock): PAnsiChar; cdecl;
	IServerBlock_getDataPtr = function(this: IServerBlock; length: CardinalPtr): BytePtr; cdecl;
	IServerBlock_putDataPtr = procedure(this: IServerBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
	IServerBlock_newKeyPtr = function(this: IServerBlock; status: IStatus): ICryptKey; cdecl;
	IClientBlock_getLoginPtr = function(this: IClientBlock): PAnsiChar; cdecl;
	IClientBlock_getPasswordPtr = function(this: IClientBlock): PAnsiChar; cdecl;
	IClientBlock_getDataPtr = function(this: IClientBlock; length: CardinalPtr): BytePtr; cdecl;
	IClientBlock_putDataPtr = procedure(this: IClientBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
	IClientBlock_newKeyPtr = function(this: IClientBlock; status: IStatus): ICryptKey; cdecl;
	IClientBlock_getAuthBlockPtr = function(this: IClientBlock; status: IStatus): IAuthBlock; cdecl;
	IServer_authenticatePtr = function(this: IServer; status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer; cdecl;
	IServer_setDbCryptCallbackPtr = procedure(this: IServer; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
	IClient_authenticatePtr = function(this: IClient; status: IStatus; cBlock: IClientBlock): Integer; cdecl;
	IUserField_enteredPtr = function(this: IUserField): Integer; cdecl;
	IUserField_specifiedPtr = function(this: IUserField): Integer; cdecl;
	IUserField_setEnteredPtr = procedure(this: IUserField; status: IStatus; newValue: Integer); cdecl;
	ICharUserField_getPtr = function(this: ICharUserField): PAnsiChar; cdecl;
	ICharUserField_set_Ptr = procedure(this: ICharUserField; status: IStatus; newValue: PAnsiChar); cdecl;
	IIntUserField_getPtr = function(this: IIntUserField): Integer; cdecl;
	IIntUserField_set_Ptr = procedure(this: IIntUserField; status: IStatus; newValue: Integer); cdecl;
	IUser_operationPtr = function(this: IUser): Cardinal; cdecl;
	IUser_userNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_passwordPtr = function(this: IUser): ICharUserField; cdecl;
	IUser_firstNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_lastNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_middleNamePtr = function(this: IUser): ICharUserField; cdecl;
	IUser_commentPtr = function(this: IUser): ICharUserField; cdecl;
	IUser_attributesPtr = function(this: IUser): ICharUserField; cdecl;
	IUser_activePtr = function(this: IUser): IIntUserField; cdecl;
	IUser_adminPtr = function(this: IUser): IIntUserField; cdecl;
	IUser_clearPtr = procedure(this: IUser; status: IStatus); cdecl;
	IListUsers_listPtr = procedure(this: IListUsers; status: IStatus; user: IUser); cdecl;
	ILogonInfo_namePtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_rolePtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_networkProtocolPtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_remoteAddressPtr = function(this: ILogonInfo): PAnsiChar; cdecl;
	ILogonInfo_authBlockPtr = function(this: ILogonInfo; length: CardinalPtr): BytePtr; cdecl;
	ILogonInfo_attachmentPtr = function(this: ILogonInfo; status: IStatus): IAttachment; cdecl;
	ILogonInfo_transactionPtr = function(this: ILogonInfo; status: IStatus): ITransaction; cdecl;
	IManagement_startPtr = procedure(this: IManagement; status: IStatus; logonInfo: ILogonInfo); cdecl;
	IManagement_executePtr = function(this: IManagement; status: IStatus; user: IUser; callback: IListUsers): Integer; cdecl;
	IManagement_commitPtr = procedure(this: IManagement; status: IStatus); cdecl;
	IManagement_rollbackPtr = procedure(this: IManagement; status: IStatus); cdecl;
	IAuthBlock_getTypePtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getNamePtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getPluginPtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getSecurityDbPtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_getOriginalPluginPtr = function(this: IAuthBlock): PAnsiChar; cdecl;
	IAuthBlock_nextPtr = function(this: IAuthBlock; status: IStatus): Boolean; cdecl;
	IAuthBlock_firstPtr = function(this: IAuthBlock; status: IStatus): Boolean; cdecl;
	IWireCryptPlugin_getKnownTypesPtr = function(this: IWireCryptPlugin; status: IStatus): PAnsiChar; cdecl;
	IWireCryptPlugin_setKeyPtr = procedure(this: IWireCryptPlugin; status: IStatus; key: ICryptKey); cdecl;
	IWireCryptPlugin_encryptPtr = procedure(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IWireCryptPlugin_decryptPtr = procedure(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IWireCryptPlugin_getSpecificDataPtr = function(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr; cdecl;
	IWireCryptPlugin_setSpecificDataPtr = procedure(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr); cdecl;
	ICryptKeyCallback_callbackPtr = function(this: ICryptKeyCallback; dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; cdecl;
	IKeyHolderPlugin_keyCallbackPtr = function(this: IKeyHolderPlugin; status: IStatus; callback: ICryptKeyCallback): Integer; cdecl;
	IKeyHolderPlugin_keyHandlePtr = function(this: IKeyHolderPlugin; status: IStatus; keyName: PAnsiChar): ICryptKeyCallback; cdecl;
	IKeyHolderPlugin_useOnlyOwnKeysPtr = function(this: IKeyHolderPlugin; status: IStatus): Boolean; cdecl;
	IKeyHolderPlugin_chainHandlePtr = function(this: IKeyHolderPlugin; status: IStatus): ICryptKeyCallback; cdecl;
	IDbCryptInfo_getDatabaseFullPathPtr = function(this: IDbCryptInfo; status: IStatus): PAnsiChar; cdecl;
	IDbCryptPlugin_setKeyPtr = procedure(this: IDbCryptPlugin; status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar); cdecl;
	IDbCryptPlugin_encryptPtr = procedure(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IDbCryptPlugin_decryptPtr = procedure(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
	IDbCryptPlugin_setInfoPtr = procedure(this: IDbCryptPlugin; status: IStatus; info: IDbCryptInfo); cdecl;
	IExternalContext_getMasterPtr = function(this: IExternalContext): IMaster; cdecl;
	IExternalContext_getEnginePtr = function(this: IExternalContext; status: IStatus): IExternalEngine; cdecl;
	IExternalContext_getAttachmentPtr = function(this: IExternalContext; status: IStatus): IAttachment; cdecl;
	IExternalContext_getTransactionPtr = function(this: IExternalContext; status: IStatus): ITransaction; cdecl;
	IExternalContext_getUserNamePtr = function(this: IExternalContext): PAnsiChar; cdecl;
	IExternalContext_getDatabaseNamePtr = function(this: IExternalContext): PAnsiChar; cdecl;
	IExternalContext_getClientCharSetPtr = function(this: IExternalContext): PAnsiChar; cdecl;
	IExternalContext_obtainInfoCodePtr = function(this: IExternalContext): Integer; cdecl;
	IExternalContext_getInfoPtr = function(this: IExternalContext; code: Integer): Pointer; cdecl;
	IExternalContext_setInfoPtr = function(this: IExternalContext; code: Integer; value: Pointer): Pointer; cdecl;
	IExternalResultSet_fetchPtr = function(this: IExternalResultSet; status: IStatus): Boolean; cdecl;
	IExternalFunction_getCharSetPtr = procedure(this: IExternalFunction; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalFunction_executePtr = procedure(this: IExternalFunction; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer); cdecl;
	IExternalProcedure_getCharSetPtr = procedure(this: IExternalProcedure; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalProcedure_openPtr = function(this: IExternalProcedure; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet; cdecl;
	IExternalTrigger_getCharSetPtr = procedure(this: IExternalTrigger; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
	IExternalTrigger_executePtr = procedure(this: IExternalTrigger; status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); cdecl;
	IRoutineMetadata_getPackagePtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getNamePtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getEntryPointPtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getBodyPtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getInputMetadataPtr = function(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
	IRoutineMetadata_getOutputMetadataPtr = function(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
	IRoutineMetadata_getTriggerMetadataPtr = function(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
	IRoutineMetadata_getTriggerTablePtr = function(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
	IRoutineMetadata_getTriggerTypePtr = function(this: IRoutineMetadata; status: IStatus): Cardinal; cdecl;
	IExternalEngine_openPtr = procedure(this: IExternalEngine; status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal); cdecl;
	IExternalEngine_openAttachmentPtr = procedure(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
	IExternalEngine_closeAttachmentPtr = procedure(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
	IExternalEngine_makeFunctionPtr = function(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction; cdecl;
	IExternalEngine_makeProcedurePtr = function(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure; cdecl;
	IExternalEngine_makeTriggerPtr = function(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger; cdecl;
	ITimer_handlerPtr = procedure(this: ITimer); cdecl;
	ITimerControl_startPtr = procedure(this: ITimerControl; status: IStatus; timer: ITimer; microSeconds: QWord); cdecl;
	ITimerControl_stopPtr = procedure(this: ITimerControl; status: IStatus; timer: ITimer); cdecl;
	IVersionCallback_callbackPtr = procedure(this: IVersionCallback; status: IStatus; text: PAnsiChar); cdecl;
	IUtil_getFbVersionPtr = procedure(this: IUtil; status: IStatus; att: IAttachment; callback: IVersionCallback); cdecl;
	IUtil_loadBlobPtr = procedure(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
	IUtil_dumpBlobPtr = procedure(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
	IUtil_getPerfCountersPtr = procedure(this: IUtil; status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr); cdecl;
	IUtil_executeCreateDatabasePtr = function(this: IUtil; status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment; cdecl;
	IUtil_decodeDatePtr = procedure(this: IUtil; date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); cdecl;
	IUtil_decodeTimePtr = procedure(this: IUtil; time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); cdecl;
	IUtil_encodeDatePtr = function(this: IUtil; year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; cdecl;
	IUtil_encodeTimePtr = function(this: IUtil; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; cdecl;
	IUtil_formatStatusPtr = function(this: IUtil; buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal; cdecl;
	IUtil_getClientVersionPtr = function(this: IUtil): Cardinal; cdecl;
	IUtil_getXpbBuilderPtr = function(this: IUtil; status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder; cdecl;
	IUtil_setOffsetsPtr = function(this: IUtil; status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal; cdecl;
	IUtil_getDecFloat16Ptr = function(this: IUtil; status: IStatus): IDecFloat16; cdecl;
	IUtil_getDecFloat34Ptr = function(this: IUtil; status: IStatus): IDecFloat34; cdecl;
	IUtil_decodeTimeTzPtr = procedure(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_decodeTimeStampTzPtr = procedure(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_encodeTimeTzPtr = procedure(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
	IUtil_encodeTimeStampTzPtr = procedure(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
	IUtil_getInt128Ptr = function(this: IUtil; status: IStatus): IInt128; cdecl;
	IUtil_decodeTimeTzExPtr = procedure(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IUtil_decodeTimeStampTzExPtr = procedure(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
	IOffsetsCallback_setOffsetPtr = procedure(this: IOffsetsCallback; status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); cdecl;
	IXpbBuilder_clearPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_removeCurrentPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_insertIntPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; value: Integer); cdecl;
	IXpbBuilder_insertBigIntPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; value: Int64); cdecl;
	IXpbBuilder_insertBytesPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal); cdecl;
	IXpbBuilder_insertStringPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte; str: PAnsiChar); cdecl;
	IXpbBuilder_insertTagPtr = procedure(this: IXpbBuilder; status: IStatus; tag: Byte); cdecl;
	IXpbBuilder_isEofPtr = function(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
	IXpbBuilder_moveNextPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_rewindPtr = procedure(this: IXpbBuilder; status: IStatus); cdecl;
	IXpbBuilder_findFirstPtr = function(this: IXpbBuilder; status: IStatus; tag: Byte): Boolean; cdecl;
	IXpbBuilder_findNextPtr = function(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
	IXpbBuilder_getTagPtr = function(this: IXpbBuilder; status: IStatus): Byte; cdecl;
	IXpbBuilder_getLengthPtr = function(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
	IXpbBuilder_getIntPtr = function(this: IXpbBuilder; status: IStatus): Integer; cdecl;
	IXpbBuilder_getBigIntPtr = function(this: IXpbBuilder; status: IStatus): Int64; cdecl;
	IXpbBuilder_getStringPtr = function(this: IXpbBuilder; status: IStatus): PAnsiChar; cdecl;
	IXpbBuilder_getBytesPtr = function(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
	IXpbBuilder_getBufferLengthPtr = function(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
	IXpbBuilder_getBufferPtr = function(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
	ITraceConnection_getKindPtr = function(this: ITraceConnection): Cardinal; cdecl;
	ITraceConnection_getProcessIDPtr = function(this: ITraceConnection): Integer; cdecl;
	ITraceConnection_getUserNamePtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRoleNamePtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getCharSetPtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRemoteProtocolPtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRemoteAddressPtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceConnection_getRemoteProcessIDPtr = function(this: ITraceConnection): Integer; cdecl;
	ITraceConnection_getRemoteProcessNamePtr = function(this: ITraceConnection): PAnsiChar; cdecl;
	ITraceDatabaseConnection_getConnectionIDPtr = function(this: ITraceDatabaseConnection): Int64; cdecl;
	ITraceDatabaseConnection_getDatabaseNamePtr = function(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
	ITraceTransaction_getTransactionIDPtr = function(this: ITraceTransaction): Int64; cdecl;
	ITraceTransaction_getReadOnlyPtr = function(this: ITraceTransaction): Boolean; cdecl;
	ITraceTransaction_getWaitPtr = function(this: ITraceTransaction): Integer; cdecl;
	ITraceTransaction_getIsolationPtr = function(this: ITraceTransaction): Cardinal; cdecl;
	ITraceTransaction_getPerfPtr = function(this: ITraceTransaction): PerformanceInfoPtr; cdecl;
	ITraceTransaction_getInitialIDPtr = function(this: ITraceTransaction): Int64; cdecl;
	ITraceTransaction_getPreviousIDPtr = function(this: ITraceTransaction): Int64; cdecl;
	ITraceParams_getCountPtr = function(this: ITraceParams): Cardinal; cdecl;
	ITraceParams_getParamPtr = function(this: ITraceParams; idx: Cardinal): dscPtr; cdecl;
	ITraceParams_getTextUTF8Ptr = function(this: ITraceParams; status: IStatus; idx: Cardinal): PAnsiChar; cdecl;
	ITraceStatement_getStmtIDPtr = function(this: ITraceStatement): Int64; cdecl;
	ITraceStatement_getPerfPtr = function(this: ITraceStatement): PerformanceInfoPtr; cdecl;
	ITraceSQLStatement_getTextPtr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceSQLStatement_getPlanPtr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceSQLStatement_getInputsPtr = function(this: ITraceSQLStatement): ITraceParams; cdecl;
	ITraceSQLStatement_getTextUTF8Ptr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceSQLStatement_getExplainedPlanPtr = function(this: ITraceSQLStatement): PAnsiChar; cdecl;
	ITraceBLRStatement_getDataPtr = function(this: ITraceBLRStatement): BytePtr; cdecl;
	ITraceBLRStatement_getDataLengthPtr = function(this: ITraceBLRStatement): Cardinal; cdecl;
	ITraceBLRStatement_getTextPtr = function(this: ITraceBLRStatement): PAnsiChar; cdecl;
	ITraceDYNRequest_getDataPtr = function(this: ITraceDYNRequest): BytePtr; cdecl;
	ITraceDYNRequest_getDataLengthPtr = function(this: ITraceDYNRequest): Cardinal; cdecl;
	ITraceDYNRequest_getTextPtr = function(this: ITraceDYNRequest): PAnsiChar; cdecl;
	ITraceContextVariable_getNameSpacePtr = function(this: ITraceContextVariable): PAnsiChar; cdecl;
	ITraceContextVariable_getVarNamePtr = function(this: ITraceContextVariable): PAnsiChar; cdecl;
	ITraceContextVariable_getVarValuePtr = function(this: ITraceContextVariable): PAnsiChar; cdecl;
	ITraceProcedure_getProcNamePtr = function(this: ITraceProcedure): PAnsiChar; cdecl;
	ITraceProcedure_getInputsPtr = function(this: ITraceProcedure): ITraceParams; cdecl;
	ITraceProcedure_getPerfPtr = function(this: ITraceProcedure): PerformanceInfoPtr; cdecl;
	ITraceFunction_getFuncNamePtr = function(this: ITraceFunction): PAnsiChar; cdecl;
	ITraceFunction_getInputsPtr = function(this: ITraceFunction): ITraceParams; cdecl;
	ITraceFunction_getResultPtr = function(this: ITraceFunction): ITraceParams; cdecl;
	ITraceFunction_getPerfPtr = function(this: ITraceFunction): PerformanceInfoPtr; cdecl;
	ITraceTrigger_getTriggerNamePtr = function(this: ITraceTrigger): PAnsiChar; cdecl;
	ITraceTrigger_getRelationNamePtr = function(this: ITraceTrigger): PAnsiChar; cdecl;
	ITraceTrigger_getActionPtr = function(this: ITraceTrigger): Integer; cdecl;
	ITraceTrigger_getWhichPtr = function(this: ITraceTrigger): Integer; cdecl;
	ITraceTrigger_getPerfPtr = function(this: ITraceTrigger): PerformanceInfoPtr; cdecl;
	ITraceServiceConnection_getServiceIDPtr = function(this: ITraceServiceConnection): Pointer; cdecl;
	ITraceServiceConnection_getServiceMgrPtr = function(this: ITraceServiceConnection): PAnsiChar; cdecl;
	ITraceServiceConnection_getServiceNamePtr = function(this: ITraceServiceConnection): PAnsiChar; cdecl;
	ITraceStatusVector_hasErrorPtr = function(this: ITraceStatusVector): Boolean; cdecl;
	ITraceStatusVector_hasWarningPtr = function(this: ITraceStatusVector): Boolean; cdecl;
	ITraceStatusVector_getStatusPtr = function(this: ITraceStatusVector): IStatus; cdecl;
	ITraceStatusVector_getTextPtr = function(this: ITraceStatusVector): PAnsiChar; cdecl;
	ITraceSweepInfo_getOITPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getOSTPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getOATPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getNextPtr = function(this: ITraceSweepInfo): Int64; cdecl;
	ITraceSweepInfo_getPerfPtr = function(this: ITraceSweepInfo): PerformanceInfoPtr; cdecl;
	ITraceLogWriter_writePtr = function(this: ITraceLogWriter; buf: Pointer; size: Cardinal): Cardinal; cdecl;
	ITraceLogWriter_write_sPtr = function(this: ITraceLogWriter; status: IStatus; buf: Pointer; size: Cardinal): Cardinal; cdecl;
	ITraceInitInfo_getConfigTextPtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getTraceSessionIDPtr = function(this: ITraceInitInfo): Integer; cdecl;
	ITraceInitInfo_getTraceSessionNamePtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getFirebirdRootDirectoryPtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getDatabaseNamePtr = function(this: ITraceInitInfo): PAnsiChar; cdecl;
	ITraceInitInfo_getConnectionPtr = function(this: ITraceInitInfo): ITraceDatabaseConnection; cdecl;
	ITraceInitInfo_getLogWriterPtr = function(this: ITraceInitInfo): ITraceLogWriter; cdecl;
	ITracePlugin_trace_get_errorPtr = function(this: ITracePlugin): PAnsiChar; cdecl;
	ITracePlugin_trace_attachPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_detachPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean; cdecl;
	ITracePlugin_trace_transaction_startPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_transaction_endPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_proc_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_trigger_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_set_contextPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean; cdecl;
	ITracePlugin_trace_dsql_preparePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dsql_freePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dsql_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_blr_compilePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_blr_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_dyn_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_attachPtr = function(this: ITracePlugin; service: ITraceServiceConnection; att_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_startPtr = function(this: ITracePlugin; service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_queryPtr = function(this: ITracePlugin; service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_service_detachPtr = function(this: ITracePlugin; service: ITraceServiceConnection; detach_result: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_event_errorPtr = function(this: ITracePlugin; connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean; cdecl;
	ITracePlugin_trace_event_sweepPtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean; cdecl;
	ITracePlugin_trace_func_executePtr = function(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean; cdecl;
	ITraceFactory_trace_needsPtr = function(this: ITraceFactory): QWord; cdecl;
	ITraceFactory_trace_createPtr = function(this: ITraceFactory; status: IStatus; init_info: ITraceInitInfo): ITracePlugin; cdecl;
	IUdrFunctionFactory_setupPtr = procedure(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
	IUdrFunctionFactory_newItemPtr = function(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction; cdecl;
	IUdrProcedureFactory_setupPtr = procedure(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
	IUdrProcedureFactory_newItemPtr = function(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure; cdecl;
	IUdrTriggerFactory_setupPtr = procedure(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder); cdecl;
	IUdrTriggerFactory_newItemPtr = function(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger; cdecl;
	IUdrPlugin_getMasterPtr = function(this: IUdrPlugin): IMaster; cdecl;
	IUdrPlugin_registerFunctionPtr = procedure(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory); cdecl;
	IUdrPlugin_registerProcedurePtr = procedure(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory); cdecl;
	IUdrPlugin_registerTriggerPtr = procedure(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory); cdecl;
	IDecFloat16_toBcdPtr = procedure(this: IDecFloat16; from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
	IDecFloat16_toStringPtr = procedure(this: IDecFloat16; status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IDecFloat16_fromBcdPtr = procedure(this: IDecFloat16; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); cdecl;
	IDecFloat16_fromStringPtr = procedure(this: IDecFloat16; status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr); cdecl;
	IDecFloat34_toBcdPtr = procedure(this: IDecFloat34; from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
	IDecFloat34_toStringPtr = procedure(this: IDecFloat34; status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IDecFloat34_fromBcdPtr = procedure(this: IDecFloat34; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); cdecl;
	IDecFloat34_fromStringPtr = procedure(this: IDecFloat34; status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr); cdecl;
	IInt128_toStringPtr = procedure(this: IInt128; status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
	IInt128_fromStringPtr = procedure(this: IInt128; status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); cdecl;
	IReplicatedField_getNamePtr = function(this: IReplicatedField): PAnsiChar; cdecl;
	IReplicatedField_getTypePtr = function(this: IReplicatedField): Cardinal; cdecl;
	IReplicatedField_getSubTypePtr = function(this: IReplicatedField): Integer; cdecl;
	IReplicatedField_getScalePtr = function(this: IReplicatedField): Integer; cdecl;
	IReplicatedField_getLengthPtr = function(this: IReplicatedField): Cardinal; cdecl;
	IReplicatedField_getCharSetPtr = function(this: IReplicatedField): Cardinal; cdecl;
	IReplicatedField_getDataPtr = function(this: IReplicatedField): Pointer; cdecl;
	IReplicatedRecord_getCountPtr = function(this: IReplicatedRecord): Cardinal; cdecl;
	IReplicatedRecord_getFieldPtr = function(this: IReplicatedRecord; index: Cardinal): IReplicatedField; cdecl;
	IReplicatedRecord_getRawLengthPtr = function(this: IReplicatedRecord): Cardinal; cdecl;
	IReplicatedRecord_getRawDataPtr = function(this: IReplicatedRecord): BytePtr; cdecl;
	IReplicatedTransaction_preparePtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_commitPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_rollbackPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_startSavepointPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_releaseSavepointPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_rollbackSavepointPtr = procedure(this: IReplicatedTransaction; status: IStatus); cdecl;
	IReplicatedTransaction_insertRecordPtr = procedure(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
	IReplicatedTransaction_updateRecordPtr = procedure(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord); cdecl;
	IReplicatedTransaction_deleteRecordPtr = procedure(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
	IReplicatedTransaction_executeSqlPtr = procedure(this: IReplicatedTransaction; status: IStatus; sql: PAnsiChar); cdecl;
	IReplicatedTransaction_executeSqlIntlPtr = procedure(this: IReplicatedTransaction; status: IStatus; charset: Cardinal; sql: PAnsiChar); cdecl;
	IReplicatedSession_initPtr = function(this: IReplicatedSession; status: IStatus; attachment: IAttachment): Boolean; cdecl;
	IReplicatedSession_startTransactionPtr = function(this: IReplicatedSession; status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction; cdecl;
	IReplicatedSession_cleanupTransactionPtr = procedure(this: IReplicatedSession; status: IStatus; number: Int64); cdecl;
	IReplicatedSession_setSequencePtr = procedure(this: IReplicatedSession; status: IStatus; name: PAnsiChar; value: Int64); cdecl;

	PVersionedVTable = ^VersionedVTable;
	VersionedVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	end;

	IVersionedImpl = class;

	TVersioned = record
	private
	  nullPtr: pointer;
	  vTable: PVersionedVTable;
	  owner: IVersionedImpl; {Only valid if isIVersionedImpl returns true }
	  function thisRecord: IVersioned inline;
	public
	  function isIVersionedImpl: boolean;
	  function getIVersionedImpl: IVersionedImpl;
	  function getvTableVersion: NativeInt inline;
	end;

	IVersionedImpl = class
	protected
	  nullPtr: pointer;
	  vTable: pointer;
	  owner: TObject;
	public
	  const VERSION = 0;
	public
	  constructor create;
	  function getInterface: IVersioned;
	  function getvTableVersion: NativeInt virtual;
	end;

	PReferenceCountedVTable = ^ReferenceCountedVTable;
	ReferenceCountedVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	end;

	IReferenceCountedImpl = class;

	TReferenceCounted = record
	private
	  nullPtr: pointer;
	  vTable: PReferenceCountedVTable;
	  owner: IReferenceCountedImpl; {Only valid if isIReferenceCountedImpl returns true }
	  function thisRecord: IReferenceCounted inline;
	public
	  function isIReferenceCountedImpl: boolean;
	  function getIReferenceCountedImpl: IReferenceCountedImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	end;

	IReferenceCountedImpl = class(IVersionedImpl)
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function getInterface: IReferenceCounted;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure addRef(); virtual; abstract;
	  function release(): Integer; virtual; abstract;
	end;

	PDisposableVTable = ^DisposableVTable;
	DisposableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	end;

	IDisposableImpl = class;

	TDisposable = record
	private
	  nullPtr: pointer;
	  vTable: PDisposableVTable;
	  owner: IDisposableImpl; {Only valid if isIDisposableImpl returns true }
	  function thisRecord: IDisposable inline;
	public
	  function isIDisposableImpl: boolean;
	  function getIDisposableImpl: IDisposableImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	end;

	IDisposableImpl = class(IVersionedImpl)
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function getInterface: IDisposable;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure dispose(); virtual; abstract;
	end;

	PStatusVTable = ^StatusVTable;
	StatusVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  init: IStatus_initPtr;
	  getState: IStatus_getStatePtr;
	  setErrors2: IStatus_setErrors2Ptr;
	  setWarnings2: IStatus_setWarnings2Ptr;
	  setErrors: IStatus_setErrorsPtr;
	  setWarnings: IStatus_setWarningsPtr;
	  getErrors: IStatus_getErrorsPtr;
	  getWarnings: IStatus_getWarningsPtr;
	  clone: IStatus_clonePtr;
	end;

	IStatusImpl = class;

	TStatus = record
	private
	  nullPtr: pointer;
	  vTable: PStatusVTable;
	  owner: IStatusImpl; {Only valid if isIStatusImpl returns true }
	  function thisRecord: IStatus inline;
	public
	  function isIStatusImpl: boolean;
	  function getIStatusImpl: IStatusImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure init();
	  function getState(): Cardinal;
	  procedure setErrors2(length: Cardinal; value: NativeIntPtr);
	  procedure setWarnings2(length: Cardinal; value: NativeIntPtr);
	  procedure setErrors(value: NativeIntPtr);
	  procedure setWarnings(value: NativeIntPtr);
	  function getErrors(): NativeIntPtr;
	  function getWarnings(): NativeIntPtr;
	  function clone(): IStatus;
	end;

	IStatusImpl = class(IDisposableImpl)
	public
	  const VERSION = 10;
	  const STATE_WARNINGS = Cardinal($1);
	  const STATE_ERRORS = Cardinal($2);
	  const RESULT_ERROR = Integer(-1);
	  const RESULT_OK = Integer(0);
	  const RESULT_NO_DATA = Integer(1);
	  const RESULT_SEGMENT = Integer(2);
	public
	  constructor create;
	  function getInterface: IStatus;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure init(); virtual; abstract;
	  function getState(): Cardinal; virtual; abstract;
	  procedure setErrors2(length: Cardinal; value: NativeIntPtr); virtual; abstract;
	  procedure setWarnings2(length: Cardinal; value: NativeIntPtr); virtual; abstract;
	  procedure setErrors(value: NativeIntPtr); virtual; abstract;
	  procedure setWarnings(value: NativeIntPtr); virtual; abstract;
	  function getErrors(): NativeIntPtr; virtual; abstract;
	  function getWarnings(): NativeIntPtr; virtual; abstract;
	  function clone(): IStatus; virtual; abstract;
	end;

	PMasterVTable = ^MasterVTable;
	MasterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStatus: IMaster_getStatusPtr;
	  getDispatcher: IMaster_getDispatcherPtr;
	  getPluginManager: IMaster_getPluginManagerPtr;
	  getTimerControl: IMaster_getTimerControlPtr;
	  getDtc: IMaster_getDtcPtr;
	  registerAttachment: IMaster_registerAttachmentPtr;
	  registerTransaction: IMaster_registerTransactionPtr;
	  getMetadataBuilder: IMaster_getMetadataBuilderPtr;
	  serverMode: IMaster_serverModePtr;
	  getUtilInterface: IMaster_getUtilInterfacePtr;
	  getConfigManager: IMaster_getConfigManagerPtr;
	  getProcessExiting: IMaster_getProcessExitingPtr;
	end;

	IMasterImpl = class;

	TMaster = record
	private
	  nullPtr: pointer;
	  vTable: PMasterVTable;
	  owner: IMasterImpl; {Only valid if isIMasterImpl returns true }
	  function thisRecord: IMaster inline;
	public
	  function isIMasterImpl: boolean;
	  function getIMasterImpl: IMasterImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getStatus(): IStatus;
	  function getDispatcher(): IProvider;
	  function getPluginManager(): IPluginManager;
	  function getTimerControl(): ITimerControl;
	  function getDtc(): IDtc;
	  function registerAttachment(provider: IProvider; attachment: IAttachment): IAttachment;
	  function registerTransaction(attachment: IAttachment; transaction: ITransaction): ITransaction;
	  function getMetadataBuilder(status: IStatus; fieldCount: Cardinal): IMetadataBuilder;
	  function serverMode(mode: Integer): Integer;
	  function getUtilInterface(): IUtil;
	  function getConfigManager(): IConfigManager;
	  function getProcessExiting(): Boolean;
	end;

	IMasterImpl = class(IVersionedImpl)
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function getInterface: IMaster;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getStatus(): IStatus; virtual; abstract;
	  function getDispatcher(): IProvider; virtual; abstract;
	  function getPluginManager(): IPluginManager; virtual; abstract;
	  function getTimerControl(): ITimerControl; virtual; abstract;
	  function getDtc(): IDtc; virtual; abstract;
	  function registerAttachment(provider: IProvider; attachment: IAttachment): IAttachment; virtual; abstract;
	  function registerTransaction(attachment: IAttachment; transaction: ITransaction): ITransaction; virtual; abstract;
	  function getMetadataBuilder(status: IStatus; fieldCount: Cardinal): IMetadataBuilder; virtual; abstract;
	  function serverMode(mode: Integer): Integer; virtual; abstract;
	  function getUtilInterface(): IUtil; virtual; abstract;
	  function getConfigManager(): IConfigManager; virtual; abstract;
	  function getProcessExiting(): Boolean; virtual; abstract;
	end;

	PPluginBaseVTable = ^PluginBaseVTable;
	PluginBaseVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	end;

	IPluginBaseImpl = class;

	TPluginBase = record
	private
	  nullPtr: pointer;
	  vTable: PPluginBaseVTable;
	  owner: IPluginBaseImpl; {Only valid if isIPluginBaseImpl returns true }
	  function thisRecord: IPluginBase inline;
	public
	  function isIPluginBaseImpl: boolean;
	  function getIPluginBaseImpl: IPluginBaseImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	end;

	IPluginBaseImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IPluginBase;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setOwner(r: IReferenceCounted); virtual; abstract;
	  function getOwner(): IReferenceCounted; virtual; abstract;
	end;

	PPluginSetVTable = ^PluginSetVTable;
	PluginSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getName: IPluginSet_getNamePtr;
	  getModuleName: IPluginSet_getModuleNamePtr;
	  getPlugin: IPluginSet_getPluginPtr;
	  next: IPluginSet_nextPtr;
	  set_: IPluginSet_set_Ptr;
	end;

	IPluginSetImpl = class;

	TPluginSet = record
	private
	  nullPtr: pointer;
	  vTable: PPluginSetVTable;
	  owner: IPluginSetImpl; {Only valid if isIPluginSetImpl returns true }
	  function thisRecord: IPluginSet inline;
	public
	  function isIPluginSetImpl: boolean;
	  function getIPluginSetImpl: IPluginSetImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getName(): PAnsiChar;
	  function getModuleName(): PAnsiChar;
	  function getPlugin(status: IStatus): IPluginBase;
	  procedure next(status: IStatus);
	  procedure set_(status: IStatus; s: PAnsiChar);
	end;

	IPluginSetImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: IPluginSet;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getName(): PAnsiChar; virtual; abstract;
	  function getModuleName(): PAnsiChar; virtual; abstract;
	  function getPlugin(status: IStatus): IPluginBase; virtual; abstract;
	  procedure next(status: IStatus); virtual; abstract;
	  procedure set_(status: IStatus; s: PAnsiChar); virtual; abstract;
	end;

	PConfigEntryVTable = ^ConfigEntryVTable;
	ConfigEntryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getName: IConfigEntry_getNamePtr;
	  getValue: IConfigEntry_getValuePtr;
	  getIntValue: IConfigEntry_getIntValuePtr;
	  getBoolValue: IConfigEntry_getBoolValuePtr;
	  getSubConfig: IConfigEntry_getSubConfigPtr;
	end;

	IConfigEntryImpl = class;

	TConfigEntry = record
	private
	  nullPtr: pointer;
	  vTable: PConfigEntryVTable;
	  owner: IConfigEntryImpl; {Only valid if isIConfigEntryImpl returns true }
	  function thisRecord: IConfigEntry inline;
	public
	  function isIConfigEntryImpl: boolean;
	  function getIConfigEntryImpl: IConfigEntryImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getName(): PAnsiChar;
	  function getValue(): PAnsiChar;
	  function getIntValue(): Int64;
	  function getBoolValue(): Boolean;
	  function getSubConfig(status: IStatus): IConfig;
	end;

	IConfigEntryImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: IConfigEntry;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getName(): PAnsiChar; virtual; abstract;
	  function getValue(): PAnsiChar; virtual; abstract;
	  function getIntValue(): Int64; virtual; abstract;
	  function getBoolValue(): Boolean; virtual; abstract;
	  function getSubConfig(status: IStatus): IConfig; virtual; abstract;
	end;

	PConfigVTable = ^ConfigVTable;
	ConfigVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  find: IConfig_findPtr;
	  findValue: IConfig_findValuePtr;
	  findPos: IConfig_findPosPtr;
	end;

	IConfigImpl = class;

	TConfig = record
	private
	  nullPtr: pointer;
	  vTable: PConfigVTable;
	  owner: IConfigImpl; {Only valid if isIConfigImpl returns true }
	  function thisRecord: IConfig inline;
	public
	  function isIConfigImpl: boolean;
	  function getIConfigImpl: IConfigImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function find(status: IStatus; name: PAnsiChar): IConfigEntry;
	  function findValue(status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry;
	  function findPos(status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry;
	end;

	IConfigImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: IConfig;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function find(status: IStatus; name: PAnsiChar): IConfigEntry; virtual; abstract;
	  function findValue(status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry; virtual; abstract;
	  function findPos(status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry; virtual; abstract;
	end;

	PFirebirdConfVTable = ^FirebirdConfVTable;
	FirebirdConfVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getKey: IFirebirdConf_getKeyPtr;
	  asInteger: IFirebirdConf_asIntegerPtr;
	  asString: IFirebirdConf_asStringPtr;
	  asBoolean: IFirebirdConf_asBooleanPtr;
	  getVersion: IFirebirdConf_getVersionPtr;
	end;

	IFirebirdConfImpl = class;

	TFirebirdConf = record
	private
	  nullPtr: pointer;
	  vTable: PFirebirdConfVTable;
	  owner: IFirebirdConfImpl; {Only valid if isIFirebirdConfImpl returns true }
	  function thisRecord: IFirebirdConf inline;
	public
	  function isIFirebirdConfImpl: boolean;
	  function getIFirebirdConfImpl: IFirebirdConfImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getKey(name: PAnsiChar): Cardinal;
	  function asInteger(key: Cardinal): Int64;
	  function asString(key: Cardinal): PAnsiChar;
	  function asBoolean(key: Cardinal): Boolean;
	  function getVersion(status: IStatus): Cardinal;
	end;

	IFirebirdConfImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: IFirebirdConf;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getKey(name: PAnsiChar): Cardinal; virtual; abstract;
	  function asInteger(key: Cardinal): Int64; virtual; abstract;
	  function asString(key: Cardinal): PAnsiChar; virtual; abstract;
	  function asBoolean(key: Cardinal): Boolean; virtual; abstract;
	  function getVersion(status: IStatus): Cardinal; virtual; abstract;
	end;

	PPluginConfigVTable = ^PluginConfigVTable;
	PluginConfigVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getConfigFileName: IPluginConfig_getConfigFileNamePtr;
	  getDefaultConfig: IPluginConfig_getDefaultConfigPtr;
	  getFirebirdConf: IPluginConfig_getFirebirdConfPtr;
	  setReleaseDelay: IPluginConfig_setReleaseDelayPtr;
	end;

	IPluginConfigImpl = class;

	TPluginConfig = record
	private
	  nullPtr: pointer;
	  vTable: PPluginConfigVTable;
	  owner: IPluginConfigImpl; {Only valid if isIPluginConfigImpl returns true }
	  function thisRecord: IPluginConfig inline;
	public
	  function isIPluginConfigImpl: boolean;
	  function getIPluginConfigImpl: IPluginConfigImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getConfigFileName(): PAnsiChar;
	  function getDefaultConfig(status: IStatus): IConfig;
	  function getFirebirdConf(status: IStatus): IFirebirdConf;
	  procedure setReleaseDelay(status: IStatus; microSeconds: QWord);
	end;

	IPluginConfigImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 6;
	public
	  constructor create;
	  function getInterface: IPluginConfig;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getConfigFileName(): PAnsiChar; virtual; abstract;
	  function getDefaultConfig(status: IStatus): IConfig; virtual; abstract;
	  function getFirebirdConf(status: IStatus): IFirebirdConf; virtual; abstract;
	  procedure setReleaseDelay(status: IStatus; microSeconds: QWord); virtual; abstract;
	end;

	PPluginFactoryVTable = ^PluginFactoryVTable;
	PluginFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  createPlugin: IPluginFactory_createPluginPtr;
	end;

	IPluginFactoryImpl = class;

	TPluginFactory = record
	private
	  nullPtr: pointer;
	  vTable: PPluginFactoryVTable;
	  owner: IPluginFactoryImpl; {Only valid if isIPluginFactoryImpl returns true }
	  function thisRecord: IPluginFactory inline;
	public
	  function isIPluginFactoryImpl: boolean;
	  function getIPluginFactoryImpl: IPluginFactoryImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function createPlugin(status: IStatus; factoryParameter: IPluginConfig): IPluginBase;
	end;

	IPluginFactoryImpl = class(IVersionedImpl)
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function getInterface: IPluginFactory;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function createPlugin(status: IStatus; factoryParameter: IPluginConfig): IPluginBase; virtual; abstract;
	end;

	PPluginModuleVTable = ^PluginModuleVTable;
	PluginModuleVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  doClean: IPluginModule_doCleanPtr;
	  threadDetach: IPluginModule_threadDetachPtr;
	end;

	IPluginModuleImpl = class;

	TPluginModule = record
	private
	  nullPtr: pointer;
	  vTable: PPluginModuleVTable;
	  owner: IPluginModuleImpl; {Only valid if isIPluginModuleImpl returns true }
	  function thisRecord: IPluginModule inline;
	public
	  function isIPluginModuleImpl: boolean;
	  function getIPluginModuleImpl: IPluginModuleImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure doClean();
	  procedure threadDetach();
	end;

	IPluginModuleImpl = class(IVersionedImpl)
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function getInterface: IPluginModule;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure doClean(); virtual; abstract;
	  procedure threadDetach(); virtual; abstract;
	end;

	PPluginManagerVTable = ^PluginManagerVTable;
	PluginManagerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  registerPluginFactory: IPluginManager_registerPluginFactoryPtr;
	  registerModule: IPluginManager_registerModulePtr;
	  unregisterModule: IPluginManager_unregisterModulePtr;
	  getPlugins: IPluginManager_getPluginsPtr;
	  getConfig: IPluginManager_getConfigPtr;
	  releasePlugin: IPluginManager_releasePluginPtr;
	end;

	IPluginManagerImpl = class;

	TPluginManager = record
	private
	  nullPtr: pointer;
	  vTable: PPluginManagerVTable;
	  owner: IPluginManagerImpl; {Only valid if isIPluginManagerImpl returns true }
	  function thisRecord: IPluginManager inline;
	public
	  function isIPluginManagerImpl: boolean;
	  function getIPluginManagerImpl: IPluginManagerImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory);
	  procedure registerModule(cleanup: IPluginModule);
	  procedure unregisterModule(cleanup: IPluginModule);
	  function getPlugins(status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet;
	  function getConfig(status: IStatus; filename: PAnsiChar): IConfig;
	  procedure releasePlugin(plugin: IPluginBase);
	end;

	IPluginManagerImpl = class(IVersionedImpl)
	public
	  const VERSION = 6;
	  const TYPE_PROVIDER = Cardinal(1);
	  const TYPE_FIRST_NON_LIB = Cardinal(2);
	  const TYPE_AUTH_SERVER = Cardinal(3);
	  const TYPE_AUTH_CLIENT = Cardinal(4);
	  const TYPE_AUTH_USER_MANAGEMENT = Cardinal(5);
	  const TYPE_EXTERNAL_ENGINE = Cardinal(6);
	  const TYPE_TRACE = Cardinal(7);
	  const TYPE_WIRE_CRYPT = Cardinal(8);
	  const TYPE_DB_CRYPT = Cardinal(9);
	  const TYPE_KEY_HOLDER = Cardinal(10);
	  const TYPE_REPLICATOR = Cardinal(11);
	  const TYPE_COUNT = Cardinal(12);
	public
	  constructor create;
	  function getInterface: IPluginManager;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory); virtual; abstract;
	  procedure registerModule(cleanup: IPluginModule); virtual; abstract;
	  procedure unregisterModule(cleanup: IPluginModule); virtual; abstract;
	  function getPlugins(status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet; virtual; abstract;
	  function getConfig(status: IStatus; filename: PAnsiChar): IConfig; virtual; abstract;
	  procedure releasePlugin(plugin: IPluginBase); virtual; abstract;
	end;

	PCryptKeyVTable = ^CryptKeyVTable;
	CryptKeyVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  setSymmetric: ICryptKey_setSymmetricPtr;
	  setAsymmetric: ICryptKey_setAsymmetricPtr;
	  getEncryptKey: ICryptKey_getEncryptKeyPtr;
	  getDecryptKey: ICryptKey_getDecryptKeyPtr;
	end;

	ICryptKeyImpl = class;

	TCryptKey = record
	private
	  nullPtr: pointer;
	  vTable: PCryptKeyVTable;
	  owner: ICryptKeyImpl; {Only valid if isICryptKeyImpl returns true }
	  function thisRecord: ICryptKey inline;
	public
	  function isICryptKeyImpl: boolean;
	  function getICryptKeyImpl: ICryptKeyImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure setSymmetric(status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer);
	  procedure setAsymmetric(status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer);
	  function getEncryptKey(length: CardinalPtr): Pointer;
	  function getDecryptKey(length: CardinalPtr): Pointer;
	end;

	ICryptKeyImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: ICryptKey;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setSymmetric(status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); virtual; abstract;
	  procedure setAsymmetric(status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); virtual; abstract;
	  function getEncryptKey(length: CardinalPtr): Pointer; virtual; abstract;
	  function getDecryptKey(length: CardinalPtr): Pointer; virtual; abstract;
	end;

	PConfigManagerVTable = ^ConfigManagerVTable;
	ConfigManagerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getDirectory: IConfigManager_getDirectoryPtr;
	  getFirebirdConf: IConfigManager_getFirebirdConfPtr;
	  getDatabaseConf: IConfigManager_getDatabaseConfPtr;
	  getPluginConfig: IConfigManager_getPluginConfigPtr;
	  getInstallDirectory: IConfigManager_getInstallDirectoryPtr;
	  getRootDirectory: IConfigManager_getRootDirectoryPtr;
	  getDefaultSecurityDb: IConfigManager_getDefaultSecurityDbPtr;
	end;

	IConfigManagerImpl = class;

	TConfigManager = record
	private
	  nullPtr: pointer;
	  vTable: PConfigManagerVTable;
	  owner: IConfigManagerImpl; {Only valid if isIConfigManagerImpl returns true }
	  function thisRecord: IConfigManager inline;
	public
	  function isIConfigManagerImpl: boolean;
	  function getIConfigManagerImpl: IConfigManagerImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getDirectory(code: Cardinal): PAnsiChar;
	  function getFirebirdConf(): IFirebirdConf;
	  function getDatabaseConf(dbName: PAnsiChar): IFirebirdConf;
	  function getPluginConfig(configuredPlugin: PAnsiChar): IConfig;
	  function getInstallDirectory(): PAnsiChar;
	  function getRootDirectory(): PAnsiChar;
	  function getDefaultSecurityDb(): PAnsiChar;
	end;

	IConfigManagerImpl = class(IVersionedImpl)
	public
	  const VERSION = 7;
	  const DIR_BIN = Cardinal(0);
	  const DIR_SBIN = Cardinal(1);
	  const DIR_CONF = Cardinal(2);
	  const DIR_LIB = Cardinal(3);
	  const DIR_INC = Cardinal(4);
	  const DIR_DOC = Cardinal(5);
	  const DIR_UDF = Cardinal(6);
	  const DIR_SAMPLE = Cardinal(7);
	  const DIR_SAMPLEDB = Cardinal(8);
	  const DIR_HELP = Cardinal(9);
	  const DIR_INTL = Cardinal(10);
	  const DIR_MISC = Cardinal(11);
	  const DIR_SECDB = Cardinal(12);
	  const DIR_MSG = Cardinal(13);
	  const DIR_LOG = Cardinal(14);
	  const DIR_GUARD = Cardinal(15);
	  const DIR_PLUGINS = Cardinal(16);
	  const DIR_TZDATA = Cardinal(17);
	  const DIR_COUNT = Cardinal(18);
	public
	  constructor create;
	  function getInterface: IConfigManager;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getDirectory(code: Cardinal): PAnsiChar; virtual; abstract;
	  function getFirebirdConf(): IFirebirdConf; virtual; abstract;
	  function getDatabaseConf(dbName: PAnsiChar): IFirebirdConf; virtual; abstract;
	  function getPluginConfig(configuredPlugin: PAnsiChar): IConfig; virtual; abstract;
	  function getInstallDirectory(): PAnsiChar; virtual; abstract;
	  function getRootDirectory(): PAnsiChar; virtual; abstract;
	  function getDefaultSecurityDb(): PAnsiChar; virtual; abstract;
	end;

	PEventCallbackVTable = ^EventCallbackVTable;
	EventCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  eventCallbackFunction: IEventCallback_eventCallbackFunctionPtr;
	end;

	IEventCallbackImpl = class;

	TEventCallback = record
	private
	  nullPtr: pointer;
	  vTable: PEventCallbackVTable;
	  owner: IEventCallbackImpl; {Only valid if isIEventCallbackImpl returns true }
	  function thisRecord: IEventCallback inline;
	public
	  function isIEventCallbackImpl: boolean;
	  function getIEventCallbackImpl: IEventCallbackImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure eventCallbackFunction(length: Cardinal; events: BytePtr);
	end;

	IEventCallbackImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IEventCallback;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure eventCallbackFunction(length: Cardinal; events: BytePtr); virtual; abstract;
	end;

	PBlobVTable = ^BlobVTable;
	BlobVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IBlob_getInfoPtr;
	  getSegment: IBlob_getSegmentPtr;
	  putSegment: IBlob_putSegmentPtr;
	  cancel: IBlob_cancelPtr;
	  close: IBlob_closePtr;
	  seek: IBlob_seekPtr;
	end;

	IBlobImpl = class;

	TBlob = record
	private
	  nullPtr: pointer;
	  vTable: PBlobVTable;
	  owner: IBlobImpl; {Only valid if isIBlobImpl returns true }
	  function thisRecord: IBlob inline;
	public
	  function isIBlobImpl: boolean;
	  function getIBlobImpl: IBlobImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function getSegment(status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer;
	  procedure putSegment(status: IStatus; length: Cardinal; buffer: Pointer);
	  procedure cancel(status: IStatus);
	  procedure close(status: IStatus);
	  function seek(status: IStatus; mode: Integer; offset: Integer): Integer;
	end;

	IBlobImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function getInterface: IBlob;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  function getSegment(status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; virtual; abstract;
	  procedure putSegment(status: IStatus; length: Cardinal; buffer: Pointer); virtual; abstract;
	  procedure cancel(status: IStatus); virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	  function seek(status: IStatus; mode: Integer; offset: Integer): Integer; virtual; abstract;
	end;

	PTransactionVTable = ^TransactionVTable;
	TransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: ITransaction_getInfoPtr;
	  prepare: ITransaction_preparePtr;
	  commit: ITransaction_commitPtr;
	  commitRetaining: ITransaction_commitRetainingPtr;
	  rollback: ITransaction_rollbackPtr;
	  rollbackRetaining: ITransaction_rollbackRetainingPtr;
	  disconnect: ITransaction_disconnectPtr;
	  join: ITransaction_joinPtr;
	  validate: ITransaction_validatePtr;
	  enterDtc: ITransaction_enterDtcPtr;
	end;

	ITransactionImpl = class;

	TTransaction = record
	private
	  nullPtr: pointer;
	  vTable: PTransactionVTable;
	  owner: ITransactionImpl; {Only valid if isITransactionImpl returns true }
	  function thisRecord: ITransaction inline;
	public
	  function isITransactionImpl: boolean;
	  function getITransactionImpl: ITransactionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure prepare(status: IStatus; msgLength: Cardinal; message: BytePtr);
	  procedure commit(status: IStatus);
	  procedure commitRetaining(status: IStatus);
	  procedure rollback(status: IStatus);
	  procedure rollbackRetaining(status: IStatus);
	  procedure disconnect(status: IStatus);
	  function join(status: IStatus; transaction: ITransaction): ITransaction;
	  function validate(status: IStatus; attachment: IAttachment): ITransaction;
	  function enterDtc(status: IStatus): ITransaction;
	end;

	ITransactionImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function getInterface: ITransaction;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  procedure prepare(status: IStatus; msgLength: Cardinal; message: BytePtr); virtual; abstract;
	  procedure commit(status: IStatus); virtual; abstract;
	  procedure commitRetaining(status: IStatus); virtual; abstract;
	  procedure rollback(status: IStatus); virtual; abstract;
	  procedure rollbackRetaining(status: IStatus); virtual; abstract;
	  procedure disconnect(status: IStatus); virtual; abstract;
	  function join(status: IStatus; transaction: ITransaction): ITransaction; virtual; abstract;
	  function validate(status: IStatus; attachment: IAttachment): ITransaction; virtual; abstract;
	  function enterDtc(status: IStatus): ITransaction; virtual; abstract;
	end;

	PMessageMetadataVTable = ^MessageMetadataVTable;
	MessageMetadataVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getCount: IMessageMetadata_getCountPtr;
	  getField: IMessageMetadata_getFieldPtr;
	  getRelation: IMessageMetadata_getRelationPtr;
	  getOwner: IMessageMetadata_getOwnerPtr;
	  getAlias: IMessageMetadata_getAliasPtr;
	  getType: IMessageMetadata_getTypePtr;
	  isNullable: IMessageMetadata_isNullablePtr;
	  getSubType: IMessageMetadata_getSubTypePtr;
	  getLength: IMessageMetadata_getLengthPtr;
	  getScale: IMessageMetadata_getScalePtr;
	  getCharSet: IMessageMetadata_getCharSetPtr;
	  getOffset: IMessageMetadata_getOffsetPtr;
	  getNullOffset: IMessageMetadata_getNullOffsetPtr;
	  getBuilder: IMessageMetadata_getBuilderPtr;
	  getMessageLength: IMessageMetadata_getMessageLengthPtr;
	  getAlignment: IMessageMetadata_getAlignmentPtr;
	  getAlignedLength: IMessageMetadata_getAlignedLengthPtr;
	end;

	IMessageMetadataImpl = class;

	TMessageMetadata = record
	private
	  nullPtr: pointer;
	  vTable: PMessageMetadataVTable;
	  owner: IMessageMetadataImpl; {Only valid if isIMessageMetadataImpl returns true }
	  function thisRecord: IMessageMetadata inline;
	public
	  function isIMessageMetadataImpl: boolean;
	  function getIMessageMetadataImpl: IMessageMetadataImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getCount(status: IStatus): Cardinal;
	  function getField(status: IStatus; index: Cardinal): PAnsiChar;
	  function getRelation(status: IStatus; index: Cardinal): PAnsiChar;
	  function getOwner(status: IStatus; index: Cardinal): PAnsiChar;
	  function getAlias(status: IStatus; index: Cardinal): PAnsiChar;
	  function getType(status: IStatus; index: Cardinal): Cardinal;
	  function isNullable(status: IStatus; index: Cardinal): Boolean;
	  function getSubType(status: IStatus; index: Cardinal): Integer;
	  function getLength(status: IStatus; index: Cardinal): Cardinal;
	  function getScale(status: IStatus; index: Cardinal): Integer;
	  function getCharSet(status: IStatus; index: Cardinal): Cardinal;
	  function getOffset(status: IStatus; index: Cardinal): Cardinal;
	  function getNullOffset(status: IStatus; index: Cardinal): Cardinal;
	  function getBuilder(status: IStatus): IMetadataBuilder;
	  function getMessageLength(status: IStatus): Cardinal;
	  function getAlignment(status: IStatus): Cardinal;
	  function getAlignedLength(status: IStatus): Cardinal;
	end;

	IMessageMetadataImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 19;
	public
	  constructor create;
	  function getInterface: IMessageMetadata;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getCount(status: IStatus): Cardinal; virtual; abstract;
	  function getField(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getRelation(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getOwner(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getAlias(status: IStatus; index: Cardinal): PAnsiChar; virtual; abstract;
	  function getType(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function isNullable(status: IStatus; index: Cardinal): Boolean; virtual; abstract;
	  function getSubType(status: IStatus; index: Cardinal): Integer; virtual; abstract;
	  function getLength(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getScale(status: IStatus; index: Cardinal): Integer; virtual; abstract;
	  function getCharSet(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getOffset(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getNullOffset(status: IStatus; index: Cardinal): Cardinal; virtual; abstract;
	  function getBuilder(status: IStatus): IMetadataBuilder; virtual; abstract;
	  function getMessageLength(status: IStatus): Cardinal; virtual; abstract;
	  function getAlignment(status: IStatus): Cardinal; virtual; abstract;
	  function getAlignedLength(status: IStatus): Cardinal; virtual; abstract;
	end;

	PMetadataBuilderVTable = ^MetadataBuilderVTable;
	MetadataBuilderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setType: IMetadataBuilder_setTypePtr;
	  setSubType: IMetadataBuilder_setSubTypePtr;
	  setLength: IMetadataBuilder_setLengthPtr;
	  setCharSet: IMetadataBuilder_setCharSetPtr;
	  setScale: IMetadataBuilder_setScalePtr;
	  truncate: IMetadataBuilder_truncatePtr;
	  moveNameToIndex: IMetadataBuilder_moveNameToIndexPtr;
	  remove: IMetadataBuilder_removePtr;
	  addField: IMetadataBuilder_addFieldPtr;
	  getMetadata: IMetadataBuilder_getMetadataPtr;
	  setField: IMetadataBuilder_setFieldPtr;
	  setRelation: IMetadataBuilder_setRelationPtr;
	  setOwner: IMetadataBuilder_setOwnerPtr;
	  setAlias: IMetadataBuilder_setAliasPtr;
	end;

	IMetadataBuilderImpl = class;

	TMetadataBuilder = record
	private
	  nullPtr: pointer;
	  vTable: PMetadataBuilderVTable;
	  owner: IMetadataBuilderImpl; {Only valid if isIMetadataBuilderImpl returns true }
	  function thisRecord: IMetadataBuilder inline;
	public
	  function isIMetadataBuilderImpl: boolean;
	  function getIMetadataBuilderImpl: IMetadataBuilderImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setType(status: IStatus; index: Cardinal; type_: Cardinal);
	  procedure setSubType(status: IStatus; index: Cardinal; subType: Integer);
	  procedure setLength(status: IStatus; index: Cardinal; length: Cardinal);
	  procedure setCharSet(status: IStatus; index: Cardinal; charSet: Cardinal);
	  procedure setScale(status: IStatus; index: Cardinal; scale: Integer);
	  procedure truncate(status: IStatus; count: Cardinal);
	  procedure moveNameToIndex(status: IStatus; name: PAnsiChar; index: Cardinal);
	  procedure remove(status: IStatus; index: Cardinal);
	  function addField(status: IStatus): Cardinal;
	  function getMetadata(status: IStatus): IMessageMetadata;
	  procedure setField(status: IStatus; index: Cardinal; field: PAnsiChar);
	  procedure setRelation(status: IStatus; index: Cardinal; relation: PAnsiChar);
	  procedure setOwner(status: IStatus; index: Cardinal; owner: PAnsiChar);
	  procedure setAlias(status: IStatus; index: Cardinal; alias: PAnsiChar);
	end;

	IMetadataBuilderImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 16;
	public
	  constructor create;
	  function getInterface: IMetadataBuilder;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setType(status: IStatus; index: Cardinal; type_: Cardinal); virtual; abstract;
	  procedure setSubType(status: IStatus; index: Cardinal; subType: Integer); virtual; abstract;
	  procedure setLength(status: IStatus; index: Cardinal; length: Cardinal); virtual; abstract;
	  procedure setCharSet(status: IStatus; index: Cardinal; charSet: Cardinal); virtual; abstract;
	  procedure setScale(status: IStatus; index: Cardinal; scale: Integer); virtual; abstract;
	  procedure truncate(status: IStatus; count: Cardinal); virtual; abstract;
	  procedure moveNameToIndex(status: IStatus; name: PAnsiChar; index: Cardinal); virtual; abstract;
	  procedure remove(status: IStatus; index: Cardinal); virtual; abstract;
	  function addField(status: IStatus): Cardinal; virtual; abstract;
	  function getMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  procedure setField(status: IStatus; index: Cardinal; field: PAnsiChar); virtual; abstract;
	  procedure setRelation(status: IStatus; index: Cardinal; relation: PAnsiChar); virtual; abstract;
	  procedure setOwner(status: IStatus; index: Cardinal; owner: PAnsiChar); virtual; abstract;
	  procedure setAlias(status: IStatus; index: Cardinal; alias: PAnsiChar); virtual; abstract;
	end;

	PResultSetVTable = ^ResultSetVTable;
	ResultSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  fetchNext: IResultSet_fetchNextPtr;
	  fetchPrior: IResultSet_fetchPriorPtr;
	  fetchFirst: IResultSet_fetchFirstPtr;
	  fetchLast: IResultSet_fetchLastPtr;
	  fetchAbsolute: IResultSet_fetchAbsolutePtr;
	  fetchRelative: IResultSet_fetchRelativePtr;
	  isEof: IResultSet_isEofPtr;
	  isBof: IResultSet_isBofPtr;
	  getMetadata: IResultSet_getMetadataPtr;
	  close: IResultSet_closePtr;
	  setDelayedOutputFormat: IResultSet_setDelayedOutputFormatPtr;
	end;

	IResultSetImpl = class;

	TResultSet = record
	private
	  nullPtr: pointer;
	  vTable: PResultSetVTable;
	  owner: IResultSetImpl; {Only valid if isIResultSetImpl returns true }
	  function thisRecord: IResultSet inline;
	public
	  function isIResultSetImpl: boolean;
	  function getIResultSetImpl: IResultSetImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function fetchNext(status: IStatus; message: Pointer): Integer;
	  function fetchPrior(status: IStatus; message: Pointer): Integer;
	  function fetchFirst(status: IStatus; message: Pointer): Integer;
	  function fetchLast(status: IStatus; message: Pointer): Integer;
	  function fetchAbsolute(status: IStatus; position: Integer; message: Pointer): Integer;
	  function fetchRelative(status: IStatus; offset: Integer; message: Pointer): Integer;
	  function isEof(status: IStatus): Boolean;
	  function isBof(status: IStatus): Boolean;
	  function getMetadata(status: IStatus): IMessageMetadata;
	  procedure close(status: IStatus);
	  procedure setDelayedOutputFormat(status: IStatus; format: IMessageMetadata);
	end;

	IResultSetImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 13;
	public
	  constructor create;
	  function getInterface: IResultSet;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function fetchNext(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchPrior(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchFirst(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchLast(status: IStatus; message: Pointer): Integer; virtual; abstract;
	  function fetchAbsolute(status: IStatus; position: Integer; message: Pointer): Integer; virtual; abstract;
	  function fetchRelative(status: IStatus; offset: Integer; message: Pointer): Integer; virtual; abstract;
	  function isEof(status: IStatus): Boolean; virtual; abstract;
	  function isBof(status: IStatus): Boolean; virtual; abstract;
	  function getMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	  procedure setDelayedOutputFormat(status: IStatus; format: IMessageMetadata); virtual; abstract;
	end;

	PStatementVTable = ^StatementVTable;
	StatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IStatement_getInfoPtr;
	  getType: IStatement_getTypePtr;
	  getPlan: IStatement_getPlanPtr;
	  getAffectedRecords: IStatement_getAffectedRecordsPtr;
	  getInputMetadata: IStatement_getInputMetadataPtr;
	  getOutputMetadata: IStatement_getOutputMetadataPtr;
	  execute: IStatement_executePtr;
	  openCursor: IStatement_openCursorPtr;
	  setCursorName: IStatement_setCursorNamePtr;
	  free: IStatement_freePtr;
	  getFlags: IStatement_getFlagsPtr;
	  getTimeout: IStatement_getTimeoutPtr;
	  setTimeout: IStatement_setTimeoutPtr;
	  createBatch: IStatement_createBatchPtr;
	end;

	IStatementImpl = class;

	TStatement = record
	private
	  nullPtr: pointer;
	  vTable: PStatementVTable;
	  owner: IStatementImpl; {Only valid if isIStatementImpl returns true }
	  function thisRecord: IStatement inline;
	public
	  function isIStatementImpl: boolean;
	  function getIStatementImpl: IStatementImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function getType(status: IStatus): Cardinal;
	  function getPlan(status: IStatus; detailed: Boolean): PAnsiChar;
	  function getAffectedRecords(status: IStatus): QWord;
	  function getInputMetadata(status: IStatus): IMessageMetadata;
	  function getOutputMetadata(status: IStatus): IMessageMetadata;
	  function execute(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
	  function openCursor(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet;
	  procedure setCursorName(status: IStatus; name: PAnsiChar);
	  procedure free(status: IStatus);
	  function getFlags(status: IStatus): Cardinal;
	  function getTimeout(status: IStatus): Cardinal;
	  procedure setTimeout(status: IStatus; timeOut: Cardinal);
	  function createBatch(status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
	end;

	IStatementImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 16;
	  const PREPARE_PREFETCH_NONE = Cardinal($0);
	  const PREPARE_PREFETCH_TYPE = Cardinal($1);
	  const PREPARE_PREFETCH_INPUT_PARAMETERS = Cardinal($2);
	  const PREPARE_PREFETCH_OUTPUT_PARAMETERS = Cardinal($4);
	  const PREPARE_PREFETCH_LEGACY_PLAN = Cardinal($8);
	  const PREPARE_PREFETCH_DETAILED_PLAN = Cardinal($10);
	  const PREPARE_PREFETCH_AFFECTED_RECORDS = Cardinal($20);
	  const PREPARE_PREFETCH_FLAGS = Cardinal($40);
	  const PREPARE_PREFETCH_METADATA = Cardinal(IStatementImpl.PREPARE_PREFETCH_TYPE or IStatementImpl.PREPARE_PREFETCH_FLAGS or IStatementImpl.PREPARE_PREFETCH_INPUT_PARAMETERS or IStatementImpl.PREPARE_PREFETCH_OUTPUT_PARAMETERS);
	  const PREPARE_PREFETCH_ALL = Cardinal(IStatementImpl.PREPARE_PREFETCH_METADATA or IStatementImpl.PREPARE_PREFETCH_LEGACY_PLAN or IStatementImpl.PREPARE_PREFETCH_DETAILED_PLAN or IStatementImpl.PREPARE_PREFETCH_AFFECTED_RECORDS);
	  const FLAG_HAS_CURSOR = Cardinal($1);
	  const FLAG_REPEAT_EXECUTE = Cardinal($2);
	  const CURSOR_TYPE_SCROLLABLE = Cardinal($1);
	public
	  constructor create;
	  function getInterface: IStatement;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  function getType(status: IStatus): Cardinal; virtual; abstract;
	  function getPlan(status: IStatus; detailed: Boolean): PAnsiChar; virtual; abstract;
	  function getAffectedRecords(status: IStatus): QWord; virtual; abstract;
	  function getInputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getOutputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function execute(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; virtual; abstract;
	  function openCursor(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet; virtual; abstract;
	  procedure setCursorName(status: IStatus; name: PAnsiChar); virtual; abstract;
	  procedure free(status: IStatus); virtual; abstract;
	  function getFlags(status: IStatus): Cardinal; virtual; abstract;
	  function getTimeout(status: IStatus): Cardinal; virtual; abstract;
	  procedure setTimeout(status: IStatus; timeOut: Cardinal); virtual; abstract;
	  function createBatch(status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; virtual; abstract;
	end;

	PBatchVTable = ^BatchVTable;
	BatchVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  add: IBatch_addPtr;
	  addBlob: IBatch_addBlobPtr;
	  appendBlobData: IBatch_appendBlobDataPtr;
	  addBlobStream: IBatch_addBlobStreamPtr;
	  registerBlob: IBatch_registerBlobPtr;
	  execute: IBatch_executePtr;
	  cancel: IBatch_cancelPtr;
	  getBlobAlignment: IBatch_getBlobAlignmentPtr;
	  getMetadata: IBatch_getMetadataPtr;
	  setDefaultBpb: IBatch_setDefaultBpbPtr;
	  close: IBatch_closePtr;
	end;

	IBatchImpl = class;

	TBatch = record
	private
	  nullPtr: pointer;
	  vTable: PBatchVTable;
	  owner: IBatchImpl; {Only valid if isIBatchImpl returns true }
	  function thisRecord: IBatch inline;
	public
	  function isIBatchImpl: boolean;
	  function getIBatchImpl: IBatchImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure add(status: IStatus; count: Cardinal; inBuffer: Pointer);
	  procedure addBlob(status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr);
	  procedure appendBlobData(status: IStatus; length: Cardinal; inBuffer: Pointer);
	  procedure addBlobStream(status: IStatus; length: Cardinal; inBuffer: Pointer);
	  procedure registerBlob(status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr);
	  function execute(status: IStatus; transaction: ITransaction): IBatchCompletionState;
	  procedure cancel(status: IStatus);
	  function getBlobAlignment(status: IStatus): Cardinal;
	  function getMetadata(status: IStatus): IMessageMetadata;
	  procedure setDefaultBpb(status: IStatus; parLength: Cardinal; par: BytePtr);
	  procedure close(status: IStatus);
	end;

	IBatchImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 13;
	  const VERSION1 = Byte(1);
	  const TAG_MULTIERROR = Byte(1);
	  const TAG_RECORD_COUNTS = Byte(2);
	  const TAG_BUFFER_BYTES_SIZE = Byte(3);
	  const TAG_BLOB_POLICY = Byte(4);
	  const TAG_DETAILED_ERRORS = Byte(5);
	  const BLOB_NONE = Byte(0);
	  const BLOB_ID_ENGINE = Byte(1);
	  const BLOB_ID_USER = Byte(2);
	  const BLOB_STREAM = Byte(3);
	  const BLOB_SEGHDR_ALIGN = Cardinal(2);
	public
	  constructor create;
	  function getInterface: IBatch;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure add(status: IStatus; count: Cardinal; inBuffer: Pointer); virtual; abstract;
	  procedure addBlob(status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); virtual; abstract;
	  procedure appendBlobData(status: IStatus; length: Cardinal; inBuffer: Pointer); virtual; abstract;
	  procedure addBlobStream(status: IStatus; length: Cardinal; inBuffer: Pointer); virtual; abstract;
	  procedure registerBlob(status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); virtual; abstract;
	  function execute(status: IStatus; transaction: ITransaction): IBatchCompletionState; virtual; abstract;
	  procedure cancel(status: IStatus); virtual; abstract;
	  function getBlobAlignment(status: IStatus): Cardinal; virtual; abstract;
	  function getMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  procedure setDefaultBpb(status: IStatus; parLength: Cardinal; par: BytePtr); virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	end;

	PBatchCompletionStateVTable = ^BatchCompletionStateVTable;
	BatchCompletionStateVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getSize: IBatchCompletionState_getSizePtr;
	  getState: IBatchCompletionState_getStatePtr;
	  findError: IBatchCompletionState_findErrorPtr;
	  getStatus: IBatchCompletionState_getStatusPtr;
	end;

	IBatchCompletionStateImpl = class;

	TBatchCompletionState = record
	private
	  nullPtr: pointer;
	  vTable: PBatchCompletionStateVTable;
	  owner: IBatchCompletionStateImpl; {Only valid if isIBatchCompletionStateImpl returns true }
	  function thisRecord: IBatchCompletionState inline;
	public
	  function isIBatchCompletionStateImpl: boolean;
	  function getIBatchCompletionStateImpl: IBatchCompletionStateImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function getSize(status: IStatus): Cardinal;
	  function getState(status: IStatus; pos: Cardinal): Integer;
	  function findError(status: IStatus; pos: Cardinal): Cardinal;
	  procedure getStatus(status: IStatus; to_: IStatus; pos: Cardinal);
	end;

	IBatchCompletionStateImpl = class(IDisposableImpl)
	public
	  const VERSION = 5;
	  const EXECUTE_FAILED = Integer(-1);
	  const SUCCESS_NO_INFO = Integer(-2);
	  const NO_MORE_ERRORS = Cardinal($ffffffff);
	public
	  constructor create;
	  function getInterface: IBatchCompletionState;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getSize(status: IStatus): Cardinal; virtual; abstract;
	  function getState(status: IStatus; pos: Cardinal): Integer; virtual; abstract;
	  function findError(status: IStatus; pos: Cardinal): Cardinal; virtual; abstract;
	  procedure getStatus(status: IStatus; to_: IStatus; pos: Cardinal); virtual; abstract;
	end;

	PReplicatorVTable = ^ReplicatorVTable;
	ReplicatorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  process: IReplicator_processPtr;
	  close: IReplicator_closePtr;
	end;

	IReplicatorImpl = class;

	TReplicator = record
	private
	  nullPtr: pointer;
	  vTable: PReplicatorVTable;
	  owner: IReplicatorImpl; {Only valid if isIReplicatorImpl returns true }
	  function thisRecord: IReplicator inline;
	public
	  function isIReplicatorImpl: boolean;
	  function getIReplicatorImpl: IReplicatorImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure process(status: IStatus; length: Cardinal; data: BytePtr);
	  procedure close(status: IStatus);
	end;

	IReplicatorImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IReplicator;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure process(status: IStatus; length: Cardinal; data: BytePtr); virtual; abstract;
	  procedure close(status: IStatus); virtual; abstract;
	end;

	PRequestVTable = ^RequestVTable;
	RequestVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  receive: IRequest_receivePtr;
	  send: IRequest_sendPtr;
	  getInfo: IRequest_getInfoPtr;
	  start: IRequest_startPtr;
	  startAndSend: IRequest_startAndSendPtr;
	  unwind: IRequest_unwindPtr;
	  free: IRequest_freePtr;
	end;

	IRequestImpl = class;

	TRequest = record
	private
	  nullPtr: pointer;
	  vTable: PRequestVTable;
	  owner: IRequestImpl; {Only valid if isIRequestImpl returns true }
	  function thisRecord: IRequest inline;
	public
	  function isIRequestImpl: boolean;
	  function getIRequestImpl: IRequestImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure receive(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure send(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure getInfo(status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure start(status: IStatus; tra: ITransaction; level: Integer);
	  procedure startAndSend(status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
	  procedure unwind(status: IStatus; level: Integer);
	  procedure free(status: IStatus);
	end;

	IRequestImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 9;
	public
	  constructor create;
	  function getInterface: IRequest;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure receive(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
	  procedure send(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
	  procedure getInfo(status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  procedure start(status: IStatus; tra: ITransaction; level: Integer); virtual; abstract;
	  procedure startAndSend(status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); virtual; abstract;
	  procedure unwind(status: IStatus; level: Integer); virtual; abstract;
	  procedure free(status: IStatus); virtual; abstract;
	end;

	PEventsVTable = ^EventsVTable;
	EventsVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  cancel: IEvents_cancelPtr;
	end;

	IEventsImpl = class;

	TEvents = record
	private
	  nullPtr: pointer;
	  vTable: PEventsVTable;
	  owner: IEventsImpl; {Only valid if isIEventsImpl returns true }
	  function thisRecord: IEvents inline;
	public
	  function isIEventsImpl: boolean;
	  function getIEventsImpl: IEventsImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure cancel(status: IStatus);
	end;

	IEventsImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IEvents;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure cancel(status: IStatus); virtual; abstract;
	end;

	PAttachmentVTable = ^AttachmentVTable;
	AttachmentVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getInfo: IAttachment_getInfoPtr;
	  startTransaction: IAttachment_startTransactionPtr;
	  reconnectTransaction: IAttachment_reconnectTransactionPtr;
	  compileRequest: IAttachment_compileRequestPtr;
	  transactRequest: IAttachment_transactRequestPtr;
	  createBlob: IAttachment_createBlobPtr;
	  openBlob: IAttachment_openBlobPtr;
	  getSlice: IAttachment_getSlicePtr;
	  putSlice: IAttachment_putSlicePtr;
	  executeDyn: IAttachment_executeDynPtr;
	  prepare: IAttachment_preparePtr;
	  execute: IAttachment_executePtr;
	  openCursor: IAttachment_openCursorPtr;
	  queEvents: IAttachment_queEventsPtr;
	  cancelOperation: IAttachment_cancelOperationPtr;
	  ping: IAttachment_pingPtr;
	  detach: IAttachment_detachPtr;
	  dropDatabase: IAttachment_dropDatabasePtr;
	  getIdleTimeout: IAttachment_getIdleTimeoutPtr;
	  setIdleTimeout: IAttachment_setIdleTimeoutPtr;
	  getStatementTimeout: IAttachment_getStatementTimeoutPtr;
	  setStatementTimeout: IAttachment_setStatementTimeoutPtr;
	  createBatch: IAttachment_createBatchPtr;
	  createReplicator: IAttachment_createReplicatorPtr;
	end;

	IAttachmentImpl = class;

	TAttachment = record
	private
	  nullPtr: pointer;
	  vTable: PAttachmentVTable;
	  owner: IAttachmentImpl; {Only valid if isIAttachmentImpl returns true }
	  function thisRecord: IAttachment inline;
	public
	  function isIAttachmentImpl: boolean;
	  function getIAttachmentImpl: IAttachmentImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  function startTransaction(status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction;
	  function reconnectTransaction(status: IStatus; length: Cardinal; id: BytePtr): ITransaction;
	  function compileRequest(status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest;
	  procedure transactRequest(status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr);
	  function createBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
	  function openBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
	  function getSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer;
	  procedure putSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr);
	  procedure executeDyn(status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr);
	  function prepare(status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement;
	  function execute(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
	  function openCursor(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet;
	  function queEvents(status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents;
	  procedure cancelOperation(status: IStatus; option: Integer);
	  procedure ping(status: IStatus);
	  procedure detach(status: IStatus);
	  procedure dropDatabase(status: IStatus);
	  function getIdleTimeout(status: IStatus): Cardinal;
	  procedure setIdleTimeout(status: IStatus; timeOut: Cardinal);
	  function getStatementTimeout(status: IStatus): Cardinal;
	  procedure setStatementTimeout(status: IStatus; timeOut: Cardinal);
	  function createBatch(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
	  function createReplicator(status: IStatus): IReplicator;
	end;

	IAttachmentImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 26;
	public
	  constructor create;
	  function getInterface: IAttachment;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  function startTransaction(status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction; virtual; abstract;
	  function reconnectTransaction(status: IStatus; length: Cardinal; id: BytePtr): ITransaction; virtual; abstract;
	  function compileRequest(status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest; virtual; abstract;
	  procedure transactRequest(status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); virtual; abstract;
	  function createBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; virtual; abstract;
	  function openBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; virtual; abstract;
	  function getSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; virtual; abstract;
	  procedure putSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); virtual; abstract;
	  procedure executeDyn(status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr); virtual; abstract;
	  function prepare(status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement; virtual; abstract;
	  function execute(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; virtual; abstract;
	  function openCursor(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet; virtual; abstract;
	  function queEvents(status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents; virtual; abstract;
	  procedure cancelOperation(status: IStatus; option: Integer); virtual; abstract;
	  procedure ping(status: IStatus); virtual; abstract;
	  procedure detach(status: IStatus); virtual; abstract;
	  procedure dropDatabase(status: IStatus); virtual; abstract;
	  function getIdleTimeout(status: IStatus): Cardinal; virtual; abstract;
	  procedure setIdleTimeout(status: IStatus; timeOut: Cardinal); virtual; abstract;
	  function getStatementTimeout(status: IStatus): Cardinal; virtual; abstract;
	  procedure setStatementTimeout(status: IStatus; timeOut: Cardinal); virtual; abstract;
	  function createBatch(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; virtual; abstract;
	  function createReplicator(status: IStatus): IReplicator; virtual; abstract;
	end;

	PServiceVTable = ^ServiceVTable;
	ServiceVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  detach: IService_detachPtr;
	  query: IService_queryPtr;
	  start: IService_startPtr;
	end;

	IServiceImpl = class;

	TService = record
	private
	  nullPtr: pointer;
	  vTable: PServiceVTable;
	  owner: IServiceImpl; {Only valid if isIServiceImpl returns true }
	  function thisRecord: IService inline;
	public
	  function isIServiceImpl: boolean;
	  function getIServiceImpl: IServiceImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure detach(status: IStatus);
	  procedure query(status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
	  procedure start(status: IStatus; spbLength: Cardinal; spb: BytePtr);
	end;

	IServiceImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: IService;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure detach(status: IStatus); virtual; abstract;
	  procedure query(status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); virtual; abstract;
	  procedure start(status: IStatus; spbLength: Cardinal; spb: BytePtr); virtual; abstract;
	end;

	PProviderVTable = ^ProviderVTable;
	ProviderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  attachDatabase: IProvider_attachDatabasePtr;
	  createDatabase: IProvider_createDatabasePtr;
	  attachServiceManager: IProvider_attachServiceManagerPtr;
	  shutdown: IProvider_shutdownPtr;
	  setDbCryptCallback: IProvider_setDbCryptCallbackPtr;
	end;

	IProviderImpl = class;

	TProvider = record
	private
	  nullPtr: pointer;
	  vTable: PProviderVTable;
	  owner: IProviderImpl; {Only valid if isIProviderImpl returns true }
	  function thisRecord: IProvider inline;
	public
	  function isIProviderImpl: boolean;
	  function getIProviderImpl: IProviderImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function attachDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
	  function createDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
	  function attachServiceManager(status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService;
	  procedure shutdown(status: IStatus; timeout: Cardinal; reason: Integer);
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
	end;

	IProviderImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 9;
	public
	  constructor create;
	  function getInterface: IProvider;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function attachDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; virtual; abstract;
	  function createDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; virtual; abstract;
	  function attachServiceManager(status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService; virtual; abstract;
	  procedure shutdown(status: IStatus; timeout: Cardinal; reason: Integer); virtual; abstract;
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback); virtual; abstract;
	end;

	PDtcStartVTable = ^DtcStartVTable;
	DtcStartVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  addAttachment: IDtcStart_addAttachmentPtr;
	  addWithTpb: IDtcStart_addWithTpbPtr;
	  start: IDtcStart_startPtr;
	end;

	IDtcStartImpl = class;

	TDtcStart = record
	private
	  nullPtr: pointer;
	  vTable: PDtcStartVTable;
	  owner: IDtcStartImpl; {Only valid if isIDtcStartImpl returns true }
	  function thisRecord: IDtcStart inline;
	public
	  function isIDtcStartImpl: boolean;
	  function getIDtcStartImpl: IDtcStartImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure addAttachment(status: IStatus; att: IAttachment);
	  procedure addWithTpb(status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr);
	  function start(status: IStatus): ITransaction;
	end;

	IDtcStartImpl = class(IDisposableImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IDtcStart;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure addAttachment(status: IStatus; att: IAttachment); virtual; abstract;
	  procedure addWithTpb(status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr); virtual; abstract;
	  function start(status: IStatus): ITransaction; virtual; abstract;
	end;

	PDtcVTable = ^DtcVTable;
	DtcVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  join: IDtc_joinPtr;
	  startBuilder: IDtc_startBuilderPtr;
	end;

	IDtcImpl = class;

	TDtc = record
	private
	  nullPtr: pointer;
	  vTable: PDtcVTable;
	  owner: IDtcImpl; {Only valid if isIDtcImpl returns true }
	  function thisRecord: IDtc inline;
	public
	  function isIDtcImpl: boolean;
	  function getIDtcImpl: IDtcImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function join(status: IStatus; one: ITransaction; two: ITransaction): ITransaction;
	  function startBuilder(status: IStatus): IDtcStart;
	end;

	IDtcImpl = class(IVersionedImpl)
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function getInterface: IDtc;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function join(status: IStatus; one: ITransaction; two: ITransaction): ITransaction; virtual; abstract;
	  function startBuilder(status: IStatus): IDtcStart; virtual; abstract;
	end;

	PAuthVTable = ^AuthVTable;
	AuthVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	end;

	IAuthImpl = class;

	TAuth = record
	private
	  nullPtr: pointer;
	  vTable: PAuthVTable;
	  owner: IAuthImpl; {Only valid if isIAuthImpl returns true }
	  function thisRecord: IAuth inline;
	public
	  function isIAuthImpl: boolean;
	  function getIAuthImpl: IAuthImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	end;

	IAuthImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 4;
	  const AUTH_FAILED = Integer(-1);
	  const AUTH_SUCCESS = Integer(0);
	  const AUTH_MORE_DATA = Integer(1);
	  const AUTH_CONTINUE = Integer(2);
	public
	  constructor create;
	  function getInterface: IAuth;
	  function getvTableVersion: NativeInt override;
	end;

	PWriterVTable = ^WriterVTable;
	WriterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  reset: IWriter_resetPtr;
	  add: IWriter_addPtr;
	  setType: IWriter_setTypePtr;
	  setDb: IWriter_setDbPtr;
	end;

	IWriterImpl = class;

	TWriter = record
	private
	  nullPtr: pointer;
	  vTable: PWriterVTable;
	  owner: IWriterImpl; {Only valid if isIWriterImpl returns true }
	  function thisRecord: IWriter inline;
	public
	  function isIWriterImpl: boolean;
	  function getIWriterImpl: IWriterImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure reset();
	  procedure add(status: IStatus; name: PAnsiChar);
	  procedure setType(status: IStatus; value: PAnsiChar);
	  procedure setDb(status: IStatus; value: PAnsiChar);
	end;

	IWriterImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IWriter;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure reset(); virtual; abstract;
	  procedure add(status: IStatus; name: PAnsiChar); virtual; abstract;
	  procedure setType(status: IStatus; value: PAnsiChar); virtual; abstract;
	  procedure setDb(status: IStatus; value: PAnsiChar); virtual; abstract;
	end;

	PServerBlockVTable = ^ServerBlockVTable;
	ServerBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getLogin: IServerBlock_getLoginPtr;
	  getData: IServerBlock_getDataPtr;
	  putData: IServerBlock_putDataPtr;
	  newKey: IServerBlock_newKeyPtr;
	end;

	IServerBlockImpl = class;

	TServerBlock = record
	private
	  nullPtr: pointer;
	  vTable: PServerBlockVTable;
	  owner: IServerBlockImpl; {Only valid if isIServerBlockImpl returns true }
	  function thisRecord: IServerBlock inline;
	public
	  function isIServerBlockImpl: boolean;
	  function getIServerBlockImpl: IServerBlockImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getLogin(): PAnsiChar;
	  function getData(length: CardinalPtr): BytePtr;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer);
	  function newKey(status: IStatus): ICryptKey;
	end;

	IServerBlockImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IServerBlock;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getLogin(): PAnsiChar; virtual; abstract;
	  function getData(length: CardinalPtr): BytePtr; virtual; abstract;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer); virtual; abstract;
	  function newKey(status: IStatus): ICryptKey; virtual; abstract;
	end;

	PClientBlockVTable = ^ClientBlockVTable;
	ClientBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getLogin: IClientBlock_getLoginPtr;
	  getPassword: IClientBlock_getPasswordPtr;
	  getData: IClientBlock_getDataPtr;
	  putData: IClientBlock_putDataPtr;
	  newKey: IClientBlock_newKeyPtr;
	  getAuthBlock: IClientBlock_getAuthBlockPtr;
	end;

	IClientBlockImpl = class;

	TClientBlock = record
	private
	  nullPtr: pointer;
	  vTable: PClientBlockVTable;
	  owner: IClientBlockImpl; {Only valid if isIClientBlockImpl returns true }
	  function thisRecord: IClientBlock inline;
	public
	  function isIClientBlockImpl: boolean;
	  function getIClientBlockImpl: IClientBlockImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getLogin(): PAnsiChar;
	  function getPassword(): PAnsiChar;
	  function getData(length: CardinalPtr): BytePtr;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer);
	  function newKey(status: IStatus): ICryptKey;
	  function getAuthBlock(status: IStatus): IAuthBlock;
	end;

	IClientBlockImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function getInterface: IClientBlock;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getLogin(): PAnsiChar; virtual; abstract;
	  function getPassword(): PAnsiChar; virtual; abstract;
	  function getData(length: CardinalPtr): BytePtr; virtual; abstract;
	  procedure putData(status: IStatus; length: Cardinal; data: Pointer); virtual; abstract;
	  function newKey(status: IStatus): ICryptKey; virtual; abstract;
	  function getAuthBlock(status: IStatus): IAuthBlock; virtual; abstract;
	end;

	PServerVTable = ^ServerVTable;
	ServerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  authenticate: IServer_authenticatePtr;
	  setDbCryptCallback: IServer_setDbCryptCallbackPtr;
	end;

	IServerImpl = class;

	TServer = record
	private
	  nullPtr: pointer;
	  vTable: PServerVTable;
	  owner: IServerImpl; {Only valid if isIServerImpl returns true }
	  function thisRecord: IServer inline;
	public
	  function isIServerImpl: boolean;
	  function getIServerImpl: IServerImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function authenticate(status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer;
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
	end;

	IServerImpl = class(IAuthImpl)
	public
	  const VERSION = 6;
	public
	  constructor create;
	  function getInterface: IServer;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function authenticate(status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer; virtual; abstract;
	  procedure setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback); virtual; abstract;
	end;

	PClientVTable = ^ClientVTable;
	ClientVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  authenticate: IClient_authenticatePtr;
	end;

	IClientImpl = class;

	TClient = record
	private
	  nullPtr: pointer;
	  vTable: PClientVTable;
	  owner: IClientImpl; {Only valid if isIClientImpl returns true }
	  function thisRecord: IClient inline;
	public
	  function isIClientImpl: boolean;
	  function getIClientImpl: IClientImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function authenticate(status: IStatus; cBlock: IClientBlock): Integer;
	end;

	IClientImpl = class(IAuthImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: IClient;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function authenticate(status: IStatus; cBlock: IClientBlock): Integer; virtual; abstract;
	end;

	PUserFieldVTable = ^UserFieldVTable;
	UserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	end;

	IUserFieldImpl = class;

	TUserField = record
	private
	  nullPtr: pointer;
	  vTable: PUserFieldVTable;
	  owner: IUserFieldImpl; {Only valid if isIUserFieldImpl returns true }
	  function thisRecord: IUserField inline;
	public
	  function isIUserFieldImpl: boolean;
	  function getIUserFieldImpl: IUserFieldImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: IStatus; newValue: Integer);
	end;

	IUserFieldImpl = class(IVersionedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IUserField;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function entered(): Integer; virtual; abstract;
	  function specified(): Integer; virtual; abstract;
	  procedure setEntered(status: IStatus; newValue: Integer); virtual; abstract;
	end;

	PCharUserFieldVTable = ^CharUserFieldVTable;
	CharUserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	  get: ICharUserField_getPtr;
	  set_: ICharUserField_set_Ptr;
	end;

	ICharUserFieldImpl = class;

	TCharUserField = record
	private
	  nullPtr: pointer;
	  vTable: PCharUserFieldVTable;
	  owner: ICharUserFieldImpl; {Only valid if isICharUserFieldImpl returns true }
	  function thisRecord: ICharUserField inline;
	public
	  function isICharUserFieldImpl: boolean;
	  function getICharUserFieldImpl: ICharUserFieldImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: IStatus; newValue: Integer);
	  function get(): PAnsiChar;
	  procedure set_(status: IStatus; newValue: PAnsiChar);
	end;

	ICharUserFieldImpl = class(IUserFieldImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: ICharUserField;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function get(): PAnsiChar; virtual; abstract;
	  procedure set_(status: IStatus; newValue: PAnsiChar); virtual; abstract;
	end;

	PIntUserFieldVTable = ^IntUserFieldVTable;
	IntUserFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  entered: IUserField_enteredPtr;
	  specified: IUserField_specifiedPtr;
	  setEntered: IUserField_setEnteredPtr;
	  get: IIntUserField_getPtr;
	  set_: IIntUserField_set_Ptr;
	end;

	IIntUserFieldImpl = class;

	TIntUserField = record
	private
	  nullPtr: pointer;
	  vTable: PIntUserFieldVTable;
	  owner: IIntUserFieldImpl; {Only valid if isIIntUserFieldImpl returns true }
	  function thisRecord: IIntUserField inline;
	public
	  function isIIntUserFieldImpl: boolean;
	  function getIIntUserFieldImpl: IIntUserFieldImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function entered(): Integer;
	  function specified(): Integer;
	  procedure setEntered(status: IStatus; newValue: Integer);
	  function get(): Integer;
	  procedure set_(status: IStatus; newValue: Integer);
	end;

	IIntUserFieldImpl = class(IUserFieldImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: IIntUserField;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function get(): Integer; virtual; abstract;
	  procedure set_(status: IStatus; newValue: Integer); virtual; abstract;
	end;

	PUserVTable = ^UserVTable;
	UserVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  operation: IUser_operationPtr;
	  userName: IUser_userNamePtr;
	  password: IUser_passwordPtr;
	  firstName: IUser_firstNamePtr;
	  lastName: IUser_lastNamePtr;
	  middleName: IUser_middleNamePtr;
	  comment: IUser_commentPtr;
	  attributes: IUser_attributesPtr;
	  active: IUser_activePtr;
	  admin: IUser_adminPtr;
	  clear: IUser_clearPtr;
	end;

	IUserImpl = class;

	TUser = record
	private
	  nullPtr: pointer;
	  vTable: PUserVTable;
	  owner: IUserImpl; {Only valid if isIUserImpl returns true }
	  function thisRecord: IUser inline;
	public
	  function isIUserImpl: boolean;
	  function getIUserImpl: IUserImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function operation(): Cardinal;
	  function userName(): ICharUserField;
	  function password(): ICharUserField;
	  function firstName(): ICharUserField;
	  function lastName(): ICharUserField;
	  function middleName(): ICharUserField;
	  function comment(): ICharUserField;
	  function attributes(): ICharUserField;
	  function active(): IIntUserField;
	  function admin(): IIntUserField;
	  procedure clear(status: IStatus);
	end;

	IUserImpl = class(IVersionedImpl)
	public
	  const VERSION = 11;
	  const OP_USER_ADD = Cardinal(1);
	  const OP_USER_MODIFY = Cardinal(2);
	  const OP_USER_DELETE = Cardinal(3);
	  const OP_USER_DISPLAY = Cardinal(4);
	  const OP_USER_SET_MAP = Cardinal(5);
	  const OP_USER_DROP_MAP = Cardinal(6);
	public
	  constructor create;
	  function getInterface: IUser;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function operation(): Cardinal; virtual; abstract;
	  function userName(): ICharUserField; virtual; abstract;
	  function password(): ICharUserField; virtual; abstract;
	  function firstName(): ICharUserField; virtual; abstract;
	  function lastName(): ICharUserField; virtual; abstract;
	  function middleName(): ICharUserField; virtual; abstract;
	  function comment(): ICharUserField; virtual; abstract;
	  function attributes(): ICharUserField; virtual; abstract;
	  function active(): IIntUserField; virtual; abstract;
	  function admin(): IIntUserField; virtual; abstract;
	  procedure clear(status: IStatus); virtual; abstract;
	end;

	PListUsersVTable = ^ListUsersVTable;
	ListUsersVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  list: IListUsers_listPtr;
	end;

	IListUsersImpl = class;

	TListUsers = record
	private
	  nullPtr: pointer;
	  vTable: PListUsersVTable;
	  owner: IListUsersImpl; {Only valid if isIListUsersImpl returns true }
	  function thisRecord: IListUsers inline;
	public
	  function isIListUsersImpl: boolean;
	  function getIListUsersImpl: IListUsersImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure list(status: IStatus; user: IUser);
	end;

	IListUsersImpl = class(IVersionedImpl)
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function getInterface: IListUsers;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure list(status: IStatus; user: IUser); virtual; abstract;
	end;

	PLogonInfoVTable = ^LogonInfoVTable;
	LogonInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  name: ILogonInfo_namePtr;
	  role: ILogonInfo_rolePtr;
	  networkProtocol: ILogonInfo_networkProtocolPtr;
	  remoteAddress: ILogonInfo_remoteAddressPtr;
	  authBlock: ILogonInfo_authBlockPtr;
	  attachment: ILogonInfo_attachmentPtr;
	  transaction: ILogonInfo_transactionPtr;
	end;

	ILogonInfoImpl = class;

	TLogonInfo = record
	private
	  nullPtr: pointer;
	  vTable: PLogonInfoVTable;
	  owner: ILogonInfoImpl; {Only valid if isILogonInfoImpl returns true }
	  function thisRecord: ILogonInfo inline;
	public
	  function isILogonInfoImpl: boolean;
	  function getILogonInfoImpl: ILogonInfoImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function name(): PAnsiChar;
	  function role(): PAnsiChar;
	  function networkProtocol(): PAnsiChar;
	  function remoteAddress(): PAnsiChar;
	  function authBlock(length: CardinalPtr): BytePtr;
	  function attachment(status: IStatus): IAttachment;
	  function transaction(status: IStatus): ITransaction;
	end;

	ILogonInfoImpl = class(IVersionedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: ILogonInfo;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function name(): PAnsiChar; virtual; abstract;
	  function role(): PAnsiChar; virtual; abstract;
	  function networkProtocol(): PAnsiChar; virtual; abstract;
	  function remoteAddress(): PAnsiChar; virtual; abstract;
	  function authBlock(length: CardinalPtr): BytePtr; virtual; abstract;
	  function attachment(status: IStatus): IAttachment; virtual; abstract;
	  function transaction(status: IStatus): ITransaction; virtual; abstract;
	end;

	PManagementVTable = ^ManagementVTable;
	ManagementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  start: IManagement_startPtr;
	  execute: IManagement_executePtr;
	  commit: IManagement_commitPtr;
	  rollback: IManagement_rollbackPtr;
	end;

	IManagementImpl = class;

	TManagement = record
	private
	  nullPtr: pointer;
	  vTable: PManagementVTable;
	  owner: IManagementImpl; {Only valid if isIManagementImpl returns true }
	  function thisRecord: IManagement inline;
	public
	  function isIManagementImpl: boolean;
	  function getIManagementImpl: IManagementImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  procedure start(status: IStatus; logonInfo: ILogonInfo);
	  function execute(status: IStatus; user: IUser; callback: IListUsers): Integer;
	  procedure commit(status: IStatus);
	  procedure rollback(status: IStatus);
	end;

	IManagementImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function getInterface: IManagement;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure start(status: IStatus; logonInfo: ILogonInfo); virtual; abstract;
	  function execute(status: IStatus; user: IUser; callback: IListUsers): Integer; virtual; abstract;
	  procedure commit(status: IStatus); virtual; abstract;
	  procedure rollback(status: IStatus); virtual; abstract;
	end;

	PAuthBlockVTable = ^AuthBlockVTable;
	AuthBlockVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getType: IAuthBlock_getTypePtr;
	  getName: IAuthBlock_getNamePtr;
	  getPlugin: IAuthBlock_getPluginPtr;
	  getSecurityDb: IAuthBlock_getSecurityDbPtr;
	  getOriginalPlugin: IAuthBlock_getOriginalPluginPtr;
	  next: IAuthBlock_nextPtr;
	  first: IAuthBlock_firstPtr;
	end;

	IAuthBlockImpl = class;

	TAuthBlock = record
	private
	  nullPtr: pointer;
	  vTable: PAuthBlockVTable;
	  owner: IAuthBlockImpl; {Only valid if isIAuthBlockImpl returns true }
	  function thisRecord: IAuthBlock inline;
	public
	  function isIAuthBlockImpl: boolean;
	  function getIAuthBlockImpl: IAuthBlockImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getType(): PAnsiChar;
	  function getName(): PAnsiChar;
	  function getPlugin(): PAnsiChar;
	  function getSecurityDb(): PAnsiChar;
	  function getOriginalPlugin(): PAnsiChar;
	  function next(status: IStatus): Boolean;
	  function first(status: IStatus): Boolean;
	end;

	IAuthBlockImpl = class(IVersionedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: IAuthBlock;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getType(): PAnsiChar; virtual; abstract;
	  function getName(): PAnsiChar; virtual; abstract;
	  function getPlugin(): PAnsiChar; virtual; abstract;
	  function getSecurityDb(): PAnsiChar; virtual; abstract;
	  function getOriginalPlugin(): PAnsiChar; virtual; abstract;
	  function next(status: IStatus): Boolean; virtual; abstract;
	  function first(status: IStatus): Boolean; virtual; abstract;
	end;

	PWireCryptPluginVTable = ^WireCryptPluginVTable;
	WireCryptPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  getKnownTypes: IWireCryptPlugin_getKnownTypesPtr;
	  setKey: IWireCryptPlugin_setKeyPtr;
	  encrypt: IWireCryptPlugin_encryptPtr;
	  decrypt: IWireCryptPlugin_decryptPtr;
	  getSpecificData: IWireCryptPlugin_getSpecificDataPtr;
	  setSpecificData: IWireCryptPlugin_setSpecificDataPtr;
	end;

	IWireCryptPluginImpl = class;

	TWireCryptPlugin = record
	private
	  nullPtr: pointer;
	  vTable: PWireCryptPluginVTable;
	  owner: IWireCryptPluginImpl; {Only valid if isIWireCryptPluginImpl returns true }
	  function thisRecord: IWireCryptPlugin inline;
	public
	  function isIWireCryptPluginImpl: boolean;
	  function getIWireCryptPluginImpl: IWireCryptPluginImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function getKnownTypes(status: IStatus): PAnsiChar;
	  procedure setKey(status: IStatus; key: ICryptKey);
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  function getSpecificData(status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr;
	  procedure setSpecificData(status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr);
	end;

	IWireCryptPluginImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 10;
	public
	  constructor create;
	  function getInterface: IWireCryptPlugin;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getKnownTypes(status: IStatus): PAnsiChar; virtual; abstract;
	  procedure setKey(status: IStatus; key: ICryptKey); virtual; abstract;
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  function getSpecificData(status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr; virtual; abstract;
	  procedure setSpecificData(status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr); virtual; abstract;
	end;

	PCryptKeyCallbackVTable = ^CryptKeyCallbackVTable;
	CryptKeyCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  callback: ICryptKeyCallback_callbackPtr;
	end;

	ICryptKeyCallbackImpl = class;

	TCryptKeyCallback = record
	private
	  nullPtr: pointer;
	  vTable: PCryptKeyCallbackVTable;
	  owner: ICryptKeyCallbackImpl; {Only valid if isICryptKeyCallbackImpl returns true }
	  function thisRecord: ICryptKeyCallback inline;
	public
	  function isICryptKeyCallbackImpl: boolean;
	  function getICryptKeyCallbackImpl: ICryptKeyCallbackImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal;
	end;

	ICryptKeyCallbackImpl = class(IVersionedImpl)
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function getInterface: ICryptKeyCallback;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; virtual; abstract;
	end;

	PKeyHolderPluginVTable = ^KeyHolderPluginVTable;
	KeyHolderPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  keyCallback: IKeyHolderPlugin_keyCallbackPtr;
	  keyHandle: IKeyHolderPlugin_keyHandlePtr;
	  useOnlyOwnKeys: IKeyHolderPlugin_useOnlyOwnKeysPtr;
	  chainHandle: IKeyHolderPlugin_chainHandlePtr;
	end;

	IKeyHolderPluginImpl = class;

	TKeyHolderPlugin = record
	private
	  nullPtr: pointer;
	  vTable: PKeyHolderPluginVTable;
	  owner: IKeyHolderPluginImpl; {Only valid if isIKeyHolderPluginImpl returns true }
	  function thisRecord: IKeyHolderPlugin inline;
	public
	  function isIKeyHolderPluginImpl: boolean;
	  function getIKeyHolderPluginImpl: IKeyHolderPluginImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function keyCallback(status: IStatus; callback: ICryptKeyCallback): Integer;
	  function keyHandle(status: IStatus; keyName: PAnsiChar): ICryptKeyCallback;
	  function useOnlyOwnKeys(status: IStatus): Boolean;
	  function chainHandle(status: IStatus): ICryptKeyCallback;
	end;

	IKeyHolderPluginImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function getInterface: IKeyHolderPlugin;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function keyCallback(status: IStatus; callback: ICryptKeyCallback): Integer; virtual; abstract;
	  function keyHandle(status: IStatus; keyName: PAnsiChar): ICryptKeyCallback; virtual; abstract;
	  function useOnlyOwnKeys(status: IStatus): Boolean; virtual; abstract;
	  function chainHandle(status: IStatus): ICryptKeyCallback; virtual; abstract;
	end;

	PDbCryptInfoVTable = ^DbCryptInfoVTable;
	DbCryptInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  getDatabaseFullPath: IDbCryptInfo_getDatabaseFullPathPtr;
	end;

	IDbCryptInfoImpl = class;

	TDbCryptInfo = record
	private
	  nullPtr: pointer;
	  vTable: PDbCryptInfoVTable;
	  owner: IDbCryptInfoImpl; {Only valid if isIDbCryptInfoImpl returns true }
	  function thisRecord: IDbCryptInfo inline;
	public
	  function isIDbCryptInfoImpl: boolean;
	  function getIDbCryptInfoImpl: IDbCryptInfoImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function getDatabaseFullPath(status: IStatus): PAnsiChar;
	end;

	IDbCryptInfoImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IDbCryptInfo;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getDatabaseFullPath(status: IStatus): PAnsiChar; virtual; abstract;
	end;

	PDbCryptPluginVTable = ^DbCryptPluginVTable;
	DbCryptPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  setKey: IDbCryptPlugin_setKeyPtr;
	  encrypt: IDbCryptPlugin_encryptPtr;
	  decrypt: IDbCryptPlugin_decryptPtr;
	  setInfo: IDbCryptPlugin_setInfoPtr;
	end;

	IDbCryptPluginImpl = class;

	TDbCryptPlugin = record
	private
	  nullPtr: pointer;
	  vTable: PDbCryptPluginVTable;
	  owner: IDbCryptPluginImpl; {Only valid if isIDbCryptPluginImpl returns true }
	  function thisRecord: IDbCryptPlugin inline;
	public
	  function isIDbCryptPluginImpl: boolean;
	  function getIDbCryptPluginImpl: IDbCryptPluginImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  procedure setKey(status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar);
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
	  procedure setInfo(status: IStatus; info: IDbCryptInfo);
	end;

	IDbCryptPluginImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function getInterface: IDbCryptPlugin;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setKey(status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar); virtual; abstract;
	  procedure encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  procedure decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); virtual; abstract;
	  procedure setInfo(status: IStatus; info: IDbCryptInfo); virtual; abstract;
	end;

	PExternalContextVTable = ^ExternalContextVTable;
	ExternalContextVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getMaster: IExternalContext_getMasterPtr;
	  getEngine: IExternalContext_getEnginePtr;
	  getAttachment: IExternalContext_getAttachmentPtr;
	  getTransaction: IExternalContext_getTransactionPtr;
	  getUserName: IExternalContext_getUserNamePtr;
	  getDatabaseName: IExternalContext_getDatabaseNamePtr;
	  getClientCharSet: IExternalContext_getClientCharSetPtr;
	  obtainInfoCode: IExternalContext_obtainInfoCodePtr;
	  getInfo: IExternalContext_getInfoPtr;
	  setInfo: IExternalContext_setInfoPtr;
	end;

	IExternalContextImpl = class;

	TExternalContext = record
	private
	  nullPtr: pointer;
	  vTable: PExternalContextVTable;
	  owner: IExternalContextImpl; {Only valid if isIExternalContextImpl returns true }
	  function thisRecord: IExternalContext inline;
	public
	  function isIExternalContextImpl: boolean;
	  function getIExternalContextImpl: IExternalContextImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getMaster(): IMaster;
	  function getEngine(status: IStatus): IExternalEngine;
	  function getAttachment(status: IStatus): IAttachment;
	  function getTransaction(status: IStatus): ITransaction;
	  function getUserName(): PAnsiChar;
	  function getDatabaseName(): PAnsiChar;
	  function getClientCharSet(): PAnsiChar;
	  function obtainInfoCode(): Integer;
	  function getInfo(code: Integer): Pointer;
	  function setInfo(code: Integer; value: Pointer): Pointer;
	end;

	IExternalContextImpl = class(IVersionedImpl)
	public
	  const VERSION = 10;
	public
	  constructor create;
	  function getInterface: IExternalContext;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getMaster(): IMaster; virtual; abstract;
	  function getEngine(status: IStatus): IExternalEngine; virtual; abstract;
	  function getAttachment(status: IStatus): IAttachment; virtual; abstract;
	  function getTransaction(status: IStatus): ITransaction; virtual; abstract;
	  function getUserName(): PAnsiChar; virtual; abstract;
	  function getDatabaseName(): PAnsiChar; virtual; abstract;
	  function getClientCharSet(): PAnsiChar; virtual; abstract;
	  function obtainInfoCode(): Integer; virtual; abstract;
	  function getInfo(code: Integer): Pointer; virtual; abstract;
	  function setInfo(code: Integer; value: Pointer): Pointer; virtual; abstract;
	end;

	PExternalResultSetVTable = ^ExternalResultSetVTable;
	ExternalResultSetVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  fetch: IExternalResultSet_fetchPtr;
	end;

	IExternalResultSetImpl = class;

	TExternalResultSet = record
	private
	  nullPtr: pointer;
	  vTable: PExternalResultSetVTable;
	  owner: IExternalResultSetImpl; {Only valid if isIExternalResultSetImpl returns true }
	  function thisRecord: IExternalResultSet inline;
	public
	  function isIExternalResultSetImpl: boolean;
	  function getIExternalResultSetImpl: IExternalResultSetImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  function fetch(status: IStatus): Boolean;
	end;

	IExternalResultSetImpl = class(IDisposableImpl)
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function getInterface: IExternalResultSet;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function fetch(status: IStatus): Boolean; virtual; abstract;
	end;

	PExternalFunctionVTable = ^ExternalFunctionVTable;
	ExternalFunctionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalFunction_getCharSetPtr;
	  execute: IExternalFunction_executePtr;
	end;

	IExternalFunctionImpl = class;

	TExternalFunction = record
	private
	  nullPtr: pointer;
	  vTable: PExternalFunctionVTable;
	  owner: IExternalFunctionImpl; {Only valid if isIExternalFunctionImpl returns true }
	  function thisRecord: IExternalFunction inline;
	public
	  function isIExternalFunctionImpl: boolean;
	  function getIExternalFunctionImpl: IExternalFunctionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
	  procedure execute(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer);
	end;

	IExternalFunctionImpl = class(IDisposableImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IExternalFunction;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
	  procedure execute(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer); virtual; abstract;
	end;

	PExternalProcedureVTable = ^ExternalProcedureVTable;
	ExternalProcedureVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalProcedure_getCharSetPtr;
	  open: IExternalProcedure_openPtr;
	end;

	IExternalProcedureImpl = class;

	TExternalProcedure = record
	private
	  nullPtr: pointer;
	  vTable: PExternalProcedureVTable;
	  owner: IExternalProcedureImpl; {Only valid if isIExternalProcedureImpl returns true }
	  function thisRecord: IExternalProcedure inline;
	public
	  function isIExternalProcedureImpl: boolean;
	  function getIExternalProcedureImpl: IExternalProcedureImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
	  function open(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet;
	end;

	IExternalProcedureImpl = class(IDisposableImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IExternalProcedure;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
	  function open(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet; virtual; abstract;
	end;

	PExternalTriggerVTable = ^ExternalTriggerVTable;
	ExternalTriggerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  getCharSet: IExternalTrigger_getCharSetPtr;
	  execute: IExternalTrigger_executePtr;
	end;

	IExternalTriggerImpl = class;

	TExternalTrigger = record
	private
	  nullPtr: pointer;
	  vTable: PExternalTriggerVTable;
	  owner: IExternalTriggerImpl; {Only valid if isIExternalTriggerImpl returns true }
	  function thisRecord: IExternalTrigger inline;
	public
	  function isIExternalTriggerImpl: boolean;
	  function getIExternalTriggerImpl: IExternalTriggerImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
	  procedure execute(status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer);
	end;

	IExternalTriggerImpl = class(IDisposableImpl)
	public
	  const VERSION = 3;
	  const TYPE_BEFORE = Cardinal(1);
	  const TYPE_AFTER = Cardinal(2);
	  const TYPE_DATABASE = Cardinal(3);
	  const ACTION_INSERT = Cardinal(1);
	  const ACTION_UPDATE = Cardinal(2);
	  const ACTION_DELETE = Cardinal(3);
	  const ACTION_CONNECT = Cardinal(4);
	  const ACTION_DISCONNECT = Cardinal(5);
	  const ACTION_TRANS_START = Cardinal(6);
	  const ACTION_TRANS_COMMIT = Cardinal(7);
	  const ACTION_TRANS_ROLLBACK = Cardinal(8);
	  const ACTION_DDL = Cardinal(9);
	public
	  constructor create;
	  function getInterface: IExternalTrigger;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); virtual; abstract;
	  procedure execute(status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); virtual; abstract;
	end;

	PRoutineMetadataVTable = ^RoutineMetadataVTable;
	RoutineMetadataVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getPackage: IRoutineMetadata_getPackagePtr;
	  getName: IRoutineMetadata_getNamePtr;
	  getEntryPoint: IRoutineMetadata_getEntryPointPtr;
	  getBody: IRoutineMetadata_getBodyPtr;
	  getInputMetadata: IRoutineMetadata_getInputMetadataPtr;
	  getOutputMetadata: IRoutineMetadata_getOutputMetadataPtr;
	  getTriggerMetadata: IRoutineMetadata_getTriggerMetadataPtr;
	  getTriggerTable: IRoutineMetadata_getTriggerTablePtr;
	  getTriggerType: IRoutineMetadata_getTriggerTypePtr;
	end;

	IRoutineMetadataImpl = class;

	TRoutineMetadata = record
	private
	  nullPtr: pointer;
	  vTable: PRoutineMetadataVTable;
	  owner: IRoutineMetadataImpl; {Only valid if isIRoutineMetadataImpl returns true }
	  function thisRecord: IRoutineMetadata inline;
	public
	  function isIRoutineMetadataImpl: boolean;
	  function getIRoutineMetadataImpl: IRoutineMetadataImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getPackage(status: IStatus): PAnsiChar;
	  function getName(status: IStatus): PAnsiChar;
	  function getEntryPoint(status: IStatus): PAnsiChar;
	  function getBody(status: IStatus): PAnsiChar;
	  function getInputMetadata(status: IStatus): IMessageMetadata;
	  function getOutputMetadata(status: IStatus): IMessageMetadata;
	  function getTriggerMetadata(status: IStatus): IMessageMetadata;
	  function getTriggerTable(status: IStatus): PAnsiChar;
	  function getTriggerType(status: IStatus): Cardinal;
	end;

	IRoutineMetadataImpl = class(IVersionedImpl)
	public
	  const VERSION = 9;
	public
	  constructor create;
	  function getInterface: IRoutineMetadata;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getPackage(status: IStatus): PAnsiChar; virtual; abstract;
	  function getName(status: IStatus): PAnsiChar; virtual; abstract;
	  function getEntryPoint(status: IStatus): PAnsiChar; virtual; abstract;
	  function getBody(status: IStatus): PAnsiChar; virtual; abstract;
	  function getInputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getOutputMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getTriggerMetadata(status: IStatus): IMessageMetadata; virtual; abstract;
	  function getTriggerTable(status: IStatus): PAnsiChar; virtual; abstract;
	  function getTriggerType(status: IStatus): Cardinal; virtual; abstract;
	end;

	PExternalEngineVTable = ^ExternalEngineVTable;
	ExternalEngineVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  open: IExternalEngine_openPtr;
	  openAttachment: IExternalEngine_openAttachmentPtr;
	  closeAttachment: IExternalEngine_closeAttachmentPtr;
	  makeFunction: IExternalEngine_makeFunctionPtr;
	  makeProcedure: IExternalEngine_makeProcedurePtr;
	  makeTrigger: IExternalEngine_makeTriggerPtr;
	end;

	IExternalEngineImpl = class;

	TExternalEngine = record
	private
	  nullPtr: pointer;
	  vTable: PExternalEngineVTable;
	  owner: IExternalEngineImpl; {Only valid if isIExternalEngineImpl returns true }
	  function thisRecord: IExternalEngine inline;
	public
	  function isIExternalEngineImpl: boolean;
	  function getIExternalEngineImpl: IExternalEngineImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  procedure open(status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal);
	  procedure openAttachment(status: IStatus; context: IExternalContext);
	  procedure closeAttachment(status: IStatus; context: IExternalContext);
	  function makeFunction(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction;
	  function makeProcedure(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure;
	  function makeTrigger(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger;
	end;

	IExternalEngineImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 10;
	public
	  constructor create;
	  function getInterface: IExternalEngine;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure open(status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal); virtual; abstract;
	  procedure openAttachment(status: IStatus; context: IExternalContext); virtual; abstract;
	  procedure closeAttachment(status: IStatus; context: IExternalContext); virtual; abstract;
	  function makeFunction(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction; virtual; abstract;
	  function makeProcedure(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure; virtual; abstract;
	  function makeTrigger(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger; virtual; abstract;
	end;

	PTimerVTable = ^TimerVTable;
	TimerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  handler: ITimer_handlerPtr;
	end;

	ITimerImpl = class;

	TTimer = record
	private
	  nullPtr: pointer;
	  vTable: PTimerVTable;
	  owner: ITimerImpl; {Only valid if isITimerImpl returns true }
	  function thisRecord: ITimer inline;
	public
	  function isITimerImpl: boolean;
	  function getITimerImpl: ITimerImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure handler();
	end;

	ITimerImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: ITimer;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure handler(); virtual; abstract;
	end;

	PTimerControlVTable = ^TimerControlVTable;
	TimerControlVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  start: ITimerControl_startPtr;
	  stop: ITimerControl_stopPtr;
	end;

	ITimerControlImpl = class;

	TTimerControl = record
	private
	  nullPtr: pointer;
	  vTable: PTimerControlVTable;
	  owner: ITimerControlImpl; {Only valid if isITimerControlImpl returns true }
	  function thisRecord: ITimerControl inline;
	public
	  function isITimerControlImpl: boolean;
	  function getITimerControlImpl: ITimerControlImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure start(status: IStatus; timer: ITimer; microSeconds: QWord);
	  procedure stop(status: IStatus; timer: ITimer);
	end;

	ITimerControlImpl = class(IVersionedImpl)
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function getInterface: ITimerControl;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure start(status: IStatus; timer: ITimer; microSeconds: QWord); virtual; abstract;
	  procedure stop(status: IStatus; timer: ITimer); virtual; abstract;
	end;

	PVersionCallbackVTable = ^VersionCallbackVTable;
	VersionCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  callback: IVersionCallback_callbackPtr;
	end;

	IVersionCallbackImpl = class;

	TVersionCallback = record
	private
	  nullPtr: pointer;
	  vTable: PVersionCallbackVTable;
	  owner: IVersionCallbackImpl; {Only valid if isIVersionCallbackImpl returns true }
	  function thisRecord: IVersionCallback inline;
	public
	  function isIVersionCallbackImpl: boolean;
	  function getIVersionCallbackImpl: IVersionCallbackImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure callback(status: IStatus; text: PAnsiChar);
	end;

	IVersionCallbackImpl = class(IVersionedImpl)
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function getInterface: IVersionCallback;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure callback(status: IStatus; text: PAnsiChar); virtual; abstract;
	end;

	PUtilVTable = ^UtilVTable;
	UtilVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getFbVersion: IUtil_getFbVersionPtr;
	  loadBlob: IUtil_loadBlobPtr;
	  dumpBlob: IUtil_dumpBlobPtr;
	  getPerfCounters: IUtil_getPerfCountersPtr;
	  executeCreateDatabase: IUtil_executeCreateDatabasePtr;
	  decodeDate: IUtil_decodeDatePtr;
	  decodeTime: IUtil_decodeTimePtr;
	  encodeDate: IUtil_encodeDatePtr;
	  encodeTime: IUtil_encodeTimePtr;
	  formatStatus: IUtil_formatStatusPtr;
	  getClientVersion: IUtil_getClientVersionPtr;
	  getXpbBuilder: IUtil_getXpbBuilderPtr;
	  setOffsets: IUtil_setOffsetsPtr;
	  getDecFloat16: IUtil_getDecFloat16Ptr;
	  getDecFloat34: IUtil_getDecFloat34Ptr;
	  decodeTimeTz: IUtil_decodeTimeTzPtr;
	  decodeTimeStampTz: IUtil_decodeTimeStampTzPtr;
	  encodeTimeTz: IUtil_encodeTimeTzPtr;
	  encodeTimeStampTz: IUtil_encodeTimeStampTzPtr;
	  getInt128: IUtil_getInt128Ptr;
	  decodeTimeTzEx: IUtil_decodeTimeTzExPtr;
	  decodeTimeStampTzEx: IUtil_decodeTimeStampTzExPtr;
	end;

	IUtilImpl = class;

	TUtil = record
	private
	  nullPtr: pointer;
	  vTable: PUtilVTable;
	  owner: IUtilImpl; {Only valid if isIUtilImpl returns true }
	  function thisRecord: IUtil inline;
	public
	  function isIUtilImpl: boolean;
	  function getIUtilImpl: IUtilImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure getFbVersion(status: IStatus; att: IAttachment; callback: IVersionCallback);
	  procedure loadBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
	  procedure dumpBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
	  procedure getPerfCounters(status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr);
	  function executeCreateDatabase(status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment;
	  procedure decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr);
	  procedure decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr);
	  function encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE;
	  function encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME;
	  function formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal;
	  function getClientVersion(): Cardinal;
	  function getXpbBuilder(status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder;
	  function setOffsets(status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal;
	  function getDecFloat16(status: IStatus): IDecFloat16;
	  function getDecFloat34(status: IStatus): IDecFloat34;
	  procedure decodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure decodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure encodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
	  procedure encodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
	  function getInt128(status: IStatus): IInt128;
	  procedure decodeTimeTzEx(status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	  procedure decodeTimeStampTzEx(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
	end;

	IUtilImpl = class(IVersionedImpl)
	public
	  const VERSION = 22;
	public
	  constructor create;
	  function getInterface: IUtil;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure getFbVersion(status: IStatus; att: IAttachment; callback: IVersionCallback); virtual; abstract;
	  procedure loadBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); virtual; abstract;
	  procedure dumpBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); virtual; abstract;
	  procedure getPerfCounters(status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr); virtual; abstract;
	  function executeCreateDatabase(status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment; virtual; abstract;
	  procedure decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); virtual; abstract;
	  procedure decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); virtual; abstract;
	  function encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; virtual; abstract;
	  function encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; virtual; abstract;
	  function formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal; virtual; abstract;
	  function getClientVersion(): Cardinal; virtual; abstract;
	  function getXpbBuilder(status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder; virtual; abstract;
	  function setOffsets(status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal; virtual; abstract;
	  function getDecFloat16(status: IStatus): IDecFloat16; virtual; abstract;
	  function getDecFloat34(status: IStatus): IDecFloat34; virtual; abstract;
	  procedure decodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	  procedure decodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	  procedure encodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); virtual; abstract;
	  procedure encodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); virtual; abstract;
	  function getInt128(status: IStatus): IInt128; virtual; abstract;
	  procedure decodeTimeTzEx(status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	  procedure decodeTimeStampTzEx(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); virtual; abstract;
	end;

	POffsetsCallbackVTable = ^OffsetsCallbackVTable;
	OffsetsCallbackVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  setOffset: IOffsetsCallback_setOffsetPtr;
	end;

	IOffsetsCallbackImpl = class;

	TOffsetsCallback = record
	private
	  nullPtr: pointer;
	  vTable: POffsetsCallbackVTable;
	  owner: IOffsetsCallbackImpl; {Only valid if isIOffsetsCallbackImpl returns true }
	  function thisRecord: IOffsetsCallback inline;
	public
	  function isIOffsetsCallbackImpl: boolean;
	  function getIOffsetsCallbackImpl: IOffsetsCallbackImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure setOffset(status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal);
	end;

	IOffsetsCallbackImpl = class(IVersionedImpl)
	public
	  const VERSION = 1;
	public
	  constructor create;
	  function getInterface: IOffsetsCallback;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setOffset(status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); virtual; abstract;
	end;

	PXpbBuilderVTable = ^XpbBuilderVTable;
	XpbBuilderVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  clear: IXpbBuilder_clearPtr;
	  removeCurrent: IXpbBuilder_removeCurrentPtr;
	  insertInt: IXpbBuilder_insertIntPtr;
	  insertBigInt: IXpbBuilder_insertBigIntPtr;
	  insertBytes: IXpbBuilder_insertBytesPtr;
	  insertString: IXpbBuilder_insertStringPtr;
	  insertTag: IXpbBuilder_insertTagPtr;
	  isEof: IXpbBuilder_isEofPtr;
	  moveNext: IXpbBuilder_moveNextPtr;
	  rewind: IXpbBuilder_rewindPtr;
	  findFirst: IXpbBuilder_findFirstPtr;
	  findNext: IXpbBuilder_findNextPtr;
	  getTag: IXpbBuilder_getTagPtr;
	  getLength: IXpbBuilder_getLengthPtr;
	  getInt: IXpbBuilder_getIntPtr;
	  getBigInt: IXpbBuilder_getBigIntPtr;
	  getString: IXpbBuilder_getStringPtr;
	  getBytes: IXpbBuilder_getBytesPtr;
	  getBufferLength: IXpbBuilder_getBufferLengthPtr;
	  getBuffer: IXpbBuilder_getBufferPtr;
	end;

	IXpbBuilderImpl = class;

	TXpbBuilder = record
	private
	  nullPtr: pointer;
	  vTable: PXpbBuilderVTable;
	  owner: IXpbBuilderImpl; {Only valid if isIXpbBuilderImpl returns true }
	  function thisRecord: IXpbBuilder inline;
	public
	  function isIXpbBuilderImpl: boolean;
	  function getIXpbBuilderImpl: IXpbBuilderImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure clear(status: IStatus);
	  procedure removeCurrent(status: IStatus);
	  procedure insertInt(status: IStatus; tag: Byte; value: Integer);
	  procedure insertBigInt(status: IStatus; tag: Byte; value: Int64);
	  procedure insertBytes(status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal);
	  procedure insertString(status: IStatus; tag: Byte; str: PAnsiChar);
	  procedure insertTag(status: IStatus; tag: Byte);
	  function isEof(status: IStatus): Boolean;
	  procedure moveNext(status: IStatus);
	  procedure rewind(status: IStatus);
	  function findFirst(status: IStatus; tag: Byte): Boolean;
	  function findNext(status: IStatus): Boolean;
	  function getTag(status: IStatus): Byte;
	  function getLength(status: IStatus): Cardinal;
	  function getInt(status: IStatus): Integer;
	  function getBigInt(status: IStatus): Int64;
	  function getString(status: IStatus): PAnsiChar;
	  function getBytes(status: IStatus): BytePtr;
	  function getBufferLength(status: IStatus): Cardinal;
	  function getBuffer(status: IStatus): BytePtr;
	end;

	IXpbBuilderImpl = class(IDisposableImpl)
	public
	  const VERSION = 21;
	  const DPB = Cardinal(1);
	  const SPB_ATTACH = Cardinal(2);
	  const SPB_START = Cardinal(3);
	  const TPB = Cardinal(4);
	  const BATCH = Cardinal(5);
	  const BPB = Cardinal(6);
	  const SPB_SEND = Cardinal(7);
	  const SPB_RECEIVE = Cardinal(8);
	  const SPB_RESPONSE = Cardinal(9);
	public
	  constructor create;
	  function getInterface: IXpbBuilder;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure clear(status: IStatus); virtual; abstract;
	  procedure removeCurrent(status: IStatus); virtual; abstract;
	  procedure insertInt(status: IStatus; tag: Byte; value: Integer); virtual; abstract;
	  procedure insertBigInt(status: IStatus; tag: Byte; value: Int64); virtual; abstract;
	  procedure insertBytes(status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal); virtual; abstract;
	  procedure insertString(status: IStatus; tag: Byte; str: PAnsiChar); virtual; abstract;
	  procedure insertTag(status: IStatus; tag: Byte); virtual; abstract;
	  function isEof(status: IStatus): Boolean; virtual; abstract;
	  procedure moveNext(status: IStatus); virtual; abstract;
	  procedure rewind(status: IStatus); virtual; abstract;
	  function findFirst(status: IStatus; tag: Byte): Boolean; virtual; abstract;
	  function findNext(status: IStatus): Boolean; virtual; abstract;
	  function getTag(status: IStatus): Byte; virtual; abstract;
	  function getLength(status: IStatus): Cardinal; virtual; abstract;
	  function getInt(status: IStatus): Integer; virtual; abstract;
	  function getBigInt(status: IStatus): Int64; virtual; abstract;
	  function getString(status: IStatus): PAnsiChar; virtual; abstract;
	  function getBytes(status: IStatus): BytePtr; virtual; abstract;
	  function getBufferLength(status: IStatus): Cardinal; virtual; abstract;
	  function getBuffer(status: IStatus): BytePtr; virtual; abstract;
	end;

	PTraceConnectionVTable = ^TraceConnectionVTable;
	TraceConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	end;

	ITraceConnectionImpl = class;

	TTraceConnection = record
	private
	  nullPtr: pointer;
	  vTable: PTraceConnectionVTable;
	  owner: ITraceConnectionImpl; {Only valid if isITraceConnectionImpl returns true }
	  function thisRecord: ITraceConnection inline;
	public
	  function isITraceConnectionImpl: boolean;
	  function getITraceConnectionImpl: ITraceConnectionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	end;

	ITraceConnectionImpl = class(IVersionedImpl)
	public
	  const VERSION = 9;
	  const KIND_DATABASE = Cardinal(1);
	  const KIND_SERVICE = Cardinal(2);
	public
	  constructor create;
	  function getInterface: ITraceConnection;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getKind(): Cardinal; virtual; abstract;
	  function getProcessID(): Integer; virtual; abstract;
	  function getUserName(): PAnsiChar; virtual; abstract;
	  function getRoleName(): PAnsiChar; virtual; abstract;
	  function getCharSet(): PAnsiChar; virtual; abstract;
	  function getRemoteProtocol(): PAnsiChar; virtual; abstract;
	  function getRemoteAddress(): PAnsiChar; virtual; abstract;
	  function getRemoteProcessID(): Integer; virtual; abstract;
	  function getRemoteProcessName(): PAnsiChar; virtual; abstract;
	end;

	PTraceDatabaseConnectionVTable = ^TraceDatabaseConnectionVTable;
	TraceDatabaseConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	  getConnectionID: ITraceDatabaseConnection_getConnectionIDPtr;
	  getDatabaseName: ITraceDatabaseConnection_getDatabaseNamePtr;
	end;

	ITraceDatabaseConnectionImpl = class;

	TTraceDatabaseConnection = record
	private
	  nullPtr: pointer;
	  vTable: PTraceDatabaseConnectionVTable;
	  owner: ITraceDatabaseConnectionImpl; {Only valid if isITraceDatabaseConnectionImpl returns true }
	  function thisRecord: ITraceDatabaseConnection inline;
	public
	  function isITraceDatabaseConnectionImpl: boolean;
	  function getITraceDatabaseConnectionImpl: ITraceDatabaseConnectionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  function getConnectionID(): Int64;
	  function getDatabaseName(): PAnsiChar;
	end;

	ITraceDatabaseConnectionImpl = class(ITraceConnectionImpl)
	public
	  const VERSION = 11;
	public
	  constructor create;
	  function getInterface: ITraceDatabaseConnection;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getConnectionID(): Int64; virtual; abstract;
	  function getDatabaseName(): PAnsiChar; virtual; abstract;
	end;

	PTraceTransactionVTable = ^TraceTransactionVTable;
	TraceTransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getTransactionID: ITraceTransaction_getTransactionIDPtr;
	  getReadOnly: ITraceTransaction_getReadOnlyPtr;
	  getWait: ITraceTransaction_getWaitPtr;
	  getIsolation: ITraceTransaction_getIsolationPtr;
	  getPerf: ITraceTransaction_getPerfPtr;
	  getInitialID: ITraceTransaction_getInitialIDPtr;
	  getPreviousID: ITraceTransaction_getPreviousIDPtr;
	end;

	ITraceTransactionImpl = class;

	TTraceTransaction = record
	private
	  nullPtr: pointer;
	  vTable: PTraceTransactionVTable;
	  owner: ITraceTransactionImpl; {Only valid if isITraceTransactionImpl returns true }
	  function thisRecord: ITraceTransaction inline;
	public
	  function isITraceTransactionImpl: boolean;
	  function getITraceTransactionImpl: ITraceTransactionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getTransactionID(): Int64;
	  function getReadOnly(): Boolean;
	  function getWait(): Integer;
	  function getIsolation(): Cardinal;
	  function getPerf(): PerformanceInfoPtr;
	  function getInitialID(): Int64;
	  function getPreviousID(): Int64;
	end;

	ITraceTransactionImpl = class(IVersionedImpl)
	public
	  const VERSION = 7;
	  const ISOLATION_CONSISTENCY = Cardinal(1);
	  const ISOLATION_CONCURRENCY = Cardinal(2);
	  const ISOLATION_READ_COMMITTED_RECVER = Cardinal(3);
	  const ISOLATION_READ_COMMITTED_NORECVER = Cardinal(4);
	  const ISOLATION_READ_COMMITTED_READ_CONSISTENCY = Cardinal(5);
	public
	  constructor create;
	  function getInterface: ITraceTransaction;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getTransactionID(): Int64; virtual; abstract;
	  function getReadOnly(): Boolean; virtual; abstract;
	  function getWait(): Integer; virtual; abstract;
	  function getIsolation(): Cardinal; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	  function getInitialID(): Int64; virtual; abstract;
	  function getPreviousID(): Int64; virtual; abstract;
	end;

	PTraceParamsVTable = ^TraceParamsVTable;
	TraceParamsVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getCount: ITraceParams_getCountPtr;
	  getParam: ITraceParams_getParamPtr;
	  getTextUTF8: ITraceParams_getTextUTF8Ptr;
	end;

	ITraceParamsImpl = class;

	TTraceParams = record
	private
	  nullPtr: pointer;
	  vTable: PTraceParamsVTable;
	  owner: ITraceParamsImpl; {Only valid if isITraceParamsImpl returns true }
	  function thisRecord: ITraceParams inline;
	public
	  function isITraceParamsImpl: boolean;
	  function getITraceParamsImpl: ITraceParamsImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getCount(): Cardinal;
	  function getParam(idx: Cardinal): dscPtr;
	  function getTextUTF8(status: IStatus; idx: Cardinal): PAnsiChar;
	end;

	ITraceParamsImpl = class(IVersionedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: ITraceParams;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getCount(): Cardinal; virtual; abstract;
	  function getParam(idx: Cardinal): dscPtr; virtual; abstract;
	  function getTextUTF8(status: IStatus; idx: Cardinal): PAnsiChar; virtual; abstract;
	end;

	PTraceStatementVTable = ^TraceStatementVTable;
	TraceStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	end;

	ITraceStatementImpl = class;

	TTraceStatement = record
	private
	  nullPtr: pointer;
	  vTable: PTraceStatementVTable;
	  owner: ITraceStatementImpl; {Only valid if isITraceStatementImpl returns true }
	  function thisRecord: ITraceStatement inline;
	public
	  function isITraceStatementImpl: boolean;
	  function getITraceStatementImpl: ITraceStatementImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceStatementImpl = class(IVersionedImpl)
	public
	  const VERSION = 2;
	public
	  constructor create;
	  function getInterface: ITraceStatement;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getStmtID(): Int64; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceSQLStatementVTable = ^TraceSQLStatementVTable;
	TraceSQLStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	  getText: ITraceSQLStatement_getTextPtr;
	  getPlan: ITraceSQLStatement_getPlanPtr;
	  getInputs: ITraceSQLStatement_getInputsPtr;
	  getTextUTF8: ITraceSQLStatement_getTextUTF8Ptr;
	  getExplainedPlan: ITraceSQLStatement_getExplainedPlanPtr;
	end;

	ITraceSQLStatementImpl = class;

	TTraceSQLStatement = record
	private
	  nullPtr: pointer;
	  vTable: PTraceSQLStatementVTable;
	  owner: ITraceSQLStatementImpl; {Only valid if isITraceSQLStatementImpl returns true }
	  function thisRecord: ITraceSQLStatement inline;
	public
	  function isITraceSQLStatementImpl: boolean;
	  function getITraceSQLStatementImpl: ITraceSQLStatementImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  function getText(): PAnsiChar;
	  function getPlan(): PAnsiChar;
	  function getInputs(): ITraceParams;
	  function getTextUTF8(): PAnsiChar;
	  function getExplainedPlan(): PAnsiChar;
	end;

	ITraceSQLStatementImpl = class(ITraceStatementImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: ITraceSQLStatement;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getText(): PAnsiChar; virtual; abstract;
	  function getPlan(): PAnsiChar; virtual; abstract;
	  function getInputs(): ITraceParams; virtual; abstract;
	  function getTextUTF8(): PAnsiChar; virtual; abstract;
	  function getExplainedPlan(): PAnsiChar; virtual; abstract;
	end;

	PTraceBLRStatementVTable = ^TraceBLRStatementVTable;
	TraceBLRStatementVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getStmtID: ITraceStatement_getStmtIDPtr;
	  getPerf: ITraceStatement_getPerfPtr;
	  getData: ITraceBLRStatement_getDataPtr;
	  getDataLength: ITraceBLRStatement_getDataLengthPtr;
	  getText: ITraceBLRStatement_getTextPtr;
	end;

	ITraceBLRStatementImpl = class;

	TTraceBLRStatement = record
	private
	  nullPtr: pointer;
	  vTable: PTraceBLRStatementVTable;
	  owner: ITraceBLRStatementImpl; {Only valid if isITraceBLRStatementImpl returns true }
	  function thisRecord: ITraceBLRStatement inline;
	public
	  function isITraceBLRStatementImpl: boolean;
	  function getITraceBLRStatementImpl: ITraceBLRStatementImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getStmtID(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	  function getData(): BytePtr;
	  function getDataLength(): Cardinal;
	  function getText(): PAnsiChar;
	end;

	ITraceBLRStatementImpl = class(ITraceStatementImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: ITraceBLRStatement;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getData(): BytePtr; virtual; abstract;
	  function getDataLength(): Cardinal; virtual; abstract;
	  function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceDYNRequestVTable = ^TraceDYNRequestVTable;
	TraceDYNRequestVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getData: ITraceDYNRequest_getDataPtr;
	  getDataLength: ITraceDYNRequest_getDataLengthPtr;
	  getText: ITraceDYNRequest_getTextPtr;
	end;

	ITraceDYNRequestImpl = class;

	TTraceDYNRequest = record
	private
	  nullPtr: pointer;
	  vTable: PTraceDYNRequestVTable;
	  owner: ITraceDYNRequestImpl; {Only valid if isITraceDYNRequestImpl returns true }
	  function thisRecord: ITraceDYNRequest inline;
	public
	  function isITraceDYNRequestImpl: boolean;
	  function getITraceDYNRequestImpl: ITraceDYNRequestImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getData(): BytePtr;
	  function getDataLength(): Cardinal;
	  function getText(): PAnsiChar;
	end;

	ITraceDYNRequestImpl = class(IVersionedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: ITraceDYNRequest;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getData(): BytePtr; virtual; abstract;
	  function getDataLength(): Cardinal; virtual; abstract;
	  function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceContextVariableVTable = ^TraceContextVariableVTable;
	TraceContextVariableVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getNameSpace: ITraceContextVariable_getNameSpacePtr;
	  getVarName: ITraceContextVariable_getVarNamePtr;
	  getVarValue: ITraceContextVariable_getVarValuePtr;
	end;

	ITraceContextVariableImpl = class;

	TTraceContextVariable = record
	private
	  nullPtr: pointer;
	  vTable: PTraceContextVariableVTable;
	  owner: ITraceContextVariableImpl; {Only valid if isITraceContextVariableImpl returns true }
	  function thisRecord: ITraceContextVariable inline;
	public
	  function isITraceContextVariableImpl: boolean;
	  function getITraceContextVariableImpl: ITraceContextVariableImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getNameSpace(): PAnsiChar;
	  function getVarName(): PAnsiChar;
	  function getVarValue(): PAnsiChar;
	end;

	ITraceContextVariableImpl = class(IVersionedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: ITraceContextVariable;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getNameSpace(): PAnsiChar; virtual; abstract;
	  function getVarName(): PAnsiChar; virtual; abstract;
	  function getVarValue(): PAnsiChar; virtual; abstract;
	end;

	PTraceProcedureVTable = ^TraceProcedureVTable;
	TraceProcedureVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getProcName: ITraceProcedure_getProcNamePtr;
	  getInputs: ITraceProcedure_getInputsPtr;
	  getPerf: ITraceProcedure_getPerfPtr;
	end;

	ITraceProcedureImpl = class;

	TTraceProcedure = record
	private
	  nullPtr: pointer;
	  vTable: PTraceProcedureVTable;
	  owner: ITraceProcedureImpl; {Only valid if isITraceProcedureImpl returns true }
	  function thisRecord: ITraceProcedure inline;
	public
	  function isITraceProcedureImpl: boolean;
	  function getITraceProcedureImpl: ITraceProcedureImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getProcName(): PAnsiChar;
	  function getInputs(): ITraceParams;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceProcedureImpl = class(IVersionedImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: ITraceProcedure;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getProcName(): PAnsiChar; virtual; abstract;
	  function getInputs(): ITraceParams; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceFunctionVTable = ^TraceFunctionVTable;
	TraceFunctionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getFuncName: ITraceFunction_getFuncNamePtr;
	  getInputs: ITraceFunction_getInputsPtr;
	  getResult: ITraceFunction_getResultPtr;
	  getPerf: ITraceFunction_getPerfPtr;
	end;

	ITraceFunctionImpl = class;

	TTraceFunction = record
	private
	  nullPtr: pointer;
	  vTable: PTraceFunctionVTable;
	  owner: ITraceFunctionImpl; {Only valid if isITraceFunctionImpl returns true }
	  function thisRecord: ITraceFunction inline;
	public
	  function isITraceFunctionImpl: boolean;
	  function getITraceFunctionImpl: ITraceFunctionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getFuncName(): PAnsiChar;
	  function getInputs(): ITraceParams;
	  function getResult(): ITraceParams;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceFunctionImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: ITraceFunction;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getFuncName(): PAnsiChar; virtual; abstract;
	  function getInputs(): ITraceParams; virtual; abstract;
	  function getResult(): ITraceParams; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceTriggerVTable = ^TraceTriggerVTable;
	TraceTriggerVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getTriggerName: ITraceTrigger_getTriggerNamePtr;
	  getRelationName: ITraceTrigger_getRelationNamePtr;
	  getAction: ITraceTrigger_getActionPtr;
	  getWhich: ITraceTrigger_getWhichPtr;
	  getPerf: ITraceTrigger_getPerfPtr;
	end;

	ITraceTriggerImpl = class;

	TTraceTrigger = record
	private
	  nullPtr: pointer;
	  vTable: PTraceTriggerVTable;
	  owner: ITraceTriggerImpl; {Only valid if isITraceTriggerImpl returns true }
	  function thisRecord: ITraceTrigger inline;
	public
	  function isITraceTriggerImpl: boolean;
	  function getITraceTriggerImpl: ITraceTriggerImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getTriggerName(): PAnsiChar;
	  function getRelationName(): PAnsiChar;
	  function getAction(): Integer;
	  function getWhich(): Integer;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceTriggerImpl = class(IVersionedImpl)
	public
	  const VERSION = 5;
	  const TYPE_ALL = Cardinal(0);
	  const TYPE_BEFORE = Cardinal(1);
	  const TYPE_AFTER = Cardinal(2);
	public
	  constructor create;
	  function getInterface: ITraceTrigger;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getTriggerName(): PAnsiChar; virtual; abstract;
	  function getRelationName(): PAnsiChar; virtual; abstract;
	  function getAction(): Integer; virtual; abstract;
	  function getWhich(): Integer; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceServiceConnectionVTable = ^TraceServiceConnectionVTable;
	TraceServiceConnectionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getKind: ITraceConnection_getKindPtr;
	  getProcessID: ITraceConnection_getProcessIDPtr;
	  getUserName: ITraceConnection_getUserNamePtr;
	  getRoleName: ITraceConnection_getRoleNamePtr;
	  getCharSet: ITraceConnection_getCharSetPtr;
	  getRemoteProtocol: ITraceConnection_getRemoteProtocolPtr;
	  getRemoteAddress: ITraceConnection_getRemoteAddressPtr;
	  getRemoteProcessID: ITraceConnection_getRemoteProcessIDPtr;
	  getRemoteProcessName: ITraceConnection_getRemoteProcessNamePtr;
	  getServiceID: ITraceServiceConnection_getServiceIDPtr;
	  getServiceMgr: ITraceServiceConnection_getServiceMgrPtr;
	  getServiceName: ITraceServiceConnection_getServiceNamePtr;
	end;

	ITraceServiceConnectionImpl = class;

	TTraceServiceConnection = record
	private
	  nullPtr: pointer;
	  vTable: PTraceServiceConnectionVTable;
	  owner: ITraceServiceConnectionImpl; {Only valid if isITraceServiceConnectionImpl returns true }
	  function thisRecord: ITraceServiceConnection inline;
	public
	  function isITraceServiceConnectionImpl: boolean;
	  function getITraceServiceConnectionImpl: ITraceServiceConnectionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getKind(): Cardinal;
	  function getProcessID(): Integer;
	  function getUserName(): PAnsiChar;
	  function getRoleName(): PAnsiChar;
	  function getCharSet(): PAnsiChar;
	  function getRemoteProtocol(): PAnsiChar;
	  function getRemoteAddress(): PAnsiChar;
	  function getRemoteProcessID(): Integer;
	  function getRemoteProcessName(): PAnsiChar;
	  function getServiceID(): Pointer;
	  function getServiceMgr(): PAnsiChar;
	  function getServiceName(): PAnsiChar;
	end;

	ITraceServiceConnectionImpl = class(ITraceConnectionImpl)
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function getInterface: ITraceServiceConnection;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getServiceID(): Pointer; virtual; abstract;
	  function getServiceMgr(): PAnsiChar; virtual; abstract;
	  function getServiceName(): PAnsiChar; virtual; abstract;
	end;

	PTraceStatusVectorVTable = ^TraceStatusVectorVTable;
	TraceStatusVectorVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  hasError: ITraceStatusVector_hasErrorPtr;
	  hasWarning: ITraceStatusVector_hasWarningPtr;
	  getStatus: ITraceStatusVector_getStatusPtr;
	  getText: ITraceStatusVector_getTextPtr;
	end;

	ITraceStatusVectorImpl = class;

	TTraceStatusVector = record
	private
	  nullPtr: pointer;
	  vTable: PTraceStatusVectorVTable;
	  owner: ITraceStatusVectorImpl; {Only valid if isITraceStatusVectorImpl returns true }
	  function thisRecord: ITraceStatusVector inline;
	public
	  function isITraceStatusVectorImpl: boolean;
	  function getITraceStatusVectorImpl: ITraceStatusVectorImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function hasError(): Boolean;
	  function hasWarning(): Boolean;
	  function getStatus(): IStatus;
	  function getText(): PAnsiChar;
	end;

	ITraceStatusVectorImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: ITraceStatusVector;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function hasError(): Boolean; virtual; abstract;
	  function hasWarning(): Boolean; virtual; abstract;
	  function getStatus(): IStatus; virtual; abstract;
	  function getText(): PAnsiChar; virtual; abstract;
	end;

	PTraceSweepInfoVTable = ^TraceSweepInfoVTable;
	TraceSweepInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getOIT: ITraceSweepInfo_getOITPtr;
	  getOST: ITraceSweepInfo_getOSTPtr;
	  getOAT: ITraceSweepInfo_getOATPtr;
	  getNext: ITraceSweepInfo_getNextPtr;
	  getPerf: ITraceSweepInfo_getPerfPtr;
	end;

	ITraceSweepInfoImpl = class;

	TTraceSweepInfo = record
	private
	  nullPtr: pointer;
	  vTable: PTraceSweepInfoVTable;
	  owner: ITraceSweepInfoImpl; {Only valid if isITraceSweepInfoImpl returns true }
	  function thisRecord: ITraceSweepInfo inline;
	public
	  function isITraceSweepInfoImpl: boolean;
	  function getITraceSweepInfoImpl: ITraceSweepInfoImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getOIT(): Int64;
	  function getOST(): Int64;
	  function getOAT(): Int64;
	  function getNext(): Int64;
	  function getPerf(): PerformanceInfoPtr;
	end;

	ITraceSweepInfoImpl = class(IVersionedImpl)
	public
	  const VERSION = 5;
	public
	  constructor create;
	  function getInterface: ITraceSweepInfo;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getOIT(): Int64; virtual; abstract;
	  function getOST(): Int64; virtual; abstract;
	  function getOAT(): Int64; virtual; abstract;
	  function getNext(): Int64; virtual; abstract;
	  function getPerf(): PerformanceInfoPtr; virtual; abstract;
	end;

	PTraceLogWriterVTable = ^TraceLogWriterVTable;
	TraceLogWriterVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  write: ITraceLogWriter_writePtr;
	  write_s: ITraceLogWriter_write_sPtr;
	end;

	ITraceLogWriterImpl = class;

	TTraceLogWriter = record
	private
	  nullPtr: pointer;
	  vTable: PTraceLogWriterVTable;
	  owner: ITraceLogWriterImpl; {Only valid if isITraceLogWriterImpl returns true }
	  function thisRecord: ITraceLogWriter inline;
	public
	  function isITraceLogWriterImpl: boolean;
	  function getITraceLogWriterImpl: ITraceLogWriterImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function write(buf: Pointer; size: Cardinal): Cardinal;
	  function write_s(status: IStatus; buf: Pointer; size: Cardinal): Cardinal;
	end;

	ITraceLogWriterImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: ITraceLogWriter;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function write(buf: Pointer; size: Cardinal): Cardinal; virtual; abstract;
	  function write_s(status: IStatus; buf: Pointer; size: Cardinal): Cardinal; virtual; abstract;
	end;

	PTraceInitInfoVTable = ^TraceInitInfoVTable;
	TraceInitInfoVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getConfigText: ITraceInitInfo_getConfigTextPtr;
	  getTraceSessionID: ITraceInitInfo_getTraceSessionIDPtr;
	  getTraceSessionName: ITraceInitInfo_getTraceSessionNamePtr;
	  getFirebirdRootDirectory: ITraceInitInfo_getFirebirdRootDirectoryPtr;
	  getDatabaseName: ITraceInitInfo_getDatabaseNamePtr;
	  getConnection: ITraceInitInfo_getConnectionPtr;
	  getLogWriter: ITraceInitInfo_getLogWriterPtr;
	end;

	ITraceInitInfoImpl = class;

	TTraceInitInfo = record
	private
	  nullPtr: pointer;
	  vTable: PTraceInitInfoVTable;
	  owner: ITraceInitInfoImpl; {Only valid if isITraceInitInfoImpl returns true }
	  function thisRecord: ITraceInitInfo inline;
	public
	  function isITraceInitInfoImpl: boolean;
	  function getITraceInitInfoImpl: ITraceInitInfoImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getConfigText(): PAnsiChar;
	  function getTraceSessionID(): Integer;
	  function getTraceSessionName(): PAnsiChar;
	  function getFirebirdRootDirectory(): PAnsiChar;
	  function getDatabaseName(): PAnsiChar;
	  function getConnection(): ITraceDatabaseConnection;
	  function getLogWriter(): ITraceLogWriter;
	end;

	ITraceInitInfoImpl = class(IVersionedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: ITraceInitInfo;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getConfigText(): PAnsiChar; virtual; abstract;
	  function getTraceSessionID(): Integer; virtual; abstract;
	  function getTraceSessionName(): PAnsiChar; virtual; abstract;
	  function getFirebirdRootDirectory(): PAnsiChar; virtual; abstract;
	  function getDatabaseName(): PAnsiChar; virtual; abstract;
	  function getConnection(): ITraceDatabaseConnection; virtual; abstract;
	  function getLogWriter(): ITraceLogWriter; virtual; abstract;
	end;

	PTracePluginVTable = ^TracePluginVTable;
	TracePluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  trace_get_error: ITracePlugin_trace_get_errorPtr;
	  trace_attach: ITracePlugin_trace_attachPtr;
	  trace_detach: ITracePlugin_trace_detachPtr;
	  trace_transaction_start: ITracePlugin_trace_transaction_startPtr;
	  trace_transaction_end: ITracePlugin_trace_transaction_endPtr;
	  trace_proc_execute: ITracePlugin_trace_proc_executePtr;
	  trace_trigger_execute: ITracePlugin_trace_trigger_executePtr;
	  trace_set_context: ITracePlugin_trace_set_contextPtr;
	  trace_dsql_prepare: ITracePlugin_trace_dsql_preparePtr;
	  trace_dsql_free: ITracePlugin_trace_dsql_freePtr;
	  trace_dsql_execute: ITracePlugin_trace_dsql_executePtr;
	  trace_blr_compile: ITracePlugin_trace_blr_compilePtr;
	  trace_blr_execute: ITracePlugin_trace_blr_executePtr;
	  trace_dyn_execute: ITracePlugin_trace_dyn_executePtr;
	  trace_service_attach: ITracePlugin_trace_service_attachPtr;
	  trace_service_start: ITracePlugin_trace_service_startPtr;
	  trace_service_query: ITracePlugin_trace_service_queryPtr;
	  trace_service_detach: ITracePlugin_trace_service_detachPtr;
	  trace_event_error: ITracePlugin_trace_event_errorPtr;
	  trace_event_sweep: ITracePlugin_trace_event_sweepPtr;
	  trace_func_execute: ITracePlugin_trace_func_executePtr;
	end;

	ITracePluginImpl = class;

	TTracePlugin = record
	private
	  nullPtr: pointer;
	  vTable: PTracePluginVTable;
	  owner: ITracePluginImpl; {Only valid if isITracePluginImpl returns true }
	  function thisRecord: ITracePlugin inline;
	public
	  function isITracePluginImpl: boolean;
	  function getITracePluginImpl: ITracePluginImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  function trace_get_error(): PAnsiChar;
	  function trace_attach(connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean;
	  function trace_detach(connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean;
	  function trace_transaction_start(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean;
	  function trace_transaction_end(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean;
	  function trace_proc_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean;
	  function trace_trigger_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean;
	  function trace_set_context(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean;
	  function trace_dsql_prepare(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_dsql_free(connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean;
	  function trace_dsql_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean;
	  function trace_blr_compile(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_blr_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean;
	  function trace_dyn_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean;
	  function trace_service_attach(service: ITraceServiceConnection; att_result: Cardinal): Boolean;
	  function trace_service_start(service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean;
	  function trace_service_query(service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean;
	  function trace_service_detach(service: ITraceServiceConnection; detach_result: Cardinal): Boolean;
	  function trace_event_error(connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean;
	  function trace_event_sweep(connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean;
	  function trace_func_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean;
	end;

	ITracePluginImpl = class(IReferenceCountedImpl)
	public
	  const VERSION = 23;
	  const RESULT_SUCCESS = Cardinal(0);
	  const RESULT_FAILED = Cardinal(1);
	  const RESULT_UNAUTHORIZED = Cardinal(2);
	  const SWEEP_STATE_STARTED = Cardinal(1);
	  const SWEEP_STATE_FINISHED = Cardinal(2);
	  const SWEEP_STATE_FAILED = Cardinal(3);
	  const SWEEP_STATE_PROGRESS = Cardinal(4);
	public
	  constructor create;
	  function getInterface: ITracePlugin;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function trace_get_error(): PAnsiChar; virtual; abstract;
	  function trace_attach(connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean; virtual; abstract;
	  function trace_detach(connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean; virtual; abstract;
	  function trace_transaction_start(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; virtual; abstract;
	  function trace_transaction_end(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; virtual; abstract;
	  function trace_proc_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean; virtual; abstract;
	  function trace_trigger_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean; virtual; abstract;
	  function trace_set_context(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean; virtual; abstract;
	  function trace_dsql_prepare(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_dsql_free(connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean; virtual; abstract;
	  function trace_dsql_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_blr_compile(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_blr_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_dyn_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_attach(service: ITraceServiceConnection; att_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_start(service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_query(service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; virtual; abstract;
	  function trace_service_detach(service: ITraceServiceConnection; detach_result: Cardinal): Boolean; virtual; abstract;
	  function trace_event_error(connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean; virtual; abstract;
	  function trace_event_sweep(connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean; virtual; abstract;
	  function trace_func_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean; virtual; abstract;
	end;

	PTraceFactoryVTable = ^TraceFactoryVTable;
	TraceFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  trace_needs: ITraceFactory_trace_needsPtr;
	  trace_create: ITraceFactory_trace_createPtr;
	end;

	ITraceFactoryImpl = class;

	TTraceFactory = record
	private
	  nullPtr: pointer;
	  vTable: PTraceFactoryVTable;
	  owner: ITraceFactoryImpl; {Only valid if isITraceFactoryImpl returns true }
	  function thisRecord: ITraceFactory inline;
	public
	  function isITraceFactoryImpl: boolean;
	  function getITraceFactoryImpl: ITraceFactoryImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function trace_needs(): QWord;
	  function trace_create(status: IStatus; init_info: ITraceInitInfo): ITracePlugin;
	end;

	ITraceFactoryImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 6;
	  const TRACE_EVENT_ATTACH = Cardinal(0);
	  const TRACE_EVENT_DETACH = Cardinal(1);
	  const TRACE_EVENT_TRANSACTION_START = Cardinal(2);
	  const TRACE_EVENT_TRANSACTION_END = Cardinal(3);
	  const TRACE_EVENT_SET_CONTEXT = Cardinal(4);
	  const TRACE_EVENT_PROC_EXECUTE = Cardinal(5);
	  const TRACE_EVENT_TRIGGER_EXECUTE = Cardinal(6);
	  const TRACE_EVENT_DSQL_PREPARE = Cardinal(7);
	  const TRACE_EVENT_DSQL_FREE = Cardinal(8);
	  const TRACE_EVENT_DSQL_EXECUTE = Cardinal(9);
	  const TRACE_EVENT_BLR_COMPILE = Cardinal(10);
	  const TRACE_EVENT_BLR_EXECUTE = Cardinal(11);
	  const TRACE_EVENT_DYN_EXECUTE = Cardinal(12);
	  const TRACE_EVENT_SERVICE_ATTACH = Cardinal(13);
	  const TRACE_EVENT_SERVICE_START = Cardinal(14);
	  const TRACE_EVENT_SERVICE_QUERY = Cardinal(15);
	  const TRACE_EVENT_SERVICE_DETACH = Cardinal(16);
	  const TRACE_EVENT_ERROR = Cardinal(17);
	  const TRACE_EVENT_SWEEP = Cardinal(18);
	  const TRACE_EVENT_FUNC_EXECUTE = Cardinal(19);
	  const TRACE_EVENT_MAX = Cardinal(20);
	public
	  constructor create;
	  function getInterface: ITraceFactory;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function trace_needs(): QWord; virtual; abstract;
	  function trace_create(status: IStatus; init_info: ITraceInitInfo): ITracePlugin; virtual; abstract;
	end;

	PUdrFunctionFactoryVTable = ^UdrFunctionFactoryVTable;
	UdrFunctionFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrFunctionFactory_setupPtr;
	  newItem: IUdrFunctionFactory_newItemPtr;
	end;

	IUdrFunctionFactoryImpl = class;

	TUdrFunctionFactory = record
	private
	  nullPtr: pointer;
	  vTable: PUdrFunctionFactoryVTable;
	  owner: IUdrFunctionFactoryImpl; {Only valid if isIUdrFunctionFactoryImpl returns true }
	  function thisRecord: IUdrFunctionFactory inline;
	public
	  function isIUdrFunctionFactoryImpl: boolean;
	  function getIUdrFunctionFactoryImpl: IUdrFunctionFactoryImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction;
	end;

	IUdrFunctionFactoryImpl = class(IDisposableImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IUdrFunctionFactory;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); virtual; abstract;
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction; virtual; abstract;
	end;

	PUdrProcedureFactoryVTable = ^UdrProcedureFactoryVTable;
	UdrProcedureFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrProcedureFactory_setupPtr;
	  newItem: IUdrProcedureFactory_newItemPtr;
	end;

	IUdrProcedureFactoryImpl = class;

	TUdrProcedureFactory = record
	private
	  nullPtr: pointer;
	  vTable: PUdrProcedureFactoryVTable;
	  owner: IUdrProcedureFactoryImpl; {Only valid if isIUdrProcedureFactoryImpl returns true }
	  function thisRecord: IUdrProcedureFactory inline;
	public
	  function isIUdrProcedureFactoryImpl: boolean;
	  function getIUdrProcedureFactoryImpl: IUdrProcedureFactoryImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure;
	end;

	IUdrProcedureFactoryImpl = class(IDisposableImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IUdrProcedureFactory;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); virtual; abstract;
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure; virtual; abstract;
	end;

	PUdrTriggerFactoryVTable = ^UdrTriggerFactoryVTable;
	UdrTriggerFactoryVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  setup: IUdrTriggerFactory_setupPtr;
	  newItem: IUdrTriggerFactory_newItemPtr;
	end;

	IUdrTriggerFactoryImpl = class;

	TUdrTriggerFactory = record
	private
	  nullPtr: pointer;
	  vTable: PUdrTriggerFactoryVTable;
	  owner: IUdrTriggerFactoryImpl; {Only valid if isIUdrTriggerFactoryImpl returns true }
	  function thisRecord: IUdrTriggerFactory inline;
	public
	  function isIUdrTriggerFactoryImpl: boolean;
	  function getIUdrTriggerFactoryImpl: IUdrTriggerFactoryImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder);
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger;
	end;

	IUdrTriggerFactoryImpl = class(IDisposableImpl)
	public
	  const VERSION = 3;
	public
	  constructor create;
	  function getInterface: IUdrTriggerFactory;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder); virtual; abstract;
	  function newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger; virtual; abstract;
	end;

	PUdrPluginVTable = ^UdrPluginVTable;
	UdrPluginVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getMaster: IUdrPlugin_getMasterPtr;
	  registerFunction: IUdrPlugin_registerFunctionPtr;
	  registerProcedure: IUdrPlugin_registerProcedurePtr;
	  registerTrigger: IUdrPlugin_registerTriggerPtr;
	end;

	IUdrPluginImpl = class;

	TUdrPlugin = record
	private
	  nullPtr: pointer;
	  vTable: PUdrPluginVTable;
	  owner: IUdrPluginImpl; {Only valid if isIUdrPluginImpl returns true }
	  function thisRecord: IUdrPlugin inline;
	public
	  function isIUdrPluginImpl: boolean;
	  function getIUdrPluginImpl: IUdrPluginImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getMaster(): IMaster;
	  procedure registerFunction(status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory);
	  procedure registerProcedure(status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory);
	  procedure registerTrigger(status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory);
	end;

	IUdrPluginImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IUdrPlugin;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getMaster(): IMaster; virtual; abstract;
	  procedure registerFunction(status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory); virtual; abstract;
	  procedure registerProcedure(status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory); virtual; abstract;
	  procedure registerTrigger(status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory); virtual; abstract;
	end;

	PDecFloat16VTable = ^DecFloat16VTable;
	DecFloat16VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toBcd: IDecFloat16_toBcdPtr;
	  toString: IDecFloat16_toStringPtr;
	  fromBcd: IDecFloat16_fromBcdPtr;
	  fromString: IDecFloat16_fromStringPtr;
	end;

	IDecFloat16Impl = class;

	TDecFloat16 = record
	private
	  nullPtr: pointer;
	  vTable: PDecFloat16VTable;
	  owner: IDecFloat16Impl; {Only valid if isIDecFloat16Impl returns true }
	  function thisRecord: IDecFloat16 inline;
	public
	  function isIDecFloat16Impl: boolean;
	  function getIDecFloat16Impl: IDecFloat16Impl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
	  procedure toString(status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr);
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr);
	end;

	IDecFloat16Impl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	  const BCD_SIZE = Cardinal(16);
	  const STRING_SIZE = Cardinal(24);
	public
	  constructor create;
	  function getInterface: IDecFloat16;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); virtual; abstract;
	  procedure toString(status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); virtual; abstract;
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr); virtual; abstract;
	end;

	PDecFloat34VTable = ^DecFloat34VTable;
	DecFloat34VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toBcd: IDecFloat34_toBcdPtr;
	  toString: IDecFloat34_toStringPtr;
	  fromBcd: IDecFloat34_fromBcdPtr;
	  fromString: IDecFloat34_fromStringPtr;
	end;

	IDecFloat34Impl = class;

	TDecFloat34 = record
	private
	  nullPtr: pointer;
	  vTable: PDecFloat34VTable;
	  owner: IDecFloat34Impl; {Only valid if isIDecFloat34Impl returns true }
	  function thisRecord: IDecFloat34 inline;
	public
	  function isIDecFloat34Impl: boolean;
	  function getIDecFloat34Impl: IDecFloat34Impl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
	  procedure toString(status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr);
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr);
	end;

	IDecFloat34Impl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	  const BCD_SIZE = Cardinal(34);
	  const STRING_SIZE = Cardinal(43);
	public
	  constructor create;
	  function getInterface: IDecFloat34;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); virtual; abstract;
	  procedure toString(status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
	  procedure fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); virtual; abstract;
	  procedure fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr); virtual; abstract;
	end;

	PInt128VTable = ^Int128VTable;
	Int128VTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  toString: IInt128_toStringPtr;
	  fromString: IInt128_fromStringPtr;
	end;

	IInt128Impl = class;

	TInt128 = record
	private
	  nullPtr: pointer;
	  vTable: PInt128VTable;
	  owner: IInt128Impl; {Only valid if isIInt128Impl returns true }
	  function thisRecord: IInt128 inline;
	public
	  function isIInt128Impl: boolean;
	  function getIInt128Impl: IInt128Impl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure toString(status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar);
	  procedure fromString(status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr);
	end;

	IInt128Impl = class(IVersionedImpl)
	public
	  const VERSION = 2;
	  const STRING_SIZE = Cardinal(46);
	public
	  constructor create;
	  function getInterface: IInt128;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure toString(status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); virtual; abstract;
	  procedure fromString(status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); virtual; abstract;
	end;

	PReplicatedFieldVTable = ^ReplicatedFieldVTable;
	ReplicatedFieldVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getName: IReplicatedField_getNamePtr;
	  getType: IReplicatedField_getTypePtr;
	  getSubType: IReplicatedField_getSubTypePtr;
	  getScale: IReplicatedField_getScalePtr;
	  getLength: IReplicatedField_getLengthPtr;
	  getCharSet: IReplicatedField_getCharSetPtr;
	  getData: IReplicatedField_getDataPtr;
	end;

	IReplicatedFieldImpl = class;

	TReplicatedField = record
	private
	  nullPtr: pointer;
	  vTable: PReplicatedFieldVTable;
	  owner: IReplicatedFieldImpl; {Only valid if isIReplicatedFieldImpl returns true }
	  function thisRecord: IReplicatedField inline;
	public
	  function isIReplicatedFieldImpl: boolean;
	  function getIReplicatedFieldImpl: IReplicatedFieldImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getName(): PAnsiChar;
	  function getType(): Cardinal;
	  function getSubType(): Integer;
	  function getScale(): Integer;
	  function getLength(): Cardinal;
	  function getCharSet(): Cardinal;
	  function getData(): Pointer;
	end;

	IReplicatedFieldImpl = class(IVersionedImpl)
	public
	  const VERSION = 7;
	public
	  constructor create;
	  function getInterface: IReplicatedField;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getName(): PAnsiChar; virtual; abstract;
	  function getType(): Cardinal; virtual; abstract;
	  function getSubType(): Integer; virtual; abstract;
	  function getScale(): Integer; virtual; abstract;
	  function getLength(): Cardinal; virtual; abstract;
	  function getCharSet(): Cardinal; virtual; abstract;
	  function getData(): Pointer; virtual; abstract;
	end;

	PReplicatedRecordVTable = ^ReplicatedRecordVTable;
	ReplicatedRecordVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  getCount: IReplicatedRecord_getCountPtr;
	  getField: IReplicatedRecord_getFieldPtr;
	  getRawLength: IReplicatedRecord_getRawLengthPtr;
	  getRawData: IReplicatedRecord_getRawDataPtr;
	end;

	IReplicatedRecordImpl = class;

	TReplicatedRecord = record
	private
	  nullPtr: pointer;
	  vTable: PReplicatedRecordVTable;
	  owner: IReplicatedRecordImpl; {Only valid if isIReplicatedRecordImpl returns true }
	  function thisRecord: IReplicatedRecord inline;
	public
	  function isIReplicatedRecordImpl: boolean;
	  function getIReplicatedRecordImpl: IReplicatedRecordImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  function getCount(): Cardinal;
	  function getField(index: Cardinal): IReplicatedField;
	  function getRawLength(): Cardinal;
	  function getRawData(): BytePtr;
	end;

	IReplicatedRecordImpl = class(IVersionedImpl)
	public
	  const VERSION = 4;
	public
	  constructor create;
	  function getInterface: IReplicatedRecord;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function getCount(): Cardinal; virtual; abstract;
	  function getField(index: Cardinal): IReplicatedField; virtual; abstract;
	  function getRawLength(): Cardinal; virtual; abstract;
	  function getRawData(): BytePtr; virtual; abstract;
	end;

	PReplicatedTransactionVTable = ^ReplicatedTransactionVTable;
	ReplicatedTransactionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  dispose: IDisposable_disposePtr;
	  prepare: IReplicatedTransaction_preparePtr;
	  commit: IReplicatedTransaction_commitPtr;
	  rollback: IReplicatedTransaction_rollbackPtr;
	  startSavepoint: IReplicatedTransaction_startSavepointPtr;
	  releaseSavepoint: IReplicatedTransaction_releaseSavepointPtr;
	  rollbackSavepoint: IReplicatedTransaction_rollbackSavepointPtr;
	  insertRecord: IReplicatedTransaction_insertRecordPtr;
	  updateRecord: IReplicatedTransaction_updateRecordPtr;
	  deleteRecord: IReplicatedTransaction_deleteRecordPtr;
	  executeSql: IReplicatedTransaction_executeSqlPtr;
	  executeSqlIntl: IReplicatedTransaction_executeSqlIntlPtr;
	end;

	IReplicatedTransactionImpl = class;

	TReplicatedTransaction = record
	private
	  nullPtr: pointer;
	  vTable: PReplicatedTransactionVTable;
	  owner: IReplicatedTransactionImpl; {Only valid if isIReplicatedTransactionImpl returns true }
	  function thisRecord: IReplicatedTransaction inline;
	public
	  function isIReplicatedTransactionImpl: boolean;
	  function getIReplicatedTransactionImpl: IReplicatedTransactionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure dispose();
	  procedure prepare(status: IStatus);
	  procedure commit(status: IStatus);
	  procedure rollback(status: IStatus);
	  procedure startSavepoint(status: IStatus);
	  procedure releaseSavepoint(status: IStatus);
	  procedure rollbackSavepoint(status: IStatus);
	  procedure insertRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
	  procedure updateRecord(status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord);
	  procedure deleteRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
	  procedure executeSql(status: IStatus; sql: PAnsiChar);
	  procedure executeSqlIntl(status: IStatus; charset: Cardinal; sql: PAnsiChar);
	end;

	IReplicatedTransactionImpl = class(IDisposableImpl)
	public
	  const VERSION = 12;
	public
	  constructor create;
	  function getInterface: IReplicatedTransaction;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  procedure prepare(status: IStatus); virtual; abstract;
	  procedure commit(status: IStatus); virtual; abstract;
	  procedure rollback(status: IStatus); virtual; abstract;
	  procedure startSavepoint(status: IStatus); virtual; abstract;
	  procedure releaseSavepoint(status: IStatus); virtual; abstract;
	  procedure rollbackSavepoint(status: IStatus); virtual; abstract;
	  procedure insertRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); virtual; abstract;
	  procedure updateRecord(status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord); virtual; abstract;
	  procedure deleteRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); virtual; abstract;
	  procedure executeSql(status: IStatus; sql: PAnsiChar); virtual; abstract;
	  procedure executeSqlIntl(status: IStatus; charset: Cardinal; sql: PAnsiChar); virtual; abstract;
	end;

	PReplicatedSessionVTable = ^ReplicatedSessionVTable;
	ReplicatedSessionVTable = record
	  NullPtr: pointer;
	  version: NativeInt;
	  addRef: IReferenceCounted_addRefPtr;
	  release: IReferenceCounted_releasePtr;
	  setOwner: IPluginBase_setOwnerPtr;
	  getOwner: IPluginBase_getOwnerPtr;
	  init: IReplicatedSession_initPtr;
	  startTransaction: IReplicatedSession_startTransactionPtr;
	  cleanupTransaction: IReplicatedSession_cleanupTransactionPtr;
	  setSequence: IReplicatedSession_setSequencePtr;
	end;

	IReplicatedSessionImpl = class;

	TReplicatedSession = record
	private
	  nullPtr: pointer;
	  vTable: PReplicatedSessionVTable;
	  owner: IReplicatedSessionImpl; {Only valid if isIReplicatedSessionImpl returns true }
	  function thisRecord: IReplicatedSession inline;
	public
	  function isIReplicatedSessionImpl: boolean;
	  function getIReplicatedSessionImpl: IReplicatedSessionImpl;
	  function getvTableVersion: NativeInt inline;
	public
	  {Firebird OOAPI methods}
	  procedure addRef();
	  function release(): Integer;
	  procedure setOwner(r: IReferenceCounted);
	  function getOwner(): IReferenceCounted;
	  function init(status: IStatus; attachment: IAttachment): Boolean;
	  function startTransaction(status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction;
	  procedure cleanupTransaction(status: IStatus; number: Int64);
	  procedure setSequence(status: IStatus; name: PAnsiChar; value: Int64);
	end;

	IReplicatedSessionImpl = class(IPluginBaseImpl)
	public
	  const VERSION = 8;
	public
	  constructor create;
	  function getInterface: IReplicatedSession;
	  function getvTableVersion: NativeInt override;
	public
	  {Firebird OOAPI interface}
	  function init(status: IStatus; attachment: IAttachment): Boolean; virtual; abstract;
	  function startTransaction(status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction; virtual; abstract;
	  procedure cleanupTransaction(status: IStatus; number: Int64); virtual; abstract;
	  procedure setSequence(status: IStatus; name: PAnsiChar; value: Int64); virtual; abstract;
	end;


{$IFDEF STATIC_LINK_TO_FIREBIRD_LIBRARY}
function GetIMaster: IMaster;
{$ELSE}
function GetIMaster(aHandle: TLibHandle): IMaster;
{$ENDIF}

implementation

resourcestring
	errNotImplementationObject = 'interface is not an implementation of %s';

function TVersioned.thisRecord: IVersioned;
begin
  Result := IVersioned(@nullPtr);
end;

function TVersioned.getIVersionedImpl: IVersionedImpl;
begin
  if isIVersionedImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TVersioned.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TReferenceCounted.thisRecord: IReferenceCounted;
begin
  Result := IReferenceCounted(@nullPtr);
end;

function TReferenceCounted.getIReferenceCountedImpl: IReferenceCountedImpl;
begin
  if isIReferenceCountedImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TReferenceCounted.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TReferenceCounted.addRef();
begin
	vTable^.addRef(thisRecord);
end;

function TReferenceCounted.release(): Integer;
begin
	Result := vTable^.release(thisRecord);
end;

function TDisposable.thisRecord: IDisposable;
begin
  Result := IDisposable(@nullPtr);
end;

function TDisposable.getIDisposableImpl: IDisposableImpl;
begin
  if isIDisposableImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDisposable.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TDisposable.dispose();
begin
	vTable^.dispose(thisRecord);
end;

function TStatus.thisRecord: IStatus;
begin
  Result := IStatus(@nullPtr);
end;

function TStatus.getIStatusImpl: IStatusImpl;
begin
  if isIStatusImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TStatus.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TStatus.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TStatus.init();
begin
	vTable^.init(thisRecord);
end;

function TStatus.getState(): Cardinal;
begin
	Result := vTable^.getState(thisRecord);
end;

procedure TStatus.setErrors2(length: Cardinal; value: NativeIntPtr);
begin
	vTable^.setErrors2(thisRecord, length, value);
end;

procedure TStatus.setWarnings2(length: Cardinal; value: NativeIntPtr);
begin
	vTable^.setWarnings2(thisRecord, length, value);
end;

procedure TStatus.setErrors(value: NativeIntPtr);
begin
	vTable^.setErrors(thisRecord, value);
end;

procedure TStatus.setWarnings(value: NativeIntPtr);
begin
	vTable^.setWarnings(thisRecord, value);
end;

function TStatus.getErrors(): NativeIntPtr;
begin
	Result := vTable^.getErrors(thisRecord);
end;

function TStatus.getWarnings(): NativeIntPtr;
begin
	Result := vTable^.getWarnings(thisRecord);
end;

function TStatus.clone(): IStatus;
begin
	Result := vTable^.clone(thisRecord);
end;

function TMaster.thisRecord: IMaster;
begin
  Result := IMaster(@nullPtr);
end;

function TMaster.getIMasterImpl: IMasterImpl;
begin
  if isIMasterImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TMaster.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TMaster.getStatus(): IStatus;
begin
	Result := vTable^.getStatus(thisRecord);
end;

function TMaster.getDispatcher(): IProvider;
begin
	Result := vTable^.getDispatcher(thisRecord);
end;

function TMaster.getPluginManager(): IPluginManager;
begin
	Result := vTable^.getPluginManager(thisRecord);
end;

function TMaster.getTimerControl(): ITimerControl;
begin
	Result := vTable^.getTimerControl(thisRecord);
end;

function TMaster.getDtc(): IDtc;
begin
	Result := vTable^.getDtc(thisRecord);
end;

function TMaster.registerAttachment(provider: IProvider; attachment: IAttachment): IAttachment;
begin
	Result := vTable^.registerAttachment(thisRecord, provider, attachment);
end;

function TMaster.registerTransaction(attachment: IAttachment; transaction: ITransaction): ITransaction;
begin
	Result := vTable^.registerTransaction(thisRecord, attachment, transaction);
end;

function TMaster.getMetadataBuilder(status: IStatus; fieldCount: Cardinal): IMetadataBuilder;
begin
	Result := vTable^.getMetadataBuilder(thisRecord, status, fieldCount);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMaster.serverMode(mode: Integer): Integer;
begin
	Result := vTable^.serverMode(thisRecord, mode);
end;

function TMaster.getUtilInterface(): IUtil;
begin
	Result := vTable^.getUtilInterface(thisRecord);
end;

function TMaster.getConfigManager(): IConfigManager;
begin
	Result := vTable^.getConfigManager(thisRecord);
end;

function TMaster.getProcessExiting(): Boolean;
begin
	Result := vTable^.getProcessExiting(thisRecord);
end;

function TPluginBase.thisRecord: IPluginBase;
begin
  Result := IPluginBase(@nullPtr);
end;

function TPluginBase.getIPluginBaseImpl: IPluginBaseImpl;
begin
  if isIPluginBaseImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TPluginBase.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TPluginBase.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TPluginBase.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TPluginBase.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(thisRecord, r);
end;

function TPluginBase.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(thisRecord);
end;

function TPluginSet.thisRecord: IPluginSet;
begin
  Result := IPluginSet(@nullPtr);
end;

function TPluginSet.getIPluginSetImpl: IPluginSetImpl;
begin
  if isIPluginSetImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TPluginSet.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TPluginSet.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TPluginSet.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TPluginSet.getName(): PAnsiChar;
begin
	Result := vTable^.getName(thisRecord);
end;

function TPluginSet.getModuleName(): PAnsiChar;
begin
	Result := vTable^.getModuleName(thisRecord);
end;

function TPluginSet.getPlugin(status: IStatus): IPluginBase;
begin
	Result := vTable^.getPlugin(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginSet.next(status: IStatus);
begin
	vTable^.next(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginSet.set_(status: IStatus; s: PAnsiChar);
begin
	vTable^.set_(thisRecord, status, s);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfigEntry.thisRecord: IConfigEntry;
begin
  Result := IConfigEntry(@nullPtr);
end;

function TConfigEntry.getIConfigEntryImpl: IConfigEntryImpl;
begin
  if isIConfigEntryImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TConfigEntry.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TConfigEntry.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TConfigEntry.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TConfigEntry.getName(): PAnsiChar;
begin
	Result := vTable^.getName(thisRecord);
end;

function TConfigEntry.getValue(): PAnsiChar;
begin
	Result := vTable^.getValue(thisRecord);
end;

function TConfigEntry.getIntValue(): Int64;
begin
	Result := vTable^.getIntValue(thisRecord);
end;

function TConfigEntry.getBoolValue(): Boolean;
begin
	Result := vTable^.getBoolValue(thisRecord);
end;

function TConfigEntry.getSubConfig(status: IStatus): IConfig;
begin
	Result := vTable^.getSubConfig(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfig.thisRecord: IConfig;
begin
  Result := IConfig(@nullPtr);
end;

function TConfig.getIConfigImpl: IConfigImpl;
begin
  if isIConfigImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TConfig.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TConfig.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TConfig.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TConfig.find(status: IStatus; name: PAnsiChar): IConfigEntry;
begin
	Result := vTable^.find(thisRecord, status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfig.findValue(status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry;
begin
	Result := vTable^.findValue(thisRecord, status, name, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TConfig.findPos(status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry;
begin
	Result := vTable^.findPos(thisRecord, status, name, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TFirebirdConf.thisRecord: IFirebirdConf;
begin
  Result := IFirebirdConf(@nullPtr);
end;

function TFirebirdConf.getIFirebirdConfImpl: IFirebirdConfImpl;
begin
  if isIFirebirdConfImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TFirebirdConf.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TFirebirdConf.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TFirebirdConf.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TFirebirdConf.getKey(name: PAnsiChar): Cardinal;
begin
	Result := vTable^.getKey(thisRecord, name);
end;

function TFirebirdConf.asInteger(key: Cardinal): Int64;
begin
	Result := vTable^.asInteger(thisRecord, key);
end;

function TFirebirdConf.asString(key: Cardinal): PAnsiChar;
begin
	Result := vTable^.asString(thisRecord, key);
end;

function TFirebirdConf.asBoolean(key: Cardinal): Boolean;
begin
	Result := vTable^.asBoolean(thisRecord, key);
end;

function TFirebirdConf.getVersion(status: IStatus): Cardinal;
begin
	Result := vTable^.getVersion(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginConfig.thisRecord: IPluginConfig;
begin
  Result := IPluginConfig(@nullPtr);
end;

function TPluginConfig.getIPluginConfigImpl: IPluginConfigImpl;
begin
  if isIPluginConfigImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TPluginConfig.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TPluginConfig.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TPluginConfig.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TPluginConfig.getConfigFileName(): PAnsiChar;
begin
	Result := vTable^.getConfigFileName(thisRecord);
end;

function TPluginConfig.getDefaultConfig(status: IStatus): IConfig;
begin
	Result := vTable^.getDefaultConfig(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginConfig.getFirebirdConf(status: IStatus): IFirebirdConf;
begin
	Result := vTable^.getFirebirdConf(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginConfig.setReleaseDelay(status: IStatus; microSeconds: QWord);
begin
	vTable^.setReleaseDelay(thisRecord, status, microSeconds);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginFactory.thisRecord: IPluginFactory;
begin
  Result := IPluginFactory(@nullPtr);
end;

function TPluginFactory.getIPluginFactoryImpl: IPluginFactoryImpl;
begin
  if isIPluginFactoryImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TPluginFactory.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TPluginFactory.createPlugin(status: IStatus; factoryParameter: IPluginConfig): IPluginBase;
begin
	Result := vTable^.createPlugin(thisRecord, status, factoryParameter);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginModule.thisRecord: IPluginModule;
begin
  Result := IPluginModule(@nullPtr);
end;

function TPluginModule.getIPluginModuleImpl: IPluginModuleImpl;
begin
  if isIPluginModuleImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TPluginModule.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TPluginModule.doClean();
begin
	vTable^.doClean(thisRecord);
end;

procedure TPluginModule.threadDetach();
begin
	vTable^.threadDetach(thisRecord);
end;

function TPluginManager.thisRecord: IPluginManager;
begin
  Result := IPluginManager(@nullPtr);
end;

function TPluginManager.getIPluginManagerImpl: IPluginManagerImpl;
begin
  if isIPluginManagerImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TPluginManager.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TPluginManager.registerPluginFactory(pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory);
begin
	vTable^.registerPluginFactory(thisRecord, pluginType, defaultName, factory);
end;

procedure TPluginManager.registerModule(cleanup: IPluginModule);
begin
	vTable^.registerModule(thisRecord, cleanup);
end;

procedure TPluginManager.unregisterModule(cleanup: IPluginModule);
begin
	vTable^.unregisterModule(thisRecord, cleanup);
end;

function TPluginManager.getPlugins(status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet;
begin
	Result := vTable^.getPlugins(thisRecord, status, pluginType, namesList, firebirdConf);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TPluginManager.getConfig(status: IStatus; filename: PAnsiChar): IConfig;
begin
	Result := vTable^.getConfig(thisRecord, status, filename);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TPluginManager.releasePlugin(plugin: IPluginBase);
begin
	vTable^.releasePlugin(thisRecord, plugin);
end;

function TCryptKey.thisRecord: ICryptKey;
begin
  Result := ICryptKey(@nullPtr);
end;

function TCryptKey.getICryptKeyImpl: ICryptKeyImpl;
begin
  if isICryptKeyImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TCryptKey.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TCryptKey.setSymmetric(status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer);
begin
	vTable^.setSymmetric(thisRecord, status, type_, keyLength, key);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TCryptKey.setAsymmetric(status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer);
begin
	vTable^.setAsymmetric(thisRecord, status, type_, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCryptKey.getEncryptKey(length: CardinalPtr): Pointer;
begin
	Result := vTable^.getEncryptKey(thisRecord, length);
end;

function TCryptKey.getDecryptKey(length: CardinalPtr): Pointer;
begin
	Result := vTable^.getDecryptKey(thisRecord, length);
end;

function TConfigManager.thisRecord: IConfigManager;
begin
  Result := IConfigManager(@nullPtr);
end;

function TConfigManager.getIConfigManagerImpl: IConfigManagerImpl;
begin
  if isIConfigManagerImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TConfigManager.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TConfigManager.getDirectory(code: Cardinal): PAnsiChar;
begin
	Result := vTable^.getDirectory(thisRecord, code);
end;

function TConfigManager.getFirebirdConf(): IFirebirdConf;
begin
	Result := vTable^.getFirebirdConf(thisRecord);
end;

function TConfigManager.getDatabaseConf(dbName: PAnsiChar): IFirebirdConf;
begin
	Result := vTable^.getDatabaseConf(thisRecord, dbName);
end;

function TConfigManager.getPluginConfig(configuredPlugin: PAnsiChar): IConfig;
begin
	Result := vTable^.getPluginConfig(thisRecord, configuredPlugin);
end;

function TConfigManager.getInstallDirectory(): PAnsiChar;
begin
	Result := vTable^.getInstallDirectory(thisRecord);
end;

function TConfigManager.getRootDirectory(): PAnsiChar;
begin
	Result := vTable^.getRootDirectory(thisRecord);
end;

function TConfigManager.getDefaultSecurityDb(): PAnsiChar;
begin
	Result := vTable^.getDefaultSecurityDb(thisRecord);
end;

function TEventCallback.thisRecord: IEventCallback;
begin
  Result := IEventCallback(@nullPtr);
end;

function TEventCallback.getIEventCallbackImpl: IEventCallbackImpl;
begin
  if isIEventCallbackImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TEventCallback.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TEventCallback.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TEventCallback.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TEventCallback.eventCallbackFunction(length: Cardinal; events: BytePtr);
begin
	vTable^.eventCallbackFunction(thisRecord, length, events);
end;

function TBlob.thisRecord: IBlob;
begin
  Result := IBlob(@nullPtr);
end;

function TBlob.getIBlobImpl: IBlobImpl;
begin
  if isIBlobImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TBlob.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TBlob.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TBlob.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TBlob.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(thisRecord, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBlob.getSegment(status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer;
begin
	Result := vTable^.getSegment(thisRecord, status, bufferLength, buffer, segmentLength);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBlob.putSegment(status: IStatus; length: Cardinal; buffer: Pointer);
begin
	vTable^.putSegment(thisRecord, status, length, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBlob.cancel(status: IStatus);
begin
	vTable^.cancel(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBlob.close(status: IStatus);
begin
	vTable^.close(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBlob.seek(status: IStatus; mode: Integer; offset: Integer): Integer;
begin
	Result := vTable^.seek(thisRecord, status, mode, offset);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.thisRecord: ITransaction;
begin
  Result := ITransaction(@nullPtr);
end;

function TTransaction.getITransactionImpl: ITransactionImpl;
begin
  if isITransactionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTransaction.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TTransaction.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TTransaction.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TTransaction.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(thisRecord, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.prepare(status: IStatus; msgLength: Cardinal; message: BytePtr);
begin
	vTable^.prepare(thisRecord, status, msgLength, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.commit(status: IStatus);
begin
	vTable^.commit(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.commitRetaining(status: IStatus);
begin
	vTable^.commitRetaining(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.rollback(status: IStatus);
begin
	vTable^.rollback(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.rollbackRetaining(status: IStatus);
begin
	vTable^.rollbackRetaining(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTransaction.disconnect(status: IStatus);
begin
	vTable^.disconnect(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.join(status: IStatus; transaction: ITransaction): ITransaction;
begin
	Result := vTable^.join(thisRecord, status, transaction);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.validate(status: IStatus; attachment: IAttachment): ITransaction;
begin
	Result := vTable^.validate(thisRecord, status, attachment);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTransaction.enterDtc(status: IStatus): ITransaction;
begin
	Result := vTable^.enterDtc(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.thisRecord: IMessageMetadata;
begin
  Result := IMessageMetadata(@nullPtr);
end;

function TMessageMetadata.getIMessageMetadataImpl: IMessageMetadataImpl;
begin
  if isIMessageMetadataImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TMessageMetadata.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TMessageMetadata.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TMessageMetadata.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TMessageMetadata.getCount(status: IStatus): Cardinal;
begin
	Result := vTable^.getCount(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getField(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getField(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getRelation(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getRelation(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getOwner(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getOwner(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getAlias(status: IStatus; index: Cardinal): PAnsiChar;
begin
	Result := vTable^.getAlias(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getType(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getType(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.isNullable(status: IStatus; index: Cardinal): Boolean;
begin
	Result := vTable^.isNullable(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getSubType(status: IStatus; index: Cardinal): Integer;
begin
	Result := vTable^.getSubType(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getLength(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getLength(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getScale(status: IStatus; index: Cardinal): Integer;
begin
	Result := vTable^.getScale(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getCharSet(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getCharSet(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getOffset(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getOffset(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getNullOffset(status: IStatus; index: Cardinal): Cardinal;
begin
	Result := vTable^.getNullOffset(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getBuilder(status: IStatus): IMetadataBuilder;
begin
	Result := vTable^.getBuilder(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getMessageLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getMessageLength(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getAlignment(status: IStatus): Cardinal;
begin
	Result := vTable^.getAlignment(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMessageMetadata.getAlignedLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getAlignedLength(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMetadataBuilder.thisRecord: IMetadataBuilder;
begin
  Result := IMetadataBuilder(@nullPtr);
end;

function TMetadataBuilder.getIMetadataBuilderImpl: IMetadataBuilderImpl;
begin
  if isIMetadataBuilderImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TMetadataBuilder.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TMetadataBuilder.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TMetadataBuilder.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TMetadataBuilder.setType(status: IStatus; index: Cardinal; type_: Cardinal);
begin
	vTable^.setType(thisRecord, status, index, type_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setSubType(status: IStatus; index: Cardinal; subType: Integer);
begin
	vTable^.setSubType(thisRecord, status, index, subType);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setLength(status: IStatus; index: Cardinal; length: Cardinal);
begin
	vTable^.setLength(thisRecord, status, index, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setCharSet(status: IStatus; index: Cardinal; charSet: Cardinal);
begin
	vTable^.setCharSet(thisRecord, status, index, charSet);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setScale(status: IStatus; index: Cardinal; scale: Integer);
begin
	vTable^.setScale(thisRecord, status, index, scale);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.truncate(status: IStatus; count: Cardinal);
begin
	vTable^.truncate(thisRecord, status, count);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.moveNameToIndex(status: IStatus; name: PAnsiChar; index: Cardinal);
begin
	vTable^.moveNameToIndex(thisRecord, status, name, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.remove(status: IStatus; index: Cardinal);
begin
	vTable^.remove(thisRecord, status, index);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMetadataBuilder.addField(status: IStatus): Cardinal;
begin
	Result := vTable^.addField(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TMetadataBuilder.getMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setField(status: IStatus; index: Cardinal; field: PAnsiChar);
begin
	vTable^.setField(thisRecord, status, index, field);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setRelation(status: IStatus; index: Cardinal; relation: PAnsiChar);
begin
	vTable^.setRelation(thisRecord, status, index, relation);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setOwner(status: IStatus; index: Cardinal; owner: PAnsiChar);
begin
	vTable^.setOwner(thisRecord, status, index, owner);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TMetadataBuilder.setAlias(status: IStatus; index: Cardinal; alias: PAnsiChar);
begin
	vTable^.setAlias(thisRecord, status, index, alias);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.thisRecord: IResultSet;
begin
  Result := IResultSet(@nullPtr);
end;

function TResultSet.getIResultSetImpl: IResultSetImpl;
begin
  if isIResultSetImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TResultSet.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TResultSet.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TResultSet.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TResultSet.fetchNext(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchNext(thisRecord, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchPrior(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchPrior(thisRecord, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchFirst(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchFirst(thisRecord, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchLast(status: IStatus; message: Pointer): Integer;
begin
	Result := vTable^.fetchLast(thisRecord, status, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchAbsolute(status: IStatus; position: Integer; message: Pointer): Integer;
begin
	Result := vTable^.fetchAbsolute(thisRecord, status, position, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.fetchRelative(status: IStatus; offset: Integer; message: Pointer): Integer;
begin
	Result := vTable^.fetchRelative(thisRecord, status, offset, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.isEof(status: IStatus): Boolean;
begin
	Result := vTable^.isEof(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.isBof(status: IStatus): Boolean;
begin
	Result := vTable^.isBof(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TResultSet.getMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TResultSet.close(status: IStatus);
begin
	vTable^.close(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TResultSet.setDelayedOutputFormat(status: IStatus; format: IMessageMetadata);
begin
	vTable^.setDelayedOutputFormat(thisRecord, status, format);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.thisRecord: IStatement;
begin
  Result := IStatement(@nullPtr);
end;

function TStatement.getIStatementImpl: IStatementImpl;
begin
  if isIStatementImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TStatement.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TStatement.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TStatement.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TStatement.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(thisRecord, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getType(status: IStatus): Cardinal;
begin
	Result := vTable^.getType(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getPlan(status: IStatus; detailed: Boolean): PAnsiChar;
begin
	Result := vTable^.getPlan(thisRecord, status, detailed);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getAffectedRecords(status: IStatus): QWord;
begin
	Result := vTable^.getAffectedRecords(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getInputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getInputMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getOutputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getOutputMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.execute(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
begin
	Result := vTable^.execute(thisRecord, status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.openCursor(status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet;
begin
	Result := vTable^.openCursor(thisRecord, status, transaction, inMetadata, inBuffer, outMetadata, flags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TStatement.setCursorName(status: IStatus; name: PAnsiChar);
begin
	vTable^.setCursorName(thisRecord, status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TStatement.free(status: IStatus);
begin
	vTable^.free(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getFlags(status: IStatus): Cardinal;
begin
	Result := vTable^.getFlags(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.getTimeout(status: IStatus): Cardinal;
begin
	Result := vTable^.getTimeout(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TStatement.setTimeout(status: IStatus; timeOut: Cardinal);
begin
	vTable^.setTimeout(thisRecord, status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TStatement.createBatch(status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
begin
	Result := vTable^.createBatch(thisRecord, status, inMetadata, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.thisRecord: IBatch;
begin
  Result := IBatch(@nullPtr);
end;

function TBatch.getIBatchImpl: IBatchImpl;
begin
  if isIBatchImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TBatch.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TBatch.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TBatch.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TBatch.add(status: IStatus; count: Cardinal; inBuffer: Pointer);
begin
	vTable^.add(thisRecord, status, count, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.addBlob(status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr);
begin
	vTable^.addBlob(thisRecord, status, length, inBuffer, blobId, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.appendBlobData(status: IStatus; length: Cardinal; inBuffer: Pointer);
begin
	vTable^.appendBlobData(thisRecord, status, length, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.addBlobStream(status: IStatus; length: Cardinal; inBuffer: Pointer);
begin
	vTable^.addBlobStream(thisRecord, status, length, inBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.registerBlob(status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr);
begin
	vTable^.registerBlob(thisRecord, status, existingBlob, blobId);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.execute(status: IStatus; transaction: ITransaction): IBatchCompletionState;
begin
	Result := vTable^.execute(thisRecord, status, transaction);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.cancel(status: IStatus);
begin
	vTable^.cancel(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.getBlobAlignment(status: IStatus): Cardinal;
begin
	Result := vTable^.getBlobAlignment(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatch.getMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.setDefaultBpb(status: IStatus; parLength: Cardinal; par: BytePtr);
begin
	vTable^.setDefaultBpb(thisRecord, status, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatch.close(status: IStatus);
begin
	vTable^.close(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatchCompletionState.thisRecord: IBatchCompletionState;
begin
  Result := IBatchCompletionState(@nullPtr);
end;

function TBatchCompletionState.getIBatchCompletionStateImpl: IBatchCompletionStateImpl;
begin
  if isIBatchCompletionStateImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TBatchCompletionState.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TBatchCompletionState.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

function TBatchCompletionState.getSize(status: IStatus): Cardinal;
begin
	Result := vTable^.getSize(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatchCompletionState.getState(status: IStatus; pos: Cardinal): Integer;
begin
	Result := vTable^.getState(thisRecord, status, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TBatchCompletionState.findError(status: IStatus; pos: Cardinal): Cardinal;
begin
	Result := vTable^.findError(thisRecord, status, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TBatchCompletionState.getStatus(status: IStatus; to_: IStatus; pos: Cardinal);
begin
	vTable^.getStatus(thisRecord, status, to_, pos);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicator.thisRecord: IReplicator;
begin
  Result := IReplicator(@nullPtr);
end;

function TReplicator.getIReplicatorImpl: IReplicatorImpl;
begin
  if isIReplicatorImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TReplicator.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TReplicator.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TReplicator.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TReplicator.process(status: IStatus; length: Cardinal; data: BytePtr);
begin
	vTable^.process(thisRecord, status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicator.close(status: IStatus);
begin
	vTable^.close(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRequest.thisRecord: IRequest;
begin
  Result := IRequest(@nullPtr);
end;

function TRequest.getIRequestImpl: IRequestImpl;
begin
  if isIRequestImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TRequest.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TRequest.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TRequest.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TRequest.receive(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.receive(thisRecord, status, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.send(status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.send(thisRecord, status, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.getInfo(status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(thisRecord, status, level, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.start(status: IStatus; tra: ITransaction; level: Integer);
begin
	vTable^.start(thisRecord, status, tra, level);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.startAndSend(status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer);
begin
	vTable^.startAndSend(thisRecord, status, tra, level, msgType, length, message);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.unwind(status: IStatus; level: Integer);
begin
	vTable^.unwind(thisRecord, status, level);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TRequest.free(status: IStatus);
begin
	vTable^.free(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TEvents.thisRecord: IEvents;
begin
  Result := IEvents(@nullPtr);
end;

function TEvents.getIEventsImpl: IEventsImpl;
begin
  if isIEventsImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TEvents.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TEvents.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TEvents.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TEvents.cancel(status: IStatus);
begin
	vTable^.cancel(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.thisRecord: IAttachment;
begin
  Result := IAttachment(@nullPtr);
end;

function TAttachment.getIAttachmentImpl: IAttachmentImpl;
begin
  if isIAttachmentImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TAttachment.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TAttachment.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TAttachment.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TAttachment.getInfo(status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.getInfo(thisRecord, status, itemsLength, items, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.startTransaction(status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction;
begin
	Result := vTable^.startTransaction(thisRecord, status, tpbLength, tpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.reconnectTransaction(status: IStatus; length: Cardinal; id: BytePtr): ITransaction;
begin
	Result := vTable^.reconnectTransaction(thisRecord, status, length, id);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.compileRequest(status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest;
begin
	Result := vTable^.compileRequest(thisRecord, status, blrLength, blr);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.transactRequest(status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr);
begin
	vTable^.transactRequest(thisRecord, status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.createBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
begin
	Result := vTable^.createBlob(thisRecord, status, transaction, id, bpbLength, bpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.openBlob(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob;
begin
	Result := vTable^.openBlob(thisRecord, status, transaction, id, bpbLength, bpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.getSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer;
begin
	Result := vTable^.getSlice(thisRecord, status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.putSlice(status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr);
begin
	vTable^.putSlice(thisRecord, status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.executeDyn(status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr);
begin
	vTable^.executeDyn(thisRecord, status, transaction, length, dyn);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.prepare(status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement;
begin
	Result := vTable^.prepare(thisRecord, status, tra, stmtLength, sqlStmt, dialect, flags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.execute(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction;
begin
	Result := vTable^.execute(thisRecord, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.openCursor(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet;
begin
	Result := vTable^.openCursor(thisRecord, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.queEvents(status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents;
begin
	Result := vTable^.queEvents(thisRecord, status, callback, length, events);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.cancelOperation(status: IStatus; option: Integer);
begin
	vTable^.cancelOperation(thisRecord, status, option);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.ping(status: IStatus);
begin
	vTable^.ping(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.detach(status: IStatus);
begin
	vTable^.detach(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.dropDatabase(status: IStatus);
begin
	vTable^.dropDatabase(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.getIdleTimeout(status: IStatus): Cardinal;
begin
	Result := vTable^.getIdleTimeout(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.setIdleTimeout(status: IStatus; timeOut: Cardinal);
begin
	vTable^.setIdleTimeout(thisRecord, status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.getStatementTimeout(status: IStatus): Cardinal;
begin
	Result := vTable^.getStatementTimeout(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TAttachment.setStatementTimeout(status: IStatus; timeOut: Cardinal);
begin
	vTable^.setStatementTimeout(thisRecord, status, timeOut);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.createBatch(status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch;
begin
	Result := vTable^.createBatch(thisRecord, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, parLength, par);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAttachment.createReplicator(status: IStatus): IReplicator;
begin
	Result := vTable^.createReplicator(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TService.thisRecord: IService;
begin
  Result := IService(@nullPtr);
end;

function TService.getIServiceImpl: IServiceImpl;
begin
  if isIServiceImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TService.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TService.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TService.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TService.detach(status: IStatus);
begin
	vTable^.detach(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TService.query(status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr);
begin
	vTable^.query(thisRecord, status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TService.start(status: IStatus; spbLength: Cardinal; spb: BytePtr);
begin
	vTable^.start(thisRecord, status, spbLength, spb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TProvider.thisRecord: IProvider;
begin
  Result := IProvider(@nullPtr);
end;

function TProvider.getIProviderImpl: IProviderImpl;
begin
  if isIProviderImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TProvider.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TProvider.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TProvider.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TProvider.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TProvider.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TProvider.attachDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
begin
	Result := vTable^.attachDatabase(thisRecord, status, fileName, dpbLength, dpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TProvider.createDatabase(status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment;
begin
	Result := vTable^.createDatabase(thisRecord, status, fileName, dpbLength, dpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TProvider.attachServiceManager(status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService;
begin
	Result := vTable^.attachServiceManager(thisRecord, status, service, spbLength, spb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TProvider.shutdown(status: IStatus; timeout: Cardinal; reason: Integer);
begin
	vTable^.shutdown(thisRecord, status, timeout, reason);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TProvider.setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
begin
	vTable^.setDbCryptCallback(thisRecord, status, cryptCallback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtcStart.thisRecord: IDtcStart;
begin
  Result := IDtcStart(@nullPtr);
end;

function TDtcStart.getIDtcStartImpl: IDtcStartImpl;
begin
  if isIDtcStartImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDtcStart.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TDtcStart.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TDtcStart.addAttachment(status: IStatus; att: IAttachment);
begin
	vTable^.addAttachment(thisRecord, status, att);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDtcStart.addWithTpb(status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr);
begin
	vTable^.addWithTpb(thisRecord, status, att, length, tpb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtcStart.start(status: IStatus): ITransaction;
begin
	Result := vTable^.start(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtc.thisRecord: IDtc;
begin
  Result := IDtc(@nullPtr);
end;

function TDtc.getIDtcImpl: IDtcImpl;
begin
  if isIDtcImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDtc.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TDtc.join(status: IStatus; one: ITransaction; two: ITransaction): ITransaction;
begin
	Result := vTable^.join(thisRecord, status, one, two);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDtc.startBuilder(status: IStatus): IDtcStart;
begin
	Result := vTable^.startBuilder(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAuth.thisRecord: IAuth;
begin
  Result := IAuth(@nullPtr);
end;

function TAuth.getIAuthImpl: IAuthImpl;
begin
  if isIAuthImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TAuth.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TAuth.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TAuth.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TAuth.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TAuth.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TWriter.thisRecord: IWriter;
begin
  Result := IWriter(@nullPtr);
end;

function TWriter.getIWriterImpl: IWriterImpl;
begin
  if isIWriterImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TWriter.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TWriter.reset();
begin
	vTable^.reset(thisRecord);
end;

procedure TWriter.add(status: IStatus; name: PAnsiChar);
begin
	vTable^.add(thisRecord, status, name);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWriter.setType(status: IStatus; value: PAnsiChar);
begin
	vTable^.setType(thisRecord, status, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWriter.setDb(status: IStatus; value: PAnsiChar);
begin
	vTable^.setDb(thisRecord, status, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TServerBlock.thisRecord: IServerBlock;
begin
  Result := IServerBlock(@nullPtr);
end;

function TServerBlock.getIServerBlockImpl: IServerBlockImpl;
begin
  if isIServerBlockImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TServerBlock.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TServerBlock.getLogin(): PAnsiChar;
begin
	Result := vTable^.getLogin(thisRecord);
end;

function TServerBlock.getData(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getData(thisRecord, length);
end;

procedure TServerBlock.putData(status: IStatus; length: Cardinal; data: Pointer);
begin
	vTable^.putData(thisRecord, status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TServerBlock.newKey(status: IStatus): ICryptKey;
begin
	Result := vTable^.newKey(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClientBlock.thisRecord: IClientBlock;
begin
  Result := IClientBlock(@nullPtr);
end;

function TClientBlock.getIClientBlockImpl: IClientBlockImpl;
begin
  if isIClientBlockImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TClientBlock.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TClientBlock.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TClientBlock.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TClientBlock.getLogin(): PAnsiChar;
begin
	Result := vTable^.getLogin(thisRecord);
end;

function TClientBlock.getPassword(): PAnsiChar;
begin
	Result := vTable^.getPassword(thisRecord);
end;

function TClientBlock.getData(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getData(thisRecord, length);
end;

procedure TClientBlock.putData(status: IStatus; length: Cardinal; data: Pointer);
begin
	vTable^.putData(thisRecord, status, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClientBlock.newKey(status: IStatus): ICryptKey;
begin
	Result := vTable^.newKey(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClientBlock.getAuthBlock(status: IStatus): IAuthBlock;
begin
	Result := vTable^.getAuthBlock(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TServer.thisRecord: IServer;
begin
  Result := IServer(@nullPtr);
end;

function TServer.getIServerImpl: IServerImpl;
begin
  if isIServerImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TServer.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TServer.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TServer.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TServer.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TServer.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TServer.authenticate(status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer;
begin
	Result := vTable^.authenticate(thisRecord, status, sBlock, writerInterface);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TServer.setDbCryptCallback(status: IStatus; cryptCallback: ICryptKeyCallback);
begin
	vTable^.setDbCryptCallback(thisRecord, status, cryptCallback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TClient.thisRecord: IClient;
begin
  Result := IClient(@nullPtr);
end;

function TClient.getIClientImpl: IClientImpl;
begin
  if isIClientImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TClient.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TClient.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TClient.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TClient.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TClient.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TClient.authenticate(status: IStatus; cBlock: IClientBlock): Integer;
begin
	Result := vTable^.authenticate(thisRecord, status, cBlock);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUserField.thisRecord: IUserField;
begin
  Result := IUserField(@nullPtr);
end;

function TUserField.getIUserFieldImpl: IUserFieldImpl;
begin
  if isIUserFieldImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUserField.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TUserField.entered(): Integer;
begin
	Result := vTable^.entered(thisRecord);
end;

function TUserField.specified(): Integer;
begin
	Result := vTable^.specified(thisRecord);
end;

procedure TUserField.setEntered(status: IStatus; newValue: Integer);
begin
	vTable^.setEntered(thisRecord, status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCharUserField.thisRecord: ICharUserField;
begin
  Result := ICharUserField(@nullPtr);
end;

function TCharUserField.getICharUserFieldImpl: ICharUserFieldImpl;
begin
  if isICharUserFieldImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TCharUserField.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TCharUserField.entered(): Integer;
begin
	Result := vTable^.entered(IUserField(thisRecord));
end;

function TCharUserField.specified(): Integer;
begin
	Result := vTable^.specified(IUserField(thisRecord));
end;

procedure TCharUserField.setEntered(status: IStatus; newValue: Integer);
begin
	vTable^.setEntered(IUserField(thisRecord), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCharUserField.get(): PAnsiChar;
begin
	Result := vTable^.get(thisRecord);
end;

procedure TCharUserField.set_(status: IStatus; newValue: PAnsiChar);
begin
	vTable^.set_(thisRecord, status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TIntUserField.thisRecord: IIntUserField;
begin
  Result := IIntUserField(@nullPtr);
end;

function TIntUserField.getIIntUserFieldImpl: IIntUserFieldImpl;
begin
  if isIIntUserFieldImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TIntUserField.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TIntUserField.entered(): Integer;
begin
	Result := vTable^.entered(IUserField(thisRecord));
end;

function TIntUserField.specified(): Integer;
begin
	Result := vTable^.specified(IUserField(thisRecord));
end;

procedure TIntUserField.setEntered(status: IStatus; newValue: Integer);
begin
	vTable^.setEntered(IUserField(thisRecord), status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TIntUserField.get(): Integer;
begin
	Result := vTable^.get(thisRecord);
end;

procedure TIntUserField.set_(status: IStatus; newValue: Integer);
begin
	vTable^.set_(thisRecord, status, newValue);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUser.thisRecord: IUser;
begin
  Result := IUser(@nullPtr);
end;

function TUser.getIUserImpl: IUserImpl;
begin
  if isIUserImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUser.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TUser.operation(): Cardinal;
begin
	Result := vTable^.operation(thisRecord);
end;

function TUser.userName(): ICharUserField;
begin
	Result := vTable^.userName(thisRecord);
end;

function TUser.password(): ICharUserField;
begin
	Result := vTable^.password(thisRecord);
end;

function TUser.firstName(): ICharUserField;
begin
	Result := vTable^.firstName(thisRecord);
end;

function TUser.lastName(): ICharUserField;
begin
	Result := vTable^.lastName(thisRecord);
end;

function TUser.middleName(): ICharUserField;
begin
	Result := vTable^.middleName(thisRecord);
end;

function TUser.comment(): ICharUserField;
begin
	Result := vTable^.comment(thisRecord);
end;

function TUser.attributes(): ICharUserField;
begin
	Result := vTable^.attributes(thisRecord);
end;

function TUser.active(): IIntUserField;
begin
	Result := vTable^.active(thisRecord);
end;

function TUser.admin(): IIntUserField;
begin
	Result := vTable^.admin(thisRecord);
end;

procedure TUser.clear(status: IStatus);
begin
	vTable^.clear(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TListUsers.thisRecord: IListUsers;
begin
  Result := IListUsers(@nullPtr);
end;

function TListUsers.getIListUsersImpl: IListUsersImpl;
begin
  if isIListUsersImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TListUsers.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TListUsers.list(status: IStatus; user: IUser);
begin
	vTable^.list(thisRecord, status, user);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TLogonInfo.thisRecord: ILogonInfo;
begin
  Result := ILogonInfo(@nullPtr);
end;

function TLogonInfo.getILogonInfoImpl: ILogonInfoImpl;
begin
  if isILogonInfoImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TLogonInfo.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TLogonInfo.name(): PAnsiChar;
begin
	Result := vTable^.name(thisRecord);
end;

function TLogonInfo.role(): PAnsiChar;
begin
	Result := vTable^.role(thisRecord);
end;

function TLogonInfo.networkProtocol(): PAnsiChar;
begin
	Result := vTable^.networkProtocol(thisRecord);
end;

function TLogonInfo.remoteAddress(): PAnsiChar;
begin
	Result := vTable^.remoteAddress(thisRecord);
end;

function TLogonInfo.authBlock(length: CardinalPtr): BytePtr;
begin
	Result := vTable^.authBlock(thisRecord, length);
end;

function TLogonInfo.attachment(status: IStatus): IAttachment;
begin
	Result := vTable^.attachment(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TLogonInfo.transaction(status: IStatus): ITransaction;
begin
	Result := vTable^.transaction(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TManagement.thisRecord: IManagement;
begin
  Result := IManagement(@nullPtr);
end;

function TManagement.getIManagementImpl: IManagementImpl;
begin
  if isIManagementImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TManagement.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TManagement.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TManagement.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TManagement.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TManagement.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

procedure TManagement.start(status: IStatus; logonInfo: ILogonInfo);
begin
	vTable^.start(thisRecord, status, logonInfo);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TManagement.execute(status: IStatus; user: IUser; callback: IListUsers): Integer;
begin
	Result := vTable^.execute(thisRecord, status, user, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TManagement.commit(status: IStatus);
begin
	vTable^.commit(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TManagement.rollback(status: IStatus);
begin
	vTable^.rollback(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAuthBlock.thisRecord: IAuthBlock;
begin
  Result := IAuthBlock(@nullPtr);
end;

function TAuthBlock.getIAuthBlockImpl: IAuthBlockImpl;
begin
  if isIAuthBlockImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TAuthBlock.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TAuthBlock.getType(): PAnsiChar;
begin
	Result := vTable^.getType(thisRecord);
end;

function TAuthBlock.getName(): PAnsiChar;
begin
	Result := vTable^.getName(thisRecord);
end;

function TAuthBlock.getPlugin(): PAnsiChar;
begin
	Result := vTable^.getPlugin(thisRecord);
end;

function TAuthBlock.getSecurityDb(): PAnsiChar;
begin
	Result := vTable^.getSecurityDb(thisRecord);
end;

function TAuthBlock.getOriginalPlugin(): PAnsiChar;
begin
	Result := vTable^.getOriginalPlugin(thisRecord);
end;

function TAuthBlock.next(status: IStatus): Boolean;
begin
	Result := vTable^.next(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TAuthBlock.first(status: IStatus): Boolean;
begin
	Result := vTable^.first(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TWireCryptPlugin.thisRecord: IWireCryptPlugin;
begin
  Result := IWireCryptPlugin(@nullPtr);
end;

function TWireCryptPlugin.getIWireCryptPluginImpl: IWireCryptPluginImpl;
begin
  if isIWireCryptPluginImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TWireCryptPlugin.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TWireCryptPlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TWireCryptPlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TWireCryptPlugin.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TWireCryptPlugin.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TWireCryptPlugin.getKnownTypes(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getKnownTypes(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.setKey(status: IStatus; key: ICryptKey);
begin
	vTable^.setKey(thisRecord, status, key);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.encrypt(thisRecord, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.decrypt(thisRecord, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TWireCryptPlugin.getSpecificData(status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr;
begin
	Result := vTable^.getSpecificData(thisRecord, status, keyType, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TWireCryptPlugin.setSpecificData(status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr);
begin
	vTable^.setSpecificData(thisRecord, status, keyType, length, data);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TCryptKeyCallback.thisRecord: ICryptKeyCallback;
begin
  Result := ICryptKeyCallback(@nullPtr);
end;

function TCryptKeyCallback.getICryptKeyCallbackImpl: ICryptKeyCallbackImpl;
begin
  if isICryptKeyCallbackImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TCryptKeyCallback.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TCryptKeyCallback.callback(dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal;
begin
	Result := vTable^.callback(thisRecord, dataLength, data, bufferLength, buffer);
end;

function TKeyHolderPlugin.thisRecord: IKeyHolderPlugin;
begin
  Result := IKeyHolderPlugin(@nullPtr);
end;

function TKeyHolderPlugin.getIKeyHolderPluginImpl: IKeyHolderPluginImpl;
begin
  if isIKeyHolderPluginImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TKeyHolderPlugin.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TKeyHolderPlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TKeyHolderPlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TKeyHolderPlugin.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TKeyHolderPlugin.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TKeyHolderPlugin.keyCallback(status: IStatus; callback: ICryptKeyCallback): Integer;
begin
	Result := vTable^.keyCallback(thisRecord, status, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TKeyHolderPlugin.keyHandle(status: IStatus; keyName: PAnsiChar): ICryptKeyCallback;
begin
	Result := vTable^.keyHandle(thisRecord, status, keyName);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TKeyHolderPlugin.useOnlyOwnKeys(status: IStatus): Boolean;
begin
	Result := vTable^.useOnlyOwnKeys(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TKeyHolderPlugin.chainHandle(status: IStatus): ICryptKeyCallback;
begin
	Result := vTable^.chainHandle(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDbCryptInfo.thisRecord: IDbCryptInfo;
begin
  Result := IDbCryptInfo(@nullPtr);
end;

function TDbCryptInfo.getIDbCryptInfoImpl: IDbCryptInfoImpl;
begin
  if isIDbCryptInfoImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDbCryptInfo.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TDbCryptInfo.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TDbCryptInfo.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TDbCryptInfo.getDatabaseFullPath(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getDatabaseFullPath(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDbCryptPlugin.thisRecord: IDbCryptPlugin;
begin
  Result := IDbCryptPlugin(@nullPtr);
end;

function TDbCryptPlugin.getIDbCryptPluginImpl: IDbCryptPluginImpl;
begin
  if isIDbCryptPluginImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDbCryptPlugin.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TDbCryptPlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TDbCryptPlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TDbCryptPlugin.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TDbCryptPlugin.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

procedure TDbCryptPlugin.setKey(status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar);
begin
	vTable^.setKey(thisRecord, status, length, sources, keyName);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDbCryptPlugin.encrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.encrypt(thisRecord, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDbCryptPlugin.decrypt(status: IStatus; length: Cardinal; from: Pointer; to_: Pointer);
begin
	vTable^.decrypt(thisRecord, status, length, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDbCryptPlugin.setInfo(status: IStatus; info: IDbCryptInfo);
begin
	vTable^.setInfo(thisRecord, status, info);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.thisRecord: IExternalContext;
begin
  Result := IExternalContext(@nullPtr);
end;

function TExternalContext.getIExternalContextImpl: IExternalContextImpl;
begin
  if isIExternalContextImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TExternalContext.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TExternalContext.getMaster(): IMaster;
begin
	Result := vTable^.getMaster(thisRecord);
end;

function TExternalContext.getEngine(status: IStatus): IExternalEngine;
begin
	Result := vTable^.getEngine(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.getAttachment(status: IStatus): IAttachment;
begin
	Result := vTable^.getAttachment(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.getTransaction(status: IStatus): ITransaction;
begin
	Result := vTable^.getTransaction(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalContext.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(thisRecord);
end;

function TExternalContext.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(thisRecord);
end;

function TExternalContext.getClientCharSet(): PAnsiChar;
begin
	Result := vTable^.getClientCharSet(thisRecord);
end;

function TExternalContext.obtainInfoCode(): Integer;
begin
	Result := vTable^.obtainInfoCode(thisRecord);
end;

function TExternalContext.getInfo(code: Integer): Pointer;
begin
	Result := vTable^.getInfo(thisRecord, code);
end;

function TExternalContext.setInfo(code: Integer; value: Pointer): Pointer;
begin
	Result := vTable^.setInfo(thisRecord, code, value);
end;

function TExternalResultSet.thisRecord: IExternalResultSet;
begin
  Result := IExternalResultSet(@nullPtr);
end;

function TExternalResultSet.getIExternalResultSetImpl: IExternalResultSetImpl;
begin
  if isIExternalResultSetImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TExternalResultSet.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TExternalResultSet.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

function TExternalResultSet.fetch(status: IStatus): Boolean;
begin
	Result := vTable^.fetch(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalFunction.thisRecord: IExternalFunction;
begin
  Result := IExternalFunction(@nullPtr);
end;

function TExternalFunction.getIExternalFunctionImpl: IExternalFunctionImpl;
begin
  if isIExternalFunctionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TExternalFunction.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TExternalFunction.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TExternalFunction.getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(thisRecord, status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalFunction.execute(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer);
begin
	vTable^.execute(thisRecord, status, context, inMsg, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalProcedure.thisRecord: IExternalProcedure;
begin
  Result := IExternalProcedure(@nullPtr);
end;

function TExternalProcedure.getIExternalProcedureImpl: IExternalProcedureImpl;
begin
  if isIExternalProcedureImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TExternalProcedure.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TExternalProcedure.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TExternalProcedure.getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(thisRecord, status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalProcedure.open(status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet;
begin
	Result := vTable^.open(thisRecord, status, context, inMsg, outMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalTrigger.thisRecord: IExternalTrigger;
begin
  Result := IExternalTrigger(@nullPtr);
end;

function TExternalTrigger.getIExternalTriggerImpl: IExternalTriggerImpl;
begin
  if isIExternalTriggerImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TExternalTrigger.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TExternalTrigger.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TExternalTrigger.getCharSet(status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal);
begin
	vTable^.getCharSet(thisRecord, status, context, name, nameSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalTrigger.execute(status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer);
begin
	vTable^.execute(thisRecord, status, context, action, oldMsg, newMsg);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.thisRecord: IRoutineMetadata;
begin
  Result := IRoutineMetadata(@nullPtr);
end;

function TRoutineMetadata.getIRoutineMetadataImpl: IRoutineMetadataImpl;
begin
  if isIRoutineMetadataImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TRoutineMetadata.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TRoutineMetadata.getPackage(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getPackage(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getName(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getName(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getEntryPoint(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getEntryPoint(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getBody(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getBody(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getInputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getInputMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getOutputMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getOutputMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getTriggerMetadata(status: IStatus): IMessageMetadata;
begin
	Result := vTable^.getTriggerMetadata(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getTriggerTable(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getTriggerTable(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TRoutineMetadata.getTriggerType(status: IStatus): Cardinal;
begin
	Result := vTable^.getTriggerType(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.thisRecord: IExternalEngine;
begin
  Result := IExternalEngine(@nullPtr);
end;

function TExternalEngine.getIExternalEngineImpl: IExternalEngineImpl;
begin
  if isIExternalEngineImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TExternalEngine.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TExternalEngine.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TExternalEngine.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TExternalEngine.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TExternalEngine.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

procedure TExternalEngine.open(status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal);
begin
	vTable^.open(thisRecord, status, context, charSet, charSetSize);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalEngine.openAttachment(status: IStatus; context: IExternalContext);
begin
	vTable^.openAttachment(thisRecord, status, context);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TExternalEngine.closeAttachment(status: IStatus; context: IExternalContext);
begin
	vTable^.closeAttachment(thisRecord, status, context);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.makeFunction(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction;
begin
	Result := vTable^.makeFunction(thisRecord, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.makeProcedure(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure;
begin
	Result := vTable^.makeProcedure(thisRecord, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TExternalEngine.makeTrigger(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger;
begin
	Result := vTable^.makeTrigger(thisRecord, status, context, metadata, fieldsBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTimer.thisRecord: ITimer;
begin
  Result := ITimer(@nullPtr);
end;

function TTimer.getITimerImpl: ITimerImpl;
begin
  if isITimerImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTimer.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TTimer.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TTimer.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TTimer.handler();
begin
	vTable^.handler(thisRecord);
end;

function TTimerControl.thisRecord: ITimerControl;
begin
  Result := ITimerControl(@nullPtr);
end;

function TTimerControl.getITimerControlImpl: ITimerControlImpl;
begin
  if isITimerControlImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTimerControl.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TTimerControl.start(status: IStatus; timer: ITimer; microSeconds: QWord);
begin
	vTable^.start(thisRecord, status, timer, microSeconds);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TTimerControl.stop(status: IStatus; timer: ITimer);
begin
	vTable^.stop(thisRecord, status, timer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TVersionCallback.thisRecord: IVersionCallback;
begin
  Result := IVersionCallback(@nullPtr);
end;

function TVersionCallback.getIVersionCallbackImpl: IVersionCallbackImpl;
begin
  if isIVersionCallbackImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TVersionCallback.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TVersionCallback.callback(status: IStatus; text: PAnsiChar);
begin
	vTable^.callback(thisRecord, status, text);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.thisRecord: IUtil;
begin
  Result := IUtil(@nullPtr);
end;

function TUtil.getIUtilImpl: IUtilImpl;
begin
  if isIUtilImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUtil.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TUtil.getFbVersion(status: IStatus; att: IAttachment; callback: IVersionCallback);
begin
	vTable^.getFbVersion(thisRecord, status, att, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.loadBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
begin
	vTable^.loadBlob(thisRecord, status, blobId, att, tra, file_, txt);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.dumpBlob(status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean);
begin
	vTable^.dumpBlob(thisRecord, status, blobId, att, tra, file_, txt);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.getPerfCounters(status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr);
begin
	vTable^.getPerfCounters(thisRecord, status, att, countersSet, counters);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.executeCreateDatabase(status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment;
begin
	Result := vTable^.executeCreateDatabase(thisRecord, status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeDate(date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr);
begin
	vTable^.decodeDate(thisRecord, date, year, month, day);
end;

procedure TUtil.decodeTime(time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr);
begin
	vTable^.decodeTime(thisRecord, time, hours, minutes, seconds, fractions);
end;

function TUtil.encodeDate(year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE;
begin
	Result := vTable^.encodeDate(thisRecord, year, month, day);
end;

function TUtil.encodeTime(hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME;
begin
	Result := vTable^.encodeTime(thisRecord, hours, minutes, seconds, fractions);
end;

function TUtil.formatStatus(buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal;
begin
	Result := vTable^.formatStatus(thisRecord, buffer, bufferSize, status);
end;

function TUtil.getClientVersion(): Cardinal;
begin
	Result := vTable^.getClientVersion(thisRecord);
end;

function TUtil.getXpbBuilder(status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder;
begin
	Result := vTable^.getXpbBuilder(thisRecord, status, kind, buf, len);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.setOffsets(status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal;
begin
	Result := vTable^.setOffsets(thisRecord, status, metadata, callback);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.getDecFloat16(status: IStatus): IDecFloat16;
begin
	Result := vTable^.getDecFloat16(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.getDecFloat34(status: IStatus): IDecFloat34;
begin
	Result := vTable^.getDecFloat34(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeTz(thisRecord, status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeStampTz(thisRecord, status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.encodeTimeTz(status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
begin
	vTable^.encodeTimeTz(thisRecord, status, timeTz, hours, minutes, seconds, fractions, timeZone);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.encodeTimeStampTz(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar);
begin
	vTable^.encodeTimeStampTz(thisRecord, status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZone);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUtil.getInt128(status: IStatus): IInt128;
begin
	Result := vTable^.getInt128(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeTzEx(status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeTzEx(thisRecord, status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUtil.decodeTimeStampTzEx(status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar);
begin
	vTable^.decodeTimeStampTzEx(thisRecord, status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TOffsetsCallback.thisRecord: IOffsetsCallback;
begin
  Result := IOffsetsCallback(@nullPtr);
end;

function TOffsetsCallback.getIOffsetsCallbackImpl: IOffsetsCallbackImpl;
begin
  if isIOffsetsCallbackImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TOffsetsCallback.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TOffsetsCallback.setOffset(status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal);
begin
	vTable^.setOffset(thisRecord, status, index, offset, nullOffset);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.thisRecord: IXpbBuilder;
begin
  Result := IXpbBuilder(@nullPtr);
end;

function TXpbBuilder.getIXpbBuilderImpl: IXpbBuilderImpl;
begin
  if isIXpbBuilderImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TXpbBuilder.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TXpbBuilder.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TXpbBuilder.clear(status: IStatus);
begin
	vTable^.clear(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.removeCurrent(status: IStatus);
begin
	vTable^.removeCurrent(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertInt(status: IStatus; tag: Byte; value: Integer);
begin
	vTable^.insertInt(thisRecord, status, tag, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertBigInt(status: IStatus; tag: Byte; value: Int64);
begin
	vTable^.insertBigInt(thisRecord, status, tag, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertBytes(status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal);
begin
	vTable^.insertBytes(thisRecord, status, tag, bytes, length);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertString(status: IStatus; tag: Byte; str: PAnsiChar);
begin
	vTable^.insertString(thisRecord, status, tag, str);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.insertTag(status: IStatus; tag: Byte);
begin
	vTable^.insertTag(thisRecord, status, tag);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.isEof(status: IStatus): Boolean;
begin
	Result := vTable^.isEof(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.moveNext(status: IStatus);
begin
	vTable^.moveNext(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TXpbBuilder.rewind(status: IStatus);
begin
	vTable^.rewind(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.findFirst(status: IStatus; tag: Byte): Boolean;
begin
	Result := vTable^.findFirst(thisRecord, status, tag);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.findNext(status: IStatus): Boolean;
begin
	Result := vTable^.findNext(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getTag(status: IStatus): Byte;
begin
	Result := vTable^.getTag(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getLength(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getInt(status: IStatus): Integer;
begin
	Result := vTable^.getInt(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBigInt(status: IStatus): Int64;
begin
	Result := vTable^.getBigInt(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getString(status: IStatus): PAnsiChar;
begin
	Result := vTable^.getString(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBytes(status: IStatus): BytePtr;
begin
	Result := vTable^.getBytes(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBufferLength(status: IStatus): Cardinal;
begin
	Result := vTable^.getBufferLength(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TXpbBuilder.getBuffer(status: IStatus): BytePtr;
begin
	Result := vTable^.getBuffer(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTraceConnection.thisRecord: ITraceConnection;
begin
  Result := ITraceConnection(@nullPtr);
end;

function TTraceConnection.getITraceConnectionImpl: ITraceConnectionImpl;
begin
  if isITraceConnectionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceConnection.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(thisRecord);
end;

function TTraceConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(thisRecord);
end;

function TTraceConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(thisRecord);
end;

function TTraceConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(thisRecord);
end;

function TTraceConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(thisRecord);
end;

function TTraceConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(thisRecord);
end;

function TTraceConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(thisRecord);
end;

function TTraceConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(thisRecord);
end;

function TTraceConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(thisRecord);
end;

function TTraceDatabaseConnection.thisRecord: ITraceDatabaseConnection;
begin
  Result := ITraceDatabaseConnection(@nullPtr);
end;

function TTraceDatabaseConnection.getITraceDatabaseConnectionImpl: ITraceDatabaseConnectionImpl;
begin
  if isITraceDatabaseConnectionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceDatabaseConnection.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceDatabaseConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(ITraceConnection(thisRecord));
end;

function TTraceDatabaseConnection.getConnectionID(): Int64;
begin
	Result := vTable^.getConnectionID(thisRecord);
end;

function TTraceDatabaseConnection.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(thisRecord);
end;

function TTraceTransaction.thisRecord: ITraceTransaction;
begin
  Result := ITraceTransaction(@nullPtr);
end;

function TTraceTransaction.getITraceTransactionImpl: ITraceTransactionImpl;
begin
  if isITraceTransactionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceTransaction.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceTransaction.getTransactionID(): Int64;
begin
	Result := vTable^.getTransactionID(thisRecord);
end;

function TTraceTransaction.getReadOnly(): Boolean;
begin
	Result := vTable^.getReadOnly(thisRecord);
end;

function TTraceTransaction.getWait(): Integer;
begin
	Result := vTable^.getWait(thisRecord);
end;

function TTraceTransaction.getIsolation(): Cardinal;
begin
	Result := vTable^.getIsolation(thisRecord);
end;

function TTraceTransaction.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(thisRecord);
end;

function TTraceTransaction.getInitialID(): Int64;
begin
	Result := vTable^.getInitialID(thisRecord);
end;

function TTraceTransaction.getPreviousID(): Int64;
begin
	Result := vTable^.getPreviousID(thisRecord);
end;

function TTraceParams.thisRecord: ITraceParams;
begin
  Result := ITraceParams(@nullPtr);
end;

function TTraceParams.getITraceParamsImpl: ITraceParamsImpl;
begin
  if isITraceParamsImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceParams.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceParams.getCount(): Cardinal;
begin
	Result := vTable^.getCount(thisRecord);
end;

function TTraceParams.getParam(idx: Cardinal): dscPtr;
begin
	Result := vTable^.getParam(thisRecord, idx);
end;

function TTraceParams.getTextUTF8(status: IStatus; idx: Cardinal): PAnsiChar;
begin
	Result := vTable^.getTextUTF8(thisRecord, status, idx);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTraceStatement.thisRecord: ITraceStatement;
begin
  Result := ITraceStatement(@nullPtr);
end;

function TTraceStatement.getITraceStatementImpl: ITraceStatementImpl;
begin
  if isITraceStatementImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceStatement.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(thisRecord);
end;

function TTraceStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(thisRecord);
end;

function TTraceSQLStatement.thisRecord: ITraceSQLStatement;
begin
  Result := ITraceSQLStatement(@nullPtr);
end;

function TTraceSQLStatement.getITraceSQLStatementImpl: ITraceSQLStatementImpl;
begin
  if isITraceSQLStatementImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceSQLStatement.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceSQLStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(ITraceStatement(thisRecord));
end;

function TTraceSQLStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(ITraceStatement(thisRecord));
end;

function TTraceSQLStatement.getText(): PAnsiChar;
begin
	Result := vTable^.getText(thisRecord);
end;

function TTraceSQLStatement.getPlan(): PAnsiChar;
begin
	Result := vTable^.getPlan(thisRecord);
end;

function TTraceSQLStatement.getInputs(): ITraceParams;
begin
	Result := vTable^.getInputs(thisRecord);
end;

function TTraceSQLStatement.getTextUTF8(): PAnsiChar;
begin
	Result := vTable^.getTextUTF8(thisRecord);
end;

function TTraceSQLStatement.getExplainedPlan(): PAnsiChar;
begin
	Result := vTable^.getExplainedPlan(thisRecord);
end;

function TTraceBLRStatement.thisRecord: ITraceBLRStatement;
begin
  Result := ITraceBLRStatement(@nullPtr);
end;

function TTraceBLRStatement.getITraceBLRStatementImpl: ITraceBLRStatementImpl;
begin
  if isITraceBLRStatementImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceBLRStatement.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceBLRStatement.getStmtID(): Int64;
begin
	Result := vTable^.getStmtID(ITraceStatement(thisRecord));
end;

function TTraceBLRStatement.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(ITraceStatement(thisRecord));
end;

function TTraceBLRStatement.getData(): BytePtr;
begin
	Result := vTable^.getData(thisRecord);
end;

function TTraceBLRStatement.getDataLength(): Cardinal;
begin
	Result := vTable^.getDataLength(thisRecord);
end;

function TTraceBLRStatement.getText(): PAnsiChar;
begin
	Result := vTable^.getText(thisRecord);
end;

function TTraceDYNRequest.thisRecord: ITraceDYNRequest;
begin
  Result := ITraceDYNRequest(@nullPtr);
end;

function TTraceDYNRequest.getITraceDYNRequestImpl: ITraceDYNRequestImpl;
begin
  if isITraceDYNRequestImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceDYNRequest.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceDYNRequest.getData(): BytePtr;
begin
	Result := vTable^.getData(thisRecord);
end;

function TTraceDYNRequest.getDataLength(): Cardinal;
begin
	Result := vTable^.getDataLength(thisRecord);
end;

function TTraceDYNRequest.getText(): PAnsiChar;
begin
	Result := vTable^.getText(thisRecord);
end;

function TTraceContextVariable.thisRecord: ITraceContextVariable;
begin
  Result := ITraceContextVariable(@nullPtr);
end;

function TTraceContextVariable.getITraceContextVariableImpl: ITraceContextVariableImpl;
begin
  if isITraceContextVariableImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceContextVariable.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceContextVariable.getNameSpace(): PAnsiChar;
begin
	Result := vTable^.getNameSpace(thisRecord);
end;

function TTraceContextVariable.getVarName(): PAnsiChar;
begin
	Result := vTable^.getVarName(thisRecord);
end;

function TTraceContextVariable.getVarValue(): PAnsiChar;
begin
	Result := vTable^.getVarValue(thisRecord);
end;

function TTraceProcedure.thisRecord: ITraceProcedure;
begin
  Result := ITraceProcedure(@nullPtr);
end;

function TTraceProcedure.getITraceProcedureImpl: ITraceProcedureImpl;
begin
  if isITraceProcedureImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceProcedure.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceProcedure.getProcName(): PAnsiChar;
begin
	Result := vTable^.getProcName(thisRecord);
end;

function TTraceProcedure.getInputs(): ITraceParams;
begin
	Result := vTable^.getInputs(thisRecord);
end;

function TTraceProcedure.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(thisRecord);
end;

function TTraceFunction.thisRecord: ITraceFunction;
begin
  Result := ITraceFunction(@nullPtr);
end;

function TTraceFunction.getITraceFunctionImpl: ITraceFunctionImpl;
begin
  if isITraceFunctionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceFunction.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceFunction.getFuncName(): PAnsiChar;
begin
	Result := vTable^.getFuncName(thisRecord);
end;

function TTraceFunction.getInputs(): ITraceParams;
begin
	Result := vTable^.getInputs(thisRecord);
end;

function TTraceFunction.getResult(): ITraceParams;
begin
	Result := vTable^.getResult(thisRecord);
end;

function TTraceFunction.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(thisRecord);
end;

function TTraceTrigger.thisRecord: ITraceTrigger;
begin
  Result := ITraceTrigger(@nullPtr);
end;

function TTraceTrigger.getITraceTriggerImpl: ITraceTriggerImpl;
begin
  if isITraceTriggerImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceTrigger.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceTrigger.getTriggerName(): PAnsiChar;
begin
	Result := vTable^.getTriggerName(thisRecord);
end;

function TTraceTrigger.getRelationName(): PAnsiChar;
begin
	Result := vTable^.getRelationName(thisRecord);
end;

function TTraceTrigger.getAction(): Integer;
begin
	Result := vTable^.getAction(thisRecord);
end;

function TTraceTrigger.getWhich(): Integer;
begin
	Result := vTable^.getWhich(thisRecord);
end;

function TTraceTrigger.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(thisRecord);
end;

function TTraceServiceConnection.thisRecord: ITraceServiceConnection;
begin
  Result := ITraceServiceConnection(@nullPtr);
end;

function TTraceServiceConnection.getITraceServiceConnectionImpl: ITraceServiceConnectionImpl;
begin
  if isITraceServiceConnectionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceServiceConnection.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceServiceConnection.getKind(): Cardinal;
begin
	Result := vTable^.getKind(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getProcessID(): Integer;
begin
	Result := vTable^.getProcessID(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getUserName(): PAnsiChar;
begin
	Result := vTable^.getUserName(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getRoleName(): PAnsiChar;
begin
	Result := vTable^.getRoleName(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getCharSet(): PAnsiChar;
begin
	Result := vTable^.getCharSet(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getRemoteProtocol(): PAnsiChar;
begin
	Result := vTable^.getRemoteProtocol(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getRemoteAddress(): PAnsiChar;
begin
	Result := vTable^.getRemoteAddress(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getRemoteProcessID(): Integer;
begin
	Result := vTable^.getRemoteProcessID(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getRemoteProcessName(): PAnsiChar;
begin
	Result := vTable^.getRemoteProcessName(ITraceConnection(thisRecord));
end;

function TTraceServiceConnection.getServiceID(): Pointer;
begin
	Result := vTable^.getServiceID(thisRecord);
end;

function TTraceServiceConnection.getServiceMgr(): PAnsiChar;
begin
	Result := vTable^.getServiceMgr(thisRecord);
end;

function TTraceServiceConnection.getServiceName(): PAnsiChar;
begin
	Result := vTable^.getServiceName(thisRecord);
end;

function TTraceStatusVector.thisRecord: ITraceStatusVector;
begin
  Result := ITraceStatusVector(@nullPtr);
end;

function TTraceStatusVector.getITraceStatusVectorImpl: ITraceStatusVectorImpl;
begin
  if isITraceStatusVectorImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceStatusVector.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceStatusVector.hasError(): Boolean;
begin
	Result := vTable^.hasError(thisRecord);
end;

function TTraceStatusVector.hasWarning(): Boolean;
begin
	Result := vTable^.hasWarning(thisRecord);
end;

function TTraceStatusVector.getStatus(): IStatus;
begin
	Result := vTable^.getStatus(thisRecord);
end;

function TTraceStatusVector.getText(): PAnsiChar;
begin
	Result := vTable^.getText(thisRecord);
end;

function TTraceSweepInfo.thisRecord: ITraceSweepInfo;
begin
  Result := ITraceSweepInfo(@nullPtr);
end;

function TTraceSweepInfo.getITraceSweepInfoImpl: ITraceSweepInfoImpl;
begin
  if isITraceSweepInfoImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceSweepInfo.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceSweepInfo.getOIT(): Int64;
begin
	Result := vTable^.getOIT(thisRecord);
end;

function TTraceSweepInfo.getOST(): Int64;
begin
	Result := vTable^.getOST(thisRecord);
end;

function TTraceSweepInfo.getOAT(): Int64;
begin
	Result := vTable^.getOAT(thisRecord);
end;

function TTraceSweepInfo.getNext(): Int64;
begin
	Result := vTable^.getNext(thisRecord);
end;

function TTraceSweepInfo.getPerf(): PerformanceInfoPtr;
begin
	Result := vTable^.getPerf(thisRecord);
end;

function TTraceLogWriter.thisRecord: ITraceLogWriter;
begin
  Result := ITraceLogWriter(@nullPtr);
end;

function TTraceLogWriter.getITraceLogWriterImpl: ITraceLogWriterImpl;
begin
  if isITraceLogWriterImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceLogWriter.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TTraceLogWriter.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TTraceLogWriter.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TTraceLogWriter.write(buf: Pointer; size: Cardinal): Cardinal;
begin
	Result := vTable^.write(thisRecord, buf, size);
end;

function TTraceLogWriter.write_s(status: IStatus; buf: Pointer; size: Cardinal): Cardinal;
begin
	Result := vTable^.write_s(thisRecord, status, buf, size);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TTraceInitInfo.thisRecord: ITraceInitInfo;
begin
  Result := ITraceInitInfo(@nullPtr);
end;

function TTraceInitInfo.getITraceInitInfoImpl: ITraceInitInfoImpl;
begin
  if isITraceInitInfoImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceInitInfo.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TTraceInitInfo.getConfigText(): PAnsiChar;
begin
	Result := vTable^.getConfigText(thisRecord);
end;

function TTraceInitInfo.getTraceSessionID(): Integer;
begin
	Result := vTable^.getTraceSessionID(thisRecord);
end;

function TTraceInitInfo.getTraceSessionName(): PAnsiChar;
begin
	Result := vTable^.getTraceSessionName(thisRecord);
end;

function TTraceInitInfo.getFirebirdRootDirectory(): PAnsiChar;
begin
	Result := vTable^.getFirebirdRootDirectory(thisRecord);
end;

function TTraceInitInfo.getDatabaseName(): PAnsiChar;
begin
	Result := vTable^.getDatabaseName(thisRecord);
end;

function TTraceInitInfo.getConnection(): ITraceDatabaseConnection;
begin
	Result := vTable^.getConnection(thisRecord);
end;

function TTraceInitInfo.getLogWriter(): ITraceLogWriter;
begin
	Result := vTable^.getLogWriter(thisRecord);
end;

function TTracePlugin.thisRecord: ITracePlugin;
begin
  Result := ITracePlugin(@nullPtr);
end;

function TTracePlugin.getITracePluginImpl: ITracePluginImpl;
begin
  if isITracePluginImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTracePlugin.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TTracePlugin.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TTracePlugin.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

function TTracePlugin.trace_get_error(): PAnsiChar;
begin
	Result := vTable^.trace_get_error(thisRecord);
end;

function TTracePlugin.trace_attach(connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_attach(thisRecord, connection, create_db, att_result);
end;

function TTracePlugin.trace_detach(connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean;
begin
	Result := vTable^.trace_detach(thisRecord, connection, drop_db);
end;

function TTracePlugin.trace_transaction_start(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_transaction_start(thisRecord, connection, transaction, tpb_length, tpb, tra_result);
end;

function TTracePlugin.trace_transaction_end(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_transaction_end(thisRecord, connection, transaction, commit, retain_context, tra_result);
end;

function TTracePlugin.trace_proc_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_proc_execute(thisRecord, connection, transaction, procedure_, started, proc_result);
end;

function TTracePlugin.trace_trigger_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_trigger_execute(thisRecord, connection, transaction, trigger, started, trig_result);
end;

function TTracePlugin.trace_set_context(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean;
begin
	Result := vTable^.trace_set_context(thisRecord, connection, transaction, variable);
end;

function TTracePlugin.trace_dsql_prepare(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_prepare(thisRecord, connection, transaction, statement, time_millis, req_result);
end;

function TTracePlugin.trace_dsql_free(connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_free(thisRecord, connection, statement, option);
end;

function TTracePlugin.trace_dsql_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dsql_execute(thisRecord, connection, transaction, statement, started, req_result);
end;

function TTracePlugin.trace_blr_compile(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_blr_compile(thisRecord, connection, transaction, statement, time_millis, req_result);
end;

function TTracePlugin.trace_blr_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_blr_execute(thisRecord, connection, transaction, statement, req_result);
end;

function TTracePlugin.trace_dyn_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_dyn_execute(thisRecord, connection, transaction, request, time_millis, req_result);
end;

function TTracePlugin.trace_service_attach(service: ITraceServiceConnection; att_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_attach(thisRecord, service, att_result);
end;

function TTracePlugin.trace_service_start(service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_start(thisRecord, service, switches_length, switches, start_result);
end;

function TTracePlugin.trace_service_query(service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_query(thisRecord, service, send_item_length, send_items, recv_item_length, recv_items, query_result);
end;

function TTracePlugin.trace_service_detach(service: ITraceServiceConnection; detach_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_service_detach(thisRecord, service, detach_result);
end;

function TTracePlugin.trace_event_error(connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean;
begin
	Result := vTable^.trace_event_error(thisRecord, connection, status, function_);
end;

function TTracePlugin.trace_event_sweep(connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean;
begin
	Result := vTable^.trace_event_sweep(thisRecord, connection, sweep, sweep_state);
end;

function TTracePlugin.trace_func_execute(connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean;
begin
	Result := vTable^.trace_func_execute(thisRecord, connection, transaction, function_, started, func_result);
end;

function TTraceFactory.thisRecord: ITraceFactory;
begin
  Result := ITraceFactory(@nullPtr);
end;

function TTraceFactory.getITraceFactoryImpl: ITraceFactoryImpl;
begin
  if isITraceFactoryImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TTraceFactory.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TTraceFactory.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TTraceFactory.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TTraceFactory.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TTraceFactory.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TTraceFactory.trace_needs(): QWord;
begin
	Result := vTable^.trace_needs(thisRecord);
end;

function TTraceFactory.trace_create(status: IStatus; init_info: ITraceInitInfo): ITracePlugin;
begin
	Result := vTable^.trace_create(thisRecord, status, init_info);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrFunctionFactory.thisRecord: IUdrFunctionFactory;
begin
  Result := IUdrFunctionFactory(@nullPtr);
end;

function TUdrFunctionFactory.getIUdrFunctionFactoryImpl: IUdrFunctionFactoryImpl;
begin
  if isIUdrFunctionFactoryImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUdrFunctionFactory.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TUdrFunctionFactory.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TUdrFunctionFactory.setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
begin
	vTable^.setup(thisRecord, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrFunctionFactory.newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction;
begin
	Result := vTable^.newItem(thisRecord, status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrProcedureFactory.thisRecord: IUdrProcedureFactory;
begin
  Result := IUdrProcedureFactory(@nullPtr);
end;

function TUdrProcedureFactory.getIUdrProcedureFactoryImpl: IUdrProcedureFactoryImpl;
begin
  if isIUdrProcedureFactoryImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUdrProcedureFactory.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TUdrProcedureFactory.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TUdrProcedureFactory.setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder);
begin
	vTable^.setup(thisRecord, status, context, metadata, inBuilder, outBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrProcedureFactory.newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure;
begin
	Result := vTable^.newItem(thisRecord, status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrTriggerFactory.thisRecord: IUdrTriggerFactory;
begin
  Result := IUdrTriggerFactory(@nullPtr);
end;

function TUdrTriggerFactory.getIUdrTriggerFactoryImpl: IUdrTriggerFactoryImpl;
begin
  if isIUdrTriggerFactoryImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUdrTriggerFactory.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TUdrTriggerFactory.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TUdrTriggerFactory.setup(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder);
begin
	vTable^.setup(thisRecord, status, context, metadata, fieldsBuilder);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrTriggerFactory.newItem(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger;
begin
	Result := vTable^.newItem(thisRecord, status, context, metadata);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TUdrPlugin.thisRecord: IUdrPlugin;
begin
  Result := IUdrPlugin(@nullPtr);
end;

function TUdrPlugin.getIUdrPluginImpl: IUdrPluginImpl;
begin
  if isIUdrPluginImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TUdrPlugin.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TUdrPlugin.getMaster(): IMaster;
begin
	Result := vTable^.getMaster(thisRecord);
end;

procedure TUdrPlugin.registerFunction(status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory);
begin
	vTable^.registerFunction(thisRecord, status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUdrPlugin.registerProcedure(status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory);
begin
	vTable^.registerProcedure(thisRecord, status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TUdrPlugin.registerTrigger(status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory);
begin
	vTable^.registerTrigger(thisRecord, status, name, factory);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDecFloat16.thisRecord: IDecFloat16;
begin
  Result := IDecFloat16(@nullPtr);
end;

function TDecFloat16.getIDecFloat16Impl: IDecFloat16Impl;
begin
  if isIDecFloat16Impl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDecFloat16.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TDecFloat16.toBcd(from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
begin
	vTable^.toBcd(thisRecord, from, sign, bcd, exp);
end;

procedure TDecFloat16.toString(status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(thisRecord, status, from, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDecFloat16.fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr);
begin
	vTable^.fromBcd(thisRecord, sign, bcd, exp, to_);
end;

procedure TDecFloat16.fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr);
begin
	vTable^.fromString(thisRecord, status, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TDecFloat34.thisRecord: IDecFloat34;
begin
  Result := IDecFloat34(@nullPtr);
end;

function TDecFloat34.getIDecFloat34Impl: IDecFloat34Impl;
begin
  if isIDecFloat34Impl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TDecFloat34.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TDecFloat34.toBcd(from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr);
begin
	vTable^.toBcd(thisRecord, from, sign, bcd, exp);
end;

procedure TDecFloat34.toString(status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(thisRecord, status, from, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TDecFloat34.fromBcd(sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr);
begin
	vTable^.fromBcd(thisRecord, sign, bcd, exp, to_);
end;

procedure TDecFloat34.fromString(status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr);
begin
	vTable^.fromString(thisRecord, status, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TInt128.thisRecord: IInt128;
begin
  Result := IInt128(@nullPtr);
end;

function TInt128.getIInt128Impl: IInt128Impl;
begin
  if isIInt128Impl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TInt128.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TInt128.toString(status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar);
begin
	vTable^.toString(thisRecord, status, from, scale, bufferLength, buffer);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TInt128.fromString(status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr);
begin
	vTable^.fromString(thisRecord, status, scale, from, to_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicatedField.thisRecord: IReplicatedField;
begin
  Result := IReplicatedField(@nullPtr);
end;

function TReplicatedField.getIReplicatedFieldImpl: IReplicatedFieldImpl;
begin
  if isIReplicatedFieldImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TReplicatedField.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TReplicatedField.getName(): PAnsiChar;
begin
	Result := vTable^.getName(thisRecord);
end;

function TReplicatedField.getType(): Cardinal;
begin
	Result := vTable^.getType(thisRecord);
end;

function TReplicatedField.getSubType(): Integer;
begin
	Result := vTable^.getSubType(thisRecord);
end;

function TReplicatedField.getScale(): Integer;
begin
	Result := vTable^.getScale(thisRecord);
end;

function TReplicatedField.getLength(): Cardinal;
begin
	Result := vTable^.getLength(thisRecord);
end;

function TReplicatedField.getCharSet(): Cardinal;
begin
	Result := vTable^.getCharSet(thisRecord);
end;

function TReplicatedField.getData(): Pointer;
begin
	Result := vTable^.getData(thisRecord);
end;

function TReplicatedRecord.thisRecord: IReplicatedRecord;
begin
  Result := IReplicatedRecord(@nullPtr);
end;

function TReplicatedRecord.getIReplicatedRecordImpl: IReplicatedRecordImpl;
begin
  if isIReplicatedRecordImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TReplicatedRecord.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

function TReplicatedRecord.getCount(): Cardinal;
begin
	Result := vTable^.getCount(thisRecord);
end;

function TReplicatedRecord.getField(index: Cardinal): IReplicatedField;
begin
	Result := vTable^.getField(thisRecord, index);
end;

function TReplicatedRecord.getRawLength(): Cardinal;
begin
	Result := vTable^.getRawLength(thisRecord);
end;

function TReplicatedRecord.getRawData(): BytePtr;
begin
	Result := vTable^.getRawData(thisRecord);
end;

function TReplicatedTransaction.thisRecord: IReplicatedTransaction;
begin
  Result := IReplicatedTransaction(@nullPtr);
end;

function TReplicatedTransaction.getIReplicatedTransactionImpl: IReplicatedTransactionImpl;
begin
  if isIReplicatedTransactionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TReplicatedTransaction.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TReplicatedTransaction.dispose();
begin
	vTable^.dispose(IDisposable(thisRecord));
end;

procedure TReplicatedTransaction.prepare(status: IStatus);
begin
	vTable^.prepare(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.commit(status: IStatus);
begin
	vTable^.commit(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.rollback(status: IStatus);
begin
	vTable^.rollback(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.startSavepoint(status: IStatus);
begin
	vTable^.startSavepoint(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.releaseSavepoint(status: IStatus);
begin
	vTable^.releaseSavepoint(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.rollbackSavepoint(status: IStatus);
begin
	vTable^.rollbackSavepoint(thisRecord, status);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.insertRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
begin
	vTable^.insertRecord(thisRecord, status, name, record_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.updateRecord(status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord);
begin
	vTable^.updateRecord(thisRecord, status, name, orgRecord, newRecord);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.deleteRecord(status: IStatus; name: PAnsiChar; record_: IReplicatedRecord);
begin
	vTable^.deleteRecord(thisRecord, status, name, record_);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.executeSql(status: IStatus; sql: PAnsiChar);
begin
	vTable^.executeSql(thisRecord, status, sql);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedTransaction.executeSqlIntl(status: IStatus; charset: Cardinal; sql: PAnsiChar);
begin
	vTable^.executeSqlIntl(thisRecord, status, charset, sql);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicatedSession.thisRecord: IReplicatedSession;
begin
  Result := IReplicatedSession(@nullPtr);
end;

function TReplicatedSession.getIReplicatedSessionImpl: IReplicatedSessionImpl;
begin
  if isIReplicatedSessionImpl then
    Result := owner
  else
    raise FbException.CreateFmt(errNotImplementationObject,[Result.ClassName]);
end;

function TReplicatedSession.getvTableVersion: NativeInt;
begin
  Result := vTable^.version
end;

procedure TReplicatedSession.addRef();
begin
	vTable^.addRef(IReferenceCounted(thisRecord));
end;

function TReplicatedSession.release(): Integer;
begin
	Result := vTable^.release(IReferenceCounted(thisRecord));
end;

procedure TReplicatedSession.setOwner(r: IReferenceCounted);
begin
	vTable^.setOwner(IPluginBase(thisRecord), r);
end;

function TReplicatedSession.getOwner(): IReferenceCounted;
begin
	Result := vTable^.getOwner(IPluginBase(thisRecord));
end;

function TReplicatedSession.init(status: IStatus; attachment: IAttachment): Boolean;
begin
	Result := vTable^.init(thisRecord, status, attachment);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function TReplicatedSession.startTransaction(status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction;
begin
	Result := vTable^.startTransaction(thisRecord, status, transaction, number);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedSession.cleanupTransaction(status: IStatus; number: Int64);
begin
	vTable^.cleanupTransaction(thisRecord, status, number);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

procedure TReplicatedSession.setSequence(status: IStatus; name: PAnsiChar; value: Int64);
begin
	vTable^.setSequence(thisRecord, status, name, value);
	{$IFDEF USEFBEXCEPTION}FbException.checkException(status);{$ENDIF}
end;

function IVersionedImpl.getInterface:IVersioned;
begin
  Result := IVersioned(@nullPtr);
end;

var IVersionedImpl_vTable: VersionedVTable = (
     NullPtr: nil;
     version: 0);

function TVersioned.isIVersionedImpl: boolean inline;
begin
  Result := (vTable = @IVersionedImpl_vTable);
end;

constructor IVersionedImpl.create;
begin
  inherited Create;
  Owner := self;
  vTable := @IVersionedImpl_vTable;
end;

function IVersionedImpl.getvTableVersion: NativeInt;
begin
  Result := PVersionedVTable(vTable)^.version
end;

function IReferenceCountedImpl.getInterface:IReferenceCounted;
begin
  Result := IReferenceCounted(@nullPtr);
end;

procedure IReferenceCountedImpl_addRefDispatcher(this: IReferenceCounted); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReferenceCountedImpl_releaseDispatcher(this: IReferenceCounted): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IReferenceCountedImpl_vTable: ReferenceCountedVTable = (
     NullPtr: nil;
     version: 2;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher);

function TReferenceCounted.isIReferenceCountedImpl: boolean inline;
begin
  Result := (vTable = @IReferenceCountedImpl_vTable);
end;

constructor IReferenceCountedImpl.create;
begin
  inherited Create;
  vTable := @IReferenceCountedImpl_vTable;
end;

function IReferenceCountedImpl.getvTableVersion: NativeInt;
begin
  Result := PReferenceCountedVTable(vTable)^.version
end;

function IDisposableImpl.getInterface:IDisposable;
begin
  Result := IDisposable(@nullPtr);
end;

procedure IDisposableImpl_disposeDispatcher(this: IDisposable); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IDisposableImpl_vTable: DisposableVTable = (
     NullPtr: nil;
     version: 1;
     dispose: @IDisposableImpl_disposeDispatcher);

function TDisposable.isIDisposableImpl: boolean inline;
begin
  Result := (vTable = @IDisposableImpl_vTable);
end;

constructor IDisposableImpl.create;
begin
  inherited Create;
  vTable := @IDisposableImpl_vTable;
end;

function IDisposableImpl.getvTableVersion: NativeInt;
begin
  Result := PDisposableVTable(vTable)^.version
end;

function IStatusImpl.getInterface:IStatus;
begin
  Result := IStatus(@nullPtr);
end;

procedure IStatusImpl_disposeDispatcher(this: IStatus); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_initDispatcher(this: IStatus); cdecl;
begin
	try
		this.owner.init();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getStateDispatcher(this: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getState();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setErrors2Dispatcher(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
begin
	try
		this.owner.setErrors2(length, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setWarnings2Dispatcher(this: IStatus; length: Cardinal; value: NativeIntPtr); cdecl;
begin
	try
		this.owner.setWarnings2(length, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setErrorsDispatcher(this: IStatus; value: NativeIntPtr); cdecl;
begin
	try
		this.owner.setErrors(value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatusImpl_setWarningsDispatcher(this: IStatus; value: NativeIntPtr); cdecl;
begin
	try
		this.owner.setWarnings(value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getErrorsDispatcher(this: IStatus): NativeIntPtr; cdecl;
begin
	try
		Result := this.owner.getErrors();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_getWarningsDispatcher(this: IStatus): NativeIntPtr; cdecl;
begin
	try
		Result := this.owner.getWarnings();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatusImpl_cloneDispatcher(this: IStatus): IStatus; cdecl;
begin
	try
		Result := this.owner.clone();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IStatusImpl_vTable: StatusVTable = (
     NullPtr: nil;
     version: 10;
     dispose: @IDisposableImpl_disposeDispatcher;
     init: @IStatusImpl_initDispatcher;
     getState: @IStatusImpl_getStateDispatcher;
     setErrors2: @IStatusImpl_setErrors2Dispatcher;
     setWarnings2: @IStatusImpl_setWarnings2Dispatcher;
     setErrors: @IStatusImpl_setErrorsDispatcher;
     setWarnings: @IStatusImpl_setWarningsDispatcher;
     getErrors: @IStatusImpl_getErrorsDispatcher;
     getWarnings: @IStatusImpl_getWarningsDispatcher;
     clone: @IStatusImpl_cloneDispatcher);

function TStatus.isIStatusImpl: boolean inline;
begin
  Result := (vTable = @IStatusImpl_vTable);
end;

constructor IStatusImpl.create;
begin
  inherited Create;
  vTable := @IStatusImpl_vTable;
end;

function IStatusImpl.getvTableVersion: NativeInt;
begin
  Result := PStatusVTable(vTable)^.version
end;

function IMasterImpl.getInterface:IMaster;
begin
  Result := IMaster(@nullPtr);
end;

function IMasterImpl_getStatusDispatcher(this: IMaster): IStatus; cdecl;
begin
	try
		Result := this.owner.getStatus();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getDispatcherDispatcher(this: IMaster): IProvider; cdecl;
begin
	try
		Result := this.owner.getDispatcher();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getPluginManagerDispatcher(this: IMaster): IPluginManager; cdecl;
begin
	try
		Result := this.owner.getPluginManager();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getTimerControlDispatcher(this: IMaster): ITimerControl; cdecl;
begin
	try
		Result := this.owner.getTimerControl();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getDtcDispatcher(this: IMaster): IDtc; cdecl;
begin
	try
		Result := this.owner.getDtc();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_registerAttachmentDispatcher(this: IMaster; provider: IProvider; attachment: IAttachment): IAttachment; cdecl;
begin
	try
		Result := this.owner.registerAttachment(provider, attachment);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_registerTransactionDispatcher(this: IMaster; attachment: IAttachment; transaction: ITransaction): ITransaction; cdecl;
begin
	try
		Result := this.owner.registerTransaction(attachment, transaction);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getMetadataBuilderDispatcher(this: IMaster; status: IStatus; fieldCount: Cardinal): IMetadataBuilder; cdecl;
begin
	try
		Result := this.owner.getMetadataBuilder(status, fieldCount);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMasterImpl_serverModeDispatcher(this: IMaster; mode: Integer): Integer; cdecl;
begin
	try
		Result := this.owner.serverMode(mode);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getUtilInterfaceDispatcher(this: IMaster): IUtil; cdecl;
begin
	try
		Result := this.owner.getUtilInterface();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getConfigManagerDispatcher(this: IMaster): IConfigManager; cdecl;
begin
	try
		Result := this.owner.getConfigManager();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMasterImpl_getProcessExitingDispatcher(this: IMaster): Boolean; cdecl;
begin
	try
		Result := this.owner.getProcessExiting();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IMasterImpl_vTable: MasterVTable = (
     NullPtr: nil;
     version: 12;
     getStatus: @IMasterImpl_getStatusDispatcher;
     getDispatcher: @IMasterImpl_getDispatcherDispatcher;
     getPluginManager: @IMasterImpl_getPluginManagerDispatcher;
     getTimerControl: @IMasterImpl_getTimerControlDispatcher;
     getDtc: @IMasterImpl_getDtcDispatcher;
     registerAttachment: @IMasterImpl_registerAttachmentDispatcher;
     registerTransaction: @IMasterImpl_registerTransactionDispatcher;
     getMetadataBuilder: @IMasterImpl_getMetadataBuilderDispatcher;
     serverMode: @IMasterImpl_serverModeDispatcher;
     getUtilInterface: @IMasterImpl_getUtilInterfaceDispatcher;
     getConfigManager: @IMasterImpl_getConfigManagerDispatcher;
     getProcessExiting: @IMasterImpl_getProcessExitingDispatcher);

function TMaster.isIMasterImpl: boolean inline;
begin
  Result := (vTable = @IMasterImpl_vTable);
end;

constructor IMasterImpl.create;
begin
  inherited Create;
  vTable := @IMasterImpl_vTable;
end;

function IMasterImpl.getvTableVersion: NativeInt;
begin
  Result := PMasterVTable(vTable)^.version
end;

function IPluginBaseImpl.getInterface:IPluginBase;
begin
  Result := IPluginBase(@nullPtr);
end;

procedure IPluginBaseImpl_addRefDispatcher(this: IPluginBase); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginBaseImpl_releaseDispatcher(this: IPluginBase): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginBaseImpl_setOwnerDispatcher(this: IPluginBase; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginBaseImpl_getOwnerDispatcher(this: IPluginBase): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IPluginBaseImpl_vTable: PluginBaseVTable = (
     NullPtr: nil;
     version: 4;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher);

function TPluginBase.isIPluginBaseImpl: boolean inline;
begin
  Result := (vTable = @IPluginBaseImpl_vTable);
end;

constructor IPluginBaseImpl.create;
begin
  inherited Create;
  vTable := @IPluginBaseImpl_vTable;
end;

function IPluginBaseImpl.getvTableVersion: NativeInt;
begin
  Result := PPluginBaseVTable(vTable)^.version
end;

function IPluginSetImpl.getInterface:IPluginSet;
begin
  Result := IPluginSet(@nullPtr);
end;

procedure IPluginSetImpl_addRefDispatcher(this: IPluginSet); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_releaseDispatcher(this: IPluginSet): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getNameDispatcher(this: IPluginSet): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getModuleNameDispatcher(this: IPluginSet): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getModuleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginSetImpl_getPluginDispatcher(this: IPluginSet; status: IStatus): IPluginBase; cdecl;
begin
	try
		Result := this.owner.getPlugin(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginSetImpl_nextDispatcher(this: IPluginSet; status: IStatus); cdecl;
begin
	try
		this.owner.next(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginSetImpl_set_Dispatcher(this: IPluginSet; status: IStatus; s: PAnsiChar); cdecl;
begin
	try
		this.owner.set_(status, s);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IPluginSetImpl_vTable: PluginSetVTable = (
     NullPtr: nil;
     version: 7;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getName: @IPluginSetImpl_getNameDispatcher;
     getModuleName: @IPluginSetImpl_getModuleNameDispatcher;
     getPlugin: @IPluginSetImpl_getPluginDispatcher;
     next: @IPluginSetImpl_nextDispatcher;
     set_: @IPluginSetImpl_set_Dispatcher);

function TPluginSet.isIPluginSetImpl: boolean inline;
begin
  Result := (vTable = @IPluginSetImpl_vTable);
end;

constructor IPluginSetImpl.create;
begin
  inherited Create;
  vTable := @IPluginSetImpl_vTable;
end;

function IPluginSetImpl.getvTableVersion: NativeInt;
begin
  Result := PPluginSetVTable(vTable)^.version
end;

function IConfigEntryImpl.getInterface:IConfigEntry;
begin
  Result := IConfigEntry(@nullPtr);
end;

procedure IConfigEntryImpl_addRefDispatcher(this: IConfigEntry); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_releaseDispatcher(this: IConfigEntry): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getNameDispatcher(this: IConfigEntry): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getValueDispatcher(this: IConfigEntry): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getIntValueDispatcher(this: IConfigEntry): Int64; cdecl;
begin
	try
		Result := this.owner.getIntValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getBoolValueDispatcher(this: IConfigEntry): Boolean; cdecl;
begin
	try
		Result := this.owner.getBoolValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigEntryImpl_getSubConfigDispatcher(this: IConfigEntry; status: IStatus): IConfig; cdecl;
begin
	try
		Result := this.owner.getSubConfig(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IConfigEntryImpl_vTable: ConfigEntryVTable = (
     NullPtr: nil;
     version: 7;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getName: @IConfigEntryImpl_getNameDispatcher;
     getValue: @IConfigEntryImpl_getValueDispatcher;
     getIntValue: @IConfigEntryImpl_getIntValueDispatcher;
     getBoolValue: @IConfigEntryImpl_getBoolValueDispatcher;
     getSubConfig: @IConfigEntryImpl_getSubConfigDispatcher);

function TConfigEntry.isIConfigEntryImpl: boolean inline;
begin
  Result := (vTable = @IConfigEntryImpl_vTable);
end;

constructor IConfigEntryImpl.create;
begin
  inherited Create;
  vTable := @IConfigEntryImpl_vTable;
end;

function IConfigEntryImpl.getvTableVersion: NativeInt;
begin
  Result := PConfigEntryVTable(vTable)^.version
end;

function IConfigImpl.getInterface:IConfig;
begin
  Result := IConfig(@nullPtr);
end;

procedure IConfigImpl_addRefDispatcher(this: IConfig); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigImpl_releaseDispatcher(this: IConfig): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigImpl_findDispatcher(this: IConfig; status: IStatus; name: PAnsiChar): IConfigEntry; cdecl;
begin
	try
		Result := this.owner.find(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IConfigImpl_findValueDispatcher(this: IConfig; status: IStatus; name: PAnsiChar; value: PAnsiChar): IConfigEntry; cdecl;
begin
	try
		Result := this.owner.findValue(status, name, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IConfigImpl_findPosDispatcher(this: IConfig; status: IStatus; name: PAnsiChar; pos: Cardinal): IConfigEntry; cdecl;
begin
	try
		Result := this.owner.findPos(status, name, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IConfigImpl_vTable: ConfigVTable = (
     NullPtr: nil;
     version: 5;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     find: @IConfigImpl_findDispatcher;
     findValue: @IConfigImpl_findValueDispatcher;
     findPos: @IConfigImpl_findPosDispatcher);

function TConfig.isIConfigImpl: boolean inline;
begin
  Result := (vTable = @IConfigImpl_vTable);
end;

constructor IConfigImpl.create;
begin
  inherited Create;
  vTable := @IConfigImpl_vTable;
end;

function IConfigImpl.getvTableVersion: NativeInt;
begin
  Result := PConfigVTable(vTable)^.version
end;

function IFirebirdConfImpl.getInterface:IFirebirdConf;
begin
  Result := IFirebirdConf(@nullPtr);
end;

procedure IFirebirdConfImpl_addRefDispatcher(this: IFirebirdConf); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_releaseDispatcher(this: IFirebirdConf): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_getKeyDispatcher(this: IFirebirdConf; name: PAnsiChar): Cardinal; cdecl;
begin
	try
		Result := this.owner.getKey(name);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asIntegerDispatcher(this: IFirebirdConf; key: Cardinal): Int64; cdecl;
begin
	try
		Result := this.owner.asInteger(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asStringDispatcher(this: IFirebirdConf; key: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.asString(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_asBooleanDispatcher(this: IFirebirdConf; key: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.asBoolean(key);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IFirebirdConfImpl_getVersionDispatcher(this: IFirebirdConf; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getVersion(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IFirebirdConfImpl_vTable: FirebirdConfVTable = (
     NullPtr: nil;
     version: 7;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getKey: @IFirebirdConfImpl_getKeyDispatcher;
     asInteger: @IFirebirdConfImpl_asIntegerDispatcher;
     asString: @IFirebirdConfImpl_asStringDispatcher;
     asBoolean: @IFirebirdConfImpl_asBooleanDispatcher;
     getVersion: @IFirebirdConfImpl_getVersionDispatcher);

function TFirebirdConf.isIFirebirdConfImpl: boolean inline;
begin
  Result := (vTable = @IFirebirdConfImpl_vTable);
end;

constructor IFirebirdConfImpl.create;
begin
  inherited Create;
  vTable := @IFirebirdConfImpl_vTable;
end;

function IFirebirdConfImpl.getvTableVersion: NativeInt;
begin
  Result := PFirebirdConfVTable(vTable)^.version
end;

function IPluginConfigImpl.getInterface:IPluginConfig;
begin
  Result := IPluginConfig(@nullPtr);
end;

procedure IPluginConfigImpl_addRefDispatcher(this: IPluginConfig); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_releaseDispatcher(this: IPluginConfig): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_getConfigFileNameDispatcher(this: IPluginConfig): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getConfigFileName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginConfigImpl_getDefaultConfigDispatcher(this: IPluginConfig; status: IStatus): IConfig; cdecl;
begin
	try
		Result := this.owner.getDefaultConfig(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IPluginConfigImpl_getFirebirdConfDispatcher(this: IPluginConfig; status: IStatus): IFirebirdConf; cdecl;
begin
	try
		Result := this.owner.getFirebirdConf(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginConfigImpl_setReleaseDelayDispatcher(this: IPluginConfig; status: IStatus; microSeconds: QWord); cdecl;
begin
	try
		this.owner.setReleaseDelay(status, microSeconds);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IPluginConfigImpl_vTable: PluginConfigVTable = (
     NullPtr: nil;
     version: 6;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getConfigFileName: @IPluginConfigImpl_getConfigFileNameDispatcher;
     getDefaultConfig: @IPluginConfigImpl_getDefaultConfigDispatcher;
     getFirebirdConf: @IPluginConfigImpl_getFirebirdConfDispatcher;
     setReleaseDelay: @IPluginConfigImpl_setReleaseDelayDispatcher);

function TPluginConfig.isIPluginConfigImpl: boolean inline;
begin
  Result := (vTable = @IPluginConfigImpl_vTable);
end;

constructor IPluginConfigImpl.create;
begin
  inherited Create;
  vTable := @IPluginConfigImpl_vTable;
end;

function IPluginConfigImpl.getvTableVersion: NativeInt;
begin
  Result := PPluginConfigVTable(vTable)^.version
end;

function IPluginFactoryImpl.getInterface:IPluginFactory;
begin
  Result := IPluginFactory(@nullPtr);
end;

function IPluginFactoryImpl_createPluginDispatcher(this: IPluginFactory; status: IStatus; factoryParameter: IPluginConfig): IPluginBase; cdecl;
begin
	try
		Result := this.owner.createPlugin(status, factoryParameter);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IPluginFactoryImpl_vTable: PluginFactoryVTable = (
     NullPtr: nil;
     version: 1;
     createPlugin: @IPluginFactoryImpl_createPluginDispatcher);

function TPluginFactory.isIPluginFactoryImpl: boolean inline;
begin
  Result := (vTable = @IPluginFactoryImpl_vTable);
end;

constructor IPluginFactoryImpl.create;
begin
  inherited Create;
  vTable := @IPluginFactoryImpl_vTable;
end;

function IPluginFactoryImpl.getvTableVersion: NativeInt;
begin
  Result := PPluginFactoryVTable(vTable)^.version
end;

function IPluginModuleImpl.getInterface:IPluginModule;
begin
  Result := IPluginModule(@nullPtr);
end;

procedure IPluginModuleImpl_doCleanDispatcher(this: IPluginModule); cdecl;
begin
	try
		this.owner.doClean();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginModuleImpl_threadDetachDispatcher(this: IPluginModule); cdecl;
begin
	try
		this.owner.threadDetach();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IPluginModuleImpl_vTable: PluginModuleVTable = (
     NullPtr: nil;
     version: 2;
     doClean: @IPluginModuleImpl_doCleanDispatcher;
     threadDetach: @IPluginModuleImpl_threadDetachDispatcher);

function TPluginModule.isIPluginModuleImpl: boolean inline;
begin
  Result := (vTable = @IPluginModuleImpl_vTable);
end;

constructor IPluginModuleImpl.create;
begin
  inherited Create;
  vTable := @IPluginModuleImpl_vTable;
end;

function IPluginModuleImpl.getvTableVersion: NativeInt;
begin
  Result := PPluginModuleVTable(vTable)^.version
end;

function IPluginManagerImpl.getInterface:IPluginManager;
begin
  Result := IPluginManager(@nullPtr);
end;

procedure IPluginManagerImpl_registerPluginFactoryDispatcher(this: IPluginManager; pluginType: Cardinal; defaultName: PAnsiChar; factory: IPluginFactory); cdecl;
begin
	try
		this.owner.registerPluginFactory(pluginType, defaultName, factory);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginManagerImpl_registerModuleDispatcher(this: IPluginManager; cleanup: IPluginModule); cdecl;
begin
	try
		this.owner.registerModule(cleanup);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IPluginManagerImpl_unregisterModuleDispatcher(this: IPluginManager; cleanup: IPluginModule); cdecl;
begin
	try
		this.owner.unregisterModule(cleanup);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IPluginManagerImpl_getPluginsDispatcher(this: IPluginManager; status: IStatus; pluginType: Cardinal; namesList: PAnsiChar; firebirdConf: IFirebirdConf): IPluginSet; cdecl;
begin
	try
		Result := this.owner.getPlugins(status, pluginType, namesList, firebirdConf);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IPluginManagerImpl_getConfigDispatcher(this: IPluginManager; status: IStatus; filename: PAnsiChar): IConfig; cdecl;
begin
	try
		Result := this.owner.getConfig(status, filename);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IPluginManagerImpl_releasePluginDispatcher(this: IPluginManager; plugin: IPluginBase); cdecl;
begin
	try
		this.owner.releasePlugin(plugin);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IPluginManagerImpl_vTable: PluginManagerVTable = (
     NullPtr: nil;
     version: 6;
     registerPluginFactory: @IPluginManagerImpl_registerPluginFactoryDispatcher;
     registerModule: @IPluginManagerImpl_registerModuleDispatcher;
     unregisterModule: @IPluginManagerImpl_unregisterModuleDispatcher;
     getPlugins: @IPluginManagerImpl_getPluginsDispatcher;
     getConfig: @IPluginManagerImpl_getConfigDispatcher;
     releasePlugin: @IPluginManagerImpl_releasePluginDispatcher);

function TPluginManager.isIPluginManagerImpl: boolean inline;
begin
  Result := (vTable = @IPluginManagerImpl_vTable);
end;

constructor IPluginManagerImpl.create;
begin
  inherited Create;
  vTable := @IPluginManagerImpl_vTable;
end;

function IPluginManagerImpl.getvTableVersion: NativeInt;
begin
  Result := PPluginManagerVTable(vTable)^.version
end;

function ICryptKeyImpl.getInterface:ICryptKey;
begin
  Result := ICryptKey(@nullPtr);
end;

procedure ICryptKeyImpl_setSymmetricDispatcher(this: ICryptKey; status: IStatus; type_: PAnsiChar; keyLength: Cardinal; key: Pointer); cdecl;
begin
	try
		this.owner.setSymmetric(status, type_, keyLength, key);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ICryptKeyImpl_setAsymmetricDispatcher(this: ICryptKey; status: IStatus; type_: PAnsiChar; encryptKeyLength: Cardinal; encryptKey: Pointer; decryptKeyLength: Cardinal; decryptKey: Pointer); cdecl;
begin
	try
		this.owner.setAsymmetric(status, type_, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ICryptKeyImpl_getEncryptKeyDispatcher(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
begin
	try
		Result := this.owner.getEncryptKey(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ICryptKeyImpl_getDecryptKeyDispatcher(this: ICryptKey; length: CardinalPtr): Pointer; cdecl;
begin
	try
		Result := this.owner.getDecryptKey(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ICryptKeyImpl_vTable: CryptKeyVTable = (
     NullPtr: nil;
     version: 4;
     setSymmetric: @ICryptKeyImpl_setSymmetricDispatcher;
     setAsymmetric: @ICryptKeyImpl_setAsymmetricDispatcher;
     getEncryptKey: @ICryptKeyImpl_getEncryptKeyDispatcher;
     getDecryptKey: @ICryptKeyImpl_getDecryptKeyDispatcher);

function TCryptKey.isICryptKeyImpl: boolean inline;
begin
  Result := (vTable = @ICryptKeyImpl_vTable);
end;

constructor ICryptKeyImpl.create;
begin
  inherited Create;
  vTable := @ICryptKeyImpl_vTable;
end;

function ICryptKeyImpl.getvTableVersion: NativeInt;
begin
  Result := PCryptKeyVTable(vTable)^.version
end;

function IConfigManagerImpl.getInterface:IConfigManager;
begin
  Result := IConfigManager(@nullPtr);
end;

function IConfigManagerImpl_getDirectoryDispatcher(this: IConfigManager; code: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getDirectory(code);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getFirebirdConfDispatcher(this: IConfigManager): IFirebirdConf; cdecl;
begin
	try
		Result := this.owner.getFirebirdConf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getDatabaseConfDispatcher(this: IConfigManager; dbName: PAnsiChar): IFirebirdConf; cdecl;
begin
	try
		Result := this.owner.getDatabaseConf(dbName);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getPluginConfigDispatcher(this: IConfigManager; configuredPlugin: PAnsiChar): IConfig; cdecl;
begin
	try
		Result := this.owner.getPluginConfig(configuredPlugin);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getInstallDirectoryDispatcher(this: IConfigManager): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getInstallDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getRootDirectoryDispatcher(this: IConfigManager): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRootDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IConfigManagerImpl_getDefaultSecurityDbDispatcher(this: IConfigManager): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getDefaultSecurityDb();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IConfigManagerImpl_vTable: ConfigManagerVTable = (
     NullPtr: nil;
     version: 7;
     getDirectory: @IConfigManagerImpl_getDirectoryDispatcher;
     getFirebirdConf: @IConfigManagerImpl_getFirebirdConfDispatcher;
     getDatabaseConf: @IConfigManagerImpl_getDatabaseConfDispatcher;
     getPluginConfig: @IConfigManagerImpl_getPluginConfigDispatcher;
     getInstallDirectory: @IConfigManagerImpl_getInstallDirectoryDispatcher;
     getRootDirectory: @IConfigManagerImpl_getRootDirectoryDispatcher;
     getDefaultSecurityDb: @IConfigManagerImpl_getDefaultSecurityDbDispatcher);

function TConfigManager.isIConfigManagerImpl: boolean inline;
begin
  Result := (vTable = @IConfigManagerImpl_vTable);
end;

constructor IConfigManagerImpl.create;
begin
  inherited Create;
  vTable := @IConfigManagerImpl_vTable;
end;

function IConfigManagerImpl.getvTableVersion: NativeInt;
begin
  Result := PConfigManagerVTable(vTable)^.version
end;

function IEventCallbackImpl.getInterface:IEventCallback;
begin
  Result := IEventCallback(@nullPtr);
end;

procedure IEventCallbackImpl_addRefDispatcher(this: IEventCallback); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IEventCallbackImpl_releaseDispatcher(this: IEventCallback): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IEventCallbackImpl_eventCallbackFunctionDispatcher(this: IEventCallback; length: Cardinal; events: BytePtr); cdecl;
begin
	try
		this.owner.eventCallbackFunction(length, events);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IEventCallbackImpl_vTable: EventCallbackVTable = (
     NullPtr: nil;
     version: 3;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     eventCallbackFunction: @IEventCallbackImpl_eventCallbackFunctionDispatcher);

function TEventCallback.isIEventCallbackImpl: boolean inline;
begin
  Result := (vTable = @IEventCallbackImpl_vTable);
end;

constructor IEventCallbackImpl.create;
begin
  inherited Create;
  vTable := @IEventCallbackImpl_vTable;
end;

function IEventCallbackImpl.getvTableVersion: NativeInt;
begin
  Result := PEventCallbackVTable(vTable)^.version
end;

function IBlobImpl.getInterface:IBlob;
begin
  Result := IBlob(@nullPtr);
end;

procedure IBlobImpl_addRefDispatcher(this: IBlob); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBlobImpl_releaseDispatcher(this: IBlob): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IBlobImpl_getInfoDispatcher(this: IBlob; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		this.owner.getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBlobImpl_getSegmentDispatcher(this: IBlob; status: IStatus; bufferLength: Cardinal; buffer: Pointer; segmentLength: CardinalPtr): Integer; cdecl;
begin
	try
		Result := this.owner.getSegment(status, bufferLength, buffer, segmentLength);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_putSegmentDispatcher(this: IBlob; status: IStatus; length: Cardinal; buffer: Pointer); cdecl;
begin
	try
		this.owner.putSegment(status, length, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_cancelDispatcher(this: IBlob; status: IStatus); cdecl;
begin
	try
		this.owner.cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBlobImpl_closeDispatcher(this: IBlob; status: IStatus); cdecl;
begin
	try
		this.owner.close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBlobImpl_seekDispatcher(this: IBlob; status: IStatus; mode: Integer; offset: Integer): Integer; cdecl;
begin
	try
		Result := this.owner.seek(status, mode, offset);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IBlobImpl_vTable: BlobVTable = (
     NullPtr: nil;
     version: 8;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getInfo: @IBlobImpl_getInfoDispatcher;
     getSegment: @IBlobImpl_getSegmentDispatcher;
     putSegment: @IBlobImpl_putSegmentDispatcher;
     cancel: @IBlobImpl_cancelDispatcher;
     close: @IBlobImpl_closeDispatcher;
     seek: @IBlobImpl_seekDispatcher);

function TBlob.isIBlobImpl: boolean inline;
begin
  Result := (vTable = @IBlobImpl_vTable);
end;

constructor IBlobImpl.create;
begin
  inherited Create;
  vTable := @IBlobImpl_vTable;
end;

function IBlobImpl.getvTableVersion: NativeInt;
begin
  Result := PBlobVTable(vTable)^.version
end;

function ITransactionImpl.getInterface:ITransaction;
begin
  Result := ITransaction(@nullPtr);
end;

procedure ITransactionImpl_addRefDispatcher(this: ITransaction); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITransactionImpl_releaseDispatcher(this: ITransaction): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITransactionImpl_getInfoDispatcher(this: ITransaction; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		this.owner.getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_prepareDispatcher(this: ITransaction; status: IStatus; msgLength: Cardinal; message: BytePtr); cdecl;
begin
	try
		this.owner.prepare(status, msgLength, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_commitDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		this.owner.commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_commitRetainingDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		this.owner.commitRetaining(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_rollbackDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		this.owner.rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_rollbackRetainingDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		this.owner.rollbackRetaining(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITransactionImpl_disconnectDispatcher(this: ITransaction; status: IStatus); cdecl;
begin
	try
		this.owner.disconnect(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_joinDispatcher(this: ITransaction; status: IStatus; transaction: ITransaction): ITransaction; cdecl;
begin
	try
		Result := this.owner.join(status, transaction);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_validateDispatcher(this: ITransaction; status: IStatus; attachment: IAttachment): ITransaction; cdecl;
begin
	try
		Result := this.owner.validate(status, attachment);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ITransactionImpl_enterDtcDispatcher(this: ITransaction; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := this.owner.enterDtc(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITransactionImpl_vTable: TransactionVTable = (
     NullPtr: nil;
     version: 12;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getInfo: @ITransactionImpl_getInfoDispatcher;
     prepare: @ITransactionImpl_prepareDispatcher;
     commit: @ITransactionImpl_commitDispatcher;
     commitRetaining: @ITransactionImpl_commitRetainingDispatcher;
     rollback: @ITransactionImpl_rollbackDispatcher;
     rollbackRetaining: @ITransactionImpl_rollbackRetainingDispatcher;
     disconnect: @ITransactionImpl_disconnectDispatcher;
     join: @ITransactionImpl_joinDispatcher;
     validate: @ITransactionImpl_validateDispatcher;
     enterDtc: @ITransactionImpl_enterDtcDispatcher);

function TTransaction.isITransactionImpl: boolean inline;
begin
  Result := (vTable = @ITransactionImpl_vTable);
end;

constructor ITransactionImpl.create;
begin
  inherited Create;
  vTable := @ITransactionImpl_vTable;
end;

function ITransactionImpl.getvTableVersion: NativeInt;
begin
  Result := PTransactionVTable(vTable)^.version
end;

function IMessageMetadataImpl.getInterface:IMessageMetadata;
begin
  Result := IMessageMetadata(@nullPtr);
end;

procedure IMessageMetadataImpl_addRefDispatcher(this: IMessageMetadata); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMessageMetadataImpl_releaseDispatcher(this: IMessageMetadata): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMessageMetadataImpl_getCountDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getCount(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getFieldDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getField(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getRelationDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRelation(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getOwnerDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getOwner(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAliasDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getAlias(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getTypeDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.getType(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_isNullableDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.isNullable(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getSubTypeDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
begin
	try
		Result := this.owner.getSubType(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getLengthDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.getLength(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getScaleDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Integer; cdecl;
begin
	try
		Result := this.owner.getScale(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getCharSetDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.getCharSet(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getOffsetDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.getOffset(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getNullOffsetDispatcher(this: IMessageMetadata; status: IStatus; index: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.getNullOffset(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getBuilderDispatcher(this: IMessageMetadata; status: IStatus): IMetadataBuilder; cdecl;
begin
	try
		Result := this.owner.getBuilder(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getMessageLengthDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getMessageLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAlignmentDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getAlignment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMessageMetadataImpl_getAlignedLengthDispatcher(this: IMessageMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getAlignedLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IMessageMetadataImpl_vTable: MessageMetadataVTable = (
     NullPtr: nil;
     version: 19;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getCount: @IMessageMetadataImpl_getCountDispatcher;
     getField: @IMessageMetadataImpl_getFieldDispatcher;
     getRelation: @IMessageMetadataImpl_getRelationDispatcher;
     getOwner: @IMessageMetadataImpl_getOwnerDispatcher;
     getAlias: @IMessageMetadataImpl_getAliasDispatcher;
     getType: @IMessageMetadataImpl_getTypeDispatcher;
     isNullable: @IMessageMetadataImpl_isNullableDispatcher;
     getSubType: @IMessageMetadataImpl_getSubTypeDispatcher;
     getLength: @IMessageMetadataImpl_getLengthDispatcher;
     getScale: @IMessageMetadataImpl_getScaleDispatcher;
     getCharSet: @IMessageMetadataImpl_getCharSetDispatcher;
     getOffset: @IMessageMetadataImpl_getOffsetDispatcher;
     getNullOffset: @IMessageMetadataImpl_getNullOffsetDispatcher;
     getBuilder: @IMessageMetadataImpl_getBuilderDispatcher;
     getMessageLength: @IMessageMetadataImpl_getMessageLengthDispatcher;
     getAlignment: @IMessageMetadataImpl_getAlignmentDispatcher;
     getAlignedLength: @IMessageMetadataImpl_getAlignedLengthDispatcher);

function TMessageMetadata.isIMessageMetadataImpl: boolean inline;
begin
  Result := (vTable = @IMessageMetadataImpl_vTable);
end;

constructor IMessageMetadataImpl.create;
begin
  inherited Create;
  vTable := @IMessageMetadataImpl_vTable;
end;

function IMessageMetadataImpl.getvTableVersion: NativeInt;
begin
  Result := PMessageMetadataVTable(vTable)^.version
end;

function IMetadataBuilderImpl.getInterface:IMetadataBuilder;
begin
  Result := IMetadataBuilder(@nullPtr);
end;

procedure IMetadataBuilderImpl_addRefDispatcher(this: IMetadataBuilder); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IMetadataBuilderImpl_releaseDispatcher(this: IMetadataBuilder): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IMetadataBuilderImpl_setTypeDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; type_: Cardinal); cdecl;
begin
	try
		this.owner.setType(status, index, type_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setSubTypeDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; subType: Integer); cdecl;
begin
	try
		this.owner.setSubType(status, index, subType);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setLengthDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; length: Cardinal); cdecl;
begin
	try
		this.owner.setLength(status, index, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setCharSetDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; charSet: Cardinal); cdecl;
begin
	try
		this.owner.setCharSet(status, index, charSet);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setScaleDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; scale: Integer); cdecl;
begin
	try
		this.owner.setScale(status, index, scale);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_truncateDispatcher(this: IMetadataBuilder; status: IStatus; count: Cardinal); cdecl;
begin
	try
		this.owner.truncate(status, count);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_moveNameToIndexDispatcher(this: IMetadataBuilder; status: IStatus; name: PAnsiChar; index: Cardinal); cdecl;
begin
	try
		this.owner.moveNameToIndex(status, name, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_removeDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal); cdecl;
begin
	try
		this.owner.remove(status, index);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMetadataBuilderImpl_addFieldDispatcher(this: IMetadataBuilder; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.addField(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IMetadataBuilderImpl_getMetadataDispatcher(this: IMetadataBuilder; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setFieldDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; field: PAnsiChar); cdecl;
begin
	try
		this.owner.setField(status, index, field);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setRelationDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; relation: PAnsiChar); cdecl;
begin
	try
		this.owner.setRelation(status, index, relation);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setOwnerDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; owner: PAnsiChar); cdecl;
begin
	try
		this.owner.setOwner(status, index, owner);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IMetadataBuilderImpl_setAliasDispatcher(this: IMetadataBuilder; status: IStatus; index: Cardinal; alias: PAnsiChar); cdecl;
begin
	try
		this.owner.setAlias(status, index, alias);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IMetadataBuilderImpl_vTable: MetadataBuilderVTable = (
     NullPtr: nil;
     version: 16;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setType: @IMetadataBuilderImpl_setTypeDispatcher;
     setSubType: @IMetadataBuilderImpl_setSubTypeDispatcher;
     setLength: @IMetadataBuilderImpl_setLengthDispatcher;
     setCharSet: @IMetadataBuilderImpl_setCharSetDispatcher;
     setScale: @IMetadataBuilderImpl_setScaleDispatcher;
     truncate: @IMetadataBuilderImpl_truncateDispatcher;
     moveNameToIndex: @IMetadataBuilderImpl_moveNameToIndexDispatcher;
     remove: @IMetadataBuilderImpl_removeDispatcher;
     addField: @IMetadataBuilderImpl_addFieldDispatcher;
     getMetadata: @IMetadataBuilderImpl_getMetadataDispatcher;
     setField: @IMetadataBuilderImpl_setFieldDispatcher;
     setRelation: @IMetadataBuilderImpl_setRelationDispatcher;
     setOwner: @IMetadataBuilderImpl_setOwnerDispatcher;
     setAlias: @IMetadataBuilderImpl_setAliasDispatcher);

function TMetadataBuilder.isIMetadataBuilderImpl: boolean inline;
begin
  Result := (vTable = @IMetadataBuilderImpl_vTable);
end;

constructor IMetadataBuilderImpl.create;
begin
  inherited Create;
  vTable := @IMetadataBuilderImpl_vTable;
end;

function IMetadataBuilderImpl.getvTableVersion: NativeInt;
begin
  Result := PMetadataBuilderVTable(vTable)^.version
end;

function IResultSetImpl.getInterface:IResultSet;
begin
  Result := IResultSet(@nullPtr);
end;

procedure IResultSetImpl_addRefDispatcher(this: IResultSet); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IResultSetImpl_releaseDispatcher(this: IResultSet): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IResultSetImpl_fetchNextDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := this.owner.fetchNext(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchPriorDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := this.owner.fetchPrior(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchFirstDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := this.owner.fetchFirst(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchLastDispatcher(this: IResultSet; status: IStatus; message: Pointer): Integer; cdecl;
begin
	try
		Result := this.owner.fetchLast(status, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchAbsoluteDispatcher(this: IResultSet; status: IStatus; position: Integer; message: Pointer): Integer; cdecl;
begin
	try
		Result := this.owner.fetchAbsolute(status, position, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_fetchRelativeDispatcher(this: IResultSet; status: IStatus; offset: Integer; message: Pointer): Integer; cdecl;
begin
	try
		Result := this.owner.fetchRelative(status, offset, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_isEofDispatcher(this: IResultSet; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.isEof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_isBofDispatcher(this: IResultSet; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.isBof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IResultSetImpl_getMetadataDispatcher(this: IResultSet; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IResultSetImpl_closeDispatcher(this: IResultSet; status: IStatus); cdecl;
begin
	try
		this.owner.close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IResultSetImpl_setDelayedOutputFormatDispatcher(this: IResultSet; status: IStatus; format: IMessageMetadata); cdecl;
begin
	try
		this.owner.setDelayedOutputFormat(status, format);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IResultSetImpl_vTable: ResultSetVTable = (
     NullPtr: nil;
     version: 13;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     fetchNext: @IResultSetImpl_fetchNextDispatcher;
     fetchPrior: @IResultSetImpl_fetchPriorDispatcher;
     fetchFirst: @IResultSetImpl_fetchFirstDispatcher;
     fetchLast: @IResultSetImpl_fetchLastDispatcher;
     fetchAbsolute: @IResultSetImpl_fetchAbsoluteDispatcher;
     fetchRelative: @IResultSetImpl_fetchRelativeDispatcher;
     isEof: @IResultSetImpl_isEofDispatcher;
     isBof: @IResultSetImpl_isBofDispatcher;
     getMetadata: @IResultSetImpl_getMetadataDispatcher;
     close: @IResultSetImpl_closeDispatcher;
     setDelayedOutputFormat: @IResultSetImpl_setDelayedOutputFormatDispatcher);

function TResultSet.isIResultSetImpl: boolean inline;
begin
  Result := (vTable = @IResultSetImpl_vTable);
end;

constructor IResultSetImpl.create;
begin
  inherited Create;
  vTable := @IResultSetImpl_vTable;
end;

function IResultSetImpl.getvTableVersion: NativeInt;
begin
  Result := PResultSetVTable(vTable)^.version
end;

function IStatementImpl.getInterface:IStatement;
begin
  Result := IStatement(@nullPtr);
end;

procedure IStatementImpl_addRefDispatcher(this: IStatement); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IStatementImpl_releaseDispatcher(this: IStatement): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IStatementImpl_getInfoDispatcher(this: IStatement; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		this.owner.getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getTypeDispatcher(this: IStatement; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getType(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getPlanDispatcher(this: IStatement; status: IStatus; detailed: Boolean): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getPlan(status, detailed);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getAffectedRecordsDispatcher(this: IStatement; status: IStatus): QWord; cdecl;
begin
	try
		Result := this.owner.getAffectedRecords(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getInputMetadataDispatcher(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getInputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getOutputMetadataDispatcher(this: IStatement; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getOutputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_executeDispatcher(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
begin
	try
		Result := this.owner.execute(status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_openCursorDispatcher(this: IStatement; status: IStatus; transaction: ITransaction; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; flags: Cardinal): IResultSet; cdecl;
begin
	try
		Result := this.owner.openCursor(status, transaction, inMetadata, inBuffer, outMetadata, flags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_setCursorNameDispatcher(this: IStatement; status: IStatus; name: PAnsiChar); cdecl;
begin
	try
		this.owner.setCursorName(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_freeDispatcher(this: IStatement; status: IStatus); cdecl;
begin
	try
		this.owner.free(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getFlagsDispatcher(this: IStatement; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getFlags(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_getTimeoutDispatcher(this: IStatement; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IStatementImpl_setTimeoutDispatcher(this: IStatement; status: IStatus; timeOut: Cardinal); cdecl;
begin
	try
		this.owner.setTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IStatementImpl_createBatchDispatcher(this: IStatement; status: IStatus; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
begin
	try
		Result := this.owner.createBatch(status, inMetadata, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IStatementImpl_vTable: StatementVTable = (
     NullPtr: nil;
     version: 16;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getInfo: @IStatementImpl_getInfoDispatcher;
     getType: @IStatementImpl_getTypeDispatcher;
     getPlan: @IStatementImpl_getPlanDispatcher;
     getAffectedRecords: @IStatementImpl_getAffectedRecordsDispatcher;
     getInputMetadata: @IStatementImpl_getInputMetadataDispatcher;
     getOutputMetadata: @IStatementImpl_getOutputMetadataDispatcher;
     execute: @IStatementImpl_executeDispatcher;
     openCursor: @IStatementImpl_openCursorDispatcher;
     setCursorName: @IStatementImpl_setCursorNameDispatcher;
     free: @IStatementImpl_freeDispatcher;
     getFlags: @IStatementImpl_getFlagsDispatcher;
     getTimeout: @IStatementImpl_getTimeoutDispatcher;
     setTimeout: @IStatementImpl_setTimeoutDispatcher;
     createBatch: @IStatementImpl_createBatchDispatcher);

function TStatement.isIStatementImpl: boolean inline;
begin
  Result := (vTable = @IStatementImpl_vTable);
end;

constructor IStatementImpl.create;
begin
  inherited Create;
  vTable := @IStatementImpl_vTable;
end;

function IStatementImpl.getvTableVersion: NativeInt;
begin
  Result := PStatementVTable(vTable)^.version
end;

function IBatchImpl.getInterface:IBatch;
begin
  Result := IBatch(@nullPtr);
end;

procedure IBatchImpl_addRefDispatcher(this: IBatch); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBatchImpl_releaseDispatcher(this: IBatch): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IBatchImpl_addDispatcher(this: IBatch; status: IStatus; count: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		this.owner.add(status, count, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_addBlobDispatcher(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer; blobId: ISC_QUADPtr; parLength: Cardinal; par: BytePtr); cdecl;
begin
	try
		this.owner.addBlob(status, length, inBuffer, blobId, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_appendBlobDataDispatcher(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		this.owner.appendBlobData(status, length, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_addBlobStreamDispatcher(this: IBatch; status: IStatus; length: Cardinal; inBuffer: Pointer); cdecl;
begin
	try
		this.owner.addBlobStream(status, length, inBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_registerBlobDispatcher(this: IBatch; status: IStatus; existingBlob: ISC_QUADPtr; blobId: ISC_QUADPtr); cdecl;
begin
	try
		this.owner.registerBlob(status, existingBlob, blobId);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_executeDispatcher(this: IBatch; status: IStatus; transaction: ITransaction): IBatchCompletionState; cdecl;
begin
	try
		Result := this.owner.execute(status, transaction);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_cancelDispatcher(this: IBatch; status: IStatus); cdecl;
begin
	try
		this.owner.cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_getBlobAlignmentDispatcher(this: IBatch; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getBlobAlignment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchImpl_getMetadataDispatcher(this: IBatch; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_setDefaultBpbDispatcher(this: IBatch; status: IStatus; parLength: Cardinal; par: BytePtr); cdecl;
begin
	try
		this.owner.setDefaultBpb(status, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchImpl_closeDispatcher(this: IBatch; status: IStatus); cdecl;
begin
	try
		this.owner.close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IBatchImpl_vTable: BatchVTable = (
     NullPtr: nil;
     version: 13;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     add: @IBatchImpl_addDispatcher;
     addBlob: @IBatchImpl_addBlobDispatcher;
     appendBlobData: @IBatchImpl_appendBlobDataDispatcher;
     addBlobStream: @IBatchImpl_addBlobStreamDispatcher;
     registerBlob: @IBatchImpl_registerBlobDispatcher;
     execute: @IBatchImpl_executeDispatcher;
     cancel: @IBatchImpl_cancelDispatcher;
     getBlobAlignment: @IBatchImpl_getBlobAlignmentDispatcher;
     getMetadata: @IBatchImpl_getMetadataDispatcher;
     setDefaultBpb: @IBatchImpl_setDefaultBpbDispatcher;
     close: @IBatchImpl_closeDispatcher);

function TBatch.isIBatchImpl: boolean inline;
begin
  Result := (vTable = @IBatchImpl_vTable);
end;

constructor IBatchImpl.create;
begin
  inherited Create;
  vTable := @IBatchImpl_vTable;
end;

function IBatchImpl.getvTableVersion: NativeInt;
begin
  Result := PBatchVTable(vTable)^.version
end;

function IBatchCompletionStateImpl.getInterface:IBatchCompletionState;
begin
  Result := IBatchCompletionState(@nullPtr);
end;

procedure IBatchCompletionStateImpl_disposeDispatcher(this: IBatchCompletionState); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IBatchCompletionStateImpl_getSizeDispatcher(this: IBatchCompletionState; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getSize(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchCompletionStateImpl_getStateDispatcher(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Integer; cdecl;
begin
	try
		Result := this.owner.getState(status, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IBatchCompletionStateImpl_findErrorDispatcher(this: IBatchCompletionState; status: IStatus; pos: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.findError(status, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IBatchCompletionStateImpl_getStatusDispatcher(this: IBatchCompletionState; status: IStatus; to_: IStatus; pos: Cardinal); cdecl;
begin
	try
		this.owner.getStatus(status, to_, pos);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IBatchCompletionStateImpl_vTable: BatchCompletionStateVTable = (
     NullPtr: nil;
     version: 5;
     dispose: @IDisposableImpl_disposeDispatcher;
     getSize: @IBatchCompletionStateImpl_getSizeDispatcher;
     getState: @IBatchCompletionStateImpl_getStateDispatcher;
     findError: @IBatchCompletionStateImpl_findErrorDispatcher;
     getStatus: @IBatchCompletionStateImpl_getStatusDispatcher);

function TBatchCompletionState.isIBatchCompletionStateImpl: boolean inline;
begin
  Result := (vTable = @IBatchCompletionStateImpl_vTable);
end;

constructor IBatchCompletionStateImpl.create;
begin
  inherited Create;
  vTable := @IBatchCompletionStateImpl_vTable;
end;

function IBatchCompletionStateImpl.getvTableVersion: NativeInt;
begin
  Result := PBatchCompletionStateVTable(vTable)^.version
end;

function IReplicatorImpl.getInterface:IReplicator;
begin
  Result := IReplicator(@nullPtr);
end;

procedure IReplicatorImpl_addRefDispatcher(this: IReplicator); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatorImpl_releaseDispatcher(this: IReplicator): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatorImpl_processDispatcher(this: IReplicator; status: IStatus; length: Cardinal; data: BytePtr); cdecl;
begin
	try
		this.owner.process(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatorImpl_closeDispatcher(this: IReplicator; status: IStatus); cdecl;
begin
	try
		this.owner.close(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IReplicatorImpl_vTable: ReplicatorVTable = (
     NullPtr: nil;
     version: 4;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     process: @IReplicatorImpl_processDispatcher;
     close: @IReplicatorImpl_closeDispatcher);

function TReplicator.isIReplicatorImpl: boolean inline;
begin
  Result := (vTable = @IReplicatorImpl_vTable);
end;

constructor IReplicatorImpl.create;
begin
  inherited Create;
  vTable := @IReplicatorImpl_vTable;
end;

function IReplicatorImpl.getvTableVersion: NativeInt;
begin
  Result := PReplicatorVTable(vTable)^.version
end;

function IRequestImpl.getInterface:IRequest;
begin
  Result := IRequest(@nullPtr);
end;

procedure IRequestImpl_addRefDispatcher(this: IRequest); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IRequestImpl_releaseDispatcher(this: IRequest): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IRequestImpl_receiveDispatcher(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		this.owner.receive(status, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_sendDispatcher(this: IRequest; status: IStatus; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		this.owner.send(status, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_getInfoDispatcher(this: IRequest; status: IStatus; level: Integer; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		this.owner.getInfo(status, level, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_startDispatcher(this: IRequest; status: IStatus; tra: ITransaction; level: Integer); cdecl;
begin
	try
		this.owner.start(status, tra, level);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_startAndSendDispatcher(this: IRequest; status: IStatus; tra: ITransaction; level: Integer; msgType: Cardinal; length: Cardinal; message: Pointer); cdecl;
begin
	try
		this.owner.startAndSend(status, tra, level, msgType, length, message);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_unwindDispatcher(this: IRequest; status: IStatus; level: Integer); cdecl;
begin
	try
		this.owner.unwind(status, level);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IRequestImpl_freeDispatcher(this: IRequest; status: IStatus); cdecl;
begin
	try
		this.owner.free(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IRequestImpl_vTable: RequestVTable = (
     NullPtr: nil;
     version: 9;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     receive: @IRequestImpl_receiveDispatcher;
     send: @IRequestImpl_sendDispatcher;
     getInfo: @IRequestImpl_getInfoDispatcher;
     start: @IRequestImpl_startDispatcher;
     startAndSend: @IRequestImpl_startAndSendDispatcher;
     unwind: @IRequestImpl_unwindDispatcher;
     free: @IRequestImpl_freeDispatcher);

function TRequest.isIRequestImpl: boolean inline;
begin
  Result := (vTable = @IRequestImpl_vTable);
end;

constructor IRequestImpl.create;
begin
  inherited Create;
  vTable := @IRequestImpl_vTable;
end;

function IRequestImpl.getvTableVersion: NativeInt;
begin
  Result := PRequestVTable(vTable)^.version
end;

function IEventsImpl.getInterface:IEvents;
begin
  Result := IEvents(@nullPtr);
end;

procedure IEventsImpl_addRefDispatcher(this: IEvents); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IEventsImpl_releaseDispatcher(this: IEvents): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IEventsImpl_cancelDispatcher(this: IEvents; status: IStatus); cdecl;
begin
	try
		this.owner.cancel(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IEventsImpl_vTable: EventsVTable = (
     NullPtr: nil;
     version: 3;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     cancel: @IEventsImpl_cancelDispatcher);

function TEvents.isIEventsImpl: boolean inline;
begin
  Result := (vTable = @IEventsImpl_vTable);
end;

constructor IEventsImpl.create;
begin
  inherited Create;
  vTable := @IEventsImpl_vTable;
end;

function IEventsImpl.getvTableVersion: NativeInt;
begin
  Result := PEventsVTable(vTable)^.version
end;

function IAttachmentImpl.getInterface:IAttachment;
begin
  Result := IAttachment(@nullPtr);
end;

procedure IAttachmentImpl_addRefDispatcher(this: IAttachment); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAttachmentImpl_releaseDispatcher(this: IAttachment): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IAttachmentImpl_getInfoDispatcher(this: IAttachment; status: IStatus; itemsLength: Cardinal; items: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		this.owner.getInfo(status, itemsLength, items, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_startTransactionDispatcher(this: IAttachment; status: IStatus; tpbLength: Cardinal; tpb: BytePtr): ITransaction; cdecl;
begin
	try
		Result := this.owner.startTransaction(status, tpbLength, tpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_reconnectTransactionDispatcher(this: IAttachment; status: IStatus; length: Cardinal; id: BytePtr): ITransaction; cdecl;
begin
	try
		Result := this.owner.reconnectTransaction(status, length, id);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_compileRequestDispatcher(this: IAttachment; status: IStatus; blrLength: Cardinal; blr: BytePtr): IRequest; cdecl;
begin
	try
		Result := this.owner.compileRequest(status, blrLength, blr);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_transactRequestDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; blrLength: Cardinal; blr: BytePtr; inMsgLength: Cardinal; inMsg: BytePtr; outMsgLength: Cardinal; outMsg: BytePtr); cdecl;
begin
	try
		this.owner.transactRequest(status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createBlobDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
begin
	try
		Result := this.owner.createBlob(status, transaction, id, bpbLength, bpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_openBlobDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; bpbLength: Cardinal; bpb: BytePtr): IBlob; cdecl;
begin
	try
		Result := this.owner.openBlob(status, transaction, id, bpbLength, bpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getSliceDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr): Integer; cdecl;
begin
	try
		Result := this.owner.getSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_putSliceDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; id: ISC_QUADPtr; sdlLength: Cardinal; sdl: BytePtr; paramLength: Cardinal; param: BytePtr; sliceLength: Integer; slice: BytePtr); cdecl;
begin
	try
		this.owner.putSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_executeDynDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; length: Cardinal; dyn: BytePtr); cdecl;
begin
	try
		this.owner.executeDyn(status, transaction, length, dyn);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_prepareDispatcher(this: IAttachment; status: IStatus; tra: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; flags: Cardinal): IStatement; cdecl;
begin
	try
		Result := this.owner.prepare(status, tra, stmtLength, sqlStmt, dialect, flags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_executeDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; outBuffer: Pointer): ITransaction; cdecl;
begin
	try
		Result := this.owner.execute(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_openCursorDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; inBuffer: Pointer; outMetadata: IMessageMetadata; cursorName: PAnsiChar; cursorFlags: Cardinal): IResultSet; cdecl;
begin
	try
		Result := this.owner.openCursor(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_queEventsDispatcher(this: IAttachment; status: IStatus; callback: IEventCallback; length: Cardinal; events: BytePtr): IEvents; cdecl;
begin
	try
		Result := this.owner.queEvents(status, callback, length, events);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_cancelOperationDispatcher(this: IAttachment; status: IStatus; option: Integer); cdecl;
begin
	try
		this.owner.cancelOperation(status, option);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_pingDispatcher(this: IAttachment; status: IStatus); cdecl;
begin
	try
		this.owner.ping(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_detachDispatcher(this: IAttachment; status: IStatus); cdecl;
begin
	try
		this.owner.detach(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_dropDatabaseDispatcher(this: IAttachment; status: IStatus); cdecl;
begin
	try
		this.owner.dropDatabase(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getIdleTimeoutDispatcher(this: IAttachment; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getIdleTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_setIdleTimeoutDispatcher(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
begin
	try
		this.owner.setIdleTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_getStatementTimeoutDispatcher(this: IAttachment; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getStatementTimeout(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IAttachmentImpl_setStatementTimeoutDispatcher(this: IAttachment; status: IStatus; timeOut: Cardinal); cdecl;
begin
	try
		this.owner.setStatementTimeout(status, timeOut);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createBatchDispatcher(this: IAttachment; status: IStatus; transaction: ITransaction; stmtLength: Cardinal; sqlStmt: PAnsiChar; dialect: Cardinal; inMetadata: IMessageMetadata; parLength: Cardinal; par: BytePtr): IBatch; cdecl;
begin
	try
		Result := this.owner.createBatch(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, parLength, par);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAttachmentImpl_createReplicatorDispatcher(this: IAttachment; status: IStatus): IReplicator; cdecl;
begin
	try
		Result := this.owner.createReplicator(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IAttachmentImpl_vTable: AttachmentVTable = (
     NullPtr: nil;
     version: 26;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getInfo: @IAttachmentImpl_getInfoDispatcher;
     startTransaction: @IAttachmentImpl_startTransactionDispatcher;
     reconnectTransaction: @IAttachmentImpl_reconnectTransactionDispatcher;
     compileRequest: @IAttachmentImpl_compileRequestDispatcher;
     transactRequest: @IAttachmentImpl_transactRequestDispatcher;
     createBlob: @IAttachmentImpl_createBlobDispatcher;
     openBlob: @IAttachmentImpl_openBlobDispatcher;
     getSlice: @IAttachmentImpl_getSliceDispatcher;
     putSlice: @IAttachmentImpl_putSliceDispatcher;
     executeDyn: @IAttachmentImpl_executeDynDispatcher;
     prepare: @IAttachmentImpl_prepareDispatcher;
     execute: @IAttachmentImpl_executeDispatcher;
     openCursor: @IAttachmentImpl_openCursorDispatcher;
     queEvents: @IAttachmentImpl_queEventsDispatcher;
     cancelOperation: @IAttachmentImpl_cancelOperationDispatcher;
     ping: @IAttachmentImpl_pingDispatcher;
     detach: @IAttachmentImpl_detachDispatcher;
     dropDatabase: @IAttachmentImpl_dropDatabaseDispatcher;
     getIdleTimeout: @IAttachmentImpl_getIdleTimeoutDispatcher;
     setIdleTimeout: @IAttachmentImpl_setIdleTimeoutDispatcher;
     getStatementTimeout: @IAttachmentImpl_getStatementTimeoutDispatcher;
     setStatementTimeout: @IAttachmentImpl_setStatementTimeoutDispatcher;
     createBatch: @IAttachmentImpl_createBatchDispatcher;
     createReplicator: @IAttachmentImpl_createReplicatorDispatcher);

function TAttachment.isIAttachmentImpl: boolean inline;
begin
  Result := (vTable = @IAttachmentImpl_vTable);
end;

constructor IAttachmentImpl.create;
begin
  inherited Create;
  vTable := @IAttachmentImpl_vTable;
end;

function IAttachmentImpl.getvTableVersion: NativeInt;
begin
  Result := PAttachmentVTable(vTable)^.version
end;

function IServiceImpl.getInterface:IService;
begin
  Result := IService(@nullPtr);
end;

procedure IServiceImpl_addRefDispatcher(this: IService); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServiceImpl_releaseDispatcher(this: IService): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServiceImpl_detachDispatcher(this: IService; status: IStatus); cdecl;
begin
	try
		this.owner.detach(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServiceImpl_queryDispatcher(this: IService; status: IStatus; sendLength: Cardinal; sendItems: BytePtr; receiveLength: Cardinal; receiveItems: BytePtr; bufferLength: Cardinal; buffer: BytePtr); cdecl;
begin
	try
		this.owner.query(status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServiceImpl_startDispatcher(this: IService; status: IStatus; spbLength: Cardinal; spb: BytePtr); cdecl;
begin
	try
		this.owner.start(status, spbLength, spb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IServiceImpl_vTable: ServiceVTable = (
     NullPtr: nil;
     version: 5;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     detach: @IServiceImpl_detachDispatcher;
     query: @IServiceImpl_queryDispatcher;
     start: @IServiceImpl_startDispatcher);

function TService.isIServiceImpl: boolean inline;
begin
  Result := (vTable = @IServiceImpl_vTable);
end;

constructor IServiceImpl.create;
begin
  inherited Create;
  vTable := @IServiceImpl_vTable;
end;

function IServiceImpl.getvTableVersion: NativeInt;
begin
  Result := PServiceVTable(vTable)^.version
end;

function IProviderImpl.getInterface:IProvider;
begin
  Result := IProvider(@nullPtr);
end;

procedure IProviderImpl_addRefDispatcher(this: IProvider); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_releaseDispatcher(this: IProvider): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IProviderImpl_setOwnerDispatcher(this: IProvider; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_getOwnerDispatcher(this: IProvider): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IProviderImpl_attachDatabaseDispatcher(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
begin
	try
		Result := this.owner.attachDatabase(status, fileName, dpbLength, dpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IProviderImpl_createDatabaseDispatcher(this: IProvider; status: IStatus; fileName: PAnsiChar; dpbLength: Cardinal; dpb: BytePtr): IAttachment; cdecl;
begin
	try
		Result := this.owner.createDatabase(status, fileName, dpbLength, dpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IProviderImpl_attachServiceManagerDispatcher(this: IProvider; status: IStatus; service: PAnsiChar; spbLength: Cardinal; spb: BytePtr): IService; cdecl;
begin
	try
		Result := this.owner.attachServiceManager(status, service, spbLength, spb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IProviderImpl_shutdownDispatcher(this: IProvider; status: IStatus; timeout: Cardinal; reason: Integer); cdecl;
begin
	try
		this.owner.shutdown(status, timeout, reason);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IProviderImpl_setDbCryptCallbackDispatcher(this: IProvider; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
begin
	try
		this.owner.setDbCryptCallback(status, cryptCallback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IProviderImpl_vTable: ProviderVTable = (
     NullPtr: nil;
     version: 9;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     attachDatabase: @IProviderImpl_attachDatabaseDispatcher;
     createDatabase: @IProviderImpl_createDatabaseDispatcher;
     attachServiceManager: @IProviderImpl_attachServiceManagerDispatcher;
     shutdown: @IProviderImpl_shutdownDispatcher;
     setDbCryptCallback: @IProviderImpl_setDbCryptCallbackDispatcher);

function TProvider.isIProviderImpl: boolean inline;
begin
  Result := (vTable = @IProviderImpl_vTable);
end;

constructor IProviderImpl.create;
begin
  inherited Create;
  vTable := @IProviderImpl_vTable;
end;

function IProviderImpl.getvTableVersion: NativeInt;
begin
  Result := PProviderVTable(vTable)^.version
end;

function IDtcStartImpl.getInterface:IDtcStart;
begin
  Result := IDtcStart(@nullPtr);
end;

procedure IDtcStartImpl_disposeDispatcher(this: IDtcStart); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDtcStartImpl_addAttachmentDispatcher(this: IDtcStart; status: IStatus; att: IAttachment); cdecl;
begin
	try
		this.owner.addAttachment(status, att);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDtcStartImpl_addWithTpbDispatcher(this: IDtcStart; status: IStatus; att: IAttachment; length: Cardinal; tpb: BytePtr); cdecl;
begin
	try
		this.owner.addWithTpb(status, att, length, tpb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IDtcStartImpl_startDispatcher(this: IDtcStart; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := this.owner.start(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDtcStartImpl_vTable: DtcStartVTable = (
     NullPtr: nil;
     version: 4;
     dispose: @IDisposableImpl_disposeDispatcher;
     addAttachment: @IDtcStartImpl_addAttachmentDispatcher;
     addWithTpb: @IDtcStartImpl_addWithTpbDispatcher;
     start: @IDtcStartImpl_startDispatcher);

function TDtcStart.isIDtcStartImpl: boolean inline;
begin
  Result := (vTable = @IDtcStartImpl_vTable);
end;

constructor IDtcStartImpl.create;
begin
  inherited Create;
  vTable := @IDtcStartImpl_vTable;
end;

function IDtcStartImpl.getvTableVersion: NativeInt;
begin
  Result := PDtcStartVTable(vTable)^.version
end;

function IDtcImpl.getInterface:IDtc;
begin
  Result := IDtc(@nullPtr);
end;

function IDtcImpl_joinDispatcher(this: IDtc; status: IStatus; one: ITransaction; two: ITransaction): ITransaction; cdecl;
begin
	try
		Result := this.owner.join(status, one, two);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IDtcImpl_startBuilderDispatcher(this: IDtc; status: IStatus): IDtcStart; cdecl;
begin
	try
		Result := this.owner.startBuilder(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDtcImpl_vTable: DtcVTable = (
     NullPtr: nil;
     version: 2;
     join: @IDtcImpl_joinDispatcher;
     startBuilder: @IDtcImpl_startBuilderDispatcher);

function TDtc.isIDtcImpl: boolean inline;
begin
  Result := (vTable = @IDtcImpl_vTable);
end;

constructor IDtcImpl.create;
begin
  inherited Create;
  vTable := @IDtcImpl_vTable;
end;

function IDtcImpl.getvTableVersion: NativeInt;
begin
  Result := PDtcVTable(vTable)^.version
end;

function IAuthImpl.getInterface:IAuth;
begin
  Result := IAuth(@nullPtr);
end;

procedure IAuthImpl_addRefDispatcher(this: IAuth); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthImpl_releaseDispatcher(this: IAuth): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IAuthImpl_setOwnerDispatcher(this: IAuth; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthImpl_getOwnerDispatcher(this: IAuth): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IAuthImpl_vTable: AuthVTable = (
     NullPtr: nil;
     version: 4;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher);

function TAuth.isIAuthImpl: boolean inline;
begin
  Result := (vTable = @IAuthImpl_vTable);
end;

constructor IAuthImpl.create;
begin
  inherited Create;
  vTable := @IAuthImpl_vTable;
end;

function IAuthImpl.getvTableVersion: NativeInt;
begin
  Result := PAuthVTable(vTable)^.version
end;

function IWriterImpl.getInterface:IWriter;
begin
  Result := IWriter(@nullPtr);
end;

procedure IWriterImpl_resetDispatcher(this: IWriter); cdecl;
begin
	try
		this.owner.reset();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IWriterImpl_addDispatcher(this: IWriter; status: IStatus; name: PAnsiChar); cdecl;
begin
	try
		this.owner.add(status, name);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWriterImpl_setTypeDispatcher(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
begin
	try
		this.owner.setType(status, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWriterImpl_setDbDispatcher(this: IWriter; status: IStatus; value: PAnsiChar); cdecl;
begin
	try
		this.owner.setDb(status, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IWriterImpl_vTable: WriterVTable = (
     NullPtr: nil;
     version: 4;
     reset: @IWriterImpl_resetDispatcher;
     add: @IWriterImpl_addDispatcher;
     setType: @IWriterImpl_setTypeDispatcher;
     setDb: @IWriterImpl_setDbDispatcher);

function TWriter.isIWriterImpl: boolean inline;
begin
  Result := (vTable = @IWriterImpl_vTable);
end;

constructor IWriterImpl.create;
begin
  inherited Create;
  vTable := @IWriterImpl_vTable;
end;

function IWriterImpl.getvTableVersion: NativeInt;
begin
  Result := PWriterVTable(vTable)^.version
end;

function IServerBlockImpl.getInterface:IServerBlock;
begin
  Result := IServerBlock(@nullPtr);
end;

function IServerBlockImpl_getLoginDispatcher(this: IServerBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getLogin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerBlockImpl_getDataDispatcher(this: IServerBlock; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := this.owner.getData(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServerBlockImpl_putDataDispatcher(this: IServerBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
begin
	try
		this.owner.putData(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IServerBlockImpl_newKeyDispatcher(this: IServerBlock; status: IStatus): ICryptKey; cdecl;
begin
	try
		Result := this.owner.newKey(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IServerBlockImpl_vTable: ServerBlockVTable = (
     NullPtr: nil;
     version: 4;
     getLogin: @IServerBlockImpl_getLoginDispatcher;
     getData: @IServerBlockImpl_getDataDispatcher;
     putData: @IServerBlockImpl_putDataDispatcher;
     newKey: @IServerBlockImpl_newKeyDispatcher);

function TServerBlock.isIServerBlockImpl: boolean inline;
begin
  Result := (vTable = @IServerBlockImpl_vTable);
end;

constructor IServerBlockImpl.create;
begin
  inherited Create;
  vTable := @IServerBlockImpl_vTable;
end;

function IServerBlockImpl.getvTableVersion: NativeInt;
begin
  Result := PServerBlockVTable(vTable)^.version
end;

function IClientBlockImpl.getInterface:IClientBlock;
begin
  Result := IClientBlock(@nullPtr);
end;

procedure IClientBlockImpl_addRefDispatcher(this: IClientBlock); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_releaseDispatcher(this: IClientBlock): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getLoginDispatcher(this: IClientBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getLogin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getPasswordDispatcher(this: IClientBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getPassword();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientBlockImpl_getDataDispatcher(this: IClientBlock; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := this.owner.getData(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IClientBlockImpl_putDataDispatcher(this: IClientBlock; status: IStatus; length: Cardinal; data: Pointer); cdecl;
begin
	try
		this.owner.putData(status, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IClientBlockImpl_newKeyDispatcher(this: IClientBlock; status: IStatus): ICryptKey; cdecl;
begin
	try
		Result := this.owner.newKey(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IClientBlockImpl_getAuthBlockDispatcher(this: IClientBlock; status: IStatus): IAuthBlock; cdecl;
begin
	try
		Result := this.owner.getAuthBlock(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IClientBlockImpl_vTable: ClientBlockVTable = (
     NullPtr: nil;
     version: 8;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getLogin: @IClientBlockImpl_getLoginDispatcher;
     getPassword: @IClientBlockImpl_getPasswordDispatcher;
     getData: @IClientBlockImpl_getDataDispatcher;
     putData: @IClientBlockImpl_putDataDispatcher;
     newKey: @IClientBlockImpl_newKeyDispatcher;
     getAuthBlock: @IClientBlockImpl_getAuthBlockDispatcher);

function TClientBlock.isIClientBlockImpl: boolean inline;
begin
  Result := (vTable = @IClientBlockImpl_vTable);
end;

constructor IClientBlockImpl.create;
begin
  inherited Create;
  vTable := @IClientBlockImpl_vTable;
end;

function IClientBlockImpl.getvTableVersion: NativeInt;
begin
  Result := PClientBlockVTable(vTable)^.version
end;

function IServerImpl.getInterface:IServer;
begin
  Result := IServer(@nullPtr);
end;

procedure IServerImpl_addRefDispatcher(this: IServer); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_releaseDispatcher(this: IServer): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IServerImpl_setOwnerDispatcher(this: IServer; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_getOwnerDispatcher(this: IServer): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IServerImpl_authenticateDispatcher(this: IServer; status: IStatus; sBlock: IServerBlock; writerInterface: IWriter): Integer; cdecl;
begin
	try
		Result := this.owner.authenticate(status, sBlock, writerInterface);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IServerImpl_setDbCryptCallbackDispatcher(this: IServer; status: IStatus; cryptCallback: ICryptKeyCallback); cdecl;
begin
	try
		this.owner.setDbCryptCallback(status, cryptCallback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IServerImpl_vTable: ServerVTable = (
     NullPtr: nil;
     version: 6;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     authenticate: @IServerImpl_authenticateDispatcher;
     setDbCryptCallback: @IServerImpl_setDbCryptCallbackDispatcher);

function TServer.isIServerImpl: boolean inline;
begin
  Result := (vTable = @IServerImpl_vTable);
end;

constructor IServerImpl.create;
begin
  inherited Create;
  vTable := @IServerImpl_vTable;
end;

function IServerImpl.getvTableVersion: NativeInt;
begin
  Result := PServerVTable(vTable)^.version
end;

function IClientImpl.getInterface:IClient;
begin
  Result := IClient(@nullPtr);
end;

procedure IClientImpl_addRefDispatcher(this: IClient); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_releaseDispatcher(this: IClient): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IClientImpl_setOwnerDispatcher(this: IClient; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_getOwnerDispatcher(this: IClient): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IClientImpl_authenticateDispatcher(this: IClient; status: IStatus; cBlock: IClientBlock): Integer; cdecl;
begin
	try
		Result := this.owner.authenticate(status, cBlock);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IClientImpl_vTable: ClientVTable = (
     NullPtr: nil;
     version: 5;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     authenticate: @IClientImpl_authenticateDispatcher);

function TClient.isIClientImpl: boolean inline;
begin
  Result := (vTable = @IClientImpl_vTable);
end;

constructor IClientImpl.create;
begin
  inherited Create;
  vTable := @IClientImpl_vTable;
end;

function IClientImpl.getvTableVersion: NativeInt;
begin
  Result := PClientVTable(vTable)^.version
end;

function IUserFieldImpl.getInterface:IUserField;
begin
  Result := IUserField(@nullPtr);
end;

function IUserFieldImpl_enteredDispatcher(this: IUserField): Integer; cdecl;
begin
	try
		Result := this.owner.entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserFieldImpl_specifiedDispatcher(this: IUserField): Integer; cdecl;
begin
	try
		Result := this.owner.specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUserFieldImpl_setEnteredDispatcher(this: IUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		this.owner.setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUserFieldImpl_vTable: UserFieldVTable = (
     NullPtr: nil;
     version: 3;
     entered: @IUserFieldImpl_enteredDispatcher;
     specified: @IUserFieldImpl_specifiedDispatcher;
     setEntered: @IUserFieldImpl_setEnteredDispatcher);

function TUserField.isIUserFieldImpl: boolean inline;
begin
  Result := (vTable = @IUserFieldImpl_vTable);
end;

constructor IUserFieldImpl.create;
begin
  inherited Create;
  vTable := @IUserFieldImpl_vTable;
end;

function IUserFieldImpl.getvTableVersion: NativeInt;
begin
  Result := PUserFieldVTable(vTable)^.version
end;

function ICharUserFieldImpl.getInterface:ICharUserField;
begin
  Result := ICharUserField(@nullPtr);
end;

function ICharUserFieldImpl_enteredDispatcher(this: ICharUserField): Integer; cdecl;
begin
	try
		Result := this.owner.entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ICharUserFieldImpl_specifiedDispatcher(this: ICharUserField): Integer; cdecl;
begin
	try
		Result := this.owner.specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ICharUserFieldImpl_setEnteredDispatcher(this: ICharUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		this.owner.setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ICharUserFieldImpl_getDispatcher(this: ICharUserField): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.get();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ICharUserFieldImpl_set_Dispatcher(this: ICharUserField; status: IStatus; newValue: PAnsiChar); cdecl;
begin
	try
		this.owner.set_(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ICharUserFieldImpl_vTable: CharUserFieldVTable = (
     NullPtr: nil;
     version: 5;
     entered: @IUserFieldImpl_enteredDispatcher;
     specified: @IUserFieldImpl_specifiedDispatcher;
     setEntered: @IUserFieldImpl_setEnteredDispatcher;
     get: @ICharUserFieldImpl_getDispatcher;
     set_: @ICharUserFieldImpl_set_Dispatcher);

function TCharUserField.isICharUserFieldImpl: boolean inline;
begin
  Result := (vTable = @ICharUserFieldImpl_vTable);
end;

constructor ICharUserFieldImpl.create;
begin
  inherited Create;
  vTable := @ICharUserFieldImpl_vTable;
end;

function ICharUserFieldImpl.getvTableVersion: NativeInt;
begin
  Result := PCharUserFieldVTable(vTable)^.version
end;

function IIntUserFieldImpl.getInterface:IIntUserField;
begin
  Result := IIntUserField(@nullPtr);
end;

function IIntUserFieldImpl_enteredDispatcher(this: IIntUserField): Integer; cdecl;
begin
	try
		Result := this.owner.entered();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IIntUserFieldImpl_specifiedDispatcher(this: IIntUserField): Integer; cdecl;
begin
	try
		Result := this.owner.specified();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IIntUserFieldImpl_setEnteredDispatcher(this: IIntUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		this.owner.setEntered(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IIntUserFieldImpl_getDispatcher(this: IIntUserField): Integer; cdecl;
begin
	try
		Result := this.owner.get();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IIntUserFieldImpl_set_Dispatcher(this: IIntUserField; status: IStatus; newValue: Integer); cdecl;
begin
	try
		this.owner.set_(status, newValue);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IIntUserFieldImpl_vTable: IntUserFieldVTable = (
     NullPtr: nil;
     version: 5;
     entered: @IUserFieldImpl_enteredDispatcher;
     specified: @IUserFieldImpl_specifiedDispatcher;
     setEntered: @IUserFieldImpl_setEnteredDispatcher;
     get: @IIntUserFieldImpl_getDispatcher;
     set_: @IIntUserFieldImpl_set_Dispatcher);

function TIntUserField.isIIntUserFieldImpl: boolean inline;
begin
  Result := (vTable = @IIntUserFieldImpl_vTable);
end;

constructor IIntUserFieldImpl.create;
begin
  inherited Create;
  vTable := @IIntUserFieldImpl_vTable;
end;

function IIntUserFieldImpl.getvTableVersion: NativeInt;
begin
  Result := PIntUserFieldVTable(vTable)^.version
end;

function IUserImpl.getInterface:IUser;
begin
  Result := IUser(@nullPtr);
end;

function IUserImpl_operationDispatcher(this: IUser): Cardinal; cdecl;
begin
	try
		Result := this.owner.operation();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_userNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.userName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_passwordDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.password();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_firstNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.firstName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_lastNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.lastName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_middleNameDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.middleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_commentDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.comment();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_attributesDispatcher(this: IUser): ICharUserField; cdecl;
begin
	try
		Result := this.owner.attributes();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_activeDispatcher(this: IUser): IIntUserField; cdecl;
begin
	try
		Result := this.owner.active();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUserImpl_adminDispatcher(this: IUser): IIntUserField; cdecl;
begin
	try
		Result := this.owner.admin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUserImpl_clearDispatcher(this: IUser; status: IStatus); cdecl;
begin
	try
		this.owner.clear(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUserImpl_vTable: UserVTable = (
     NullPtr: nil;
     version: 11;
     operation: @IUserImpl_operationDispatcher;
     userName: @IUserImpl_userNameDispatcher;
     password: @IUserImpl_passwordDispatcher;
     firstName: @IUserImpl_firstNameDispatcher;
     lastName: @IUserImpl_lastNameDispatcher;
     middleName: @IUserImpl_middleNameDispatcher;
     comment: @IUserImpl_commentDispatcher;
     attributes: @IUserImpl_attributesDispatcher;
     active: @IUserImpl_activeDispatcher;
     admin: @IUserImpl_adminDispatcher;
     clear: @IUserImpl_clearDispatcher);

function TUser.isIUserImpl: boolean inline;
begin
  Result := (vTable = @IUserImpl_vTable);
end;

constructor IUserImpl.create;
begin
  inherited Create;
  vTable := @IUserImpl_vTable;
end;

function IUserImpl.getvTableVersion: NativeInt;
begin
  Result := PUserVTable(vTable)^.version
end;

function IListUsersImpl.getInterface:IListUsers;
begin
  Result := IListUsers(@nullPtr);
end;

procedure IListUsersImpl_listDispatcher(this: IListUsers; status: IStatus; user: IUser); cdecl;
begin
	try
		this.owner.list(status, user);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IListUsersImpl_vTable: ListUsersVTable = (
     NullPtr: nil;
     version: 1;
     list: @IListUsersImpl_listDispatcher);

function TListUsers.isIListUsersImpl: boolean inline;
begin
  Result := (vTable = @IListUsersImpl_vTable);
end;

constructor IListUsersImpl.create;
begin
  inherited Create;
  vTable := @IListUsersImpl_vTable;
end;

function IListUsersImpl.getvTableVersion: NativeInt;
begin
  Result := PListUsersVTable(vTable)^.version
end;

function ILogonInfoImpl.getInterface:ILogonInfo;
begin
  Result := ILogonInfo(@nullPtr);
end;

function ILogonInfoImpl_nameDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.name();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_roleDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.role();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_networkProtocolDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.networkProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_remoteAddressDispatcher(this: ILogonInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.remoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_authBlockDispatcher(this: ILogonInfo; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := this.owner.authBlock(length);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ILogonInfoImpl_attachmentDispatcher(this: ILogonInfo; status: IStatus): IAttachment; cdecl;
begin
	try
		Result := this.owner.attachment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function ILogonInfoImpl_transactionDispatcher(this: ILogonInfo; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := this.owner.transaction(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ILogonInfoImpl_vTable: LogonInfoVTable = (
     NullPtr: nil;
     version: 7;
     name: @ILogonInfoImpl_nameDispatcher;
     role: @ILogonInfoImpl_roleDispatcher;
     networkProtocol: @ILogonInfoImpl_networkProtocolDispatcher;
     remoteAddress: @ILogonInfoImpl_remoteAddressDispatcher;
     authBlock: @ILogonInfoImpl_authBlockDispatcher;
     attachment: @ILogonInfoImpl_attachmentDispatcher;
     transaction: @ILogonInfoImpl_transactionDispatcher);

function TLogonInfo.isILogonInfoImpl: boolean inline;
begin
  Result := (vTable = @ILogonInfoImpl_vTable);
end;

constructor ILogonInfoImpl.create;
begin
  inherited Create;
  vTable := @ILogonInfoImpl_vTable;
end;

function ILogonInfoImpl.getvTableVersion: NativeInt;
begin
  Result := PLogonInfoVTable(vTable)^.version
end;

function IManagementImpl.getInterface:IManagement;
begin
  Result := IManagement(@nullPtr);
end;

procedure IManagementImpl_addRefDispatcher(this: IManagement); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IManagementImpl_releaseDispatcher(this: IManagement): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IManagementImpl_setOwnerDispatcher(this: IManagement; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IManagementImpl_getOwnerDispatcher(this: IManagement): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IManagementImpl_startDispatcher(this: IManagement; status: IStatus; logonInfo: ILogonInfo); cdecl;
begin
	try
		this.owner.start(status, logonInfo);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IManagementImpl_executeDispatcher(this: IManagement; status: IStatus; user: IUser; callback: IListUsers): Integer; cdecl;
begin
	try
		Result := this.owner.execute(status, user, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IManagementImpl_commitDispatcher(this: IManagement; status: IStatus); cdecl;
begin
	try
		this.owner.commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IManagementImpl_rollbackDispatcher(this: IManagement; status: IStatus); cdecl;
begin
	try
		this.owner.rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IManagementImpl_vTable: ManagementVTable = (
     NullPtr: nil;
     version: 8;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     start: @IManagementImpl_startDispatcher;
     execute: @IManagementImpl_executeDispatcher;
     commit: @IManagementImpl_commitDispatcher;
     rollback: @IManagementImpl_rollbackDispatcher);

function TManagement.isIManagementImpl: boolean inline;
begin
  Result := (vTable = @IManagementImpl_vTable);
end;

constructor IManagementImpl.create;
begin
  inherited Create;
  vTable := @IManagementImpl_vTable;
end;

function IManagementImpl.getvTableVersion: NativeInt;
begin
  Result := PManagementVTable(vTable)^.version
end;

function IAuthBlockImpl.getInterface:IAuthBlock;
begin
  Result := IAuthBlock(@nullPtr);
end;

function IAuthBlockImpl_getTypeDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getNameDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getPluginDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getPlugin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getSecurityDbDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getSecurityDb();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_getOriginalPluginDispatcher(this: IAuthBlock): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getOriginalPlugin();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IAuthBlockImpl_nextDispatcher(this: IAuthBlock; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.next(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IAuthBlockImpl_firstDispatcher(this: IAuthBlock; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.first(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IAuthBlockImpl_vTable: AuthBlockVTable = (
     NullPtr: nil;
     version: 7;
     getType: @IAuthBlockImpl_getTypeDispatcher;
     getName: @IAuthBlockImpl_getNameDispatcher;
     getPlugin: @IAuthBlockImpl_getPluginDispatcher;
     getSecurityDb: @IAuthBlockImpl_getSecurityDbDispatcher;
     getOriginalPlugin: @IAuthBlockImpl_getOriginalPluginDispatcher;
     next: @IAuthBlockImpl_nextDispatcher;
     first: @IAuthBlockImpl_firstDispatcher);

function TAuthBlock.isIAuthBlockImpl: boolean inline;
begin
  Result := (vTable = @IAuthBlockImpl_vTable);
end;

constructor IAuthBlockImpl.create;
begin
  inherited Create;
  vTable := @IAuthBlockImpl_vTable;
end;

function IAuthBlockImpl.getvTableVersion: NativeInt;
begin
  Result := PAuthBlockVTable(vTable)^.version
end;

function IWireCryptPluginImpl.getInterface:IWireCryptPlugin;
begin
  Result := IWireCryptPlugin(@nullPtr);
end;

procedure IWireCryptPluginImpl_addRefDispatcher(this: IWireCryptPlugin); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_releaseDispatcher(this: IWireCryptPlugin): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IWireCryptPluginImpl_setOwnerDispatcher(this: IWireCryptPlugin; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_getOwnerDispatcher(this: IWireCryptPlugin): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IWireCryptPluginImpl_getKnownTypesDispatcher(this: IWireCryptPlugin; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getKnownTypes(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_setKeyDispatcher(this: IWireCryptPlugin; status: IStatus; key: ICryptKey); cdecl;
begin
	try
		this.owner.setKey(status, key);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_encryptDispatcher(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		this.owner.encrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_decryptDispatcher(this: IWireCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		this.owner.decrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IWireCryptPluginImpl_getSpecificDataDispatcher(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: CardinalPtr): BytePtr; cdecl;
begin
	try
		Result := this.owner.getSpecificData(status, keyType, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IWireCryptPluginImpl_setSpecificDataDispatcher(this: IWireCryptPlugin; status: IStatus; keyType: PAnsiChar; length: Cardinal; data: BytePtr); cdecl;
begin
	try
		this.owner.setSpecificData(status, keyType, length, data);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IWireCryptPluginImpl_vTable: WireCryptPluginVTable = (
     NullPtr: nil;
     version: 10;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     getKnownTypes: @IWireCryptPluginImpl_getKnownTypesDispatcher;
     setKey: @IWireCryptPluginImpl_setKeyDispatcher;
     encrypt: @IWireCryptPluginImpl_encryptDispatcher;
     decrypt: @IWireCryptPluginImpl_decryptDispatcher;
     getSpecificData: @IWireCryptPluginImpl_getSpecificDataDispatcher;
     setSpecificData: @IWireCryptPluginImpl_setSpecificDataDispatcher);

function TWireCryptPlugin.isIWireCryptPluginImpl: boolean inline;
begin
  Result := (vTable = @IWireCryptPluginImpl_vTable);
end;

constructor IWireCryptPluginImpl.create;
begin
  inherited Create;
  vTable := @IWireCryptPluginImpl_vTable;
end;

function IWireCryptPluginImpl.getvTableVersion: NativeInt;
begin
  Result := PWireCryptPluginVTable(vTable)^.version
end;

function ICryptKeyCallbackImpl.getInterface:ICryptKeyCallback;
begin
  Result := ICryptKeyCallback(@nullPtr);
end;

function ICryptKeyCallbackImpl_callbackDispatcher(this: ICryptKeyCallback; dataLength: Cardinal; data: Pointer; bufferLength: Cardinal; buffer: Pointer): Cardinal; cdecl;
begin
	try
		Result := this.owner.callback(dataLength, data, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ICryptKeyCallbackImpl_vTable: CryptKeyCallbackVTable = (
     NullPtr: nil;
     version: 1;
     callback: @ICryptKeyCallbackImpl_callbackDispatcher);

function TCryptKeyCallback.isICryptKeyCallbackImpl: boolean inline;
begin
  Result := (vTable = @ICryptKeyCallbackImpl_vTable);
end;

constructor ICryptKeyCallbackImpl.create;
begin
  inherited Create;
  vTable := @ICryptKeyCallbackImpl_vTable;
end;

function ICryptKeyCallbackImpl.getvTableVersion: NativeInt;
begin
  Result := PCryptKeyCallbackVTable(vTable)^.version
end;

function IKeyHolderPluginImpl.getInterface:IKeyHolderPlugin;
begin
  Result := IKeyHolderPlugin(@nullPtr);
end;

procedure IKeyHolderPluginImpl_addRefDispatcher(this: IKeyHolderPlugin); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_releaseDispatcher(this: IKeyHolderPlugin): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IKeyHolderPluginImpl_setOwnerDispatcher(this: IKeyHolderPlugin; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_getOwnerDispatcher(this: IKeyHolderPlugin): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IKeyHolderPluginImpl_keyCallbackDispatcher(this: IKeyHolderPlugin; status: IStatus; callback: ICryptKeyCallback): Integer; cdecl;
begin
	try
		Result := this.owner.keyCallback(status, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_keyHandleDispatcher(this: IKeyHolderPlugin; status: IStatus; keyName: PAnsiChar): ICryptKeyCallback; cdecl;
begin
	try
		Result := this.owner.keyHandle(status, keyName);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_useOnlyOwnKeysDispatcher(this: IKeyHolderPlugin; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.useOnlyOwnKeys(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IKeyHolderPluginImpl_chainHandleDispatcher(this: IKeyHolderPlugin; status: IStatus): ICryptKeyCallback; cdecl;
begin
	try
		Result := this.owner.chainHandle(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IKeyHolderPluginImpl_vTable: KeyHolderPluginVTable = (
     NullPtr: nil;
     version: 8;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     keyCallback: @IKeyHolderPluginImpl_keyCallbackDispatcher;
     keyHandle: @IKeyHolderPluginImpl_keyHandleDispatcher;
     useOnlyOwnKeys: @IKeyHolderPluginImpl_useOnlyOwnKeysDispatcher;
     chainHandle: @IKeyHolderPluginImpl_chainHandleDispatcher);

function TKeyHolderPlugin.isIKeyHolderPluginImpl: boolean inline;
begin
  Result := (vTable = @IKeyHolderPluginImpl_vTable);
end;

constructor IKeyHolderPluginImpl.create;
begin
  inherited Create;
  vTable := @IKeyHolderPluginImpl_vTable;
end;

function IKeyHolderPluginImpl.getvTableVersion: NativeInt;
begin
  Result := PKeyHolderPluginVTable(vTable)^.version
end;

function IDbCryptInfoImpl.getInterface:IDbCryptInfo;
begin
  Result := IDbCryptInfo(@nullPtr);
end;

procedure IDbCryptInfoImpl_addRefDispatcher(this: IDbCryptInfo); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptInfoImpl_releaseDispatcher(this: IDbCryptInfo): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptInfoImpl_getDatabaseFullPathDispatcher(this: IDbCryptInfo; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getDatabaseFullPath(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDbCryptInfoImpl_vTable: DbCryptInfoVTable = (
     NullPtr: nil;
     version: 3;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     getDatabaseFullPath: @IDbCryptInfoImpl_getDatabaseFullPathDispatcher);

function TDbCryptInfo.isIDbCryptInfoImpl: boolean inline;
begin
  Result := (vTable = @IDbCryptInfoImpl_vTable);
end;

constructor IDbCryptInfoImpl.create;
begin
  inherited Create;
  vTable := @IDbCryptInfoImpl_vTable;
end;

function IDbCryptInfoImpl.getvTableVersion: NativeInt;
begin
  Result := PDbCryptInfoVTable(vTable)^.version
end;

function IDbCryptPluginImpl.getInterface:IDbCryptPlugin;
begin
  Result := IDbCryptPlugin(@nullPtr);
end;

procedure IDbCryptPluginImpl_addRefDispatcher(this: IDbCryptPlugin); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptPluginImpl_releaseDispatcher(this: IDbCryptPlugin): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDbCryptPluginImpl_setOwnerDispatcher(this: IDbCryptPlugin; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IDbCryptPluginImpl_getOwnerDispatcher(this: IDbCryptPlugin): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDbCryptPluginImpl_setKeyDispatcher(this: IDbCryptPlugin; status: IStatus; length: Cardinal; sources: IKeyHolderPlugin; keyName: PAnsiChar); cdecl;
begin
	try
		this.owner.setKey(status, length, sources, keyName);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_encryptDispatcher(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		this.owner.encrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_decryptDispatcher(this: IDbCryptPlugin; status: IStatus; length: Cardinal; from: Pointer; to_: Pointer); cdecl;
begin
	try
		this.owner.decrypt(status, length, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDbCryptPluginImpl_setInfoDispatcher(this: IDbCryptPlugin; status: IStatus; info: IDbCryptInfo); cdecl;
begin
	try
		this.owner.setInfo(status, info);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDbCryptPluginImpl_vTable: DbCryptPluginVTable = (
     NullPtr: nil;
     version: 8;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     setKey: @IDbCryptPluginImpl_setKeyDispatcher;
     encrypt: @IDbCryptPluginImpl_encryptDispatcher;
     decrypt: @IDbCryptPluginImpl_decryptDispatcher;
     setInfo: @IDbCryptPluginImpl_setInfoDispatcher);

function TDbCryptPlugin.isIDbCryptPluginImpl: boolean inline;
begin
  Result := (vTable = @IDbCryptPluginImpl_vTable);
end;

constructor IDbCryptPluginImpl.create;
begin
  inherited Create;
  vTable := @IDbCryptPluginImpl_vTable;
end;

function IDbCryptPluginImpl.getvTableVersion: NativeInt;
begin
  Result := PDbCryptPluginVTable(vTable)^.version
end;

function IExternalContextImpl.getInterface:IExternalContext;
begin
  Result := IExternalContext(@nullPtr);
end;

function IExternalContextImpl_getMasterDispatcher(this: IExternalContext): IMaster; cdecl;
begin
	try
		Result := this.owner.getMaster();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getEngineDispatcher(this: IExternalContext; status: IStatus): IExternalEngine; cdecl;
begin
	try
		Result := this.owner.getEngine(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getAttachmentDispatcher(this: IExternalContext; status: IStatus): IAttachment; cdecl;
begin
	try
		Result := this.owner.getAttachment(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getTransactionDispatcher(this: IExternalContext; status: IStatus): ITransaction; cdecl;
begin
	try
		Result := this.owner.getTransaction(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalContextImpl_getUserNameDispatcher(this: IExternalContext): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getDatabaseNameDispatcher(this: IExternalContext): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getClientCharSetDispatcher(this: IExternalContext): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getClientCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_obtainInfoCodeDispatcher(this: IExternalContext): Integer; cdecl;
begin
	try
		Result := this.owner.obtainInfoCode();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_getInfoDispatcher(this: IExternalContext; code: Integer): Pointer; cdecl;
begin
	try
		Result := this.owner.getInfo(code);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalContextImpl_setInfoDispatcher(this: IExternalContext; code: Integer; value: Pointer): Pointer; cdecl;
begin
	try
		Result := this.owner.setInfo(code, value);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IExternalContextImpl_vTable: ExternalContextVTable = (
     NullPtr: nil;
     version: 10;
     getMaster: @IExternalContextImpl_getMasterDispatcher;
     getEngine: @IExternalContextImpl_getEngineDispatcher;
     getAttachment: @IExternalContextImpl_getAttachmentDispatcher;
     getTransaction: @IExternalContextImpl_getTransactionDispatcher;
     getUserName: @IExternalContextImpl_getUserNameDispatcher;
     getDatabaseName: @IExternalContextImpl_getDatabaseNameDispatcher;
     getClientCharSet: @IExternalContextImpl_getClientCharSetDispatcher;
     obtainInfoCode: @IExternalContextImpl_obtainInfoCodeDispatcher;
     getInfo: @IExternalContextImpl_getInfoDispatcher;
     setInfo: @IExternalContextImpl_setInfoDispatcher);

function TExternalContext.isIExternalContextImpl: boolean inline;
begin
  Result := (vTable = @IExternalContextImpl_vTable);
end;

constructor IExternalContextImpl.create;
begin
  inherited Create;
  vTable := @IExternalContextImpl_vTable;
end;

function IExternalContextImpl.getvTableVersion: NativeInt;
begin
  Result := PExternalContextVTable(vTable)^.version
end;

function IExternalResultSetImpl.getInterface:IExternalResultSet;
begin
  Result := IExternalResultSet(@nullPtr);
end;

procedure IExternalResultSetImpl_disposeDispatcher(this: IExternalResultSet); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalResultSetImpl_fetchDispatcher(this: IExternalResultSet; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.fetch(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalResultSetImpl_vTable: ExternalResultSetVTable = (
     NullPtr: nil;
     version: 2;
     dispose: @IDisposableImpl_disposeDispatcher;
     fetch: @IExternalResultSetImpl_fetchDispatcher);

function TExternalResultSet.isIExternalResultSetImpl: boolean inline;
begin
  Result := (vTable = @IExternalResultSetImpl_vTable);
end;

constructor IExternalResultSetImpl.create;
begin
  inherited Create;
  vTable := @IExternalResultSetImpl_vTable;
end;

function IExternalResultSetImpl.getvTableVersion: NativeInt;
begin
  Result := PExternalResultSetVTable(vTable)^.version
end;

function IExternalFunctionImpl.getInterface:IExternalFunction;
begin
  Result := IExternalFunction(@nullPtr);
end;

procedure IExternalFunctionImpl_disposeDispatcher(this: IExternalFunction); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalFunctionImpl_getCharSetDispatcher(this: IExternalFunction; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		this.owner.getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalFunctionImpl_executeDispatcher(this: IExternalFunction; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer); cdecl;
begin
	try
		this.owner.execute(status, context, inMsg, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalFunctionImpl_vTable: ExternalFunctionVTable = (
     NullPtr: nil;
     version: 3;
     dispose: @IDisposableImpl_disposeDispatcher;
     getCharSet: @IExternalFunctionImpl_getCharSetDispatcher;
     execute: @IExternalFunctionImpl_executeDispatcher);

function TExternalFunction.isIExternalFunctionImpl: boolean inline;
begin
  Result := (vTable = @IExternalFunctionImpl_vTable);
end;

constructor IExternalFunctionImpl.create;
begin
  inherited Create;
  vTable := @IExternalFunctionImpl_vTable;
end;

function IExternalFunctionImpl.getvTableVersion: NativeInt;
begin
  Result := PExternalFunctionVTable(vTable)^.version
end;

function IExternalProcedureImpl.getInterface:IExternalProcedure;
begin
  Result := IExternalProcedure(@nullPtr);
end;

procedure IExternalProcedureImpl_disposeDispatcher(this: IExternalProcedure); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalProcedureImpl_getCharSetDispatcher(this: IExternalProcedure; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		this.owner.getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalProcedureImpl_openDispatcher(this: IExternalProcedure; status: IStatus; context: IExternalContext; inMsg: Pointer; outMsg: Pointer): IExternalResultSet; cdecl;
begin
	try
		Result := this.owner.open(status, context, inMsg, outMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalProcedureImpl_vTable: ExternalProcedureVTable = (
     NullPtr: nil;
     version: 3;
     dispose: @IDisposableImpl_disposeDispatcher;
     getCharSet: @IExternalProcedureImpl_getCharSetDispatcher;
     open: @IExternalProcedureImpl_openDispatcher);

function TExternalProcedure.isIExternalProcedureImpl: boolean inline;
begin
  Result := (vTable = @IExternalProcedureImpl_vTable);
end;

constructor IExternalProcedureImpl.create;
begin
  inherited Create;
  vTable := @IExternalProcedureImpl_vTable;
end;

function IExternalProcedureImpl.getvTableVersion: NativeInt;
begin
  Result := PExternalProcedureVTable(vTable)^.version
end;

function IExternalTriggerImpl.getInterface:IExternalTrigger;
begin
  Result := IExternalTrigger(@nullPtr);
end;

procedure IExternalTriggerImpl_disposeDispatcher(this: IExternalTrigger); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalTriggerImpl_getCharSetDispatcher(this: IExternalTrigger; status: IStatus; context: IExternalContext; name: PAnsiChar; nameSize: Cardinal); cdecl;
begin
	try
		this.owner.getCharSet(status, context, name, nameSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalTriggerImpl_executeDispatcher(this: IExternalTrigger; status: IStatus; context: IExternalContext; action: Cardinal; oldMsg: Pointer; newMsg: Pointer); cdecl;
begin
	try
		this.owner.execute(status, context, action, oldMsg, newMsg);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalTriggerImpl_vTable: ExternalTriggerVTable = (
     NullPtr: nil;
     version: 3;
     dispose: @IDisposableImpl_disposeDispatcher;
     getCharSet: @IExternalTriggerImpl_getCharSetDispatcher;
     execute: @IExternalTriggerImpl_executeDispatcher);

function TExternalTrigger.isIExternalTriggerImpl: boolean inline;
begin
  Result := (vTable = @IExternalTriggerImpl_vTable);
end;

constructor IExternalTriggerImpl.create;
begin
  inherited Create;
  vTable := @IExternalTriggerImpl_vTable;
end;

function IExternalTriggerImpl.getvTableVersion: NativeInt;
begin
  Result := PExternalTriggerVTable(vTable)^.version
end;

function IRoutineMetadataImpl.getInterface:IRoutineMetadata;
begin
  Result := IRoutineMetadata(@nullPtr);
end;

function IRoutineMetadataImpl_getPackageDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getPackage(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getNameDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getName(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getEntryPointDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getEntryPoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getBodyDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getBody(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getInputMetadataDispatcher(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getInputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getOutputMetadataDispatcher(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getOutputMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerMetadataDispatcher(this: IRoutineMetadata; status: IStatus): IMessageMetadata; cdecl;
begin
	try
		Result := this.owner.getTriggerMetadata(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerTableDispatcher(this: IRoutineMetadata; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getTriggerTable(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IRoutineMetadataImpl_getTriggerTypeDispatcher(this: IRoutineMetadata; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getTriggerType(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IRoutineMetadataImpl_vTable: RoutineMetadataVTable = (
     NullPtr: nil;
     version: 9;
     getPackage: @IRoutineMetadataImpl_getPackageDispatcher;
     getName: @IRoutineMetadataImpl_getNameDispatcher;
     getEntryPoint: @IRoutineMetadataImpl_getEntryPointDispatcher;
     getBody: @IRoutineMetadataImpl_getBodyDispatcher;
     getInputMetadata: @IRoutineMetadataImpl_getInputMetadataDispatcher;
     getOutputMetadata: @IRoutineMetadataImpl_getOutputMetadataDispatcher;
     getTriggerMetadata: @IRoutineMetadataImpl_getTriggerMetadataDispatcher;
     getTriggerTable: @IRoutineMetadataImpl_getTriggerTableDispatcher;
     getTriggerType: @IRoutineMetadataImpl_getTriggerTypeDispatcher);

function TRoutineMetadata.isIRoutineMetadataImpl: boolean inline;
begin
  Result := (vTable = @IRoutineMetadataImpl_vTable);
end;

constructor IRoutineMetadataImpl.create;
begin
  inherited Create;
  vTable := @IRoutineMetadataImpl_vTable;
end;

function IRoutineMetadataImpl.getvTableVersion: NativeInt;
begin
  Result := PRoutineMetadataVTable(vTable)^.version
end;

function IExternalEngineImpl.getInterface:IExternalEngine;
begin
  Result := IExternalEngine(@nullPtr);
end;

procedure IExternalEngineImpl_addRefDispatcher(this: IExternalEngine); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalEngineImpl_releaseDispatcher(this: IExternalEngine): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalEngineImpl_setOwnerDispatcher(this: IExternalEngine; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IExternalEngineImpl_getOwnerDispatcher(this: IExternalEngine): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IExternalEngineImpl_openDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; charSet: PAnsiChar; charSetSize: Cardinal); cdecl;
begin
	try
		this.owner.open(status, context, charSet, charSetSize);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalEngineImpl_openAttachmentDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
begin
	try
		this.owner.openAttachment(status, context);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IExternalEngineImpl_closeAttachmentDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext); cdecl;
begin
	try
		this.owner.closeAttachment(status, context);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeFunctionDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalFunction; cdecl;
begin
	try
		Result := this.owner.makeFunction(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeProcedureDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder): IExternalProcedure; cdecl;
begin
	try
		Result := this.owner.makeProcedure(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IExternalEngineImpl_makeTriggerDispatcher(this: IExternalEngine; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder): IExternalTrigger; cdecl;
begin
	try
		Result := this.owner.makeTrigger(status, context, metadata, fieldsBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IExternalEngineImpl_vTable: ExternalEngineVTable = (
     NullPtr: nil;
     version: 10;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     open: @IExternalEngineImpl_openDispatcher;
     openAttachment: @IExternalEngineImpl_openAttachmentDispatcher;
     closeAttachment: @IExternalEngineImpl_closeAttachmentDispatcher;
     makeFunction: @IExternalEngineImpl_makeFunctionDispatcher;
     makeProcedure: @IExternalEngineImpl_makeProcedureDispatcher;
     makeTrigger: @IExternalEngineImpl_makeTriggerDispatcher);

function TExternalEngine.isIExternalEngineImpl: boolean inline;
begin
  Result := (vTable = @IExternalEngineImpl_vTable);
end;

constructor IExternalEngineImpl.create;
begin
  inherited Create;
  vTable := @IExternalEngineImpl_vTable;
end;

function IExternalEngineImpl.getvTableVersion: NativeInt;
begin
  Result := PExternalEngineVTable(vTable)^.version
end;

function ITimerImpl.getInterface:ITimer;
begin
  Result := ITimer(@nullPtr);
end;

procedure ITimerImpl_addRefDispatcher(this: ITimer); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITimerImpl_releaseDispatcher(this: ITimer): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITimerImpl_handlerDispatcher(this: ITimer); cdecl;
begin
	try
		this.owner.handler();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITimerImpl_vTable: TimerVTable = (
     NullPtr: nil;
     version: 3;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     handler: @ITimerImpl_handlerDispatcher);

function TTimer.isITimerImpl: boolean inline;
begin
  Result := (vTable = @ITimerImpl_vTable);
end;

constructor ITimerImpl.create;
begin
  inherited Create;
  vTable := @ITimerImpl_vTable;
end;

function ITimerImpl.getvTableVersion: NativeInt;
begin
  Result := PTimerVTable(vTable)^.version
end;

function ITimerControlImpl.getInterface:ITimerControl;
begin
  Result := ITimerControl(@nullPtr);
end;

procedure ITimerControlImpl_startDispatcher(this: ITimerControl; status: IStatus; timer: ITimer; microSeconds: QWord); cdecl;
begin
	try
		this.owner.start(status, timer, microSeconds);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure ITimerControlImpl_stopDispatcher(this: ITimerControl; status: IStatus; timer: ITimer); cdecl;
begin
	try
		this.owner.stop(status, timer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITimerControlImpl_vTable: TimerControlVTable = (
     NullPtr: nil;
     version: 2;
     start: @ITimerControlImpl_startDispatcher;
     stop: @ITimerControlImpl_stopDispatcher);

function TTimerControl.isITimerControlImpl: boolean inline;
begin
  Result := (vTable = @ITimerControlImpl_vTable);
end;

constructor ITimerControlImpl.create;
begin
  inherited Create;
  vTable := @ITimerControlImpl_vTable;
end;

function ITimerControlImpl.getvTableVersion: NativeInt;
begin
  Result := PTimerControlVTable(vTable)^.version
end;

function IVersionCallbackImpl.getInterface:IVersionCallback;
begin
  Result := IVersionCallback(@nullPtr);
end;

procedure IVersionCallbackImpl_callbackDispatcher(this: IVersionCallback; status: IStatus; text: PAnsiChar); cdecl;
begin
	try
		this.owner.callback(status, text);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IVersionCallbackImpl_vTable: VersionCallbackVTable = (
     NullPtr: nil;
     version: 1;
     callback: @IVersionCallbackImpl_callbackDispatcher);

function TVersionCallback.isIVersionCallbackImpl: boolean inline;
begin
  Result := (vTable = @IVersionCallbackImpl_vTable);
end;

constructor IVersionCallbackImpl.create;
begin
  inherited Create;
  vTable := @IVersionCallbackImpl_vTable;
end;

function IVersionCallbackImpl.getvTableVersion: NativeInt;
begin
  Result := PVersionCallbackVTable(vTable)^.version
end;

function IUtilImpl.getInterface:IUtil;
begin
  Result := IUtil(@nullPtr);
end;

procedure IUtilImpl_getFbVersionDispatcher(this: IUtil; status: IStatus; att: IAttachment; callback: IVersionCallback); cdecl;
begin
	try
		this.owner.getFbVersion(status, att, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_loadBlobDispatcher(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
begin
	try
		this.owner.loadBlob(status, blobId, att, tra, file_, txt);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_dumpBlobDispatcher(this: IUtil; status: IStatus; blobId: ISC_QUADPtr; att: IAttachment; tra: ITransaction; file_: PAnsiChar; txt: Boolean); cdecl;
begin
	try
		this.owner.dumpBlob(status, blobId, att, tra, file_, txt);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_getPerfCountersDispatcher(this: IUtil; status: IStatus; att: IAttachment; countersSet: PAnsiChar; counters: Int64Ptr); cdecl;
begin
	try
		this.owner.getPerfCounters(status, att, countersSet, counters);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_executeCreateDatabaseDispatcher(this: IUtil; status: IStatus; stmtLength: Cardinal; creatDBstatement: PAnsiChar; dialect: Cardinal; stmtIsCreateDb: BooleanPtr): IAttachment; cdecl;
begin
	try
		Result := this.owner.executeCreateDatabase(status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeDateDispatcher(this: IUtil; date: ISC_DATE; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr); cdecl;
begin
	try
		this.owner.decodeDate(date, year, month, day);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUtilImpl_decodeTimeDispatcher(this: IUtil; time: ISC_TIME; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr); cdecl;
begin
	try
		this.owner.decodeTime(time, hours, minutes, seconds, fractions);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_encodeDateDispatcher(this: IUtil; year: Cardinal; month: Cardinal; day: Cardinal): ISC_DATE; cdecl;
begin
	try
		Result := this.owner.encodeDate(year, month, day);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_encodeTimeDispatcher(this: IUtil; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal): ISC_TIME; cdecl;
begin
	try
		Result := this.owner.encodeTime(hours, minutes, seconds, fractions);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_formatStatusDispatcher(this: IUtil; buffer: PAnsiChar; bufferSize: Cardinal; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.formatStatus(buffer, bufferSize, status);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_getClientVersionDispatcher(this: IUtil): Cardinal; cdecl;
begin
	try
		Result := this.owner.getClientVersion();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IUtilImpl_getXpbBuilderDispatcher(this: IUtil; status: IStatus; kind: Cardinal; buf: BytePtr; len: Cardinal): IXpbBuilder; cdecl;
begin
	try
		Result := this.owner.getXpbBuilder(status, kind, buf, len);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_setOffsetsDispatcher(this: IUtil; status: IStatus; metadata: IMessageMetadata; callback: IOffsetsCallback): Cardinal; cdecl;
begin
	try
		Result := this.owner.setOffsets(status, metadata, callback);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getDecFloat16Dispatcher(this: IUtil; status: IStatus): IDecFloat16; cdecl;
begin
	try
		Result := this.owner.getDecFloat16(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getDecFloat34Dispatcher(this: IUtil; status: IStatus): IDecFloat34; cdecl;
begin
	try
		Result := this.owner.getDecFloat34(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeTzDispatcher(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		this.owner.decodeTimeTz(status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeStampTzDispatcher(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		this.owner.decodeTimeStampTz(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_encodeTimeTzDispatcher(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZPtr; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
begin
	try
		this.owner.encodeTimeTz(status, timeTz, hours, minutes, seconds, fractions, timeZone);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_encodeTimeStampTzDispatcher(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZPtr; year: Cardinal; month: Cardinal; day: Cardinal; hours: Cardinal; minutes: Cardinal; seconds: Cardinal; fractions: Cardinal; timeZone: PAnsiChar); cdecl;
begin
	try
		this.owner.encodeTimeStampTz(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZone);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUtilImpl_getInt128Dispatcher(this: IUtil; status: IStatus): IInt128; cdecl;
begin
	try
		Result := this.owner.getInt128(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeTzExDispatcher(this: IUtil; status: IStatus; timeTz: ISC_TIME_TZ_EXPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		this.owner.decodeTimeTzEx(status, timeTz, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUtilImpl_decodeTimeStampTzExDispatcher(this: IUtil; status: IStatus; timeStampTz: ISC_TIMESTAMP_TZ_EXPtr; year: CardinalPtr; month: CardinalPtr; day: CardinalPtr; hours: CardinalPtr; minutes: CardinalPtr; seconds: CardinalPtr; fractions: CardinalPtr; timeZoneBufferLength: Cardinal; timeZoneBuffer: PAnsiChar); cdecl;
begin
	try
		this.owner.decodeTimeStampTzEx(status, timeStampTz, year, month, day, hours, minutes, seconds, fractions, timeZoneBufferLength, timeZoneBuffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUtilImpl_vTable: UtilVTable = (
     NullPtr: nil;
     version: 22;
     getFbVersion: @IUtilImpl_getFbVersionDispatcher;
     loadBlob: @IUtilImpl_loadBlobDispatcher;
     dumpBlob: @IUtilImpl_dumpBlobDispatcher;
     getPerfCounters: @IUtilImpl_getPerfCountersDispatcher;
     executeCreateDatabase: @IUtilImpl_executeCreateDatabaseDispatcher;
     decodeDate: @IUtilImpl_decodeDateDispatcher;
     decodeTime: @IUtilImpl_decodeTimeDispatcher;
     encodeDate: @IUtilImpl_encodeDateDispatcher;
     encodeTime: @IUtilImpl_encodeTimeDispatcher;
     formatStatus: @IUtilImpl_formatStatusDispatcher;
     getClientVersion: @IUtilImpl_getClientVersionDispatcher;
     getXpbBuilder: @IUtilImpl_getXpbBuilderDispatcher;
     setOffsets: @IUtilImpl_setOffsetsDispatcher;
     getDecFloat16: @IUtilImpl_getDecFloat16Dispatcher;
     getDecFloat34: @IUtilImpl_getDecFloat34Dispatcher;
     decodeTimeTz: @IUtilImpl_decodeTimeTzDispatcher;
     decodeTimeStampTz: @IUtilImpl_decodeTimeStampTzDispatcher;
     encodeTimeTz: @IUtilImpl_encodeTimeTzDispatcher;
     encodeTimeStampTz: @IUtilImpl_encodeTimeStampTzDispatcher;
     getInt128: @IUtilImpl_getInt128Dispatcher;
     decodeTimeTzEx: @IUtilImpl_decodeTimeTzExDispatcher;
     decodeTimeStampTzEx: @IUtilImpl_decodeTimeStampTzExDispatcher);

function TUtil.isIUtilImpl: boolean inline;
begin
  Result := (vTable = @IUtilImpl_vTable);
end;

constructor IUtilImpl.create;
begin
  inherited Create;
  vTable := @IUtilImpl_vTable;
end;

function IUtilImpl.getvTableVersion: NativeInt;
begin
  Result := PUtilVTable(vTable)^.version
end;

function IOffsetsCallbackImpl.getInterface:IOffsetsCallback;
begin
  Result := IOffsetsCallback(@nullPtr);
end;

procedure IOffsetsCallbackImpl_setOffsetDispatcher(this: IOffsetsCallback; status: IStatus; index: Cardinal; offset: Cardinal; nullOffset: Cardinal); cdecl;
begin
	try
		this.owner.setOffset(status, index, offset, nullOffset);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IOffsetsCallbackImpl_vTable: OffsetsCallbackVTable = (
     NullPtr: nil;
     version: 1;
     setOffset: @IOffsetsCallbackImpl_setOffsetDispatcher);

function TOffsetsCallback.isIOffsetsCallbackImpl: boolean inline;
begin
  Result := (vTable = @IOffsetsCallbackImpl_vTable);
end;

constructor IOffsetsCallbackImpl.create;
begin
  inherited Create;
  vTable := @IOffsetsCallbackImpl_vTable;
end;

function IOffsetsCallbackImpl.getvTableVersion: NativeInt;
begin
  Result := POffsetsCallbackVTable(vTable)^.version
end;

function IXpbBuilderImpl.getInterface:IXpbBuilder;
begin
  Result := IXpbBuilder(@nullPtr);
end;

procedure IXpbBuilderImpl_disposeDispatcher(this: IXpbBuilder); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IXpbBuilderImpl_clearDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		this.owner.clear(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_removeCurrentDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		this.owner.removeCurrent(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertIntDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; value: Integer); cdecl;
begin
	try
		this.owner.insertInt(status, tag, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertBigIntDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; value: Int64); cdecl;
begin
	try
		this.owner.insertBigInt(status, tag, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertBytesDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; bytes: Pointer; length: Cardinal); cdecl;
begin
	try
		this.owner.insertBytes(status, tag, bytes, length);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertStringDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte; str: PAnsiChar); cdecl;
begin
	try
		this.owner.insertString(status, tag, str);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_insertTagDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte); cdecl;
begin
	try
		this.owner.insertTag(status, tag);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_isEofDispatcher(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.isEof(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_moveNextDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		this.owner.moveNext(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IXpbBuilderImpl_rewindDispatcher(this: IXpbBuilder; status: IStatus); cdecl;
begin
	try
		this.owner.rewind(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_findFirstDispatcher(this: IXpbBuilder; status: IStatus; tag: Byte): Boolean; cdecl;
begin
	try
		Result := this.owner.findFirst(status, tag);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_findNextDispatcher(this: IXpbBuilder; status: IStatus): Boolean; cdecl;
begin
	try
		Result := this.owner.findNext(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getTagDispatcher(this: IXpbBuilder; status: IStatus): Byte; cdecl;
begin
	try
		Result := this.owner.getTag(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getLengthDispatcher(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getIntDispatcher(this: IXpbBuilder; status: IStatus): Integer; cdecl;
begin
	try
		Result := this.owner.getInt(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBigIntDispatcher(this: IXpbBuilder; status: IStatus): Int64; cdecl;
begin
	try
		Result := this.owner.getBigInt(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getStringDispatcher(this: IXpbBuilder; status: IStatus): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getString(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBytesDispatcher(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
begin
	try
		Result := this.owner.getBytes(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBufferLengthDispatcher(this: IXpbBuilder; status: IStatus): Cardinal; cdecl;
begin
	try
		Result := this.owner.getBufferLength(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IXpbBuilderImpl_getBufferDispatcher(this: IXpbBuilder; status: IStatus): BytePtr; cdecl;
begin
	try
		Result := this.owner.getBuffer(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IXpbBuilderImpl_vTable: XpbBuilderVTable = (
     NullPtr: nil;
     version: 21;
     dispose: @IDisposableImpl_disposeDispatcher;
     clear: @IXpbBuilderImpl_clearDispatcher;
     removeCurrent: @IXpbBuilderImpl_removeCurrentDispatcher;
     insertInt: @IXpbBuilderImpl_insertIntDispatcher;
     insertBigInt: @IXpbBuilderImpl_insertBigIntDispatcher;
     insertBytes: @IXpbBuilderImpl_insertBytesDispatcher;
     insertString: @IXpbBuilderImpl_insertStringDispatcher;
     insertTag: @IXpbBuilderImpl_insertTagDispatcher;
     isEof: @IXpbBuilderImpl_isEofDispatcher;
     moveNext: @IXpbBuilderImpl_moveNextDispatcher;
     rewind: @IXpbBuilderImpl_rewindDispatcher;
     findFirst: @IXpbBuilderImpl_findFirstDispatcher;
     findNext: @IXpbBuilderImpl_findNextDispatcher;
     getTag: @IXpbBuilderImpl_getTagDispatcher;
     getLength: @IXpbBuilderImpl_getLengthDispatcher;
     getInt: @IXpbBuilderImpl_getIntDispatcher;
     getBigInt: @IXpbBuilderImpl_getBigIntDispatcher;
     getString: @IXpbBuilderImpl_getStringDispatcher;
     getBytes: @IXpbBuilderImpl_getBytesDispatcher;
     getBufferLength: @IXpbBuilderImpl_getBufferLengthDispatcher;
     getBuffer: @IXpbBuilderImpl_getBufferDispatcher);

function TXpbBuilder.isIXpbBuilderImpl: boolean inline;
begin
  Result := (vTable = @IXpbBuilderImpl_vTable);
end;

constructor IXpbBuilderImpl.create;
begin
  inherited Create;
  vTable := @IXpbBuilderImpl_vTable;
end;

function IXpbBuilderImpl.getvTableVersion: NativeInt;
begin
  Result := PXpbBuilderVTable(vTable)^.version
end;

function ITraceConnectionImpl.getInterface:ITraceConnection;
begin
  Result := ITraceConnection(@nullPtr);
end;

function ITraceConnectionImpl_getKindDispatcher(this: ITraceConnection): Cardinal; cdecl;
begin
	try
		Result := this.owner.getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getProcessIDDispatcher(this: ITraceConnection): Integer; cdecl;
begin
	try
		Result := this.owner.getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getUserNameDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRoleNameDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getCharSetDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProtocolDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteAddressDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProcessIDDispatcher(this: ITraceConnection): Integer; cdecl;
begin
	try
		Result := this.owner.getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceConnectionImpl_getRemoteProcessNameDispatcher(this: ITraceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceConnectionImpl_vTable: TraceConnectionVTable = (
     NullPtr: nil;
     version: 9;
     getKind: @ITraceConnectionImpl_getKindDispatcher;
     getProcessID: @ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName: @ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName: @ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet: @ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol: @ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress: @ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID: @ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName: @ITraceConnectionImpl_getRemoteProcessNameDispatcher);

function TTraceConnection.isITraceConnectionImpl: boolean inline;
begin
  Result := (vTable = @ITraceConnectionImpl_vTable);
end;

constructor ITraceConnectionImpl.create;
begin
  inherited Create;
  vTable := @ITraceConnectionImpl_vTable;
end;

function ITraceConnectionImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceConnectionVTable(vTable)^.version
end;

function ITraceDatabaseConnectionImpl.getInterface:ITraceDatabaseConnection;
begin
  Result := ITraceDatabaseConnection(@nullPtr);
end;

function ITraceDatabaseConnectionImpl_getKindDispatcher(this: ITraceDatabaseConnection): Cardinal; cdecl;
begin
	try
		Result := this.owner.getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getProcessIDDispatcher(this: ITraceDatabaseConnection): Integer; cdecl;
begin
	try
		Result := this.owner.getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getUserNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRoleNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getCharSetDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProtocolDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteAddressDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProcessIDDispatcher(this: ITraceDatabaseConnection): Integer; cdecl;
begin
	try
		Result := this.owner.getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getRemoteProcessNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getConnectionIDDispatcher(this: ITraceDatabaseConnection): Int64; cdecl;
begin
	try
		Result := this.owner.getConnectionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDatabaseConnectionImpl_getDatabaseNameDispatcher(this: ITraceDatabaseConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceDatabaseConnectionImpl_vTable: TraceDatabaseConnectionVTable = (
     NullPtr: nil;
     version: 11;
     getKind: @ITraceConnectionImpl_getKindDispatcher;
     getProcessID: @ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName: @ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName: @ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet: @ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol: @ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress: @ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID: @ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName: @ITraceConnectionImpl_getRemoteProcessNameDispatcher;
     getConnectionID: @ITraceDatabaseConnectionImpl_getConnectionIDDispatcher;
     getDatabaseName: @ITraceDatabaseConnectionImpl_getDatabaseNameDispatcher);

function TTraceDatabaseConnection.isITraceDatabaseConnectionImpl: boolean inline;
begin
  Result := (vTable = @ITraceDatabaseConnectionImpl_vTable);
end;

constructor ITraceDatabaseConnectionImpl.create;
begin
  inherited Create;
  vTable := @ITraceDatabaseConnectionImpl_vTable;
end;

function ITraceDatabaseConnectionImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceDatabaseConnectionVTable(vTable)^.version
end;

function ITraceTransactionImpl.getInterface:ITraceTransaction;
begin
  Result := ITraceTransaction(@nullPtr);
end;

function ITraceTransactionImpl_getTransactionIDDispatcher(this: ITraceTransaction): Int64; cdecl;
begin
	try
		Result := this.owner.getTransactionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getReadOnlyDispatcher(this: ITraceTransaction): Boolean; cdecl;
begin
	try
		Result := this.owner.getReadOnly();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getWaitDispatcher(this: ITraceTransaction): Integer; cdecl;
begin
	try
		Result := this.owner.getWait();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getIsolationDispatcher(this: ITraceTransaction): Cardinal; cdecl;
begin
	try
		Result := this.owner.getIsolation();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getPerfDispatcher(this: ITraceTransaction): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getInitialIDDispatcher(this: ITraceTransaction): Int64; cdecl;
begin
	try
		Result := this.owner.getInitialID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTransactionImpl_getPreviousIDDispatcher(this: ITraceTransaction): Int64; cdecl;
begin
	try
		Result := this.owner.getPreviousID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceTransactionImpl_vTable: TraceTransactionVTable = (
     NullPtr: nil;
     version: 7;
     getTransactionID: @ITraceTransactionImpl_getTransactionIDDispatcher;
     getReadOnly: @ITraceTransactionImpl_getReadOnlyDispatcher;
     getWait: @ITraceTransactionImpl_getWaitDispatcher;
     getIsolation: @ITraceTransactionImpl_getIsolationDispatcher;
     getPerf: @ITraceTransactionImpl_getPerfDispatcher;
     getInitialID: @ITraceTransactionImpl_getInitialIDDispatcher;
     getPreviousID: @ITraceTransactionImpl_getPreviousIDDispatcher);

function TTraceTransaction.isITraceTransactionImpl: boolean inline;
begin
  Result := (vTable = @ITraceTransactionImpl_vTable);
end;

constructor ITraceTransactionImpl.create;
begin
  inherited Create;
  vTable := @ITraceTransactionImpl_vTable;
end;

function ITraceTransactionImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceTransactionVTable(vTable)^.version
end;

function ITraceParamsImpl.getInterface:ITraceParams;
begin
  Result := ITraceParams(@nullPtr);
end;

function ITraceParamsImpl_getCountDispatcher(this: ITraceParams): Cardinal; cdecl;
begin
	try
		Result := this.owner.getCount();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceParamsImpl_getParamDispatcher(this: ITraceParams; idx: Cardinal): dscPtr; cdecl;
begin
	try
		Result := this.owner.getParam(idx);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceParamsImpl_getTextUTF8Dispatcher(this: ITraceParams; status: IStatus; idx: Cardinal): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getTextUTF8(status, idx);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITraceParamsImpl_vTable: TraceParamsVTable = (
     NullPtr: nil;
     version: 3;
     getCount: @ITraceParamsImpl_getCountDispatcher;
     getParam: @ITraceParamsImpl_getParamDispatcher;
     getTextUTF8: @ITraceParamsImpl_getTextUTF8Dispatcher);

function TTraceParams.isITraceParamsImpl: boolean inline;
begin
  Result := (vTable = @ITraceParamsImpl_vTable);
end;

constructor ITraceParamsImpl.create;
begin
  inherited Create;
  vTable := @ITraceParamsImpl_vTable;
end;

function ITraceParamsImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceParamsVTable(vTable)^.version
end;

function ITraceStatementImpl.getInterface:ITraceStatement;
begin
  Result := ITraceStatement(@nullPtr);
end;

function ITraceStatementImpl_getStmtIDDispatcher(this: ITraceStatement): Int64; cdecl;
begin
	try
		Result := this.owner.getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatementImpl_getPerfDispatcher(this: ITraceStatement): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceStatementImpl_vTable: TraceStatementVTable = (
     NullPtr: nil;
     version: 2;
     getStmtID: @ITraceStatementImpl_getStmtIDDispatcher;
     getPerf: @ITraceStatementImpl_getPerfDispatcher);

function TTraceStatement.isITraceStatementImpl: boolean inline;
begin
  Result := (vTable = @ITraceStatementImpl_vTable);
end;

constructor ITraceStatementImpl.create;
begin
  inherited Create;
  vTable := @ITraceStatementImpl_vTable;
end;

function ITraceStatementImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceStatementVTable(vTable)^.version
end;

function ITraceSQLStatementImpl.getInterface:ITraceSQLStatement;
begin
  Result := ITraceSQLStatement(@nullPtr);
end;

function ITraceSQLStatementImpl_getStmtIDDispatcher(this: ITraceSQLStatement): Int64; cdecl;
begin
	try
		Result := this.owner.getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getPerfDispatcher(this: ITraceSQLStatement): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getTextDispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getPlanDispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getPlan();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getInputsDispatcher(this: ITraceSQLStatement): ITraceParams; cdecl;
begin
	try
		Result := this.owner.getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getTextUTF8Dispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getTextUTF8();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSQLStatementImpl_getExplainedPlanDispatcher(this: ITraceSQLStatement): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getExplainedPlan();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceSQLStatementImpl_vTable: TraceSQLStatementVTable = (
     NullPtr: nil;
     version: 7;
     getStmtID: @ITraceStatementImpl_getStmtIDDispatcher;
     getPerf: @ITraceStatementImpl_getPerfDispatcher;
     getText: @ITraceSQLStatementImpl_getTextDispatcher;
     getPlan: @ITraceSQLStatementImpl_getPlanDispatcher;
     getInputs: @ITraceSQLStatementImpl_getInputsDispatcher;
     getTextUTF8: @ITraceSQLStatementImpl_getTextUTF8Dispatcher;
     getExplainedPlan: @ITraceSQLStatementImpl_getExplainedPlanDispatcher);

function TTraceSQLStatement.isITraceSQLStatementImpl: boolean inline;
begin
  Result := (vTable = @ITraceSQLStatementImpl_vTable);
end;

constructor ITraceSQLStatementImpl.create;
begin
  inherited Create;
  vTable := @ITraceSQLStatementImpl_vTable;
end;

function ITraceSQLStatementImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceSQLStatementVTable(vTable)^.version
end;

function ITraceBLRStatementImpl.getInterface:ITraceBLRStatement;
begin
  Result := ITraceBLRStatement(@nullPtr);
end;

function ITraceBLRStatementImpl_getStmtIDDispatcher(this: ITraceBLRStatement): Int64; cdecl;
begin
	try
		Result := this.owner.getStmtID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getPerfDispatcher(this: ITraceBLRStatement): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getDataDispatcher(this: ITraceBLRStatement): BytePtr; cdecl;
begin
	try
		Result := this.owner.getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getDataLengthDispatcher(this: ITraceBLRStatement): Cardinal; cdecl;
begin
	try
		Result := this.owner.getDataLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceBLRStatementImpl_getTextDispatcher(this: ITraceBLRStatement): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceBLRStatementImpl_vTable: TraceBLRStatementVTable = (
     NullPtr: nil;
     version: 5;
     getStmtID: @ITraceStatementImpl_getStmtIDDispatcher;
     getPerf: @ITraceStatementImpl_getPerfDispatcher;
     getData: @ITraceBLRStatementImpl_getDataDispatcher;
     getDataLength: @ITraceBLRStatementImpl_getDataLengthDispatcher;
     getText: @ITraceBLRStatementImpl_getTextDispatcher);

function TTraceBLRStatement.isITraceBLRStatementImpl: boolean inline;
begin
  Result := (vTable = @ITraceBLRStatementImpl_vTable);
end;

constructor ITraceBLRStatementImpl.create;
begin
  inherited Create;
  vTable := @ITraceBLRStatementImpl_vTable;
end;

function ITraceBLRStatementImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceBLRStatementVTable(vTable)^.version
end;

function ITraceDYNRequestImpl.getInterface:ITraceDYNRequest;
begin
  Result := ITraceDYNRequest(@nullPtr);
end;

function ITraceDYNRequestImpl_getDataDispatcher(this: ITraceDYNRequest): BytePtr; cdecl;
begin
	try
		Result := this.owner.getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDYNRequestImpl_getDataLengthDispatcher(this: ITraceDYNRequest): Cardinal; cdecl;
begin
	try
		Result := this.owner.getDataLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceDYNRequestImpl_getTextDispatcher(this: ITraceDYNRequest): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceDYNRequestImpl_vTable: TraceDYNRequestVTable = (
     NullPtr: nil;
     version: 3;
     getData: @ITraceDYNRequestImpl_getDataDispatcher;
     getDataLength: @ITraceDYNRequestImpl_getDataLengthDispatcher;
     getText: @ITraceDYNRequestImpl_getTextDispatcher);

function TTraceDYNRequest.isITraceDYNRequestImpl: boolean inline;
begin
  Result := (vTable = @ITraceDYNRequestImpl_vTable);
end;

constructor ITraceDYNRequestImpl.create;
begin
  inherited Create;
  vTable := @ITraceDYNRequestImpl_vTable;
end;

function ITraceDYNRequestImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceDYNRequestVTable(vTable)^.version
end;

function ITraceContextVariableImpl.getInterface:ITraceContextVariable;
begin
  Result := ITraceContextVariable(@nullPtr);
end;

function ITraceContextVariableImpl_getNameSpaceDispatcher(this: ITraceContextVariable): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getNameSpace();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceContextVariableImpl_getVarNameDispatcher(this: ITraceContextVariable): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getVarName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceContextVariableImpl_getVarValueDispatcher(this: ITraceContextVariable): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getVarValue();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceContextVariableImpl_vTable: TraceContextVariableVTable = (
     NullPtr: nil;
     version: 3;
     getNameSpace: @ITraceContextVariableImpl_getNameSpaceDispatcher;
     getVarName: @ITraceContextVariableImpl_getVarNameDispatcher;
     getVarValue: @ITraceContextVariableImpl_getVarValueDispatcher);

function TTraceContextVariable.isITraceContextVariableImpl: boolean inline;
begin
  Result := (vTable = @ITraceContextVariableImpl_vTable);
end;

constructor ITraceContextVariableImpl.create;
begin
  inherited Create;
  vTable := @ITraceContextVariableImpl_vTable;
end;

function ITraceContextVariableImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceContextVariableVTable(vTable)^.version
end;

function ITraceProcedureImpl.getInterface:ITraceProcedure;
begin
  Result := ITraceProcedure(@nullPtr);
end;

function ITraceProcedureImpl_getProcNameDispatcher(this: ITraceProcedure): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getProcName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceProcedureImpl_getInputsDispatcher(this: ITraceProcedure): ITraceParams; cdecl;
begin
	try
		Result := this.owner.getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceProcedureImpl_getPerfDispatcher(this: ITraceProcedure): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceProcedureImpl_vTable: TraceProcedureVTable = (
     NullPtr: nil;
     version: 3;
     getProcName: @ITraceProcedureImpl_getProcNameDispatcher;
     getInputs: @ITraceProcedureImpl_getInputsDispatcher;
     getPerf: @ITraceProcedureImpl_getPerfDispatcher);

function TTraceProcedure.isITraceProcedureImpl: boolean inline;
begin
  Result := (vTable = @ITraceProcedureImpl_vTable);
end;

constructor ITraceProcedureImpl.create;
begin
  inherited Create;
  vTable := @ITraceProcedureImpl_vTable;
end;

function ITraceProcedureImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceProcedureVTable(vTable)^.version
end;

function ITraceFunctionImpl.getInterface:ITraceFunction;
begin
  Result := ITraceFunction(@nullPtr);
end;

function ITraceFunctionImpl_getFuncNameDispatcher(this: ITraceFunction): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getFuncName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getInputsDispatcher(this: ITraceFunction): ITraceParams; cdecl;
begin
	try
		Result := this.owner.getInputs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getResultDispatcher(this: ITraceFunction): ITraceParams; cdecl;
begin
	try
		Result := this.owner.getResult();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFunctionImpl_getPerfDispatcher(this: ITraceFunction): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceFunctionImpl_vTable: TraceFunctionVTable = (
     NullPtr: nil;
     version: 4;
     getFuncName: @ITraceFunctionImpl_getFuncNameDispatcher;
     getInputs: @ITraceFunctionImpl_getInputsDispatcher;
     getResult: @ITraceFunctionImpl_getResultDispatcher;
     getPerf: @ITraceFunctionImpl_getPerfDispatcher);

function TTraceFunction.isITraceFunctionImpl: boolean inline;
begin
  Result := (vTable = @ITraceFunctionImpl_vTable);
end;

constructor ITraceFunctionImpl.create;
begin
  inherited Create;
  vTable := @ITraceFunctionImpl_vTable;
end;

function ITraceFunctionImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceFunctionVTable(vTable)^.version
end;

function ITraceTriggerImpl.getInterface:ITraceTrigger;
begin
  Result := ITraceTrigger(@nullPtr);
end;

function ITraceTriggerImpl_getTriggerNameDispatcher(this: ITraceTrigger): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getTriggerName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getRelationNameDispatcher(this: ITraceTrigger): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRelationName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getActionDispatcher(this: ITraceTrigger): Integer; cdecl;
begin
	try
		Result := this.owner.getAction();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getWhichDispatcher(this: ITraceTrigger): Integer; cdecl;
begin
	try
		Result := this.owner.getWhich();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceTriggerImpl_getPerfDispatcher(this: ITraceTrigger): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceTriggerImpl_vTable: TraceTriggerVTable = (
     NullPtr: nil;
     version: 5;
     getTriggerName: @ITraceTriggerImpl_getTriggerNameDispatcher;
     getRelationName: @ITraceTriggerImpl_getRelationNameDispatcher;
     getAction: @ITraceTriggerImpl_getActionDispatcher;
     getWhich: @ITraceTriggerImpl_getWhichDispatcher;
     getPerf: @ITraceTriggerImpl_getPerfDispatcher);

function TTraceTrigger.isITraceTriggerImpl: boolean inline;
begin
  Result := (vTable = @ITraceTriggerImpl_vTable);
end;

constructor ITraceTriggerImpl.create;
begin
  inherited Create;
  vTable := @ITraceTriggerImpl_vTable;
end;

function ITraceTriggerImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceTriggerVTable(vTable)^.version
end;

function ITraceServiceConnectionImpl.getInterface:ITraceServiceConnection;
begin
  Result := ITraceServiceConnection(@nullPtr);
end;

function ITraceServiceConnectionImpl_getKindDispatcher(this: ITraceServiceConnection): Cardinal; cdecl;
begin
	try
		Result := this.owner.getKind();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getProcessIDDispatcher(this: ITraceServiceConnection): Integer; cdecl;
begin
	try
		Result := this.owner.getProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getUserNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getUserName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRoleNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRoleName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getCharSetDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProtocolDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteProtocol();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteAddressDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteAddress();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProcessIDDispatcher(this: ITraceServiceConnection): Integer; cdecl;
begin
	try
		Result := this.owner.getRemoteProcessID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getRemoteProcessNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getRemoteProcessName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceIDDispatcher(this: ITraceServiceConnection): Pointer; cdecl;
begin
	try
		Result := this.owner.getServiceID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceMgrDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getServiceMgr();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceServiceConnectionImpl_getServiceNameDispatcher(this: ITraceServiceConnection): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getServiceName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceServiceConnectionImpl_vTable: TraceServiceConnectionVTable = (
     NullPtr: nil;
     version: 12;
     getKind: @ITraceConnectionImpl_getKindDispatcher;
     getProcessID: @ITraceConnectionImpl_getProcessIDDispatcher;
     getUserName: @ITraceConnectionImpl_getUserNameDispatcher;
     getRoleName: @ITraceConnectionImpl_getRoleNameDispatcher;
     getCharSet: @ITraceConnectionImpl_getCharSetDispatcher;
     getRemoteProtocol: @ITraceConnectionImpl_getRemoteProtocolDispatcher;
     getRemoteAddress: @ITraceConnectionImpl_getRemoteAddressDispatcher;
     getRemoteProcessID: @ITraceConnectionImpl_getRemoteProcessIDDispatcher;
     getRemoteProcessName: @ITraceConnectionImpl_getRemoteProcessNameDispatcher;
     getServiceID: @ITraceServiceConnectionImpl_getServiceIDDispatcher;
     getServiceMgr: @ITraceServiceConnectionImpl_getServiceMgrDispatcher;
     getServiceName: @ITraceServiceConnectionImpl_getServiceNameDispatcher);

function TTraceServiceConnection.isITraceServiceConnectionImpl: boolean inline;
begin
  Result := (vTable = @ITraceServiceConnectionImpl_vTable);
end;

constructor ITraceServiceConnectionImpl.create;
begin
  inherited Create;
  vTable := @ITraceServiceConnectionImpl_vTable;
end;

function ITraceServiceConnectionImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceServiceConnectionVTable(vTable)^.version
end;

function ITraceStatusVectorImpl.getInterface:ITraceStatusVector;
begin
  Result := ITraceStatusVector(@nullPtr);
end;

function ITraceStatusVectorImpl_hasErrorDispatcher(this: ITraceStatusVector): Boolean; cdecl;
begin
	try
		Result := this.owner.hasError();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_hasWarningDispatcher(this: ITraceStatusVector): Boolean; cdecl;
begin
	try
		Result := this.owner.hasWarning();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_getStatusDispatcher(this: ITraceStatusVector): IStatus; cdecl;
begin
	try
		Result := this.owner.getStatus();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceStatusVectorImpl_getTextDispatcher(this: ITraceStatusVector): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceStatusVectorImpl_vTable: TraceStatusVectorVTable = (
     NullPtr: nil;
     version: 4;
     hasError: @ITraceStatusVectorImpl_hasErrorDispatcher;
     hasWarning: @ITraceStatusVectorImpl_hasWarningDispatcher;
     getStatus: @ITraceStatusVectorImpl_getStatusDispatcher;
     getText: @ITraceStatusVectorImpl_getTextDispatcher);

function TTraceStatusVector.isITraceStatusVectorImpl: boolean inline;
begin
  Result := (vTable = @ITraceStatusVectorImpl_vTable);
end;

constructor ITraceStatusVectorImpl.create;
begin
  inherited Create;
  vTable := @ITraceStatusVectorImpl_vTable;
end;

function ITraceStatusVectorImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceStatusVectorVTable(vTable)^.version
end;

function ITraceSweepInfoImpl.getInterface:ITraceSweepInfo;
begin
  Result := ITraceSweepInfo(@nullPtr);
end;

function ITraceSweepInfoImpl_getOITDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := this.owner.getOIT();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getOSTDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := this.owner.getOST();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getOATDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := this.owner.getOAT();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getNextDispatcher(this: ITraceSweepInfo): Int64; cdecl;
begin
	try
		Result := this.owner.getNext();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceSweepInfoImpl_getPerfDispatcher(this: ITraceSweepInfo): PerformanceInfoPtr; cdecl;
begin
	try
		Result := this.owner.getPerf();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceSweepInfoImpl_vTable: TraceSweepInfoVTable = (
     NullPtr: nil;
     version: 5;
     getOIT: @ITraceSweepInfoImpl_getOITDispatcher;
     getOST: @ITraceSweepInfoImpl_getOSTDispatcher;
     getOAT: @ITraceSweepInfoImpl_getOATDispatcher;
     getNext: @ITraceSweepInfoImpl_getNextDispatcher;
     getPerf: @ITraceSweepInfoImpl_getPerfDispatcher);

function TTraceSweepInfo.isITraceSweepInfoImpl: boolean inline;
begin
  Result := (vTable = @ITraceSweepInfoImpl_vTable);
end;

constructor ITraceSweepInfoImpl.create;
begin
  inherited Create;
  vTable := @ITraceSweepInfoImpl_vTable;
end;

function ITraceSweepInfoImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceSweepInfoVTable(vTable)^.version
end;

function ITraceLogWriterImpl.getInterface:ITraceLogWriter;
begin
  Result := ITraceLogWriter(@nullPtr);
end;

procedure ITraceLogWriterImpl_addRefDispatcher(this: ITraceLogWriter); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_releaseDispatcher(this: ITraceLogWriter): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_writeDispatcher(this: ITraceLogWriter; buf: Pointer; size: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.write(buf, size);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceLogWriterImpl_write_sDispatcher(this: ITraceLogWriter; status: IStatus; buf: Pointer; size: Cardinal): Cardinal; cdecl;
begin
	try
		Result := this.owner.write_s(status, buf, size);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITraceLogWriterImpl_vTable: TraceLogWriterVTable = (
     NullPtr: nil;
     version: 4;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     write: @ITraceLogWriterImpl_writeDispatcher;
     write_s: @ITraceLogWriterImpl_write_sDispatcher);

function TTraceLogWriter.isITraceLogWriterImpl: boolean inline;
begin
  Result := (vTable = @ITraceLogWriterImpl_vTable);
end;

constructor ITraceLogWriterImpl.create;
begin
  inherited Create;
  vTable := @ITraceLogWriterImpl_vTable;
end;

function ITraceLogWriterImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceLogWriterVTable(vTable)^.version
end;

function ITraceInitInfoImpl.getInterface:ITraceInitInfo;
begin
  Result := ITraceInitInfo(@nullPtr);
end;

function ITraceInitInfoImpl_getConfigTextDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getConfigText();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getTraceSessionIDDispatcher(this: ITraceInitInfo): Integer; cdecl;
begin
	try
		Result := this.owner.getTraceSessionID();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getTraceSessionNameDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getTraceSessionName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getFirebirdRootDirectoryDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getFirebirdRootDirectory();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getDatabaseNameDispatcher(this: ITraceInitInfo): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getDatabaseName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getConnectionDispatcher(this: ITraceInitInfo): ITraceDatabaseConnection; cdecl;
begin
	try
		Result := this.owner.getConnection();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceInitInfoImpl_getLogWriterDispatcher(this: ITraceInitInfo): ITraceLogWriter; cdecl;
begin
	try
		Result := this.owner.getLogWriter();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITraceInitInfoImpl_vTable: TraceInitInfoVTable = (
     NullPtr: nil;
     version: 7;
     getConfigText: @ITraceInitInfoImpl_getConfigTextDispatcher;
     getTraceSessionID: @ITraceInitInfoImpl_getTraceSessionIDDispatcher;
     getTraceSessionName: @ITraceInitInfoImpl_getTraceSessionNameDispatcher;
     getFirebirdRootDirectory: @ITraceInitInfoImpl_getFirebirdRootDirectoryDispatcher;
     getDatabaseName: @ITraceInitInfoImpl_getDatabaseNameDispatcher;
     getConnection: @ITraceInitInfoImpl_getConnectionDispatcher;
     getLogWriter: @ITraceInitInfoImpl_getLogWriterDispatcher);

function TTraceInitInfo.isITraceInitInfoImpl: boolean inline;
begin
  Result := (vTable = @ITraceInitInfoImpl_vTable);
end;

constructor ITraceInitInfoImpl.create;
begin
  inherited Create;
  vTable := @ITraceInitInfoImpl_vTable;
end;

function ITraceInitInfoImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceInitInfoVTable(vTable)^.version
end;

function ITracePluginImpl.getInterface:ITracePlugin;
begin
  Result := ITracePlugin(@nullPtr);
end;

procedure ITracePluginImpl_addRefDispatcher(this: ITracePlugin); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_releaseDispatcher(this: ITracePlugin): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_get_errorDispatcher(this: ITracePlugin): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.trace_get_error();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_attachDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; create_db: Boolean; att_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_attach(connection, create_db, att_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_detachDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; drop_db: Boolean): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_detach(connection, drop_db);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_transaction_startDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; tpb_length: Cardinal; tpb: BytePtr; tra_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_transaction_start(connection, transaction, tpb_length, tpb, tra_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_transaction_endDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; commit: Boolean; retain_context: Boolean; tra_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_transaction_end(connection, transaction, commit, retain_context, tra_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_proc_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; procedure_: ITraceProcedure; started: Boolean; proc_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_proc_execute(connection, transaction, procedure_, started, proc_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_trigger_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; trigger: ITraceTrigger; started: Boolean; trig_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_trigger_execute(connection, transaction, trigger, started, trig_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_set_contextDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; variable: ITraceContextVariable): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_set_context(connection, transaction, variable);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_prepareDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_dsql_prepare(connection, transaction, statement, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_freeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; statement: ITraceSQLStatement; option: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_dsql_free(connection, statement, option);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dsql_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceSQLStatement; started: Boolean; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_dsql_execute(connection, transaction, statement, started, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_blr_compileDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_blr_compile(connection, transaction, statement, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_blr_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; statement: ITraceBLRStatement; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_blr_execute(connection, transaction, statement, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_dyn_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; request: ITraceDYNRequest; time_millis: Int64; req_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_dyn_execute(connection, transaction, request, time_millis, req_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_attachDispatcher(this: ITracePlugin; service: ITraceServiceConnection; att_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_service_attach(service, att_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_startDispatcher(this: ITracePlugin; service: ITraceServiceConnection; switches_length: Cardinal; switches: PAnsiChar; start_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_service_start(service, switches_length, switches, start_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_queryDispatcher(this: ITracePlugin; service: ITraceServiceConnection; send_item_length: Cardinal; send_items: BytePtr; recv_item_length: Cardinal; recv_items: BytePtr; query_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_service_query(service, send_item_length, send_items, recv_item_length, recv_items, query_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_service_detachDispatcher(this: ITracePlugin; service: ITraceServiceConnection; detach_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_service_detach(service, detach_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_event_errorDispatcher(this: ITracePlugin; connection: ITraceConnection; status: ITraceStatusVector; function_: PAnsiChar): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_event_error(connection, status, function_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_event_sweepDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; sweep: ITraceSweepInfo; sweep_state: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_event_sweep(connection, sweep, sweep_state);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITracePluginImpl_trace_func_executeDispatcher(this: ITracePlugin; connection: ITraceDatabaseConnection; transaction: ITraceTransaction; function_: ITraceFunction; started: Boolean; func_result: Cardinal): Boolean; cdecl;
begin
	try
		Result := this.owner.trace_func_execute(connection, transaction, function_, started, func_result);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var ITracePluginImpl_vTable: TracePluginVTable = (
     NullPtr: nil;
     version: 23;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     trace_get_error: @ITracePluginImpl_trace_get_errorDispatcher;
     trace_attach: @ITracePluginImpl_trace_attachDispatcher;
     trace_detach: @ITracePluginImpl_trace_detachDispatcher;
     trace_transaction_start: @ITracePluginImpl_trace_transaction_startDispatcher;
     trace_transaction_end: @ITracePluginImpl_trace_transaction_endDispatcher;
     trace_proc_execute: @ITracePluginImpl_trace_proc_executeDispatcher;
     trace_trigger_execute: @ITracePluginImpl_trace_trigger_executeDispatcher;
     trace_set_context: @ITracePluginImpl_trace_set_contextDispatcher;
     trace_dsql_prepare: @ITracePluginImpl_trace_dsql_prepareDispatcher;
     trace_dsql_free: @ITracePluginImpl_trace_dsql_freeDispatcher;
     trace_dsql_execute: @ITracePluginImpl_trace_dsql_executeDispatcher;
     trace_blr_compile: @ITracePluginImpl_trace_blr_compileDispatcher;
     trace_blr_execute: @ITracePluginImpl_trace_blr_executeDispatcher;
     trace_dyn_execute: @ITracePluginImpl_trace_dyn_executeDispatcher;
     trace_service_attach: @ITracePluginImpl_trace_service_attachDispatcher;
     trace_service_start: @ITracePluginImpl_trace_service_startDispatcher;
     trace_service_query: @ITracePluginImpl_trace_service_queryDispatcher;
     trace_service_detach: @ITracePluginImpl_trace_service_detachDispatcher;
     trace_event_error: @ITracePluginImpl_trace_event_errorDispatcher;
     trace_event_sweep: @ITracePluginImpl_trace_event_sweepDispatcher;
     trace_func_execute: @ITracePluginImpl_trace_func_executeDispatcher);

function TTracePlugin.isITracePluginImpl: boolean inline;
begin
  Result := (vTable = @ITracePluginImpl_vTable);
end;

constructor ITracePluginImpl.create;
begin
  inherited Create;
  vTable := @ITracePluginImpl_vTable;
end;

function ITracePluginImpl.getvTableVersion: NativeInt;
begin
  Result := PTracePluginVTable(vTable)^.version
end;

function ITraceFactoryImpl.getInterface:ITraceFactory;
begin
  Result := ITraceFactory(@nullPtr);
end;

procedure ITraceFactoryImpl_addRefDispatcher(this: ITraceFactory); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_releaseDispatcher(this: ITraceFactory): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure ITraceFactoryImpl_setOwnerDispatcher(this: ITraceFactory; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_getOwnerDispatcher(this: ITraceFactory): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_trace_needsDispatcher(this: ITraceFactory): QWord; cdecl;
begin
	try
		Result := this.owner.trace_needs();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function ITraceFactoryImpl_trace_createDispatcher(this: ITraceFactory; status: IStatus; init_info: ITraceInitInfo): ITracePlugin; cdecl;
begin
	try
		Result := this.owner.trace_create(status, init_info);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var ITraceFactoryImpl_vTable: TraceFactoryVTable = (
     NullPtr: nil;
     version: 6;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     trace_needs: @ITraceFactoryImpl_trace_needsDispatcher;
     trace_create: @ITraceFactoryImpl_trace_createDispatcher);

function TTraceFactory.isITraceFactoryImpl: boolean inline;
begin
  Result := (vTable = @ITraceFactoryImpl_vTable);
end;

constructor ITraceFactoryImpl.create;
begin
  inherited Create;
  vTable := @ITraceFactoryImpl_vTable;
end;

function ITraceFactoryImpl.getvTableVersion: NativeInt;
begin
  Result := PTraceFactoryVTable(vTable)^.version
end;

function IUdrFunctionFactoryImpl.getInterface:IUdrFunctionFactory;
begin
  Result := IUdrFunctionFactory(@nullPtr);
end;

procedure IUdrFunctionFactoryImpl_disposeDispatcher(this: IUdrFunctionFactory); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrFunctionFactoryImpl_setupDispatcher(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
begin
	try
		this.owner.setup(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrFunctionFactoryImpl_newItemDispatcher(this: IUdrFunctionFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalFunction; cdecl;
begin
	try
		Result := this.owner.newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrFunctionFactoryImpl_vTable: UdrFunctionFactoryVTable = (
     NullPtr: nil;
     version: 3;
     dispose: @IDisposableImpl_disposeDispatcher;
     setup: @IUdrFunctionFactoryImpl_setupDispatcher;
     newItem: @IUdrFunctionFactoryImpl_newItemDispatcher);

function TUdrFunctionFactory.isIUdrFunctionFactoryImpl: boolean inline;
begin
  Result := (vTable = @IUdrFunctionFactoryImpl_vTable);
end;

constructor IUdrFunctionFactoryImpl.create;
begin
  inherited Create;
  vTable := @IUdrFunctionFactoryImpl_vTable;
end;

function IUdrFunctionFactoryImpl.getvTableVersion: NativeInt;
begin
  Result := PUdrFunctionFactoryVTable(vTable)^.version
end;

function IUdrProcedureFactoryImpl.getInterface:IUdrProcedureFactory;
begin
  Result := IUdrProcedureFactory(@nullPtr);
end;

procedure IUdrProcedureFactoryImpl_disposeDispatcher(this: IUdrProcedureFactory); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrProcedureFactoryImpl_setupDispatcher(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder); cdecl;
begin
	try
		this.owner.setup(status, context, metadata, inBuilder, outBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrProcedureFactoryImpl_newItemDispatcher(this: IUdrProcedureFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalProcedure; cdecl;
begin
	try
		Result := this.owner.newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrProcedureFactoryImpl_vTable: UdrProcedureFactoryVTable = (
     NullPtr: nil;
     version: 3;
     dispose: @IDisposableImpl_disposeDispatcher;
     setup: @IUdrProcedureFactoryImpl_setupDispatcher;
     newItem: @IUdrProcedureFactoryImpl_newItemDispatcher);

function TUdrProcedureFactory.isIUdrProcedureFactoryImpl: boolean inline;
begin
  Result := (vTable = @IUdrProcedureFactoryImpl_vTable);
end;

constructor IUdrProcedureFactoryImpl.create;
begin
  inherited Create;
  vTable := @IUdrProcedureFactoryImpl_vTable;
end;

function IUdrProcedureFactoryImpl.getvTableVersion: NativeInt;
begin
  Result := PUdrProcedureFactoryVTable(vTable)^.version
end;

function IUdrTriggerFactoryImpl.getInterface:IUdrTriggerFactory;
begin
  Result := IUdrTriggerFactory(@nullPtr);
end;

procedure IUdrTriggerFactoryImpl_disposeDispatcher(this: IUdrTriggerFactory); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrTriggerFactoryImpl_setupDispatcher(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder); cdecl;
begin
	try
		this.owner.setup(status, context, metadata, fieldsBuilder);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IUdrTriggerFactoryImpl_newItemDispatcher(this: IUdrTriggerFactory; status: IStatus; context: IExternalContext; metadata: IRoutineMetadata): IExternalTrigger; cdecl;
begin
	try
		Result := this.owner.newItem(status, context, metadata);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrTriggerFactoryImpl_vTable: UdrTriggerFactoryVTable = (
     NullPtr: nil;
     version: 3;
     dispose: @IDisposableImpl_disposeDispatcher;
     setup: @IUdrTriggerFactoryImpl_setupDispatcher;
     newItem: @IUdrTriggerFactoryImpl_newItemDispatcher);

function TUdrTriggerFactory.isIUdrTriggerFactoryImpl: boolean inline;
begin
  Result := (vTable = @IUdrTriggerFactoryImpl_vTable);
end;

constructor IUdrTriggerFactoryImpl.create;
begin
  inherited Create;
  vTable := @IUdrTriggerFactoryImpl_vTable;
end;

function IUdrTriggerFactoryImpl.getvTableVersion: NativeInt;
begin
  Result := PUdrTriggerFactoryVTable(vTable)^.version
end;

function IUdrPluginImpl.getInterface:IUdrPlugin;
begin
  Result := IUdrPlugin(@nullPtr);
end;

function IUdrPluginImpl_getMasterDispatcher(this: IUdrPlugin): IMaster; cdecl;
begin
	try
		Result := this.owner.getMaster();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IUdrPluginImpl_registerFunctionDispatcher(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrFunctionFactory); cdecl;
begin
	try
		this.owner.registerFunction(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUdrPluginImpl_registerProcedureDispatcher(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrProcedureFactory); cdecl;
begin
	try
		this.owner.registerProcedure(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IUdrPluginImpl_registerTriggerDispatcher(this: IUdrPlugin; status: IStatus; name: PAnsiChar; factory: IUdrTriggerFactory); cdecl;
begin
	try
		this.owner.registerTrigger(status, name, factory);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IUdrPluginImpl_vTable: UdrPluginVTable = (
     NullPtr: nil;
     version: 4;
     getMaster: @IUdrPluginImpl_getMasterDispatcher;
     registerFunction: @IUdrPluginImpl_registerFunctionDispatcher;
     registerProcedure: @IUdrPluginImpl_registerProcedureDispatcher;
     registerTrigger: @IUdrPluginImpl_registerTriggerDispatcher);

function TUdrPlugin.isIUdrPluginImpl: boolean inline;
begin
  Result := (vTable = @IUdrPluginImpl_vTable);
end;

constructor IUdrPluginImpl.create;
begin
  inherited Create;
  vTable := @IUdrPluginImpl_vTable;
end;

function IUdrPluginImpl.getvTableVersion: NativeInt;
begin
  Result := PUdrPluginVTable(vTable)^.version
end;

function IDecFloat16Impl.getInterface:IDecFloat16;
begin
  Result := IDecFloat16(@nullPtr);
end;

procedure IDecFloat16Impl_toBcdDispatcher(this: IDecFloat16; from: FB_DEC16Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
begin
	try
		this.owner.toBcd(from, sign, bcd, exp);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat16Impl_toStringDispatcher(this: IDecFloat16; status: IStatus; from: FB_DEC16Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		this.owner.toString(status, from, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDecFloat16Impl_fromBcdDispatcher(this: IDecFloat16; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC16Ptr); cdecl;
begin
	try
		this.owner.fromBcd(sign, bcd, exp, to_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat16Impl_fromStringDispatcher(this: IDecFloat16; status: IStatus; from: PAnsiChar; to_: FB_DEC16Ptr); cdecl;
begin
	try
		this.owner.fromString(status, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDecFloat16Impl_vTable: DecFloat16VTable = (
     NullPtr: nil;
     version: 4;
     toBcd: @IDecFloat16Impl_toBcdDispatcher;
     toString: @IDecFloat16Impl_toStringDispatcher;
     fromBcd: @IDecFloat16Impl_fromBcdDispatcher;
     fromString: @IDecFloat16Impl_fromStringDispatcher);

function TDecFloat16.isIDecFloat16Impl: boolean inline;
begin
  Result := (vTable = @IDecFloat16Impl_vTable);
end;

constructor IDecFloat16Impl.create;
begin
  inherited Create;
  vTable := @IDecFloat16Impl_vTable;
end;

function IDecFloat16Impl.getvTableVersion: NativeInt;
begin
  Result := PDecFloat16VTable(vTable)^.version
end;

function IDecFloat34Impl.getInterface:IDecFloat34;
begin
  Result := IDecFloat34(@nullPtr);
end;

procedure IDecFloat34Impl_toBcdDispatcher(this: IDecFloat34; from: FB_DEC34Ptr; sign: IntegerPtr; bcd: BytePtr; exp: IntegerPtr); cdecl;
begin
	try
		this.owner.toBcd(from, sign, bcd, exp);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat34Impl_toStringDispatcher(this: IDecFloat34; status: IStatus; from: FB_DEC34Ptr; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		this.owner.toString(status, from, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IDecFloat34Impl_fromBcdDispatcher(this: IDecFloat34; sign: Integer; bcd: BytePtr; exp: Integer; to_: FB_DEC34Ptr); cdecl;
begin
	try
		this.owner.fromBcd(sign, bcd, exp, to_);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IDecFloat34Impl_fromStringDispatcher(this: IDecFloat34; status: IStatus; from: PAnsiChar; to_: FB_DEC34Ptr); cdecl;
begin
	try
		this.owner.fromString(status, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IDecFloat34Impl_vTable: DecFloat34VTable = (
     NullPtr: nil;
     version: 4;
     toBcd: @IDecFloat34Impl_toBcdDispatcher;
     toString: @IDecFloat34Impl_toStringDispatcher;
     fromBcd: @IDecFloat34Impl_fromBcdDispatcher;
     fromString: @IDecFloat34Impl_fromStringDispatcher);

function TDecFloat34.isIDecFloat34Impl: boolean inline;
begin
  Result := (vTable = @IDecFloat34Impl_vTable);
end;

constructor IDecFloat34Impl.create;
begin
  inherited Create;
  vTable := @IDecFloat34Impl_vTable;
end;

function IDecFloat34Impl.getvTableVersion: NativeInt;
begin
  Result := PDecFloat34VTable(vTable)^.version
end;

function IInt128Impl.getInterface:IInt128;
begin
  Result := IInt128(@nullPtr);
end;

procedure IInt128Impl_toStringDispatcher(this: IInt128; status: IStatus; from: FB_I128Ptr; scale: Integer; bufferLength: Cardinal; buffer: PAnsiChar); cdecl;
begin
	try
		this.owner.toString(status, from, scale, bufferLength, buffer);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IInt128Impl_fromStringDispatcher(this: IInt128; status: IStatus; scale: Integer; from: PAnsiChar; to_: FB_I128Ptr); cdecl;
begin
	try
		this.owner.fromString(status, scale, from, to_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IInt128Impl_vTable: Int128VTable = (
     NullPtr: nil;
     version: 2;
     toString: @IInt128Impl_toStringDispatcher;
     fromString: @IInt128Impl_fromStringDispatcher);

function TInt128.isIInt128Impl: boolean inline;
begin
  Result := (vTable = @IInt128Impl_vTable);
end;

constructor IInt128Impl.create;
begin
  inherited Create;
  vTable := @IInt128Impl_vTable;
end;

function IInt128Impl.getvTableVersion: NativeInt;
begin
  Result := PInt128VTable(vTable)^.version
end;

function IReplicatedFieldImpl.getInterface:IReplicatedField;
begin
  Result := IReplicatedField(@nullPtr);
end;

function IReplicatedFieldImpl_getNameDispatcher(this: IReplicatedField): PAnsiChar; cdecl;
begin
	try
		Result := this.owner.getName();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getTypeDispatcher(this: IReplicatedField): Cardinal; cdecl;
begin
	try
		Result := this.owner.getType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getSubTypeDispatcher(this: IReplicatedField): Integer; cdecl;
begin
	try
		Result := this.owner.getSubType();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getScaleDispatcher(this: IReplicatedField): Integer; cdecl;
begin
	try
		Result := this.owner.getScale();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getLengthDispatcher(this: IReplicatedField): Cardinal; cdecl;
begin
	try
		Result := this.owner.getLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getCharSetDispatcher(this: IReplicatedField): Cardinal; cdecl;
begin
	try
		Result := this.owner.getCharSet();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedFieldImpl_getDataDispatcher(this: IReplicatedField): Pointer; cdecl;
begin
	try
		Result := this.owner.getData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IReplicatedFieldImpl_vTable: ReplicatedFieldVTable = (
     NullPtr: nil;
     version: 7;
     getName: @IReplicatedFieldImpl_getNameDispatcher;
     getType: @IReplicatedFieldImpl_getTypeDispatcher;
     getSubType: @IReplicatedFieldImpl_getSubTypeDispatcher;
     getScale: @IReplicatedFieldImpl_getScaleDispatcher;
     getLength: @IReplicatedFieldImpl_getLengthDispatcher;
     getCharSet: @IReplicatedFieldImpl_getCharSetDispatcher;
     getData: @IReplicatedFieldImpl_getDataDispatcher);

function TReplicatedField.isIReplicatedFieldImpl: boolean inline;
begin
  Result := (vTable = @IReplicatedFieldImpl_vTable);
end;

constructor IReplicatedFieldImpl.create;
begin
  inherited Create;
  vTable := @IReplicatedFieldImpl_vTable;
end;

function IReplicatedFieldImpl.getvTableVersion: NativeInt;
begin
  Result := PReplicatedFieldVTable(vTable)^.version
end;

function IReplicatedRecordImpl.getInterface:IReplicatedRecord;
begin
  Result := IReplicatedRecord(@nullPtr);
end;

function IReplicatedRecordImpl_getCountDispatcher(this: IReplicatedRecord): Cardinal; cdecl;
begin
	try
		Result := this.owner.getCount();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getFieldDispatcher(this: IReplicatedRecord; index: Cardinal): IReplicatedField; cdecl;
begin
	try
		Result := this.owner.getField(index);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getRawLengthDispatcher(this: IReplicatedRecord): Cardinal; cdecl;
begin
	try
		Result := this.owner.getRawLength();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedRecordImpl_getRawDataDispatcher(this: IReplicatedRecord): BytePtr; cdecl;
begin
	try
		Result := this.owner.getRawData();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

var IReplicatedRecordImpl_vTable: ReplicatedRecordVTable = (
     NullPtr: nil;
     version: 4;
     getCount: @IReplicatedRecordImpl_getCountDispatcher;
     getField: @IReplicatedRecordImpl_getFieldDispatcher;
     getRawLength: @IReplicatedRecordImpl_getRawLengthDispatcher;
     getRawData: @IReplicatedRecordImpl_getRawDataDispatcher);

function TReplicatedRecord.isIReplicatedRecordImpl: boolean inline;
begin
  Result := (vTable = @IReplicatedRecordImpl_vTable);
end;

constructor IReplicatedRecordImpl.create;
begin
  inherited Create;
  vTable := @IReplicatedRecordImpl_vTable;
end;

function IReplicatedRecordImpl.getvTableVersion: NativeInt;
begin
  Result := PReplicatedRecordVTable(vTable)^.version
end;

function IReplicatedTransactionImpl.getInterface:IReplicatedTransaction;
begin
  Result := IReplicatedTransaction(@nullPtr);
end;

procedure IReplicatedTransactionImpl_disposeDispatcher(this: IReplicatedTransaction); cdecl;
begin
	try
		this.owner.dispose();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatedTransactionImpl_prepareDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		this.owner.prepare(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_commitDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		this.owner.commit(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_rollbackDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		this.owner.rollback(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_startSavepointDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		this.owner.startSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_releaseSavepointDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		this.owner.releaseSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_rollbackSavepointDispatcher(this: IReplicatedTransaction; status: IStatus); cdecl;
begin
	try
		this.owner.rollbackSavepoint(status);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_insertRecordDispatcher(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
begin
	try
		this.owner.insertRecord(status, name, record_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_updateRecordDispatcher(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; orgRecord: IReplicatedRecord; newRecord: IReplicatedRecord); cdecl;
begin
	try
		this.owner.updateRecord(status, name, orgRecord, newRecord);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_deleteRecordDispatcher(this: IReplicatedTransaction; status: IStatus; name: PAnsiChar; record_: IReplicatedRecord); cdecl;
begin
	try
		this.owner.deleteRecord(status, name, record_);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_executeSqlDispatcher(this: IReplicatedTransaction; status: IStatus; sql: PAnsiChar); cdecl;
begin
	try
		this.owner.executeSql(status, sql);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedTransactionImpl_executeSqlIntlDispatcher(this: IReplicatedTransaction; status: IStatus; charset: Cardinal; sql: PAnsiChar); cdecl;
begin
	try
		this.owner.executeSqlIntl(status, charset, sql);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IReplicatedTransactionImpl_vTable: ReplicatedTransactionVTable = (
     NullPtr: nil;
     version: 12;
     dispose: @IDisposableImpl_disposeDispatcher;
     prepare: @IReplicatedTransactionImpl_prepareDispatcher;
     commit: @IReplicatedTransactionImpl_commitDispatcher;
     rollback: @IReplicatedTransactionImpl_rollbackDispatcher;
     startSavepoint: @IReplicatedTransactionImpl_startSavepointDispatcher;
     releaseSavepoint: @IReplicatedTransactionImpl_releaseSavepointDispatcher;
     rollbackSavepoint: @IReplicatedTransactionImpl_rollbackSavepointDispatcher;
     insertRecord: @IReplicatedTransactionImpl_insertRecordDispatcher;
     updateRecord: @IReplicatedTransactionImpl_updateRecordDispatcher;
     deleteRecord: @IReplicatedTransactionImpl_deleteRecordDispatcher;
     executeSql: @IReplicatedTransactionImpl_executeSqlDispatcher;
     executeSqlIntl: @IReplicatedTransactionImpl_executeSqlIntlDispatcher);

function TReplicatedTransaction.isIReplicatedTransactionImpl: boolean inline;
begin
  Result := (vTable = @IReplicatedTransactionImpl_vTable);
end;

constructor IReplicatedTransactionImpl.create;
begin
  inherited Create;
  vTable := @IReplicatedTransactionImpl_vTable;
end;

function IReplicatedTransactionImpl.getvTableVersion: NativeInt;
begin
  Result := PReplicatedTransactionVTable(vTable)^.version
end;

function IReplicatedSessionImpl.getInterface:IReplicatedSession;
begin
  Result := IReplicatedSession(@nullPtr);
end;

procedure IReplicatedSessionImpl_addRefDispatcher(this: IReplicatedSession); cdecl;
begin
	try
		this.owner.addRef();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_releaseDispatcher(this: IReplicatedSession): Integer; cdecl;
begin
	try
		Result := this.owner.release();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

procedure IReplicatedSessionImpl_setOwnerDispatcher(this: IReplicatedSession; r: IReferenceCounted); cdecl;
begin
	try
		this.owner.setOwner(r);
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_getOwnerDispatcher(this: IReplicatedSession): IReferenceCounted; cdecl;
begin
	try
		Result := this.owner.getOwner();
	except
		on e: Exception do FbException.catchException(nil, e);
	end
end;

function IReplicatedSessionImpl_initDispatcher(this: IReplicatedSession; status: IStatus; attachment: IAttachment): Boolean; cdecl;
begin
	try
		Result := this.owner.init(status, attachment);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

function IReplicatedSessionImpl_startTransactionDispatcher(this: IReplicatedSession; status: IStatus; transaction: ITransaction; number: Int64): IReplicatedTransaction; cdecl;
begin
	try
		Result := this.owner.startTransaction(status, transaction, number);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedSessionImpl_cleanupTransactionDispatcher(this: IReplicatedSession; status: IStatus; number: Int64); cdecl;
begin
	try
		this.owner.cleanupTransaction(status, number);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

procedure IReplicatedSessionImpl_setSequenceDispatcher(this: IReplicatedSession; status: IStatus; name: PAnsiChar; value: Int64); cdecl;
begin
	try
		this.owner.setSequence(status, name, value);
	except
		on e: Exception do FbException.catchException(status, e);
	end
end;

var IReplicatedSessionImpl_vTable: ReplicatedSessionVTable = (
     NullPtr: nil;
     version: 8;
     addRef: @IReferenceCountedImpl_addRefDispatcher;
     release: @IReferenceCountedImpl_releaseDispatcher;
     setOwner: @IPluginBaseImpl_setOwnerDispatcher;
     getOwner: @IPluginBaseImpl_getOwnerDispatcher;
     init: @IReplicatedSessionImpl_initDispatcher;
     startTransaction: @IReplicatedSessionImpl_startTransactionDispatcher;
     cleanupTransaction: @IReplicatedSessionImpl_cleanupTransactionDispatcher;
     setSequence: @IReplicatedSessionImpl_setSequenceDispatcher);

function TReplicatedSession.isIReplicatedSessionImpl: boolean inline;
begin
  Result := (vTable = @IReplicatedSessionImpl_vTable);
end;

constructor IReplicatedSessionImpl.create;
begin
  inherited Create;
  vTable := @IReplicatedSessionImpl_vTable;
end;

function IReplicatedSessionImpl.getvTableVersion: NativeInt;
begin
  Result := PReplicatedSessionVTable(vTable)^.version
end;

constructor FbException.create(status: IStatus);
begin
	inherited Create('FbException');
	self.status := status.clone;
end;

destructor FbException.Destroy();
begin
	status.dispose;
	inherited Destroy;
end;

function FbException.getStatus: IStatus;
begin
	Result := status;
end;

class procedure FbException.checkException(status: IStatus);
begin
	if ((status.getState and IStatusImpl.STATE_ERRORS) <> 0) then
		raise FbException.create(status);
end;

class procedure FbException.catchException(status: IStatus; e: Exception);
var
	statusVector: array[0..4] of NativeIntPtr;
	msg: AnsiString;
begin
	if (e.inheritsFrom(FbException)) then
		status.setErrors(FbException(e).getStatus.getErrors)
	else
	begin
		msg := e.message;

		statusVector[0] := NativeIntPtr(isc_arg_gds);
		statusVector[1] := NativeIntPtr(isc_random);
		statusVector[2] := NativeIntPtr(isc_arg_string);
		statusVector[3] := NativeIntPtr(PAnsiChar(msg));
		statusVector[4] := NativeIntPtr(isc_arg_end);

		status.setErrors(@statusVector);
	end
end;

{$IFDEF STATIC_LINK_TO_FIREBIRD_LIBRARY}
function fb_get_master_interface : IMaster; {$IFDEF WINDOWS} stdcall; {$ELSE} cdecl; {$ENDIF}; external 'fbclient';

function GetIMaster: IMaster;
begin
  Result := fb_get_master_interface;
end;

{$ELSE}
type
    Tfb_get_master_interface = function: IMaster
                              {$IFDEF WINDOWS} stdcall; {$ELSE} cdecl; {$ENDIF}
                              
function GetIMaster(aHandle: TLibHandle): IMaster;
var fb_get_master_interface: Tfb_get_master_interface;
begin
  Result := nil;
  fb_get_master_interface := GetProcAddress(aHandle, 'fb_get_master_interface');
  if fb_get_master_interface <> nil then
    Result := fb_get_master_interface;
end;
{$ENDIF}

end.
